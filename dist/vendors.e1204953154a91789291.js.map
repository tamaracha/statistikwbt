{"version":3,"sources":["webpack:///vendors.e1204953154a91789291.js","webpack:///webpack/bootstrap e1204953154a91789291","webpack:///external \"angular\"","webpack:///./~/api-check/dist/api-check.js","webpack:///./~/angular-formly/dist/formly.js","webpack:///./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js","webpack:///./~/angular-permission/dist/angular-permission.js","webpack:///./~/angular-ui-bootstrap/index.js","webpack:///./~/angular-ui-router.statehelper/statehelper.js","webpack:///./~/angular-ui-router/release/angular-ui-router.js","webpack:///./~/ngstorage/ngStorage.js","webpack:///./~/oclazyload/dist/ocLazyLoad.js","webpack:///./~/utf8/utf8.js","webpack:///./src/angular-locale_de-de.js","webpack:///./~/angular-ui-bootstrap/dist/ui-bootstrap-tpls.js","webpack:///(webpack)/buildin/module.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","_m","args","slice","templateId","a","b","c","this","concat","shift",1,"e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","0","2","3","appendChild","m","Object","prototype","hasOwnProperty","fn","angular","root","factory","_interopRequireDefault","obj","__esModule","default","defineProperty","value","_apiCheck","_apiCheck2","getApiCheckInstance","apiCheck","api","output","config","disabled","globalConfig","apiTypes","argTypes","passed","message","failed","checkApiCheckApi","arguments","Array","isArray","messages","checkEnoughArgs","checkApiWithArgs","returnObject","getTypes","getErrorMessage","checkApiArgs","isArrayOrArgs","Error","prefix","errors","apiCheckApis","handleErrorMessage","getApiCheck","shouldThrow","result","console","warn","getPrefix","onlyPrefix","gOut","trim","getSuffix","s","onlySuffix","suffix","getUrl","u","url","docsBaseUrl","urlSuffix","join","passedAndShouldHavePassed","buildMessageFromApiAndArgs","replaceFunctionWithName","each","val","name","replacedItems","indexOf","displayName","getObjectString","types","stringify","generateMessage","n","useS","keys","newLine","passedArgs","_getTypes","copy","arrayify","map","checker","index","specified","getCheckerDisplay","terse","verbose","addHelpers","arg","getArgDisplay","extraCheckers","apiCheckApiCheck","getApiCheckInstanceCheckers","additionalProperties","throw","utils","apiCheckUtil","wrapper","checkers","getCheckers","checkerIndex","argIndex","res","lastChecker","argName","argFailed","skipPreviousChecker","isOptional","isError","getCheckerErrorMessage","t","checkerTypeType","checkerType","location","apiCheckDataChecker","shape","string","optional","bool","asFunc","func","withProperties","__apiCheckData","asShape","wrongShape","oneOfType","getError","checkerHelp","getCheckerHelp","_ref","help","requiredArgs","filter","gottenArgs","hasKeys","getDisplayIfNotGotten","getDisplay","cName","constructor","typeOf","properties","argDisplay","v","k","getApiCheckApis","os","checkerFnChecker","shortType","notOptional","notRequired","strict","objectOf","typeOrArrayOf","any","VERSION","internalChecker","getSerialize","decycle","seen","key","getPath","ret","path","unshift","spaces","JSON","_defineProperty","enumerable","configurable","writable","daCopy","RegExp","options","display","short","getCheckerType","typeTypes","iterator","context","eachArry","eachObj","hasOwn","list","arry","finalJoin","last","pop","stringType","nAtL","tName","tLocation","thing","undef","setupChecker","getNoop","isNoop","prop","getRequiredVersion","notNullable","addNullable","addOptional","requiredChecker","copyProps","originalChecker","optionalCheck","fixType","nullableCheck","isNullable","nullable","checkerCopy","dest","noop","checkerHelpers","typeOfCheckGetter","lType","toLowerCase","funcCheckGetter","functionChecker","apiError","shapeChecker","notFunction","objectCheckGetter","nullType","objectNullOkChecker","objectChecker","nullOk","instanceCheckGetter","classToCheck","oneOfCheckGetter","enums","enum","enm","some","oneOfTypeCheckGetter","typeCheckers","checkersDisplay","arrayOfCheckGetter","shortCheckerDisplay","array","every","item","objectOfCheckGetter","checkerDisplay","notObject","object","allTypesSuccess","typeOrArrayOfCheckGetter","arrayOf","getShapeCheckGetter","shapeCheckGetter","nonObject","modifyTypeDisplayToHelpOut","theRet","required","addHelper","property","objectMessage","stringMessage","error","toUpperCase","parentRequired","strictType","shapeTypes","isObject","shapePropError","shapeError","allowedProperties","extraProps","getRequiredIfNotChecker","all","otherProps","propChecker","props","ifProps","description","getTypeForShapeChild","propName","propExists","iteration","otherPropsExist","otherProp","ifNot","onlyIf","othersPresent","requiredIfNot","argumentsCheckerGetter","number","anyCheckGetter","nullCheckGetter","rangeCheckGetter","min","max","lessThanCheckGetter","greaterThanCheckGetter","emptyObjectCheckGetter","emptyObject","instanceOf","oneOf","range","lessThan","greaterThan","null","_require",5,"__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_5__","_indexCommon","_indexCommon2","_angularFix","_angularFix2","_providersFormlyApiCheck","_providersFormlyApiCheck2","_otherDocsBaseUrl","_otherDocsBaseUrl2","_providersFormlyUsability","_providersFormlyUsability2","_providersFormlyConfig","_providersFormlyConfig2","_providersFormlyValidationMessages","_providersFormlyValidationMessages2","_servicesFormlyUtil","_servicesFormlyUtil2","_servicesFormlyWarn","_servicesFormlyWarn2","_directivesFormlyCustomValidation","_directivesFormlyCustomValidation2","_directivesFormlyField","_directivesFormlyField2","_directivesFormlyFocus","_directivesFormlyFocus2","_directivesFormlyForm","_directivesFormlyForm2","_runFormlyNgModelAttrsManipulator","_runFormlyNgModelAttrsManipulator2","_runFormlyCustomTags","_runFormlyCustomTags2","ngModuleName","ngModule","constant","provider","directive","run","version","shapeRequiredIfNot","shapeRequiredIfNotDefinition","formlyExpression","specifyWrapperType","apiCheckProperty","apiCheckInstanceProperty","apiCheckFunctionProperty","formlyWrapperType","template","templateUrl","overwriteOk","apiCheckInstance","apiCheckFunction","apiCheckOptions","expressionProperties","expression","modelChecker","templateManipulators","preWrapper","postWrapper","validatorChecker","fieldOptionsApiShape","$$hashKey","model","originalModel","className","extras","validateOnModelChange","skipNgModelAttrsManipulator","data","templateOptions","modelOptions","updateOn","debounce","allowInvalid","getterSetter","timezone","watcher","listener","runFieldExpressions","validators","asyncValidators","parsers","formatters","noFormControl","hide","hideExpression","ngModelElAttrs","ngModelAttrs","statement","attribute","bound","boolean","elementAttributes","optionsTypes","link","controller","validation","show","errorExistsAndShouldBeVisible","formControl","runExpressions","resetModel","updateInitialValue","initialValue","defaultValue","formlyFieldOptions","formOptionsApi","formState","removeChromeAutoComplete","manualModelWatcher","watchAllExpressions","fieldTransform","fieldGroup","form","typeOptionsDefaultOptions","formlyTypeOptions","defaultOptions","extends","extend","formlyUsability","formlyApiCheck","formlyErrorAndWarningsUrlPrefix","getFieldError","errorInfoSlug","field","toJson","getFormlyError","checkWrapper","checkWrapperTemplate","additionalInfo","formlyTransclude","_this","$get","$inject","_toConsumableArray","arr","arr2","from","formlyConfig","formlyUsabilityProvider","setType","checkType","extendTypeOptions","typeMap","_ret","allTypes","forEach","checkOverwrite","extendsType","getType","extendTypeControllerFunction","extendTypeLinkFunction","extendTypeDefaultOptions","_otherUtils2","reverseDeepMerge","extendTemplate","extendsCtrl","isDefined","optionsCtrl","$scope","$controller","extendsFn","optionsFn","extendsDO","optionsDO","optionsDOIsFn","isFunction","extendsDOIsFn","opts","scope","extendsDefaultOptions","mergedDefaultOptions","extenderOptionsDefaultOptions","newDefaultOptions","throwError","errorContext","getTypeHeritage","parent","heritage","isString","setWrapper","_x","_x2","_again","wrapperOptions","getOptionsTypes","getOptionsName","checkWrapperAPI","templateWrappersMap","defaultWrapperName","checkWrapperTypes","newValue","objectName","getWrapper","getWrapperByType","wrappers","_name","removeWrapperByName","removeWrappersForType","disableWarnings","warnInfoSlug","_this2","disableNgModelAttrsManipulator","ngModelAttrsManipulatorPreferUnbound","defaultHideDirective","getFieldId","_otherUtils","containsSelector","containsSpecialChar","formlyEval","$modelValue","$viewValue","extraLocals","$eval","formId","objAndSameType","obj1","obj2","getPrototypeOf","findByNodeName","el","nodeName","element","children","node","extendFunction","_len","fns","_key","extendArray","primary","secondary","startsWith","str","search","substring","contains","formlyValidationMessages","addTemplateOptionValueMessage","alternate","validationMessages","templateOptionValue","addStringMessage","viewValue","modelValue","formlyUtil","formlyWarn","$log","formlyCustomValidation","restrict","require","attrs","ctrl","addValidatorToPipeline","isAsync","validator","setupMessage","useNewValidatorsApi","setupWithValidators","setupWithParsers","validatorCollection","inFlightValidator","$parsers","isValid","$pending","then","$setValidity","bind","formlyField","$http","$q","$compile","$templateCache","$interpolate","FormlyFieldController","$timeout","$parse","currentValue","valueGetterSetter","setter","assign","promise","when","watchExpressions","formOptions","$watch","newVal","parseSet","parseGet","shouldNotUseParseKey","isNumber","simplifyLife","to","setFieldIdAndName","formName","$name","setDefaultValue","setInitialValue","mergeFieldOptionsWithTypeDefaults","mergeOptions","properOrder","reverse","typeName","extraOptions","extendOptionsWithDefaults","resetFormControl","$setUntouched","$setPristine","isMultiNgModel","$setViewValue","$render","$root","$$phase","$digest","addValidationMessages","invokeControllers","setupFieldGroup","fieldType","getFieldType","checkApi","fieldLink","formlyFormCtrl","setFieldGroupTemplate","checkFieldGroupApi","addClass","extraAttributes","getTemplate","transcludeInWrappers","setElementTemplate","addAttributes","attr","addClasses","templateString","html","asHtml","contents","watchFormControl","watchFieldNameOrExistence","nameExpressionRegex","nameExpression","exec","watchFieldExistence","fieldCount","fc","stopWatchingShowError","addShowMessagesWatcher","addParsers","addFormatters","customExpression","errorExistsAndShouldBeVisibleExpression","formControls","$invalid","noTouchedButDirty","isUndefined","$touched","$dirty","showError","setParsersOrFormatters","formWasPristine","$pristine","$formatters","formatter","which","getThingsFromType","theType","typeThings","getDefaultOptionsProperty","getThingsFromOptionsTypes","getDefaultOptionsOptionsTypes","optionsTypesThings","optionsTypeName","getFormlyExpressionThing","formlyExpressionParserOrFormatterFunction","originalThingProp","things","ngModelCtrls","ngModelCtrl","_ngModelCtrl","templateEl","ngModelNodes","querySelectorAll","ngModelNode","getAttribute","callLinkFunctions","thusly","runManipulators","manipulators","templateToManipulate","chain","manipulator","newTemplate","fieldManipulators","getManipulators","getFieldTemplate","append","addManipulators","_ref$preWrapper","pre","_ref$postWrapper","post","fromOptionsOrType","isUrl","templatePromise","_ret3","httpOptions","cache","get","response","getWrapperOption","aWrapper","runApiCheck","promises","w","wrappersTemplates","wrapperTemplate","totalWrapper","doTransclusion","superWrapper","transcludeEl","find","replaceWith","typeWrappers","formWrappers","defaultWrapper","_ref2","forType","runApiCheckForType","instance","checkerObjects","checkOptions","transclude","fields","formlyFocus","$document","previousEl","doc","$observe","activeElement","focus","focusWait","blur","formlyForm","formlyFormGetTemplate","getRootEl","rootEl","getFieldRootEl","fieldRootEl","getHideDirective","hideDirective","getTrackBy","trackBy","getFormName","bindName","minor","startSymbol","endSymbol","getTranscludeClass","transcludeClass","copyAttributes","attributes","excluded","arrayAttrs","toKebabCase","currentFormId","parentFormAttributes","hasClass","FormlyFormController","onModelOrFormStateChange","runFieldExpressionProperties","evalCloseToFormlyExpression","validate","$validate","setupFields","checkDeprecatedOptions","fieldTransforms","setupModels","setupHideExpressionWatcher","attachKey","setupWatchers","setupOptions","isFieldGroup","watchedModels","isNewModel","initModel","referencesCurrentlyWatchedModel","watchers","watchExpression","getWatchExpression","watchListener","getWatchListener","stopWatching","watchDeep","toString","split","originalExpression","modifyArgs","_slice","originalListener","originalArgs","getFormlyFieldLikeLocals","formlyFormLink","setFormController","theFormlyForm","getter","parentForm","$parent","$removeControl","removeData","fixChromeAutocomplete","global","offInstance","onInstance","input","setAttribute","replace","$1","addFormlyNgModelAttrsManipulator","ngModelAttrsManipulator","addValidation","addIfNotPresent","modelNodes","alterNgModelAttr","isPropertyAccessor","addRegardlessOfPresence","addModelOptions","addTemplateOptionsAttrs","ep","ngModelAttributes","getBuiltInAttributes","attrVal","attrName","ref","toVal","epVal","getEpValue","inTo","inEp","addNgModelElAttrs","skip","innerHTML","getNgModelNodes","selectorNot","skipNot","query","getNgModelNodesFallback","allNgModelNodes","matchingNgModelNodes","hasAttribute","nodeMatches","selector","div","outerHTML","querySelector","boundOnly","bothBooleanAndBound","bothAttributeAndBound","statementOnly","attributeOnly","substr","nodes","addCustomTags","documentMode","customElements",7,"__WEBPACK_EXTERNAL_MODULE_4__","addWrappers","formlyConfigProvider","check","label","labelSrOnly","addCheckboxType","labelProp","valueProp","checkValidity","expressionValue","valid","setModel","multiCheckbox","checked","checkbox","$setTouched","change","newModelValue","newOptionsValues","unwatchFormControl","addInputType","addRadioType","addSelectType","ngOptions","optionsAttr","groupProp","addTextareaType","rows","cols","_addons","_addons2","_description","_description2","addAddonsManipulator","formlyBootstrapApiCheck","addonTemplate","addonChecker","class","text","onClick","addonLeft","addonRight","addDescriptionManipulator","modelEls",8,"permission","$stateProvider","decorator","state","parentFn","self","getState","$rootScope","$state","Authorization","PermissionMap","$on","event","toState","toParams","fromState","fromParams","areSetStatePermissions","permissions","setStateAuthorizationStatus","status","$$isAuthorizationFinished","areStateEventsDefaultPrevented","isStateChangePermissionStartDefaultPrevented","isStateChangeStartDefaultPrevented","compensatePermissionMap","statePermissionMap","permissionMap","redirectTo","toStatePath","extendPermissionMap","authorizeForState","authorize","$broadcast","goToState","rejectedPermission","redirectToState","go","notify","defaultPrevented","preventDefault","compensatedPermissionMap","only","resolvePermissionMapProperty","except","handleFunctionRedirect","redirectFunction","redirectState","TypeError","handleStringRedirect","handleObjectRedirect","redirectObject","ReferenceError","rejectedPermissionName","Permission","permissionName","validationFunction","validateConstructor","wrapInPromise","dfd","defer","resolve","reject","validatePermission","validationResult","PermissionStore","Role","roleName","permissionNames","defineManyPermissions","validateRole","hasPermissionDefinition","getPermissionDefinition","service","definePermission","permissionStore","removePermissionDefinition","getStore","clearStore","defineRole","roleStore","removeRoleDefinition","hasRoleDefinition","getRoleDefinition","removeClass","RoleStore","permissionsMap","handleAuthorization","deferred","exceptPromises","findMatchingPermissions","rejectedPermissions","onlyPromises","resolvedPermissions","handleRoleValidation","handlePermissionValidation","role",9,10,"fixStateName","addSiblings","childState","idx","nextSibling","previousSibling","keepOriginalNames","siblingTraversal","setNestedState",11,"inherit","extra","merge","dst","ancestors","first","second","objectKeys","Number","len","Math","ceil","floor","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","j","equalForKeys","filterByKeys","values","filtered","pick","omit","collection","$Resolve","$injector","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","$$promises","$$values","study","invocables","visit","visited","cycle","splice","plan","annotate","param","isResolve","invocableKeys","locals","done","wait","merged","$$inheritedValues","resolution","fail","reason","$$failure","invoke","invocable","onfailure","invocation","proceed","waitParams","dep","ii","$TemplateFactory","fromConfig","fromString","fromUrl","templateProvider","fromProvider","headers","Accept","UrlMatcher","pattern","parentMatcher","addParameter","paramNames","test","$$UMFP","Param","quoteRegExp","squash","surroundPattern","matchDetails","isSearch","regexp","segment","cfg","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","lastIndex","sourceSearch","sourcePath","$$paramNames","Type","$UrlMatcherFactory","valToString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","parseInt","date","getFullYear","getMonth","getDate","match","capture","Date","isNaN","valueOf","equals","toISOString","json","fromJson","identity","$$getDefaultValue","strictMode","compile","isMatcher","o","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","ignore","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","handler","$match","$location","$browser","$sniffer","appendBasePath","isHtml5","absolute","baseHref","update","evt","rule","handled","lastPushedUrl","rules","otherwise","listen","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","href","validates","html5Mode","enabled","history","hashPrefix","slash","port","protocol","host","redirect","handlerIsString","strategies","matcher","regex","sticky","deferIntercept","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","pathLength","current","states","queueState","parentName","queue","flushQueuedChildren","queued","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","l","MAX_VALUE","$view","$resolve","$urlRouter","handleRedirect","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","resolveState","paramsAreFiltered","resolveViews","viewsPromises","views","view","injectables","$template","load","globals","controllerProvider","injectLocals","$$controller","$$state","$$controllerAs","controllerAs","TransitionPrevented","reload","relative","fromPath","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","resolved","entering","exiting","onExit","onEnter","includes","lossy","nav","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","charAt","","abstract","$ViewProvider","$templateFactory","defaults","$ViewScrollProvider","useAnchorScroll","$anchorScroll","$element","scrollIntoView","$ViewDirective","$uiViewScroll","getService","has","getRenderer","animEnabled","ngMajorVer","ngMinorVer","$animate","$animator","statics","enter","target","cb","after","leave","remove","noanimation","animate","terminal","priority","tElement","tAttrs","$transclude","cleanupLastView","cleanOld","_previousEl","_currentScope","$destroy","currentScope","_willBeDestroyed","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","$emit","clone","autoScrollExp","onloadExp","onload","autoscroll","$ViewDirectiveFill","initial","uiView","inheritedData","parseStateRef","parsed","preparsed","paramExpr","stateContext","stateData","getTypeInfo","isSvg","isForm","isAnchor","clickable","clickHook","button","ctrlKey","metaKey","shiftKey","ignorePreventDefaultCount","cancel","defaultOpts","$StateRefDirective","uiSrefActive","uiSref","active","uiSrefOpts","$$addStateInfo","$set","$StateRefDynamicDirective","runStateRefLink","group","uiState","uiStateParams","uiStateOpts","watch","$StateRefActiveDirective","$attrs","addState","stateParams","activeClass","stateHash","createStateHash","activeClasses","anyMatch","exactMatch","activeEqClass","uiSrefActiveEq","newState","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","charCodeAt","isPathParam","isDefaultValue","nextSegment","isFinalPathParam","$subPattern","sub","mode","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","major",12,"__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_storageProvider","storageType","storageKeyPrefix","setKeyPrefix","serializer","deserializer","setSerializer","setDeserializer","d","getItem","set","setItem","$window","isStorageSupported","supported","err","round","random","localStorage","removeItem","_last$storage","_debounce","prefixLength","webStorage","$storage","$default","items","$sync","$reset","$apply","temp$storage","addEventListener","hasFocus",13,"regModules","regInvokes","regConfigs","modulesToLoad","realModules","recordDeclarations","broadcast","runBlocks","justLoaded","ocLazyLoad","$controllerProvider","$provide","$compileProvider","$filterProvider","$animateProvider","_register","providers","registerModules","moduleName","moduleFn","tempRunBlocks","getModuleName","newModule","ngModuleFct","requires","_runBlocks","rerun","_invokeQueue","reconfig","_configBlocks","instanceInjector","getInstanceInjector","_registerInvokeList","checkHashes","potentialNew","invokes","newHash","isNew","signature","hashCode","invokeList","newInvoke","onInvoke","invokeName","callInvoke","fct","invoked","jlen","moduleExists","debug","events","moduleCache","modulePromises","moduleConfig","_init","elements","names","NG_APP_CLASS_REGEXP","elm","getElementById","jasmine","mocha","mock","addReg","mainModule","chr","$rootElement","$cacheFactory","filesCache","eventName","info","_broadcast","_$log","_getFilesCache","toggleWatch","getModuleConfig","setModuleConfig","getModules","isLoaded","modulesNames","moduleLoaded","_getModuleName","_getModule","_loadDependencies","localParams","loadedModule","diff","promisesList","getRequires","requireEntry","files","filesLoader","entry","inject","real","_addToLoadList","loadNext","requireModule","_unregister","bootstrapFct","bootstrap","force","configFn","$ocLazyLoad","content","$attr","$delegate","$interval","uaCssChecked","useCssLoadPatch","anchor","buildElement","cacheBuster","dc","getTime","put","onerror","serie","insertBeforeElem","lastChild","insertBefore","jQuery","parentNode","ua","navigator","userAgent","platform","appVersion","iOSVersion","parseFloat","androidVersion","versionMatch","tries","interval","sheet","cssRules","cssFiles","templatesFiles","jsFiles","cachePromise","pushFile","file_type","jsLoader","cssDeferred","cssLoader","templatesDeferred","templatesLoader","jsDeferred","originalModule","errText","originalParams","deferredList","paths","ocLazyLoadLoader","success","searchElement","fromIndex","O","abs","Infinity",14,"ucs2decode","counter","ucs2encode","stringFromCharCode","checkScalarValue","codePoint","createByte","encodeCodePoint","symbol","utf8encode","codePoints","byteString","readContinuationByte","byteIndex","byteCount","continuationByte","byteArray","decodeSymbol","byte1","byte2","byte3","byte4","utf8decode","tmp","freeExports","freeGlobal","String","fromCharCode","utf8",15,"getDecimals","getVF","opt_precision","pow","f","PLURAL_CATEGORY","ZERO","ONE","TWO","FEW","MANY","OTHER","DATETIME_FORMATS","AMPMS","DAY","ERANAMES","ERAS","FIRSTDAYOFWEEK","MONTH","SHORTDAY","SHORTMONTH","STANDALONEMONTH","WEEKENDRANGE","fullDate","longDate","medium","mediumDate","mediumTime","shortDate","shortTime","NUMBER_FORMATS","CURRENCY_SYM","DECIMAL_SEP","GROUP_SEP","PATTERNS","gSize","lgSize","maxFrac","minFrac","minInt","negPre","negSuf","posPre","posSuf","pluralCat","vf",16,"$animateCss","expand","expandingExpr","easing","height","scrollHeight","start","expandDone","css","expandedExpr","collapse","collapsingExpr","collapseDone","collapsedExpr","expanding","expanded","collapsing","collapsed","uibCollapse","shouldCollapse","closeOthers","accordionConfig","groups","openGroup","isOpen","addGroup","groupScope","that","removeGroup","heading","isDisabled","setHeading","accordionCtrl","openClass","panelClass","toggleClass","toggleOpen","$event","$id","headingId","panelId","accordionGroupCtrl","uibAccordionTransclude","closeable","close","dismissOnTimeout","toggleEvent","buttonConfig","ctrls","buttonsCtrl","uncheckableExpr","uibUncheckable","uibBtnRadio","on","isActive","uncheckable","getTrueValue","getCheckboxValue","btnCheckboxTrue","getFalseValue","btnCheckboxFalse","clearBufferedTransitions","bufferedTransitions","getSlideByIndex","slides","goNext","slide","direction","destroyed","currentSlide","$currentTransition","SLIDE_DIRECTION","phase","off","nextSlide","nextIndex","indexOfSlide","nextDirection","getCurrentIndex","currentIndex","restartTimer","resetTimer","currentInterval","resetTransition","timerFn","isPlaying","next","pause","addSlide","select","play","newIndex","noWrap","prev","removeSlide","sort","bufferedIndex","noPause","noTransition","$watchCollection","actual","carouselCtrl","animation","beforeAddClass","stopped","directionClass","removeClassFn","beforeRemoveClass","$locale","dateFilter","orderByFilter","createParser","quoteIndex","inLiteral","formatCodeToRegex","year","month","toInt","toTimezone","convertTimezoneToLocal","fromTimezone","timezoneToOffset","fallback","requestedTimezoneOffset","parse","addDateMinutes","minutes","setMinutes","getMinutes","timezoneOffset","getTimezoneOffset","localeId","SPECIAL_CHARACTERS_REGEXP","init","_date","setFullYear","hours","milliseconds","seconds","matches","sign","isDate","parser","_format","reduce","mapper","baseDate","results","tzOffset","dt","getHours","getSeconds","getMilliseconds","datesetter","setUTCFullYear","timesetter","setUTCHours","setHours","ON_REGEXP","IS_REGEXP","linkFn","linkedScopes","instances","exps","exp","addForExp","removeScope","clazz","compareWithExp","expToData","watchFn","compareWithVal","newActivated","thisVal","onExp","lastActivated","removedScope","targetScope","newWatchScope","onExpMatches","uibIsClass","expsStr","SCROLLBAR_WIDTH","OVERFLOW_REGEX","normal","hidden","PLACEMENT_REGEX","auto","vertical","getRawNode","elem","parseStyle","isFinite","offsetParent","isStaticPositioned","getComputedStyle","position","documentElement","scrollbarWidth","scrollElem","offsetWidth","clientWidth","scrollParent","includeHidden","overflowRegex","documentEl","elemStyle","excludeStatic","parentElement","spStyle","overflow","overflowY","overflowX","includeMagins","elemOffset","offset","top","marginTop","marginLeft","parentOffset","clientTop","scrollTop","clientLeft","scrollLeft","width","offsetHeight","elemBCR","getBoundingClientRect","pageYOffset","pageXOffset","viewportOffset","useDocument","includePadding","offsetBCR","bottom","offsetParentBCR","clientHeight","offsetParentStyle","paddingTop","paddingBottom","paddingLeft","paddingRight","parsePlacement","placement","autoPlace","positionElements","hostElem","targetElem","appendToBody","targetWidth","targetHeight","hostElemPos","targetElemPos","targetElemStyle","adjustedSize","marginRight","marginBottom","xOverflow","yOverflow","positionArrow","innerElem","isTooltip","arrowElem","margin","borderProp","borderWidth","borderRadiusProp","borderRadius","arrowCss","datepickerMode","formatDay","formatMonth","formatYear","formatDayHeader","formatDayTitle","formatMonthTitle","maxDate","maxMode","minDate","minMode","ngModelOptions","shortcutPropagation","showWeeks","yearColumns","yearRows","datepickerConfig","$datepickerSuppressError","dateParser","watchListeners","modes","datepickerOptions","startingDay","refreshView","initDate","activeDate","$isEmpty","uniqueId","ngDisabled","dateObject","compare","activeDateId","uid","ngModelCtrl_","$options","render","selectedDt","_refreshView","activeDt","createDateObject","selected","customClass","dateDisabled","size","arrays","move","step","years","months","toggleMode",32,33,34,35,36,37,38,39,40,"focusElement","keydown","altKey","stopPropagation","handleKeyDown","getDaysInMonth","DAYS_IN_MONTH","getISO8601WeekNumber","checkDate","setDate","getDay","time","setMonth","getDates","startDate","dates","firstDayOfMonth","difference","numDisplayedFromPreviousMonth","firstDate","days","labels","abbr","full","title","weekNumbers","thursdayIndex","numWeeks","curWeek","date1","date2","_date1","_date2","getStartingYear","columns","yearpickerInit","datepickerCtrl","daypickerCtrl","monthpickerCtrl","altInputFormats","clearText","closeOnDateSelection","closeText","currentText","datepickerPopup","datepickerPopupTemplateUrl","datepickerTemplateUrl","html5Types","datetime-local","onOpenFocus","showButtonBar","$position","datepickerPopupConfig","cameltoDash","parseDateString","dateFormat","parseDate","ngModel","ngRequired","documentClickBind","popup","$popup","dpContainsTarget","popupContainsTarget","inputKeydownBind","popupEl","datepickerEl","isHtml5DateInput","watchData","_ngModel_","datepickerAppendToBody","uibDatepickerPopup","oldValue","newDateFormat","ng-model","ng-model-options","ng-change","template-url","option","propConfig","$$parserName","$validators","$viewChangeListeners","getText","dateSelection","today","debounceTime","timeoutPromise","appendToOpenClass","openScope","open","dropdownScope","closeDropdown","keybindFilter","getAutoClose","toggleElement","getToggleElement","dropdownElement","getDropdownElement","focusToggleElement","isKeynavEnabled","focusDropdownEntry","dropdownConfig","uibDropdownService","$templateRequest","templateScope","getIsOpen","setIsOpen","toggleInvoker","onToggle","appendTo","keynavEnabled","body","dropdownAppendTo","appendToEl","dropdownAppendToBody","keyboardNav","dropdownMenu","toggle","autoClose","getElement","keyCode","elems","eq","selectedOption","wasOpen","rightalign","pos","innerWidth","appendOffset","openContainer","dropdownMenuTemplateUrl","tplContent","newEl","dropdownCtrl","dropdownNested","tplUrl","toggleDropdown","aria-haspopup","aria-expanded","unbind","createNew","stack","add","removeTop","entries","hasKey","resolver","setResolver","resolves","resolveObj","resolveIter","$modalStack","modalInClass","NOW_CLOSING_EVENT","setIsAsync","modalOptions","backdropClass","windowClass","windowTopClass","modal","getTop","backdrop","currentTarget","dismiss","$isRendered","modalRenderDeferObj","animationPromise","inputWithAutofocus","modalRendered","modalAnimation","uibModalAnimationClass","empty","$$multiMap","$$stackedMap","backdropIndex","topBackdropIndex","opened","openedWindows","removeModalWindow","modalInstance","elementToReceiveFocus","modalWindow","appendToElement","removeAfterAnimate","modalDomEl","modalScope","modalBodyClass","openedClass","OPENED_MODAL_CLASS","openedClasses","toggleTopWindowClass","closedDeferred","checkRemoveBackdrop","toggleSwitch","backdropDomEl","backdropScopeRef","backdropScope","domEl","afterAnimating","asyncDeferred","asyncPromise","keydownListener","isDefaultPrevented","keyboard","loadFocusElementList","focusChanged","isFocusInFirstItem","isModalFocused","focusLastFocusableElement","isFocusInLastItem","focusFirstFocusableElement","broadcastClosing","resultOrReason","closing","focusableElementList","focusIndex","tababbleSelector","newBackdropIndex","modalOpener","renderDeferred","currBackdropIndex","angularDomEl","windowTemplateUrl","window-class","window-top-class","clearFocusListCache","$$uibDestructionScheduled","dismissAll","topModal","srcElement","modalDomE1","$modalProvider","$uibResolve","getTemplatePromise","$modal","promiseChain","getPromiseChain","resolveWithTemplate","templateAndResolvePromise","modalResultDeferred","modalOpenedDeferred","modalClosedDeferred","modalRenderDeferred","closed","rendered","samePromise","tplAndVars","providedScope","$close","$dismiss","ctrlInstance","ctrlLocals","$uibModalInstance","bindToController","create","setNumPages","numPages","_watchers","itemsPerPage","totalPages","calculateTotalPages","updatePage","newTotal","oldTotal","totalItems","page","selectPage","clickAllowed","noPrevious","noNext","uibPaging","uibPagerConfig","align","previousText","nextText","paginationCtrl","uibPaginationConfig","makePage","getPages","currentPage","pages","startPage","endPage","isMaxSized","maxSize","rotate","forceEllipses","boundaryLinkNumbers","previousPageSet","secondPageLink","firstPageLink","nextPageSet","secondToLastPageLink","lastPageLink","boundaryLinks","directionLinks","originalRender","firstText","lastText","snake_case","separator","letter","placementClassPrefix","popupDelay","popupCloseDelay","useContentExp","triggerMap","mouseenter","click","outsideClick","none","globalOptions","setTriggers","triggers","keypressListener","openedTooltips","ttType","defaultTriggerShow","getTriggers","trigger","directiveName","startSym","endSym","tElem","tooltipLinker","tooltipCtrl","toggleTooltipBind","ttScope","hideTooltipBind","showTooltipBind","hasEnableExp","cancelHide","prepareTooltip","showTimeout","cancelShow","hideTimeout","createTooltip","$evalAsync","assignIsOpen","positionTooltip","positionTimeout","transitionTimeout","removeTooltip","tooltip","tooltipLinkedScope","prepObservers","unregisterObservers","contentParse","popupClass","delay","closeDelay","isOpenParse","observers","repositionScheduled","$$postDigest","observer","bodyHideTooltipBind","prepTriggers","unregisterTriggers","ttPosition","visibility","origScope","contentExp","appendToBodyVal","appendKey","$sce","previousElement","currentElement","tooltipTemplateTranscludeScope","changeCounter","cleanupLastIncludeContent","parseAsResourceUrl","uibTooltipTemplateTransclude","thisChangeId","$uibPosition","tooltipAnimationClass","$uibTooltip","originScope","progressConfig","bars","addBar","bar","recalculatePercentage","totalPercentage","total","percent","toFixed","removeBar","progressCtrl","stateOn","stateOff","titles","ratingConfig","tmpTitles","ratingStates","buildTemplateObjects","getTitle","rate","readonly","onHover","reset","onLeave","onKeydown","ratingCtrl","tabs","selectedTab","tab","onDeselect","selectCalled","onSelect","addTab","removeTab","newActiveIndex","justified","tabsetCtrl","disable","$transcludeFn","isTabHeading","tagName","uibTabContentTransclude","headingElement","hourStep","minuteStep","secondStep","showMeridian","showSeconds","meridians","readonlyInput","mousewheel","arrowkeys","showSpinners","timepickerConfig","getHoursFromTemplate","meridian","getMinutesFromTemplate","getSecondsFromTemplate","pad","refresh","keyboardChange","makeValid","updateTemplate","invalidHours","invalidMinutes","invalidSeconds","addSecondsToSelected","addSeconds","addMinutes","newDate","tabindex","removeAttr","inputs","hoursInputEl","minutesInputEl","secondsInputEl","setupMousewheelEvents","setupArrowkeyEvents","setupInputEvents","noIncrementHours","incrementedSelected","noDecrementHours","decrementedSelected","noIncrementMinutes","noDecrementMinutes","noIncrementSeconds","noDecrementSeconds","noToggleMeridian","$error","isScrollingUp","originalEvent","delta","wheelDelta","deltaY","detail","incrementHours","decrementHours","incrementMinutes","decrementMinutes","incrementSeconds","decrementSeconds","updateHours","updateMinutes","updateSeconds","invalidate","$setDirty","setSeconds","toggleMeridian","uibTimepickerConfig","timepickerCtrl","TYPEAHEAD_REGEXP","itemName","viewMapper","modelMapper","originalScope","$$debounce","typeaheadParser","fireRecalculating","moveInProgress","debouncedRecalculate","recalculatePosition","modelCtrl","HOT_KEYS","eventDebounceTime","minLength","typeaheadMinLength","waitTime","typeaheadWaitMs","isEditable","typeaheadEditable","isLoadingSetter","typeaheadLoading","onSelectCallback","typeaheadOnSelect","isSelectOnBlur","typeaheadSelectOnBlur","isNoResultsSetter","typeaheadNoResults","inputFormatter","typeaheadInputFormatter","typeaheadAppendToBody","typeaheadAppendTo","focusFirst","typeaheadFocusFirst","selectOnExact","typeaheadSelectOnExact","isOpenSetter","typeaheadIsOpen","showHint","typeaheadShowHint","parsedModel","invokeModelSetter","$setModelValue","$$$p","parserResult","uibTypeahead","offDestroy","popupId","aria-autocomplete","aria-owns","inputsContainer","hintInputElem","border-color","box-shadow","opacity","background","color","vertical-align","background-color","popUpEl","move-in-progress","assign-is-open","typeaheadTemplateUrl","typeaheadPopupTemplateUrl","resetHint","resetMatches","activeIdx","getMatchId","inputIsExactMatch","inputValue","getMatchesAsync","onCurrentRequest","debounceUpdate","firstLabel","scheduleSearchWithTimeout","cancelPreviousTimeout","$item","$model","$label","typeaheadFocusOnSelect","offsetTop","editable","dismissClickHandler","_modelCtrl","_ngModelOptions","candidateViewValue","emptyViewValue","popupTemplateUrl","isDropdownOpen","matchIdx","selectActive","selectMatch","tplEl","escapeRegexp","queryToEscape","containsHtml","matchItem","isSanitizePresent","trustAsHtml","$$csp","noInlineStyle","prepend",131,"webpackPolyfill","deprecate"],"mappings":"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","file":"vendors.e1204953154a91789291.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tvar _m = moreModules[moduleId];\n/******/\n/******/ \t\t\t// Check if module is deduplicated\n/******/ \t\t\tswitch(typeof _m) {\n/******/ \t\t\tcase \"object\":\n/******/ \t\t\t\t// Module can be created from a template\n/******/ \t\t\t\tmodules[moduleId] = (function(_m) {\n/******/ \t\t\t\t\tvar args = _m.slice(1), templateId = _m[0];\n/******/ \t\t\t\t\treturn function (a,b,c) {\n/******/ \t\t\t\t\t\tmodules[templateId].apply(this, [a,b,c].concat(args));\n/******/ \t\t\t\t\t};\n/******/ \t\t\t\t}(_m));\n/******/ \t\t\t\tbreak;\n/******/ \t\t\tcase \"function\":\n/******/ \t\t\t\t// Normal module\n/******/ \t\t\t\tmodules[moduleId] = _m;\n/******/ \t\t\t\tbreak;\n/******/ \t\t\tdefault:\n/******/ \t\t\t\t// Module is a copy of another module\n/******/ \t\t\t\tmodules[moduleId] = modules[_m];\n/******/ \t\t\t\tbreak;\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t1:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"chunk.\" + {\"0\":\"bea689d366ba2240570d\",\"2\":\"44e5298b476cca0e3b35\",\"3\":\"8ac7b8fbb39273951380\"}[chunkId] + \".js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"function\": break;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(11);\n\t__webpack_require__(10);\n\t__webpack_require__(9);\n\t__webpack_require__(13);\n\t__webpack_require__(3);\n\t__webpack_require__(5);\n\t__webpack_require__(7);\n\t__webpack_require__(12);\n\t__webpack_require__(8);\n\t__webpack_require__(15);\n\tmodule.exports = __webpack_require__(14);\n\n\n/***/ },\n\n/***/ 2:\n/***/ function(module, exports) {\n\n\tmodule.exports = angular;\n\n/***/ },\n\n/***/ 3:\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! api-check version 7.5.5 built with  by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) ( _)==(_ )\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"apiCheck\"] = factory();\n\t\telse\n\t\t\troot[\"apiCheck\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _apiCheck = __webpack_require__(1);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = _apiCheck2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar apiCheckUtil = __webpack_require__(3);\n\t\tvar each = apiCheckUtil.each;\n\t\tvar isError = apiCheckUtil.isError;\n\t\tvar t = apiCheckUtil.t;\n\t\tvar arrayify = apiCheckUtil.arrayify;\n\t\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\t\tvar typeOf = apiCheckUtil.typeOf;\n\t\tvar getError = apiCheckUtil.getError;\n\t\n\t\tvar checkers = __webpack_require__(4);\n\t\tvar apiCheckApis = getApiCheckApis();\n\t\n\t\tmodule.exports = getApiCheckInstance;\n\t\tmodule.exports.VERSION = (\"7.5.5\");\n\t\tmodule.exports.utils = apiCheckUtil;\n\t\tmodule.exports.globalConfig = {\n\t\t  verbose: false,\n\t\t  disabled: false\n\t\t};\n\t\n\t\tvar apiCheckApiCheck = getApiCheckInstance({\n\t\t  output: { prefix: 'apiCheck' }\n\t\t});\n\t\tmodule.exports.internalChecker = apiCheckApiCheck;\n\t\n\t\teach(checkers, function (checker, name) {\n\t\t  return module.exports[name] = checker;\n\t\t});\n\t\n\t\tfunction getApiCheckInstance() {\n\t\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t\t  /* eslint complexity:[2, 6] */\n\t\t  if (apiCheckApiCheck && arguments.length) {\n\t\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t\t      prefix: 'creating an apiCheck instance'\n\t\t    });\n\t\t  }\n\t\n\t\t  var additionalProperties = {\n\t\t    'throw': getApiCheck(true),\n\t\t    warn: getApiCheck(false),\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    handleErrorMessage: handleErrorMessage,\n\t\t    config: {\n\t\t      output: config.output || {\n\t\t        prefix: '',\n\t\t        suffix: '',\n\t\t        docsBaseUrl: ''\n\t\t      },\n\t\t      verbose: config.verbose || false,\n\t\t      disabled: config.disabled || false\n\t\t    },\n\t\t    utils: apiCheckUtil\n\t\t  };\n\t\n\t\t  each(additionalProperties, function (wrapper, name) {\n\t\t    return apiCheck[name] = wrapper;\n\t\t  });\n\t\n\t\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\t  each(extraCheckers, function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\n\t\t  return apiCheck;\n\t\n\t\t  /**\n\t\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t\t   * @param {Array} api - the checkers to check with\n\t\t   * @param {Array} args - the args to check\n\t\t   * @param {Object} output - output options\n\t\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t\t   */\n\t\t  function apiCheck(api, args, output) {\n\t\t    /* eslint complexity:[2, 8] */\n\t\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t\t      return {\n\t\t        apiTypes: {}, argTypes: {},\n\t\t        passed: true, message: '',\n\t\t        failed: false\n\t\t      }; // empty version of what is normally returned\n\t\t    }\n\t\t    checkApiCheckApi(arguments);\n\t\t    if (!Array.isArray(api)) {\n\t\t      api = [api];\n\t\t      args = [args];\n\t\t    } else {\n\t\t      // turn arguments into an array\n\t\t      args = Array.prototype.slice.call(args);\n\t\t    }\n\t\t    var messages = checkEnoughArgs(api, args);\n\t\t    if (!messages.length) {\n\t\t      // this is where we actually go perform the checks.\n\t\t      messages = checkApiWithArgs(api, args);\n\t\t    }\n\t\n\t\t    var returnObject = getTypes(api, args);\n\t\t    returnObject.args = args;\n\t\t    if (messages.length) {\n\t\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t\t      returnObject.failed = true;\n\t\t      returnObject.passed = false;\n\t\t    } else {\n\t\t      returnObject.message = '';\n\t\t      returnObject.failed = false;\n\t\t      returnObject.passed = true;\n\t\t    }\n\t\t    return returnObject;\n\t\t  }\n\t\n\t\t  /**\n\t\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t\t   */\n\t\t  function checkApiCheckApi(checkApiArgs) {\n\t\t    var api = checkApiArgs[0];\n\t\t    var args = checkApiArgs[1];\n\t\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\t\n\t\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t\t    }\n\t\t    // dog fooding here\n\t\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t\t    if (errors.length) {\n\t\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t\t        prefix: 'apiCheck'\n\t\t      });\n\t\t      apiCheck.handleErrorMessage(message, true);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getApiCheck(shouldThrow) {\n\t\t    return function apiCheckWrapper(api, args, output) {\n\t\t      var result = apiCheck(api, args, output);\n\t\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t\t      return result; // wont get here if an error is thrown\n\t\t    };\n\t\t  }\n\t\n\t\t  function handleErrorMessage(message, shouldThrow) {\n\t\t    if (shouldThrow && message) {\n\t\t      throw new Error(message);\n\t\t    } else if (message) {\n\t\t      /* eslint no-console:0 */\n\t\t      console.warn(message);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getErrorMessage(api, args) {\n\t\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t\n\t\t    var gOut = apiCheck.config.output || {};\n\t\t    var prefix = getPrefix();\n\t\t    var suffix = getSuffix();\n\t\t    var url = getUrl();\n\t\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\t\n\t\t    function getPrefix() {\n\t\t      var p = output.onlyPrefix;\n\t\t      if (!p) {\n\t\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t\t      }\n\t\t      return p;\n\t\t    }\n\t\n\t\t    function getSuffix() {\n\t\t      var s = output.onlySuffix;\n\t\t      if (!s) {\n\t\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t\t      }\n\t\t      return s;\n\t\t    }\n\t\n\t\t    function getUrl() {\n\t\t      var u = output.url;\n\t\t      if (!u) {\n\t\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t\t      }\n\t\t      return u;\n\t\t    }\n\t\t  }\n\t\n\t\t  function buildMessageFromApiAndArgs(api, args) {\n\t\t    var _getTypes = getTypes(api, args);\n\t\n\t\t    var apiTypes = _getTypes.apiTypes;\n\t\t    var argTypes = _getTypes.argTypes;\n\t\n\t\t    var copy = Array.prototype.slice.call(args || []);\n\t\t    var replacedItems = [];\n\t\t    replaceFunctionWithName(copy);\n\t\t    var passedArgs = getObjectString(copy);\n\t\t    argTypes = getObjectString(argTypes);\n\t\t    apiTypes = getObjectString(apiTypes);\n\t\n\t\t    return generateMessage();\n\t\n\t\t    // functions\n\t\n\t\t    function replaceFunctionWithName(obj) {\n\t\t      each(obj, function (val, name) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        if (replacedItems.indexOf(val) === -1) {\n\t\t          // avoid recursive problems\n\t\t          replacedItems.push(val);\n\t\t          if (typeof val === 'object') {\n\t\t            replaceFunctionWithName(obj);\n\t\t          } else if (typeof val === 'function') {\n\t\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function getObjectString(types) {\n\t\t      if (!types || !types.length) {\n\t\t        return 'nothing';\n\t\t      } else if (types && types.length === 1) {\n\t\t        types = types[0];\n\t\t      }\n\t\t      return stringify(types, null, 2);\n\t\t    }\n\t\n\t\t    function generateMessage() {\n\t\t      var n = '\\n';\n\t\t      var useS = true;\n\t\t      if (args && args.length === 1) {\n\t\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t\t          useS = !!Object.keys(args[0]).length;\n\t\t        } else {\n\t\t          useS = false;\n\t\t        }\n\t\t      }\n\t\t      var types = 'type' + (useS ? 's' : '');\n\t\t      var newLine = n + n;\n\t\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypes(api, args) {\n\t\t    api = arrayify(api);\n\t\t    args = arrayify(args);\n\t\t    var apiTypes = api.map(function (checker, index) {\n\t\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t\t      return getCheckerDisplay(checker, {\n\t\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t\t        obj: args[index],\n\t\t        addHelpers: true\n\t\t      });\n\t\t    });\n\t\t    var argTypes = args.map(function (arg) {\n\t\t      return getArgDisplay(arg, []);\n\t\t    });\n\t\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t\t  }\n\t\t}\n\t\n\t\t// STATELESS FUNCTIONS\n\t\n\t\t/**\n\t\t * This is where the magic happens for actually checking the arguments with the api.\n\t\t * @param {Array} api - checkers\n\t\t * @param  {Array} args - and arguments object\n\t\t * @returns {Array} - the error messages\n\t\t */\n\t\tfunction checkApiWithArgs(api, args) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var messages = [];\n\t\t  var failed = false;\n\t\t  var checkerIndex = 0;\n\t\t  var argIndex = 0;\n\t\t  var arg = undefined,\n\t\t      checker = undefined,\n\t\t      res = undefined,\n\t\t      lastChecker = undefined,\n\t\t      argName = undefined,\n\t\t      argFailed = undefined,\n\t\t      skipPreviousChecker = undefined;\n\t\t  /* jshint -W084 */\n\t\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t\t    arg = args[argIndex++];\n\t\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t\t    res = checker(arg, 'value', argName);\n\t\t    argFailed = isError(res);\n\t\t    lastChecker = checkerIndex >= api.length;\n\t\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t\t      failed = true;\n\t\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t\t    } else if (argFailed && checker.isOptional) {\n\t\t      argIndex--;\n\t\t    } else {\n\t\t      messages.push(t(argName) + ' passed');\n\t\t    }\n\t\t  }\n\t\t  return failed ? messages : [];\n\t\t}\n\t\n\t\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\t\tfunction checkerTypeType(checkerType, name, location) {\n\t\t  var apiCheckDataChecker = checkers.shape({\n\t\t    type: checkers.string,\n\t\t    optional: checkers.bool\n\t\t  });\n\t\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t\t  if (isError(wrongShape)) {\n\t\t    return wrongShape;\n\t\t  }\n\t\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t\t    return getError(name, location, checkerTypeType.type);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerErrorMessage(res, checker, val) {\n\t\t  var checkerHelp = getCheckerHelp(checker, val);\n\t\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t\t  return res.message + checkerHelp;\n\t\t}\n\t\n\t\tfunction getCheckerHelp(_ref, val) {\n\t\t  var help = _ref.help;\n\t\n\t\t  if (!help) {\n\t\t    return '';\n\t\t  }\n\t\t  if (typeof help === 'function') {\n\t\t    help = help(val);\n\t\t  }\n\t\t  return help;\n\t\t}\n\t\n\t\tfunction checkEnoughArgs(api, args) {\n\t\t  var requiredArgs = api.filter(function (a) {\n\t\t    return !a.isOptional;\n\t\t  });\n\t\t  if (args.length < requiredArgs.length) {\n\t\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t\t  } else {\n\t\t    return [];\n\t\t  }\n\t\t}\n\t\n\t\tfunction getArgDisplay(arg, gottenArgs) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t\t  var type = typeOf(arg);\n\t\t  if (type === 'function') {\n\t\t    if (hasKeys()) {\n\t\t      var properties = stringify(getDisplayIfNotGotten());\n\t\t      return cName + ' (with properties: ' + properties + ')';\n\t\t    }\n\t\t    return cName;\n\t\t  }\n\t\n\t\t  if (arg === null) {\n\t\t    return 'null';\n\t\t  }\n\t\n\t\t  if (type !== 'array' && type !== 'object') {\n\t\t    return type;\n\t\t  }\n\t\n\t\t  if (hasKeys()) {\n\t\t    return getDisplayIfNotGotten();\n\t\t  }\n\t\n\t\t  return cName;\n\t\n\t\t  // utility functions\n\t\t  function hasKeys() {\n\t\t    return arg && Object.keys(arg).length;\n\t\t  }\n\t\n\t\t  function getDisplayIfNotGotten() {\n\t\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t\t      return '[Circular]';\n\t\t    }\n\t\t    gottenArgs.push(arg);\n\t\t    return getDisplay(arg, gottenArgs);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getDisplay(obj, gottenArgs) {\n\t\t  var argDisplay = {};\n\t\t  each(obj, function (v, k) {\n\t\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t\t  });\n\t\t  return argDisplay;\n\t\t}\n\t\n\t\tfunction getApiCheckApis() {\n\t\t  var os = checkers.string.optional;\n\t\n\t\t  var checkerFnChecker = checkers.func.withProperties({\n\t\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t\t    displayName: checkers.string.optional,\n\t\t    shortType: checkers.string.optional,\n\t\t    notOptional: checkers.bool.optional,\n\t\t    notRequired: checkers.bool.optional\n\t\t  });\n\t\n\t\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t\t    output: checkers.shape({\n\t\t      prefix: checkers.string.optional,\n\t\t      suffix: checkers.string.optional,\n\t\t      docsBaseUrl: checkers.string.optional\n\t\t    }).strict.optional,\n\t\t    verbose: checkers.bool.optional,\n\t\t    disabled: checkers.bool.optional\n\t\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\t\n\t\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t\t  }).strict.optional];\n\t\n\t\t  return {\n\t\t    checkerFnChecker: checkerFnChecker,\n\t\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t\t    checkApiCheckApi: checkApiCheckApi\n\t\t  };\n\t\t}\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = stringify;\n\t\n\t\tfunction getSerialize (fn, decycle) {\n\t\t  var seen = [], keys = [];\n\t\t  decycle = decycle || function(key, value) {\n\t\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t\t  };\n\t\t  return function(key, value) {\n\t\t    var ret = value;\n\t\t    if (typeof value === 'object' && value) {\n\t\t      if (seen.indexOf(value) !== -1)\n\t\t        ret = decycle(key, value);\n\t\t      else {\n\t\t        seen.push(value);\n\t\t        keys.push(key);\n\t\t      }\n\t\t    }\n\t\t    if (fn) ret = fn(key, ret);\n\t\t    return ret;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getPath (value, seen, keys) {\n\t\t  var index = seen.indexOf(value);\n\t\t  var path = [ keys[index] ];\n\t\t  for (index--; index >= 0; index--) {\n\t\t    if (seen[index][ path[0] ] === value) {\n\t\t      value = seen[index];\n\t\t      path.unshift(keys[index]);\n\t\t    }\n\t\t  }\n\t\t  return '~' + path.join('.');\n\t\t}\n\t\n\t\tfunction stringify(obj, fn, spaces, decycle) {\n\t\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t\t}\n\t\n\t\tstringify.getSerialize = getSerialize;\n\t\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar checkerHelpers = {\n\t\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t\t};\n\t\n\t\tmodule.exports = {\n\t\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t\t  noop: noop\n\t\t};\n\t\n\t\tfunction copy(obj) {\n\t\t  var type = typeOf(obj);\n\t\t  var daCopy = undefined;\n\t\t  if (type === 'array') {\n\t\t    daCopy = [];\n\t\t  } else if (type === 'object') {\n\t\t    daCopy = {};\n\t\t  } else {\n\t\t    return obj;\n\t\t  }\n\t\t  each(obj, function (val, key) {\n\t\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t\t  });\n\t\t  return daCopy;\n\t\t}\n\t\n\t\tfunction typeOf(obj) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return 'array';\n\t\t  } else if (obj instanceof RegExp) {\n\t\t    return 'object';\n\t\t  } else {\n\t\t    return typeof obj;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerDisplay(checker, options) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var display = undefined;\n\t\t  var short = options && options.short;\n\t\t  if (short && checker.shortType) {\n\t\t    display = checker.shortType;\n\t\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t\t    display = getCheckerType(checker, options);\n\t\t  } else {\n\t\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t\t  }\n\t\t  return display;\n\t\t}\n\t\n\t\tfunction getCheckerType(_ref, options) {\n\t\t  var type = _ref.type;\n\t\n\t\t  if (typeof type === 'function') {\n\t\t    var __apiCheckData = type.__apiCheckData;\n\t\t    var typeTypes = type(options);\n\t\t    type = _defineProperty({\n\t\t      __apiCheckData: __apiCheckData\n\t\t    }, __apiCheckData.type, typeTypes);\n\t\t  }\n\t\t  return type;\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (!obj) {\n\t\t    return [];\n\t\t  } else if (Array.isArray(obj)) {\n\t\t    return obj;\n\t\t  } else {\n\t\t    return [obj];\n\t\t  }\n\t\t}\n\t\n\t\tfunction each(obj, iterator, context) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return eachArry(obj, iterator, context);\n\t\t  } else {\n\t\t    return eachObj(obj, iterator, context);\n\t\t  }\n\t\t}\n\t\n\t\tfunction eachObj(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t\t  for (var key in obj) {\n\t\t    if (hasOwn.call(obj, key)) {\n\t\t      ret = iterator.call(context, obj[key], key, obj);\n\t\t      if (ret === false) {\n\t\t        return ret;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction eachArry(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var length = obj.length;\n\t\t  for (var i = 0; i < length; i++) {\n\t\t    ret = iterator.call(context, obj[i], i, obj);\n\t\t    if (ret === false) {\n\t\t      return ret;\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction isError(obj) {\n\t\t  return obj instanceof Error;\n\t\t}\n\t\n\t\tfunction list(arry, join, finalJoin) {\n\t\t  arry = arrayify(arry);\n\t\t  var copy = arry.slice();\n\t\t  var last = copy.pop();\n\t\t  if (copy.length === 1) {\n\t\t    join = ' ';\n\t\t  }\n\t\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t\t}\n\t\n\t\tfunction getError(name, location, checkerType) {\n\t\t  if (typeof checkerType === 'function') {\n\t\t    checkerType = checkerType({ short: true });\n\t\t  }\n\t\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t\t}\n\t\n\t\tfunction nAtL(name, location) {\n\t\t  var tName = t(name || 'value');\n\t\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t\t  return '' + tName + tLocation;\n\t\t}\n\t\n\t\tfunction t(thing) {\n\t\t  return '`' + thing + '`';\n\t\t}\n\t\n\t\tfunction undef(thing) {\n\t\t  return typeof thing === 'undefined';\n\t\t}\n\t\n\t\t/**\n\t\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t\t * optional version\n\t\t *\n\t\t * @param {Function} checker - the checker to setup with properties\n\t\t * @param {Object} properties - properties to add to the checker\n\t\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t\t * @returns {Function} checker - the setup checker\n\t\t */\n\t\tfunction setupChecker(checker, properties, disabled) {\n\t\t  /* eslint complexity:[2, 9] */\n\t\t  if (disabled) {\n\t\t    // swap out the checker for its own copy of noop\n\t\t    checker = getNoop();\n\t\t    checker.isNoop = true;\n\t\t  }\n\t\n\t\t  if (typeof checker.type === 'string') {\n\t\t    checker.shortType = checker.type;\n\t\t  }\n\t\n\t\t  // assign all properties given\n\t\t  each(properties, function (prop, name) {\n\t\t    return checker[name] = prop;\n\t\t  });\n\t\n\t\t  if (!checker.displayName) {\n\t\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t\t  }\n\t\n\t\t  if (!checker.notRequired) {\n\t\t    checker = getRequiredVersion(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notNullable) {\n\t\t    addNullable(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker, disabled);\n\t\t  }\n\t\n\t\t  return checker;\n\t\t}\n\t\n\t\tfunction getRequiredVersion(checker, disabled) {\n\t\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t\t    if (undef(val) && !checker.isOptional) {\n\t\t      var tLocation = location ? ' in ' + t(location) : '';\n\t\t      var type = getCheckerDisplay(checker, { short: true });\n\t\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t\t    } else {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  copyProps(checker, requiredChecker);\n\t\t  requiredChecker.originalChecker = checker;\n\t\t  return requiredChecker;\n\t\t}\n\t\n\t\tfunction addOptional(checker, disabled) {\n\t\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t\t    if (!undef(val)) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, optionalCheck);\n\t\n\t\t  optionalCheck.isOptional = true;\n\t\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t\t  optionalCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .optional to the end of the checkers\n\t\t  checker.optional = optionalCheck;\n\t\n\t\t  fixType(checker, checker.optional);\n\t\t}\n\t\n\t\tfunction addNullable(checker, disabled) {\n\t\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t\t    if (val !== null) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, nullableCheck);\n\t\n\t\t  nullableCheck.isNullable = true;\n\t\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t\t  nullableCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t\t  checker.nullable = nullableCheck;\n\t\n\t\t  fixType(checker, checker.nullable);\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker.nullable, disabled);\n\t\t  }\n\t\t}\n\t\n\t\tfunction fixType(checker, checkerCopy) {\n\t\t  // fix type, because it's not a straight copy...\n\t\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t\t  // we also want to add \"(optional)\" to the types with a string\n\t\t  if (typeof checkerCopy.type === 'object') {\n\t\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t\t  } else if (typeof checkerCopy.type === 'function') {\n\t\t      checkerCopy.type = function () {\n\t\t        return checker.type.apply(checker, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      checkerCopy.type += ' (optional)';\n\t\t      return;\n\t\t    }\n\t\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t\t  checkerCopy.type.__apiCheckData.optional = true;\n\t\t}\n\t\n\t\t// UTILS\n\t\n\t\tfunction copyProps(src, dest) {\n\t\t  each(Object.keys(src), function (key) {\n\t\t    return dest[key] = src[key];\n\t\t  });\n\t\t}\n\t\n\t\tfunction noop() {}\n\t\n\t\tfunction getNoop() {\n\t\t  /* eslint no-shadow:0 */\n\t\t  /* istanbul ignore next */\n\t\t  return function noop() {};\n\t\t}\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\n\t\tvar _require = __webpack_require__(3);\n\t\n\t\tvar typeOf = _require.typeOf;\n\t\tvar each = _require.each;\n\t\tvar copy = _require.copy;\n\t\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\t\tvar isError = _require.isError;\n\t\tvar arrayify = _require.arrayify;\n\t\tvar list = _require.list;\n\t\tvar getError = _require.getError;\n\t\tvar nAtL = _require.nAtL;\n\t\tvar t = _require.t;\n\t\tvar checkerHelpers = _require.checkerHelpers;\n\t\tvar undef = _require.undef;\n\t\tvar setupChecker = checkerHelpers.setupChecker;\n\t\n\t\tvar checkers = module.exports = getCheckers();\n\t\tmodule.exports.getCheckers = getCheckers;\n\t\n\t\tfunction getCheckers(disabled) {\n\t\t  return {\n\t\t    array: typeOfCheckGetter('Array'),\n\t\t    bool: typeOfCheckGetter('Boolean'),\n\t\t    number: typeOfCheckGetter('Number'),\n\t\t    string: typeOfCheckGetter('String'),\n\t\t    func: funcCheckGetter(),\n\t\t    object: objectCheckGetter(),\n\t\n\t\t    emptyObject: emptyObjectCheckGetter(),\n\t\n\t\t    instanceOf: instanceCheckGetter,\n\t\t    oneOf: oneOfCheckGetter,\n\t\t    oneOfType: oneOfTypeCheckGetter,\n\t\n\t\t    arrayOf: arrayOfCheckGetter,\n\t\t    objectOf: objectOfCheckGetter,\n\t\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\t\n\t\t    range: rangeCheckGetter,\n\t\t    lessThan: lessThanCheckGetter,\n\t\t    greaterThan: greaterThanCheckGetter,\n\t\n\t\t    shape: getShapeCheckGetter(),\n\t\t    args: argumentsCheckerGetter(),\n\t\n\t\t    any: anyCheckGetter(),\n\t\t    'null': nullCheckGetter()\n\t\n\t\t  };\n\t\n\t\t  function typeOfCheckGetter(type) {\n\t\t    var lType = type.toLowerCase();\n\t\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== lType) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function funcCheckGetter() {\n\t\t    var type = 'Function';\n\t\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'function') {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\n\t\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t\t      if (isError(apiError)) {\n\t\t        throw apiError;\n\t\t      }\n\t\t      var shapeChecker = checkers.shape(properties, true);\n\t\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\t\n\t\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t\t        var notFunction = checkers.func(val, name, location);\n\t\t        if (isError(notFunction)) {\n\t\t          return notFunction;\n\t\t        }\n\t\t        return shapeChecker(val, name, location);\n\t\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t\t    };\n\t\t    return functionChecker;\n\t\t  }\n\t\n\t\t  function objectCheckGetter() {\n\t\t    var type = 'Object';\n\t\t    var nullType = 'Object (null ok)';\n\t\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'object') {\n\t\t        return getError(name, location, nullType);\n\t\t      }\n\t\t    }, { type: nullType }, disabled);\n\t\n\t\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t\t        return getError(name, location, objectChecker.type);\n\t\t      }\n\t\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\t\n\t\t    return objectChecker;\n\t\t  }\n\t\n\t\t  function instanceCheckGetter(classToCheck) {\n\t\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t\t      if (!(val instanceof classToCheck)) {\n\t\t        return getError(name, location, classToCheck.name);\n\t\t      }\n\t\t    }, { type: classToCheck.name }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfCheckGetter(enums) {\n\t\t    var type = {\n\t\t      __apiCheckData: { optional: false, type: 'enum' },\n\t\t      'enum': enums\n\t\t    };\n\t\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t\t      return stringify(enm);\n\t\t    }).join(', ') + ']';\n\t\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t\t      if (!enums.some(function (enm) {\n\t\t        return enm === val;\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t\t      return getCheckerDisplay(checker, { short: true });\n\t\t    });\n\t\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return typeCheckers.map(function (checker) {\n\t\t        return getCheckerDisplay(checker, options);\n\t\t      });\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t\t      if (!typeCheckers.some(function (checker) {\n\t\t        return !isError(checker(val, name, location));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function arrayOfCheckGetter(checker) {\n\t\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\t\n\t\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t\t        return !isError(checker(item));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function objectOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\t\n\t\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t\t      var notObject = checkers.object(val, name, location);\n\t\t      if (isError(notObject)) {\n\t\t        return notObject;\n\t\t      }\n\t\t      var allTypesSuccess = each(val, function (item, key) {\n\t\t        if (isError(checker(item, key, name))) {\n\t\t          return false;\n\t\t        }\n\t\t      });\n\t\t      if (!allTypesSuccess) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function typeOrArrayOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\n\t\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function getShapeCheckGetter() {\n\t\t    function shapeCheckGetter(shape, nonObject) {\n\t\t      var shapeTypes = {};\n\t\t      each(shape, function (checker, prop) {\n\t\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t\t      });\n\t\t      function type() {\n\t\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t\t        var ret = {};\n\t\t        var terse = options.terse;\n\t\t        var obj = options.obj;\n\t\t        var addHelpers = options.addHelpers;\n\t\n\t\t        var parentRequired = options.required;\n\t\t        each(shape, function (checker, prop) {\n\t\t          /* eslint complexity:[2, 6] */\n\t\t          var specified = obj && obj.hasOwnProperty(prop);\n\t\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t\t          if (!terse || (specified || !checker.isOptional)) {\n\t\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t\t          }\n\t\t          if (addHelpers) {\n\t\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t\t          }\n\t\t        });\n\t\t        return ret;\n\t\n\t\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t\t          if (!specified && required && !checker.isOptional) {\n\t\t            var item = 'ITEM';\n\t\t            if (checker.type && checker.type.__apiCheckData) {\n\t\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t\t            }\n\t\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t\t          } else if (specified) {\n\t\t            var error = checker(obj[prop], prop, null, obj);\n\t\t            if (isError(error)) {\n\t\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t\t            }\n\t\t          }\n\t\n\t\t          function addHelper(property, objectMessage, stringMessage) {\n\t\t            if (typeof theRet[prop] === 'string') {\n\t\t              theRet[prop] += stringMessage;\n\t\t            } else {\n\t\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\n\t\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t\t        if (isError(isObject)) {\n\t\t          return isObject;\n\t\t        }\n\t\t        var shapePropError = undefined;\n\t\t        location = location ? location + (name ? '/' : '') : '';\n\t\t        name = name || '';\n\t\t        each(shape, function (checker, prop) {\n\t\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t\t            return !isError(shapePropError);\n\t\t          }\n\t\t        });\n\t\t        if (isError(shapePropError)) {\n\t\t          return shapePropError;\n\t\t        }\n\t\t      }, { type: type, shortType: 'shape' }, disabled);\n\t\n\t\t      function strictType() {\n\t\t        return type.apply(undefined, arguments);\n\t\t      }\n\t\n\t\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t\t      strictType.__apiCheckData.strict = true;\n\t\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t\t        var shapeError = shapeChecker(val, name, location);\n\t\t        if (isError(shapeError)) {\n\t\t          return shapeError;\n\t\t        }\n\t\t        var allowedProperties = Object.keys(shape);\n\t\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t\t          return allowedProperties.indexOf(prop) === -1;\n\t\t        });\n\t\t        if (extraProps.length) {\n\t\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t\t        }\n\t\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\t\n\t\t      return shapeChecker;\n\t\t    }\n\t\n\t\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t\t      } else {\n\t\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (propExists === otherPropsExist) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t\t      otherProps = arrayify(otherProps);\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t\t      } else {\n\t\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t\t        var othersPresent = otherProps.every(function (property) {\n\t\t          return obj.hasOwnProperty(property);\n\t\t        });\n\t\t        if (!othersPresent) {\n\t\t          return getError(propName, location, type);\n\t\t        } else {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        throw new Error('requiredIfNot.all must be passed an array');\n\t\t      }\n\t\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t\t      var props = t(otherProps.join(', '));\n\t\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var iteration = all ? 'every' : 'some';\n\t\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (!otherPropsExist && !propExists) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, notRequired: true }, disabled);\n\t\t    }\n\t\n\t\t    return shapeCheckGetter;\n\t\n\t\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t\t      function type(options) {\n\t\t        if (options && options.short) {\n\t\t          return shortType;\n\t\t        }\n\t\t        return getCheckerDisplay(propChecker);\n\t\t      }\n\t\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function argumentsCheckerGetter() {\n\t\t    var type = 'function arguments';\n\t\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function anyCheckGetter() {\n\t\t    return setupChecker(function anyCheckerDefinition() {\n\t\t      // don't do anything\n\t\t    }, { type: 'any' }, disabled);\n\t\t  }\n\t\n\t\t  function nullCheckGetter() {\n\t\t    var type = 'null';\n\t\t    return setupChecker(function nullChecker(val, name, location) {\n\t\t      if (val !== null) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function rangeCheckGetter(min, max) {\n\t\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t\t    return setupChecker(function rangeChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < min || val > max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function lessThanCheckGetter(min) {\n\t\t    var type = 'lessThan[' + min + ']';\n\t\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val > min) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function greaterThanCheckGetter(max) {\n\t\t    var type = 'greaterThan[' + max + ']';\n\t\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function emptyObjectCheckGetter() {\n\t\t    var type = 'empty object';\n\t\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\t}\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n\n/***/ 5:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t* angular-formly JavaScript Library v7.5.0\n\t*\n\t* @license MIT (http://license.angular-formly.com)\n\t*\n\t* built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n\t* ( _)==(_ )\n\t*/\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _indexCommon = __webpack_require__(1);\n\t\n\t\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\t\n\t\texports['default'] = _indexCommon2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\t\n\t\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\t\n\t\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\t\n\t\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\t\n\t\tvar _providersFormlyUsability = __webpack_require__(7);\n\t\n\t\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\t\n\t\tvar _providersFormlyConfig = __webpack_require__(8);\n\t\n\t\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\t\n\t\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\t\n\t\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\t\n\t\tvar _servicesFormlyUtil = __webpack_require__(11);\n\t\n\t\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\t\n\t\tvar _servicesFormlyWarn = __webpack_require__(12);\n\t\n\t\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\t\n\t\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\t\n\t\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\t\n\t\tvar _directivesFormlyField = __webpack_require__(14);\n\t\n\t\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\t\n\t\tvar _directivesFormlyFocus = __webpack_require__(15);\n\t\n\t\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\t\n\t\tvar _directivesFormlyForm = __webpack_require__(16);\n\t\n\t\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\t\n\t\tvar _runFormlyCustomTags = __webpack_require__(18);\n\t\n\t\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\t\n\t\tvar ngModuleName = 'formly';\n\t\n\t\texports['default'] = ngModuleName;\n\t\n\t\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\t\n\t\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\t\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\t\tngModule.constant('formlyVersion', (\"7.5.0\")); // <-- webpack variable\n\t\n\t\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\t\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\t\n\t\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\t\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\t\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\t\n\t\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\t\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\t\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\t\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\t\n\t\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\t\tngModule.run(_runFormlyCustomTags2['default']);\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar angular = __webpack_require__(3);\n\t\n\t\t/* istanbul ignore next */\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\texports['default'] = angular;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\tvar apiCheck = (0, _apiCheck2['default'])({\n\t\t  output: {\n\t\t    prefix: 'angular-formly:',\n\t\t    docsBaseUrl: __webpack_require__(6)\n\t\t  }\n\t\t});\n\t\n\t\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t\t    otherProps = [otherProps];\n\t\t  }\n\t\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\t\n\t\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t      return obj && obj.hasOwnProperty(otherProp);\n\t\t    });\n\t\t    if (!otherPropsExist && !propExists) {\n\t\t      return apiCheck.utils.getError(propName, location, type);\n\t\t    } else if (propExists) {\n\t\t      return propChecker(prop, propName, location, obj);\n\t\t    }\n\t\t  }\n\t\n\t\t  shapeRequiredIfNotDefinition.type = type;\n\t\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t\t}\n\t\n\t\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\t\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\t\n\t\tvar apiCheckProperty = apiCheck.func;\n\t\n\t\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t\t  warn: apiCheck.func,\n\t\t  'throw': apiCheck.func,\n\t\t  shape: apiCheck.func\n\t\t}));\n\t\n\t\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\t\n\t\tvar formlyWrapperType = apiCheck.shape({\n\t\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  overwriteOk: apiCheck.bool.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\t\n\t\tvar templateManipulators = apiCheck.shape({\n\t\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t\t}).strict.nullable;\n\t\n\t\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar fieldOptionsApiShape = {\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  model: modelChecker.optional,\n\t\t  originalModel: modelChecker.optional,\n\t\t  className: apiCheck.string.optional,\n\t\t  id: apiCheck.string.optional,\n\t\t  name: apiCheck.string.optional,\n\t\t  expressionProperties: expressionProperties.optional,\n\t\t  extras: apiCheck.shape({\n\t\t    validateOnModelChange: apiCheck.bool.optional,\n\t\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t\t  }).strict.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  templateOptions: apiCheck.object.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  modelOptions: apiCheck.shape({\n\t\t    updateOn: apiCheck.string.optional,\n\t\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t\t    allowInvalid: apiCheck.bool.optional,\n\t\t    getterSetter: apiCheck.bool.optional,\n\t\t    timezone: apiCheck.string.optional\n\t\t  }).optional,\n\t\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t\t    expression: formlyExpression.optional,\n\t\t    listener: formlyExpression.optional,\n\t\t    runFieldExpressions: apiCheck.bool.optional\n\t\t  })).optional,\n\t\t  validators: validatorChecker.optional,\n\t\t  asyncValidators: validatorChecker.optional,\n\t\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  noFormControl: apiCheck.bool.optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t\t  }).strict).optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t\t  validation: apiCheck.shape({\n\t\t    show: apiCheck.bool.nullable.optional,\n\t\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t\t  }).optional,\n\t\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t\t  value: apiCheck.func.optional,\n\t\t  runExpressions: apiCheck.func.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  initialValue: apiCheck.any.optional,\n\t\t  defaultValue: apiCheck.any.optional\n\t\t};\n\t\n\t\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\t\n\t\tvar formOptionsApi = apiCheck.shape({\n\t\t  formState: apiCheck.object.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  manualModelWatcher: apiCheck.oneOfType([apiCheck.bool, apiCheck.func]).optional,\n\t\t  watchAllExpressions: apiCheck.bool.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t\t  data: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar fieldGroup = apiCheck.shape({\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  // danger. Nested field groups wont get api-checked...\n\t\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t\t  className: apiCheck.string.optional,\n\t\t  options: formOptionsApi.optional,\n\t\t  templateOptions: apiCheck.object.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t\t    expression: formlyExpression.optional,\n\t\t    listener: formlyExpression\n\t\t  })).optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  model: modelChecker.optional,\n\t\t  form: apiCheck.object.optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t\t}).strict;\n\t\n\t\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\t\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\t\n\t\tvar formlyTypeOptions = apiCheck.shape({\n\t\t  name: apiCheck.string,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t\t  'extends': apiCheck.string.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional,\n\t\t  overwriteOk: apiCheck.bool.optional\n\t\t}).strict;\n\t\n\t\t_angularFix2['default'].extend(apiCheck, {\n\t\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t\t});\n\t\n\t\texports['default'] = apiCheck;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.5.0\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\t\tmodule.exports = exports[\"default\"];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyUsability;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t\t  var _this = this;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    getFormlyError: getFormlyError,\n\t\t    getFieldError: getFieldError,\n\t\t    checkWrapper: checkWrapper,\n\t\t    checkWrapperTemplate: checkWrapperTemplate,\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    $get: function $get() {\n\t\t      return _this;\n\t\t    }\n\t\t  });\n\t\n\t\t  function getFieldError(errorInfoSlug, message, field) {\n\t\t    if (arguments.length < 3) {\n\t\t      field = message;\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t\t  }\n\t\n\t\t  function getFormlyError(errorInfoSlug, message) {\n\t\t    if (!message) {\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t\t  }\n\t\n\t\t  function getErrorMessage(errorInfoSlug, message) {\n\t\t    var url = '';\n\t\t    if (errorInfoSlug !== null) {\n\t\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t\t    }\n\t\t    return 'Formly Error: ' + message + '. ' + url;\n\t\t  }\n\t\n\t\t  function checkWrapper(wrapper) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t\t      prefix: 'formlyConfig.setWrapper',\n\t\t      urlSuffix: 'setwrapper-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function checkWrapperTemplate(template, additionalInfo) {\n\t\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t\t    if (template.indexOf(formlyTransclude) === -1) {\n\t\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyConfig;\n\t\n\t\t// @ngInject\n\t\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t\t  var _this2 = this;\n\t\n\t\t  var typeMap = {};\n\t\t  var templateWrappersMap = {};\n\t\t  var defaultWrapperName = 'default';\n\t\t  var _this = this;\n\t\t  var getError = formlyUsabilityProvider.getFormlyError;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    setType: setType,\n\t\t    getType: getType,\n\t\t    getTypeHeritage: getTypeHeritage,\n\t\t    setWrapper: setWrapper,\n\t\t    getWrapper: getWrapper,\n\t\t    getWrapperByType: getWrapperByType,\n\t\t    removeWrapperByName: removeWrapperByName,\n\t\t    removeWrappersForType: removeWrappersForType,\n\t\t    disableWarnings: false,\n\t\t    extras: {\n\t\t      disableNgModelAttrsManipulator: false,\n\t\t      fieldTransform: [],\n\t\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t\t      removeChromeAutoComplete: false,\n\t\t      defaultHideDirective: 'ng-if',\n\t\t      getFieldId: null\n\t\t    },\n\t\t    templateManipulators: {\n\t\t      preWrapper: [],\n\t\t      postWrapper: []\n\t\t    },\n\t\t    $get: function $get() {\n\t\t      return _this2;\n\t\t    }\n\t\t  });\n\t\n\t\t  function setType(options) {\n\t\t    if (_angularFix2['default'].isArray(options)) {\n\t\t      var _ret = (function () {\n\t\t        var allTypes = [];\n\t\t        _angularFix2['default'].forEach(options, function (item) {\n\t\t          allTypes.push(setType(item));\n\t\t        });\n\t\t        return {\n\t\t          v: allTypes\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret === 'object') return _ret.v;\n\t\t    } else if (_angularFix2['default'].isObject(options)) {\n\t\t      checkType(options);\n\t\t      if (options['extends']) {\n\t\t        extendTypeOptions(options);\n\t\t      }\n\t\t      typeMap[options.name] = options;\n\t\t      return typeMap[options.name];\n\t\t    } else {\n\t\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkType(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t\t      prefix: 'formlyConfig.setType',\n\t\t      url: 'settype-validation-failed'\n\t\t    });\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t\t    } else {\n\t\t      options.overwriteOk = undefined;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeOptions(options) {\n\t\t    var extendsType = getType(options['extends'], true, options);\n\t\t    extendTypeControllerFunction(options, extendsType);\n\t\t    extendTypeLinkFunction(options, extendsType);\n\t\t    extendTypeDefaultOptions(options, extendsType);\n\t\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t\t    extendTemplate(options, extendsType);\n\t\t  }\n\t\n\t\t  function extendTemplate(options, extendsType) {\n\t\t    if (options.template && extendsType.templateUrl) {\n\t\t      delete options.templateUrl;\n\t\t    } else if (options.templateUrl && extendsType.template) {\n\t\t      delete options.template;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeControllerFunction(options, extendsType) {\n\t\t    var extendsCtrl = extendsType.controller;\n\t\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsCtrl = options.controller;\n\t\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t\t      options.controller = function ($scope, $controller) {\n\t\t        $controller(extendsCtrl, { $scope: $scope });\n\t\t        $controller(optionsCtrl, { $scope: $scope });\n\t\t      };\n\t\t      options.controller.$inject = ['$scope', '$controller'];\n\t\t    } else {\n\t\t      options.controller = extendsCtrl;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeLinkFunction(options, extendsType) {\n\t\t    var extendsFn = extendsType.link;\n\t\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsFn = options.link;\n\t\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t\t      options.link = function () {\n\t\t        extendsFn.apply(undefined, arguments);\n\t\t        optionsFn.apply(undefined, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      options.link = extendsFn;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeDefaultOptions(options, extendsType) {\n\t\t    var extendsDO = extendsType.defaultOptions;\n\t\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsDO = options.defaultOptions;\n\t\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t\t    if (extendsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t\t        var mergedDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t\t        var extenderOptionsDefaultOptions = optionsDO;\n\t\t        if (optionsDOIsFn) {\n\t\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t\t        }\n\t\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t\t        return extendsDefaultOptions;\n\t\t      };\n\t\t    } else if (optionsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var newDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t\t        return optionsDO(newDefaultOptions, scope);\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function getType(name, throwError, errorContext) {\n\t\t    if (!name) {\n\t\t      return undefined;\n\t\t    }\n\t\t    var type = typeMap[name];\n\t\t    if (!type && throwError === true) {\n\t\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t\t    } else {\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypeHeritage(parent) {\n\t\t    var heritage = [];\n\t\t    var type = parent;\n\t\t    if (_angularFix2['default'].isString(type)) {\n\t\t      type = getType(parent);\n\t\t    }\n\t\t    parent = type['extends'];\n\t\t    while (parent) {\n\t\t      type = getType(parent);\n\t\t      heritage.push(type);\n\t\t      parent = type['extends'];\n\t\t    }\n\t\t    return heritage;\n\t\t  }\n\t\n\t\t  function setWrapper(_x, _x2) {\n\t\t    var _again = true;\n\t\n\t\t    _function: while (_again) {\n\t\t      var options = _x,\n\t\t          name = _x2;\n\t\t      _again = false;\n\t\n\t\t      if (_angularFix2['default'].isArray(options)) {\n\t\t        return options.map(function (wrapperOptions) {\n\t\t          return setWrapper(wrapperOptions);\n\t\t        });\n\t\t      } else if (_angularFix2['default'].isObject(options)) {\n\t\t        options.types = getOptionsTypes(options);\n\t\t        options.name = getOptionsName(options, name);\n\t\t        checkWrapperAPI(options);\n\t\t        templateWrappersMap[options.name] = options;\n\t\t        return options;\n\t\t      } else if (_angularFix2['default'].isString(options)) {\n\t\t        _x = {\n\t\t          template: options,\n\t\t          name: name\n\t\t        };\n\t\t        _x2 = undefined;\n\t\t        _again = true;\n\t\t        continue _function;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsTypes(options) {\n\t\t    if (_angularFix2['default'].isString(options.types)) {\n\t\t      return [options.types];\n\t\t    }\n\t\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t\t      return [];\n\t\t    } else {\n\t\t      return options.types;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsName(options, name) {\n\t\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t\t  }\n\t\n\t\t  function checkWrapperAPI(options) {\n\t\t    formlyUsabilityProvider.checkWrapper(options);\n\t\t    if (options.template) {\n\t\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t\t    }\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t\t    } else {\n\t\t      delete options.overwriteOk;\n\t\t    }\n\t\t    checkWrapperTypes(options);\n\t\t  }\n\t\n\t\t  function checkWrapperTypes(options) {\n\t\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t\t    if (shouldThrow) {\n\t\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkOverwrite(property, object, newValue, objectName) {\n\t\t    if (object.hasOwnProperty(property)) {\n\t\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t\t    }\n\t\t  }\n\t\n\t\t  function getWrapper(name) {\n\t\t    return templateWrappersMap[name || defaultWrapperName];\n\t\t  }\n\t\n\t\t  function getWrapperByType(type) {\n\t\t    /* eslint prefer-const:0 */\n\t\t    var wrappers = [];\n\t\t    for (var _name in templateWrappersMap) {\n\t\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t\t          wrappers.push(templateWrappersMap[_name]);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return wrappers;\n\t\t  }\n\t\n\t\t  function removeWrapperByName(name) {\n\t\t    var wrapper = templateWrappersMap[name];\n\t\t    delete templateWrappersMap[name];\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function removeWrappersForType(type) {\n\t\t    var wrappers = getWrapperByType(type);\n\t\t    if (!wrappers) {\n\t\t      return undefined;\n\t\t    }\n\t\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t\t      return removeWrapperByName(wrappers.name);\n\t\t    } else {\n\t\t      wrappers.forEach(function (wrapper) {\n\t\t        return removeWrapperByName(wrapper.name);\n\t\t      });\n\t\t      return wrappers;\n\t\t    }\n\t\t  }\n\t\n\t\t  function warn() {\n\t\t    if (!_this.disableWarnings && console.warn) {\n\t\t      /* eslint no-console:0 */\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      console.warn.apply(console, _toConsumableArray(args));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = {\n\t\t  containsSelector: containsSelector, containsSpecialChar: containsSpecialChar, formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName,\n\t\t  arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t\t};\n\t\n\t\tfunction containsSelector(string) {\n\t\t  return containsSpecialChar(string, '.') || containsSpecialChar(string, '[') && containsSpecialChar(string, ']');\n\t\t}\n\t\n\t\tfunction containsSpecialChar(a, b) {\n\t\t  if (!a || !a.indexOf) {\n\t\t    return false;\n\t\t  }\n\t\t  return a.indexOf(b) !== -1;\n\t\t}\n\t\n\t\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t\t  if (_angularFix2['default'].isFunction(expression)) {\n\t\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t\t  } else {\n\t\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t\t  }\n\t\t}\n\t\n\t\tfunction getFieldId(formId, options, index) {\n\t\t  if (options.id) {\n\t\t    return options.id;\n\t\t  }\n\t\t  var type = options.type;\n\t\t  if (!type && options.template) {\n\t\t    type = 'template';\n\t\t  } else if (!type && options.templateUrl) {\n\t\t    type = 'templateUrl';\n\t\t  }\n\t\n\t\t  return [formId, type, options.key, index].join('_');\n\t\t}\n\t\n\t\tfunction reverseDeepMerge(dest) {\n\t\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t\t    if (!index) {\n\t\t      return;\n\t\t    }\n\t\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t\t        dest[prop] = _angularFix2['default'].copy(val);\n\t\t      } else if (objAndSameType(dest[prop], val)) {\n\t\t        reverseDeepMerge(dest[prop], val);\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t  return dest;\n\t\t}\n\t\n\t\tfunction objAndSameType(obj1, obj2) {\n\t\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t\t}\n\t\n\t\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\t\tfunction findByNodeName(el, nodeName) {\n\t\t  if (!el.prop) {\n\t\t    // not a jQuery or jqLite object -> wrap it\n\t\t    el = _angularFix2['default'].element(el);\n\t\t  }\n\t\n\t\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t\t    return el;\n\t\t  }\n\t\n\t\t  var c = el.children();\n\t\t  for (var i = 0; c && i < c.length; i++) {\n\t\t    var node = findByNodeName(c[i], nodeName);\n\t\t    if (node) {\n\t\t      return node;\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t\t    obj = [obj];\n\t\t  } else if (!obj) {\n\t\t    obj = [];\n\t\t  }\n\t\t  return obj;\n\t\t}\n\t\n\t\tfunction extendFunction() {\n\t\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t    fns[_key] = arguments[_key];\n\t\t  }\n\t\n\t\t  return function extendedFunction() {\n\t\t    var args = arguments;\n\t\t    fns.forEach(function (fn) {\n\t\t      return fn.apply(null, args);\n\t\t    });\n\t\t  };\n\t\t}\n\t\n\t\tfunction extendArray(primary, secondary, property) {\n\t\t  if (property) {\n\t\t    primary = primary[property];\n\t\t    secondary = secondary[property];\n\t\t  }\n\t\t  if (secondary && primary) {\n\t\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t\t      if (primary.indexOf(item) === -1) {\n\t\t        primary.push(item);\n\t\t      }\n\t\t    });\n\t\t    return primary;\n\t\t  } else if (secondary) {\n\t\t    return secondary;\n\t\t  } else {\n\t\t    return primary;\n\t\t  }\n\t\t}\n\t\n\t\tfunction startsWith(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\n\t\tfunction contains(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\texports['default'] = formlyValidationMessages;\n\t\n\t\t// @ngInject\n\t\tfunction formlyValidationMessages() {\n\t\n\t\t  var validationMessages = {\n\t\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t\t    addStringMessage: addStringMessage,\n\t\t    messages: {}\n\t\t  };\n\t\n\t\t  return validationMessages;\n\t\n\t\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t\t  }\n\t\n\t\t  function addStringMessage(name, string) {\n\t\t    validationMessages.messages[name] = function () {\n\t\t      return string;\n\t\t    };\n\t\t  }\n\t\n\t\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t\t      if (typeof scope.options.templateOptions[prop] !== 'undefined') {\n\t\t        return prefix + ' ' + scope.options.templateOptions[prop] + ' ' + suffix;\n\t\t      } else {\n\t\t        return alternate;\n\t\t      }\n\t\t    };\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyUtil;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUtil() {\n\t\t  return _otherUtils2['default'];\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\texports['default'] = formlyWarn;\n\t\n\t\t// @ngInject\n\t\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t\t  return function warn() {\n\t\t    if (!formlyConfig.disableWarnings) {\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      $log.warn.apply($log, _toConsumableArray(args));\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyCustomValidation;\n\t\n\t\t// @ngInject\n\t\tfunction formlyCustomValidation(formlyUtil) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    require: 'ngModel',\n\t\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t\t      var opts = scope.options;\n\t\t      opts.validation.messages = opts.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t\t        opts.validation.messages[key] = function () {\n\t\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t        };\n\t\t      });\n\t\n\t\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\t\n\t\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t\t        setupMessage(validator, name);\n\t\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t\t        if (useNewValidatorsApi) {\n\t\t          setupWithValidators(validator, name, isAsync);\n\t\t        } else {\n\t\t          setupWithParsers(validator, name, isAsync);\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupMessage(validator, name) {\n\t\t        var message = validator.message;\n\t\t        if (message) {\n\t\t          opts.validation.messages[name] = function () {\n\t\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t          };\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupWithValidators(validator, name, isAsync) {\n\t\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\t\n\t\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t\t        };\n\t\t      }\n\t\n\t\t      function setupWithParsers(validator, name, isAsync) {\n\t\t        var inFlightValidator = undefined;\n\t\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t\t          if (isAsync) {\n\t\t            ctrl.$pending = ctrl.$pending || {};\n\t\t            ctrl.$pending[name] = true;\n\t\t            inFlightValidator = isValid;\n\t\t            isValid.then(function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, true);\n\t\t              }\n\t\t            })['catch'](function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, false);\n\t\t              }\n\t\t            })['finally'](function () {\n\t\t              var $pending = ctrl.$pending || {};\n\t\t              if (Object.keys($pending).length === 1) {\n\t\t                delete ctrl.$pending;\n\t\t              } else {\n\t\t                delete ctrl.$pending[name];\n\t\t              }\n\t\t            });\n\t\t          } else {\n\t\t            ctrl.$setValidity(name, isValid);\n\t\t          }\n\t\t          return viewValue;\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = formlyField;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyField\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t\t  var arrayify = formlyUtil.arrayify;\n\t\n\t\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    transclude: true,\n\t\t    require: '?^formlyForm',\n\t\t    scope: {\n\t\t      options: '=',\n\t\t      model: '=',\n\t\t      originalModel: '=?',\n\t\t      formId: '@', // TODO remove formId in a breaking release\n\t\t      index: '=?',\n\t\t      fields: '=?',\n\t\t      formState: '=?',\n\t\t      formOptions: '=?',\n\t\t      form: '=?' },\n\t\t    // TODO require form in a breaking release\n\t\t    controller: FormlyFieldController,\n\t\t    link: fieldLink\n\t\t  };\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t\t    /* eslint max-statements:[2, 34] */\n\t\t    if ($scope.options.fieldGroup) {\n\t\t      setupFieldGroup();\n\t\t      return;\n\t\t    }\n\t\n\t\t    var fieldType = getFieldType($scope.options);\n\t\t    simplifyLife($scope.options);\n\t\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t\t    checkApi($scope.options);\n\t\t    // set field id to link labels and fields\n\t\n\t\t    // initalization\n\t\t    setFieldIdAndName();\n\t\t    setDefaultValue();\n\t\t    setInitialValue();\n\t\t    runExpressions();\n\t\t    watchExpressions();\n\t\t    addValidationMessages($scope.options);\n\t\t    invokeControllers($scope, $scope.options, fieldType);\n\t\n\t\t    // function definitions\n\t\t    function runExpressions() {\n\t\t      // must run on next tick to make sure that the current value is correct.\n\t\t      return $timeout(function runExpressionsOnNextTick() {\n\t\t        var field = $scope.options;\n\t\t        var currentValue = valueGetterSetter();\n\t\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t\t          var setter = $parse(prop).assign;\n\t\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t\t          promise.then(function setFieldValue(value) {\n\t\t            setter(field, value);\n\t\t          });\n\t\t        });\n\t\t      }, 0, false);\n\t\t    }\n\t\n\t\t    function watchExpressions() {\n\t\t      if ($scope.formOptions.watchAllExpressions) {\n\t\t        (function () {\n\t\t          var field = $scope.options;\n\t\t          var currentValue = valueGetterSetter();\n\t\t          _angularFix2['default'].forEach(field.expressionProperties, function watchExpression(expression, prop) {\n\t\t            var setter = $parse(prop).assign;\n\t\t            $scope.$watch(function expressionPropertyWatcher() {\n\t\t              return formlyUtil.formlyEval($scope, expression, currentValue, currentValue);\n\t\t            }, function expressionPropertyListener(value) {\n\t\t              setter(field, value);\n\t\t            }, true);\n\t\t          });\n\t\t        })();\n\t\t      }\n\t\t    }\n\t\n\t\t    function valueGetterSetter(newVal) {\n\t\t      if (!$scope.model || !$scope.options.key) {\n\t\t        return undefined;\n\t\t      }\n\t\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t\t        parseSet($scope.options.key, $scope.model, newVal);\n\t\t      }\n\t\t      return parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function shouldNotUseParseKey(key) {\n\t\t      return _angularFix2['default'].isNumber(key) || !formlyUtil.containsSelector(key);\n\t\t    }\n\t\n\t\t    function parseSet(key, model, newVal) {\n\t\t      // If either of these are null/undefined then just return undefined\n\t\t      if (!key || !model) {\n\t\t        return;\n\t\t      }\n\t\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t\t      if (shouldNotUseParseKey(key)) {\n\t\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t\t        model[key] = newVal;\n\t\t      } else {\n\t\t        var setter = $parse($scope.options.key).assign;\n\t\t        if (setter) {\n\t\t          setter($scope.model, newVal);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function parseGet(key, model) {\n\t\t      // If either of these are null/undefined then just return undefined\n\t\t      if (!key || !model) {\n\t\t        return undefined;\n\t\t      }\n\t\n\t\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t\t      if (shouldNotUseParseKey(key)) {\n\t\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t\t        return model[key];\n\t\t      } else {\n\t\t        return $parse(key)(model);\n\t\t      }\n\t\t    }\n\t\n\t\t    function simplifyLife(options) {\n\t\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t\t      formlyUtil.reverseDeepMerge(options, {\n\t\t        originalModel: options.model,\n\t\t        extras: {},\n\t\t        data: {},\n\t\t        templateOptions: {},\n\t\t        validation: {}\n\t\t      });\n\t\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t\t      $scope.to = $scope.options.templateOptions;\n\t\t      $scope.formOptions = $scope.formOptions || {};\n\t\t    }\n\t\n\t\t    function setFieldIdAndName() {\n\t\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t\t      } else {\n\t\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t\t      }\n\t\t      $scope.options.id = $scope.id;\n\t\t      $scope.name = $scope.options.name || $scope.options.id;\n\t\t      $scope.options.name = $scope.name;\n\t\t    }\n\t\n\t\t    function setDefaultValue() {\n\t\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined(parseGet($scope.options.key, $scope.model))) {\n\t\t        parseSet($scope.options.key, $scope.model, $scope.options.defaultValue);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setInitialValue() {\n\t\t      $scope.options.initialValue = $scope.model && parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t\t      if (type) {\n\t\t        mergeOptions(options, type.defaultOptions);\n\t\t      }\n\t\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t\t      });\n\t\t    }\n\t\n\t\t    function mergeOptions(options, extraOptions) {\n\t\t      if (extraOptions) {\n\t\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t\t          extraOptions = extraOptions(options, $scope);\n\t\t        }\n\t\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t\t      }\n\t\t    }\n\t\n\t\t    function extendOptionsWithDefaults(options, index) {\n\t\t      var key = options.key || index || 0;\n\t\t      _angularFix2['default'].extend(options, {\n\t\t        // attach the key in case the formly-field directive is used directly\n\t\t        key: key,\n\t\t        value: options.value || valueGetterSetter,\n\t\t        runExpressions: runExpressions,\n\t\t        resetModel: resetModel,\n\t\t        updateInitialValue: updateInitialValue\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      parseSet($scope.options.key, $scope.model, $scope.options.initialValue);\n\t\t      if ($scope.options.formControl) {\n\t\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t\t            resetFormControl(formControl, true);\n\t\t          });\n\t\t        } else {\n\t\t          resetFormControl($scope.options.formControl);\n\t\t        }\n\t\t      }\n\t\t      if ($scope.form) {\n\t\t        $scope.form.$setUntouched && $scope.form.$setUntouched();\n\t\t        $scope.form.$setPristine();\n\t\t      }\n\t\t    }\n\t\n\t\t    function resetFormControl(formControl, isMultiNgModel) {\n\t\t      if (!isMultiNgModel) {\n\t\t        formControl.$setViewValue(parseGet($scope.options.key, $scope.model));\n\t\t      }\n\t\n\t\t      formControl.$render();\n\t\t      formControl.$setUntouched && formControl.$setUntouched();\n\t\t      formControl.$setPristine();\n\t\n\t\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t\t      if (!$scope.$root.$$phase) {\n\t\t        $scope.$digest();\n\t\t      }\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      $scope.options.initialValue = parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function addValidationMessages(options) {\n\t\t      options.validation.messages = options.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t\t        if (!options.validation.messages[name]) {\n\t\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t\t          };\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function invokeControllers(scope) {\n\t\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t\t        if (controller) {\n\t\t          $controller(controller, { $scope: scope });\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupFieldGroup() {\n\t\t      $scope.options.options = $scope.options.options || {};\n\t\t      $scope.options.options.formState = $scope.formState;\n\t\t      $scope.to = $scope.options.templateOptions;\n\t\t    }\n\t\t  }\n\t\n\t\t  // link function\n\t\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t\t    if (scope.options.fieldGroup) {\n\t\t      setFieldGroupTemplate();\n\t\t      return;\n\t\t    }\n\t\n\t\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t\t    if (!formlyFormCtrl && scope.options.model) {\n\t\t      scope.$watch('options.model', function () {\n\t\t        return scope.options.runExpressions();\n\t\t      }, true);\n\t\t    }\n\t\n\t\t    addAttributes();\n\t\t    addClasses();\n\t\n\t\t    var type = getFieldType(scope.options);\n\t\t    var args = arguments;\n\t\t    var thusly = this;\n\t\t    var fieldCount = 0;\n\t\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t\t    });\n\t\n\t\t    function setFieldGroupTemplate() {\n\t\t      checkFieldGroupApi(scope.options);\n\t\t      el.addClass('formly-field-group');\n\t\t      var extraAttributes = '';\n\t\t      if (scope.options.elementAttributes) {\n\t\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t\t        }).join(' ');\n\t\t      }\n\t\t      var modelValue = 'model';\n\t\t      scope.options.form = scope.form;\n\t\t      if (scope.options.key) {\n\t\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t\t      }\n\t\t      getTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ').then(transcludeInWrappers(scope.options, scope.formOptions)).then(setElementTemplate);\n\t\t    }\n\t\n\t\t    function addAttributes() {\n\t\t      if (scope.options.elementAttributes) {\n\t\t        el.attr(scope.options.elementAttributes);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addClasses() {\n\t\t      if (scope.options.className) {\n\t\t        el.addClass(scope.options.className);\n\t\t      }\n\t\t      if (scope.options.type) {\n\t\t        el.addClass('formly-field-' + scope.options.type);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setElementTemplate(templateString) {\n\t\t      el.html(asHtml(templateString));\n\t\t      $compile(el.contents())(scope);\n\t\t      return templateString;\n\t\t    }\n\t\n\t\t    function watchFormControl(templateString) {\n\t\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t\t      if (scope.options.noFormControl) {\n\t\t        return;\n\t\t      }\n\t\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\t\n\t\t      if (ngModelNodes.length) {\n\t\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t\t          fieldCount++;\n\t\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t\t        });\n\t\t      }\n\t\n\t\t      function watchFieldNameOrExistence(name) {\n\t\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t\t        var nameExpression = nameExpressionRegex.exec(name);\n\t\t        if (nameExpression) {\n\t\t          name = $interpolate(name)(scope);\n\t\t        }\n\t\t        watchFieldExistence(name);\n\t\t      }\n\t\n\t\t      function watchFieldExistence(name) {\n\t\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t\t          if (formControl) {\n\t\t            if (fieldCount > 1) {\n\t\t              if (!scope.options.formControl) {\n\t\t                scope.options.formControl = [];\n\t\t              }\n\t\t              scope.options.formControl.push(formControl);\n\t\t            } else {\n\t\t              scope.options.formControl = formControl;\n\t\t            }\n\t\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t\t            stopWatchingShowError();\n\t\t            addShowMessagesWatcher();\n\t\t            addParsers();\n\t\t            addFormatters();\n\t\t          }\n\t\t        });\n\t\t      }\n\t\n\t\t      function addShowMessagesWatcher() {\n\t\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t\t          var options = scope.options;\n\t\t          var formControls = arrayify(scope.fc);\n\t\t          if (!formControls.some(function (fc) {\n\t\t            return fc.$invalid;\n\t\t          })) {\n\t\t            return false;\n\t\t          } else if (typeof options.validation.show === 'boolean') {\n\t\t            return options.validation.show;\n\t\t          } else if (customExpression) {\n\t\t            return formControls.some(function (fc) {\n\t\t              return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t\t            });\n\t\t          } else {\n\t\t            return formControls.some(function (fc) {\n\t\t              var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t\t              return fc.$touched || noTouchedButDirty;\n\t\t            });\n\t\t          }\n\t\t        }, function onShowValidationChange(show) {\n\t\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t\t          scope.showError = show; // shortcut for template authors\n\t\t        });\n\t\t      }\n\t\n\t\t      function addParsers() {\n\t\t        setParsersOrFormatters('parsers');\n\t\t      }\n\t\n\t\t      function addFormatters() {\n\t\t        setParsersOrFormatters('formatters');\n\t\t        var ctrl = scope.fc;\n\t\t        var formWasPristine = scope.form.$pristine;\n\t\t        if (scope.options.formatters) {\n\t\t          (function () {\n\t\t            var value = ctrl.$modelValue;\n\t\t            ctrl.$formatters.forEach(function (formatter) {\n\t\t              value = formatter(value);\n\t\t            });\n\t\n\t\t            ctrl.$setViewValue(value);\n\t\t            ctrl.$render();\n\t\t            ctrl.$setPristine();\n\t\t            if (formWasPristine) {\n\t\t              scope.form.$setPristine();\n\t\t            }\n\t\t          })();\n\t\t        }\n\t\t      }\n\t\n\t\t      function setParsersOrFormatters(which) {\n\t\t        var originalThingProp = 'originalParser';\n\t\t        if (which === 'formatters') {\n\t\t          originalThingProp = 'originalFormatter';\n\t\t        }\n\t\n\t\t        // init with type's parsers\n\t\t        var things = getThingsFromType(type);\n\t\n\t\t        // get optionsTypes things\n\t\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\t\n\t\t        // get field's things\n\t\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\t\n\t\t        // convert things into formlyExpression things\n\t\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t\t          things[index] = getFormlyExpressionThing(thing);\n\t\t        });\n\t\n\t\t        var ngModelCtrls = scope.fc;\n\t\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t\t          ngModelCtrls = [ngModelCtrls];\n\t\t        }\n\t\n\t\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t\t          var _ngModelCtrl;\n\t\n\t\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t\t        });\n\t\n\t\t        function getThingsFromType(theType) {\n\t\t          if (!theType) {\n\t\t            return [];\n\t\t          }\n\t\t          if (_angularFix2['default'].isString(theType)) {\n\t\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t\t          }\n\t\t          var typeThings = [];\n\t\n\t\t          // get things from parent\n\t\t          if (theType['extends']) {\n\t\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t\t          }\n\t\n\t\t          // get own type's things\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\t\n\t\t          // get things from optionsTypes\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\t\n\t\t          return typeThings;\n\t\t        }\n\t\n\t\t        function getThingsFromOptionsTypes() {\n\t\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t\t          var optionsTypesThings = [];\n\t\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t\t          });\n\t\t          return optionsTypesThings;\n\t\t        }\n\t\n\t\t        function getFormlyExpressionThing(thing) {\n\t\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t\t          return formlyExpressionParserOrFormatterFunction;\n\t\n\t\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t\t            var $modelValue = scope.options.value();\n\t\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function callLinkFunctions() {\n\t\t      if (type && type.link) {\n\t\t        type.link.apply(thusly, args);\n\t\t      }\n\t\t      if (scope.options.link) {\n\t\t        scope.options.link.apply(thusly, args);\n\t\t      }\n\t\t    }\n\t\n\t\t    function runManipulators(manipulators) {\n\t\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t\t        var chain = $q.when(templateToManipulate);\n\t\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t\t          chain = chain.then(function (template) {\n\t\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t\t            });\n\t\t          });\n\t\t        });\n\t\t        return chain;\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  // sort-of stateless util functions\n\t\t  function asHtml(el) {\n\t\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t\t    return wrapper.append(el).html();\n\t\t  }\n\t\n\t\t  function getFieldType(options) {\n\t\t    return options.type && formlyConfig.getType(options.type);\n\t\t  }\n\t\n\t\t  function getManipulators(options, formOptions) {\n\t\t    var preWrapper = [];\n\t\t    var postWrapper = [];\n\t\t    addManipulators(options.templateManipulators);\n\t\t    addManipulators(formOptions.templateManipulators);\n\t\t    addManipulators(formlyConfig.templateManipulators);\n\t\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\t\n\t\t    function addManipulators(manipulators) {\n\t\t      /* eslint-disable */ // it doesn't understand this :-(\n\t\n\t\t      var _ref = manipulators || {};\n\t\n\t\t      var _ref$preWrapper = _ref.preWrapper;\n\t\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t\t      var _ref$postWrapper = _ref.postWrapper;\n\t\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\t\n\t\t      preWrapper = preWrapper.concat(pre);\n\t\t      postWrapper = postWrapper.concat(post);\n\t\t      /* eslint-enable */\n\t\t    }\n\t\t  }\n\t\n\t\t  function getFieldTemplate(options) {\n\t\t    function fromOptionsOrType(key, fieldType) {\n\t\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t\t        return options[key];\n\t\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t\t        return fieldType[key];\n\t\t      }\n\t\t    }\n\t\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    var template = fromOptionsOrType('template', type);\n\t\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t\t    }\n\t\n\t\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t\t  }\n\t\n\t\t  function getTemplate(template, isUrl, options) {\n\t\t    var templatePromise = undefined;\n\t\t    if (_angularFix2['default'].isFunction(template)) {\n\t\t      templatePromise = $q.when(template(options));\n\t\t    } else {\n\t\t      templatePromise = $q.when(template);\n\t\t    }\n\t\n\t\t    if (!isUrl) {\n\t\t      return templatePromise;\n\t\t    } else {\n\t\t      var _ret3 = (function () {\n\t\t        var httpOptions = { cache: $templateCache };\n\t\t        return {\n\t\t          v: templatePromise.then(function (url) {\n\t\t            return $http.get(url, httpOptions);\n\t\t          }).then(function (response) {\n\t\t            return response.data;\n\t\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t\t          })\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret3 === 'object') return _ret3.v;\n\t\t    }\n\t\t  }\n\t\n\t\t  function transcludeInWrappers(options, formOptions) {\n\t\t    var wrapper = getWrapperOption(options, formOptions);\n\t\n\t\t    return function transcludeTemplate(template) {\n\t\t      if (!wrapper.length) {\n\t\t        return $q.when(template);\n\t\t      }\n\t\n\t\t      wrapper.forEach(function (aWrapper) {\n\t\t        formlyUsability.checkWrapper(aWrapper, options);\n\t\t        runApiCheck(aWrapper, options);\n\t\t      });\n\t\t      var promises = wrapper.map(function (w) {\n\t\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t\t      });\n\t\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t\t        });\n\t\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t\t        var totalWrapper = wrappersTemplates.shift();\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t\t        });\n\t\t        return doTransclusion(totalWrapper, template);\n\t\t      });\n\t\t    };\n\t\t  }\n\t\n\t\t  function doTransclusion(wrapper, template) {\n\t\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t\t    superWrapper.append(wrapper);\n\t\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t\t    if (!transcludeEl.length) {\n\t\t      // try it using our custom find function\n\t\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t\t    }\n\t\t    transcludeEl.replaceWith(template);\n\t\t    return superWrapper.html();\n\t\t  }\n\t\n\t\t  function getWrapperOption(options, formOptions) {\n\t\t    /* eslint complexity:[2, 6] */\n\t\t    var wrapper = options.wrapper;\n\t\t    // explicit null means no wrapper\n\t\t    if (wrapper === null) {\n\t\t      return [];\n\t\t    }\n\t\n\t\t    // nothing specified means use the default wrapper for the type\n\t\t    if (!wrapper) {\n\t\t      // get all wrappers that specify they apply to this type\n\t\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t\t    } else {\n\t\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t\t    }\n\t\n\t\t    // get all wrappers for that the type specified that it uses.\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    if (type && type.wrapper) {\n\t\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(typeWrappers);\n\t\t    }\n\t\n\t\t    // add form wrappers\n\t\t    if (formOptions.wrapper) {\n\t\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(formWrappers);\n\t\t    }\n\t\n\t\t    // add the default wrapper last\n\t\t    var defaultWrapper = formlyConfig.getWrapper();\n\t\t    if (defaultWrapper) {\n\t\t      wrapper.push(defaultWrapper);\n\t\t    }\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function checkApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t    // validate with the type\n\t\t    var type = options.type && formlyConfig.getType(options.type);\n\t\t    if (type) {\n\t\t      runApiCheck(type, options, true);\n\t\t    }\n\t\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkFieldGroupApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function runApiCheck(_ref2, options, forType) {\n\t\t    var apiCheck = _ref2.apiCheck;\n\t\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\t\n\t\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t\t    if (forType && options.type) {\n\t\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t\t    /* eslint complexity:[2, 9] */\n\t\t    if (!apiCheck) {\n\t\t      return;\n\t\t    }\n\t\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t\t      return;\n\t\t    }\n\t\t    var fn = apiCheckFunction || 'warn';\n\t\t    // this is the new API\n\t\t    var checkerObjects = apiCheck(instance);\n\t\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t\t      var checker = instance.shape(shape);\n\t\t      var checkOptions = _angularFix2['default'].extend({\n\t\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t\t      }, apiCheckOptions);\n\t\t      instance[fn](checker, options[name], checkOptions);\n\t\t    });\n\t\t  }\n\t\t}\n\t\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\t\n\t\t// Stateless util functions\n\t\tfunction getDefaultOptionsOptionsTypes(type) {\n\t\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t\t}\n\t\n\t\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\texports['default'] = formlyFocus;\n\t\n\t\t// @ngInject\n\t\tfunction formlyFocus($timeout, $document) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    link: function formlyFocusLink(scope, element, attrs) {\n\t\t      var previousEl = null;\n\t\t      var el = element[0];\n\t\t      var doc = $document[0];\n\t\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t\t        if (value === 'true') {\n\t\t          $timeout(function setElementFocus() {\n\t\t            previousEl = doc.activeElement;\n\t\t            el.focus();\n\t\t          }, ~ ~attrs.focusWait);\n\t\t        } else if (value === 'false') {\n\t\t          if (doc.activeElement === el) {\n\t\t            el.blur();\n\t\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t\t              previousEl.focus();\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar _slice = Array.prototype.slice;\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyForm;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyForm\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t\t  var currentFormId = 1;\n\t\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    template: formlyFormGetTemplate,\n\t\t    replace: true,\n\t\t    transclude: true,\n\t\t    scope: {\n\t\t      fields: '=',\n\t\t      model: '=',\n\t\t      form: '=?',\n\t\t      options: '=?'\n\t\t    },\n\t\t    controller: FormlyFormController,\n\t\t    link: formlyFormLink\n\t\t  };\n\t\n\t\t  function formlyFormGetTemplate(el, attrs) {\n\t\t    var rootEl = getRootEl();\n\t\t    var fieldRootEl = getFieldRootEl();\n\t\t    var formId = 'formly_' + currentFormId++;\n\t\t    var parentFormAttributes = '';\n\t\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t\t    }\n\t\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\t\n\t\t    function getRootEl() {\n\t\t      return attrs.rootEl || 'ng-form';\n\t\t    }\n\t\n\t\t    function getFieldRootEl() {\n\t\t      return attrs.fieldRootEl || 'div';\n\t\t    }\n\t\n\t\t    function getHideDirective() {\n\t\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t\t    }\n\t\n\t\t    function getTrackBy() {\n\t\t      if (!attrs.trackBy) {\n\t\t        return '';\n\t\t      } else {\n\t\t        return 'track by ' + attrs.trackBy;\n\t\t      }\n\t\t    }\n\t\n\t\t    function getFormName() {\n\t\t      var formName = formId;\n\t\t      var bindName = attrs.bindName;\n\t\t      if (bindName) {\n\t\t        if (_angularFix2['default'].version.minor < 3) {\n\t\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t\t        }\n\t\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t\t      }\n\t\t      return formName;\n\t\t    }\n\t\n\t\t    function getTranscludeClass() {\n\t\t      return attrs.transcludeClass || '';\n\t\t    }\n\t\n\t\t    function copyAttributes(attributes) {\n\t\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t\t      var arrayAttrs = [];\n\t\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t\t        var nodeName = _ref.nodeName;\n\t\t        var value = _ref.value;\n\t\n\t\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t\t        }\n\t\t      });\n\t\t      return arrayAttrs.join(' ');\n\t\t    }\n\t\t  }\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t\t    setupOptions();\n\t\t    $scope.model = $scope.model || {};\n\t\t    setupFields();\n\t\n\t\t    // watch the model and evaluate watch expressions that depend on it.\n\t\t    if (!$scope.options.manualModelWatcher) {\n\t\t      $scope.$watch('model', onModelOrFormStateChange, true);\n\t\t    } else if (_angularFix2['default'].isFunction($scope.options.manualModelWatcher)) {\n\t\t      $scope.$watch($scope.options.manualModelWatcher, onModelOrFormStateChange, true);\n\t\t    }\n\t\n\t\t    if ($scope.options.formState) {\n\t\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t\t    }\n\t\n\t\t    function onModelOrFormStateChange() {\n\t\t      _angularFix2['default'].forEach($scope.fields, runFieldExpressionProperties);\n\t\t    }\n\t\n\t\t    function runFieldExpressionProperties(field, index) {\n\t\t      var model = field.model || $scope.model;\n\t\t      var promise = field.runExpressions && field.runExpressions();\n\t\t      if (field.hideExpression) {\n\t\t        // can't use hide with expressionProperties reliably\n\t\t        var val = model[field.key];\n\t\t        field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t\t      }\n\t\t      if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t\t        var validate = field.formControl.$validate;\n\t\t        if (promise) {\n\t\t          promise.then(validate);\n\t\t        } else {\n\t\t          validate();\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupFields() {\n\t\t      $scope.fields = $scope.fields || [];\n\t\n\t\t      checkDeprecatedOptions($scope.options);\n\t\n\t\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\t\n\t\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t\t        fieldTransforms = [fieldTransforms];\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t\t        if (fieldTransform) {\n\t\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t\t          if (!$scope.fields) {\n\t\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t\t          }\n\t\t        }\n\t\t      });\n\t\n\t\t      setupModels();\n\t\n\t\t      if ($scope.options.watchAllExpressions) {\n\t\t        _angularFix2['default'].forEach($scope.fields, setupHideExpressionWatcher);\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t\t    }\n\t\n\t\t    function checkDeprecatedOptions(options) {\n\t\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupOptions() {\n\t\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t\t      $scope.options = $scope.options || {};\n\t\t      $scope.options.formState = $scope.options.formState || {};\n\t\n\t\t      _angularFix2['default'].extend($scope.options, {\n\t\t        updateInitialValue: updateInitialValue,\n\t\t        resetModel: resetModel\n\t\t      });\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.updateInitialValue();\n\t\t        } else {\n\t\t          field.updateInitialValue();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.resetModel();\n\t\t        } else if (field.resetModel) {\n\t\t          field.resetModel();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupModels() {\n\t\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t\t      var watchedModels = [$scope.model];\n\t\t      // we will not set up automatic model watchers if manual mode is set\n\t\t      var manualModelWatcher = $scope.options.manualModelWatcher;\n\t\n\t\t      if ($scope.options.formState) {\n\t\t        // $scope.options.formState will have its own watcher\n\t\t        watchedModels.push($scope.options.formState);\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        var isNewModel = initModel(field);\n\t\n\t\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1 && !manualModelWatcher) {\n\t\t          $scope.$watch(function () {\n\t\t            return field.model;\n\t\t          }, onModelOrFormStateChange, true);\n\t\t          watchedModels.push(field.model);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupHideExpressionWatcher(field, index) {\n\t\t      if (field.hideExpression) {\n\t\t        (function () {\n\t\t          // can't use hide with expressionProperties reliably\n\t\t          var model = field.model || $scope.model;\n\t\t          $scope.$watch(function hideExpressionWatcher() {\n\t\t            var val = model[field.key];\n\t\t            return evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t\t          }, function (hide) {\n\t\t            return field.hide = hide;\n\t\t          }, true);\n\t\t        })();\n\t\t      }\n\t\t    }\n\t\n\t\t    function initModel(field) {\n\t\t      var isNewModel = true;\n\t\n\t\t      if (_angularFix2['default'].isString(field.model)) {\n\t\t        var expression = field.model;\n\t\t        var index = $scope.fields.indexOf(field);\n\t\n\t\t        isNewModel = !referencesCurrentlyWatchedModel(expression);\n\t\n\t\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t\t        if (!field.model) {\n\t\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t\t        }\n\t\t      }\n\t\t      return isNewModel;\n\t\t    }\n\t\n\t\t    function referencesCurrentlyWatchedModel(expression) {\n\t\t      return ['model', 'formState'].some(function (item) {\n\t\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t\t      });\n\t\t    }\n\t\n\t\t    function attachKey(field, index) {\n\t\t      if (!isFieldGroup(field)) {\n\t\t        field.key = field.key || index || 0;\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupWatchers(field, index) {\n\t\t      if (!_angularFix2['default'].isDefined(field.watcher)) {\n\t\t        return;\n\t\t      }\n\t\t      var watchers = field.watcher;\n\t\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t\t        watchers = [watchers];\n\t\t      }\n\t\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t\t        if (!_angularFix2['default'].isDefined(watcher.listener) && !watcher.runFieldExpressions) {\n\t\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t\t        }\n\t\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t\t        var watchListener = getWatchListener(watcher, field, index);\n\t\n\t\t        var type = watcher.type || '$watch';\n\t\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t\t      });\n\t\t    }\n\t\n\t\t    function getWatchExpression(watcher, field, index) {\n\t\t      var watchExpression = undefined;\n\t\t      if (!_angularFix2['default'].isUndefined(watcher.expression)) {\n\t\t        watchExpression = watcher.expression;\n\t\t      } else if (field.key) {\n\t\t        watchExpression = 'model[\\'' + field.key.toString().split('.').join('\\'][\\'') + '\\']';\n\t\t      }\n\t\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t\t        (function () {\n\t\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalExpression = watchExpression;\n\t\t          watchExpression = function formlyWatchExpression() {\n\t\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t\t          };\n\t\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchExpression;\n\t\t    }\n\t\n\t\t    function getWatchListener(watcher, field, index) {\n\t\t      var watchListener = watcher.listener;\n\t\t      if (_angularFix2['default'].isFunction(watchListener) || watcher.runFieldExpressions) {\n\t\t        (function () {\n\t\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalListener = watchListener;\n\t\t          watchListener = function formlyWatchListener() {\n\t\t            var value = undefined;\n\t\t            if (originalListener) {\n\t\t              var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t              value = originalListener.apply(undefined, _toConsumableArray(args));\n\t\t            }\n\t\t            if (watcher.runFieldExpressions) {\n\t\t              runFieldExpressionProperties(field, index);\n\t\t            }\n\t\t            return value;\n\t\t          };\n\t\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchListener;\n\t\t    }\n\t\n\t\t    function modifyArgs(watcher, index) {\n\t\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\t        originalArgs[_key - 2] = arguments[_key];\n\t\t      }\n\t\n\t\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t\t    }\n\t\n\t\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t\t    }\n\t\n\t\t    function getFormlyFieldLikeLocals(field, index) {\n\t\t      // this makes it closer to what a regular formlyExpression would be\n\t\t      return {\n\t\t        options: field,\n\t\t        index: index,\n\t\t        formState: $scope.options.formState,\n\t\t        formId: $scope.formId\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function formlyFormLink(scope, el, attrs) {\n\t\t    setFormController();\n\t\t    fixChromeAutocomplete();\n\t\n\t\t    function setFormController() {\n\t\t      var formId = attrs.name;\n\t\t      scope.formId = formId;\n\t\t      scope.theFormlyForm = scope[formId];\n\t\t      if (attrs.form) {\n\t\t        var getter = $parse(attrs.form);\n\t\t        var setter = getter.assign;\n\t\t        var parentForm = getter(scope.$parent);\n\t\t        if (parentForm) {\n\t\t          scope.theFormlyForm = parentForm;\n\t\t          if (scope[formId]) {\n\t\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t\t          }\n\t\n\t\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t\t          // to children forms :-( This line was added to solve this issue:\n\t\t          // https://github.com/formly-js/angular-formly/issues/287\n\t\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t\t          // so I expect it will remain this way for the life of angular 1.x\n\t\t          el.removeData('$formController');\n\t\t        } else {\n\t\t          setter(scope.$parent, scope[formId]);\n\t\t        }\n\t\t      }\n\t\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t\t        /* eslint no-console:0 */\n\t\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t\t      }\n\t\t    }\n\t\n\t\t    /*\n\t\t     * chrome autocomplete lameness\n\t\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t\t     * ()   ()     ()\n\t\t     */\n\t\t    function fixChromeAutocomplete() {\n\t\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t\t      if (global && !offInstance || onInstance) {\n\t\t        var input = document.createElement('input');\n\t\t        input.setAttribute('autocomplete', 'address-level4');\n\t\t        input.setAttribute('hidden', 'true');\n\t\t        el[0].appendChild(input);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  // stateless util functions\n\t\t  function toKebabCase(string) {\n\t\t    if (string) {\n\t\t      return string.replace(/([A-Z])/g, function ($1) {\n\t\t        return '-' + $1.toLowerCase();\n\t\t      });\n\t\t    } else {\n\t\t      return '';\n\t\t    }\n\t\t  }\n\t\n\t\t  function isFieldGroup(field) {\n\t\t    return field && !!field.fieldGroup;\n\t\t  }\n\t\t}\n\t\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\texports['default'] = addFormlyNgModelAttrsManipulator;\n\t\n\t\t// @ngInject\n\t\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t\t    return;\n\t\t  }\n\t\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\t\n\t\t  function ngModelAttrsManipulator(template, options, scope) {\n\t\t    var node = document.createElement('div');\n\t\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t\t    if (skip === true) {\n\t\t      return template;\n\t\t    }\n\t\t    node.innerHTML = template;\n\t\n\t\t    var modelNodes = getNgModelNodes(node, skip);\n\t\t    if (!modelNodes || !modelNodes.length) {\n\t\t      return template;\n\t\t    }\n\t\n\t\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\t\n\t\t    addValidation();\n\t\t    alterNgModelAttr();\n\t\t    addModelOptions();\n\t\t    addTemplateOptionsAttrs();\n\t\t    addNgModelElAttrs();\n\t\n\t\t    return node.innerHTML;\n\t\n\t\t    function addValidation() {\n\t\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t\t      }\n\t\t    }\n\t\n\t\t    function alterNgModelAttr() {\n\t\t      if (isPropertyAccessor(options.key)) {\n\t\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addModelOptions() {\n\t\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t\t        if (options.modelOptions.getterSetter) {\n\t\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function addTemplateOptionsAttrs() {\n\t\t      if (!options.templateOptions && !options.expressionProperties) {\n\t\t        // no need to run these if there are no templateOptions or expressionProperties\n\t\t        return;\n\t\t      }\n\t\t      var to = options.templateOptions || {};\n\t\t      var ep = options.expressionProperties || {};\n\t\n\t\t      var ngModelAttributes = getBuiltInAttributes();\n\t\n\t\t      // extend with the user's specifications winning\n\t\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\t\n\t\t      // Feel free to make this more simple :-)\n\t\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t\t        /* eslint complexity:[2, 14] */\n\t\t        var attrVal = undefined,\n\t\t            attrName = undefined;\n\t\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t\t        var toVal = to[name];\n\t\t        var epVal = getEpValue(ep, name);\n\t\n\t\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t\t        if (val.value) {\n\t\t          // I realize this looks backwards, but it's right, trust me...\n\t\t          attrName = val.value;\n\t\t          attrVal = name;\n\t\t        } else if (val.statement && inTo) {\n\t\t          attrName = val.statement;\n\t\t          if (_angularFix2['default'].isString(to[name])) {\n\t\t            attrVal = '$eval(' + ref + ')';\n\t\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t\t          } else {\n\t\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t\t          }\n\t\t        } else if (val.bound && inEp) {\n\t\t          attrName = val.bound;\n\t\t          attrVal = ref;\n\t\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t\t          attrName = val.attribute || val.boolean;\n\t\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t\t        } else if (val.attribute && inTo) {\n\t\t          attrName = val.attribute;\n\t\t          attrVal = toVal;\n\t\t        } else if (val.boolean) {\n\t\t          if (inTo && !inEp && toVal) {\n\t\t            attrName = val.boolean;\n\t\t            attrVal = true;\n\t\t          } else {\n\t\t            /* eslint no-empty:0 */\n\t\t            // empty to illustrate that a boolean will not be added via val.bound\n\t\t            // if you want it added via val.bound, then put it in expressionProperties\n\t\t          }\n\t\t        } else if (val.bound && inTo) {\n\t\t            attrName = val.bound;\n\t\t            attrVal = ref;\n\t\t          }\n\t\n\t\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function addNgModelElAttrs() {\n\t\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t\t        addRegardlessOfPresence(modelNodes, name, val);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  // Utility functions\n\t\t  function getNgModelNodes(node, skip) {\n\t\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t\t    try {\n\t\t      return node.querySelectorAll(query);\n\t\t    } catch (e) {\n\t\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t\t      //it should be removed when IE8 support is dropped\n\t\t      return getNgModelNodesFallback(node, skip);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getNgModelNodesFallback(node, skip) {\n\t\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t\t    var matchingNgModelNodes = [];\n\t\n\t\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t\t    matchingNgModelNodes.item = function (i) {\n\t\t      return this[i];\n\t\t    };\n\t\n\t\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t\t      var ngModelNode = allNgModelNodes[i];\n\t\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t\t        matchingNgModelNodes.push(ngModelNode);\n\t\t      }\n\t\t    }\n\t\n\t\t    return matchingNgModelNodes;\n\t\t  }\n\t\n\t\t  function nodeMatches(node, selector) {\n\t\t    var div = document.createElement('div');\n\t\t    div.innerHTML = node.outerHTML;\n\t\t    return div.querySelector(selector);\n\t\t  }\n\t\n\t\t  function getBuiltInAttributes() {\n\t\t    var ngModelAttributes = {\n\t\t      focus: {\n\t\t        attribute: 'formly-focus'\n\t\t      }\n\t\t    };\n\t\t    var boundOnly = [];\n\t\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t\t    var attributeOnly = ['placeholder', 'min', 'max', 'tabindex', 'type'];\n\t\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t\t      bothAttributeAndBound.push('maxlength');\n\t\t    } else {\n\t\t      boundOnly.push('maxlength');\n\t\t    }\n\t\n\t\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item };\n\t\t    });\n\t\t    return ngModelAttributes;\n\t\t  }\n\t\n\t\t  function getEpValue(ep, name) {\n\t\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t\t  }\n\t\n\t\t  function addIfNotPresent(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      if (!node.getAttribute(attr)) {\n\t\t        node.setAttribute(attr, val);\n\t\t      }\n\t\t    });\n\t\t  }\n\t\n\t\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      node.setAttribute(attr, val);\n\t\t    });\n\t\t  }\n\t\n\t\t  function isPropertyAccessor(key) {\n\t\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t\t  }\n\t\t}\n\t\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = addCustomTags;\n\t\n\t\t// @ngInject\n\t\tfunction addCustomTags($document) {\n\t\t  // IE8 check ->\n\t\t  // https://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx\n\t\t  if ($document && $document.documentMode < 9) {\n\t\t    (function () {\n\t\t      var document = $document.get(0);\n\t\t      // add the custom elements that we need for formly\n\t\t      var customElements = ['formly-field', 'formly-form'];\n\t\t      _angularFix2['default'].forEach(customElements, function (el) {\n\t\t        document.createElement(el);\n\t\t      });\n\t\t    })();\n\t\t  }\n\t\t}\n\t\taddCustomTags.$inject = [\"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n\n/***/ 7:\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! angular-formly-templates-bootstrap version 6.3.0 built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> ( _)==(_ )\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(2), __webpack_require__(5), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar ngModuleName = 'formlyBootstrap';\n\t\tvar angular = __webpack_require__(2);\n\t\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\t\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t\t  output: {\n\t\t    prefix: 'angular-formly-bootstrap'\n\t\t  }\n\t\t}));\n\t\tngModule.constant('formlyBootstrapVersion', (\"6.3.0\"));\n\t\n\t\t__webpack_require__(6)(ngModule);\n\t\t__webpack_require__(9)(ngModule);\n\t\t__webpack_require__(19)(ngModule);\n\t\n\t\texports['default'] = ngModuleName;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tvar angular = __webpack_require__(3);\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\tmodule.exports = angular;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addWrappers);\n\t\n\t\t  function addWrappers(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setWrapper([{\n\t\t      name: 'bootstrapLabel',\n\t\t      template: __webpack_require__(7),\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string.optional,\n\t\t            required: check.bool.optional,\n\t\t            labelSrOnly: check.bool.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t\t  }\n\t\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  __webpack_require__(10)(ngModule);\n\t\t  __webpack_require__(12)(ngModule);\n\t\t  __webpack_require__(14)(ngModule);\n\t\t  __webpack_require__(15)(ngModule);\n\t\t  __webpack_require__(17)(ngModule);\n\t\t  __webpack_require__(18)(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'checkbox',\n\t\t      template: __webpack_require__(11),\n\t\t      wrapper: ['bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'multiCheckbox',\n\t\t      template: __webpack_require__(13),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      },\n\t\t      defaultOptions: {\n\t\t        noFormControl: false,\n\t\t        ngModelAttrs: {\n\t\t          required: {\n\t\t            attribute: '',\n\t\t            bound: ''\n\t\t          }\n\t\t        }\n\t\t      },\n\t\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t\t        var to = $scope.to;\n\t\t        var opts = $scope.options;\n\t\t        $scope.multiCheckbox = {\n\t\t          checked: [],\n\t\t          change: setModel\n\t\t        };\n\t\n\t\t        // initialize the checkboxes check property\n\t\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t\t          var modelValue, valueProp;\n\t\n\t\t          if (Object.keys(newModelValue).length) {\n\t\t            modelValue = newModelValue[opts.key];\n\t\n\t\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t\t                valueProp = to.valueProp || 'value';\n\t\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t\t                }\n\t\t              }\n\t\t            });\n\t\t          }\n\t\t        }, true);\n\t\n\t\t        function checkValidity(expressionValue) {\n\t\t          var valid;\n\t\n\t\t          if ($scope.to.required) {\n\t\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\t\n\t\t            $scope.fc.$setValidity('required', valid);\n\t\t          }\n\t\t        }\n\t\n\t\t        function setModel() {\n\t\t          $scope.model[opts.key] = [];\n\t\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t\t            if (checkbox) {\n\t\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t\t            }\n\t\t          });\n\t\n\t\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t\t          $scope.fc.$setTouched();\n\t\t          checkValidity(true);\n\t\t        }\n\t\n\t\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t\t          $scope.$watch(function () {\n\t\t            return $scope.to.required;\n\t\t          }, function (newValue) {\n\t\t            checkValidity(newValue);\n\t\t          });\n\t\t        }\n\t\n\t\t        if ($scope.to.required) {\n\t\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t\t            if (!newValue) {\n\t\t              return;\n\t\t            }\n\t\t            checkValidity(true);\n\t\t            unwatchFormControl();\n\t\t          });\n\t\t        }\n\t\t      }]\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addInputType);\n\t\n\t\t  function addInputType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'input',\n\t\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t\t    });\n\t\t  }\n\t\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addRadioType);\n\t\n\t\t  function addRadioType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'radio',\n\t\t      template: __webpack_require__(16),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        noFormControl: false\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addSelectType);\n\t\n\t\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\t\n\t\t  function addSelectType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'select',\n\t\t      template: template,\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: function defaultOptions(options) {\n\t\t        /* jshint maxlen:195 */\n\t\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t\t        return {\n\t\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t\t          })\n\t\t        };\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            optionsAttr: check.string.optional,\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional,\n\t\t            groupProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addTextareaType);\n\t\n\t\t  function addTextareaType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'textarea',\n\t\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        ngModelAttrs: {\n\t\t          rows: { attribute: 'rows' },\n\t\t          cols: { attribute: 'cols' }\n\t\t        }\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            rows: check.number.optional,\n\t\t            cols: check.number.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 19 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _addons = __webpack_require__(20);\n\t\n\t\tvar _addons2 = _interopRequireDefault(_addons);\n\t\n\t\tvar _description = __webpack_require__(22);\n\t\n\t\tvar _description2 = _interopRequireDefault(_description);\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  (0, _addons2['default'])(ngModule);\n\t\t  (0, _description2['default'])(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 20 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addAddonsManipulator);\n\t\n\t\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t\t    var addonTemplate = __webpack_require__(21);\n\t\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t\t      'class': formlyBootstrapApiCheck.string.optional,\n\t\t      text: formlyBootstrapApiCheck.string.optional,\n\t\t      onClick: formlyBootstrapApiCheck.func.optional\n\t\t    }).strict.optional;\n\t\t    var api = formlyBootstrapApiCheck.shape({\n\t\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t\t        addonLeft: addonChecker,\n\t\t        addonRight: addonChecker\n\t\t      })\n\t\t    });\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t\t        return template;\n\t\t      }\n\t\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t\t    });\n\t\t  }\n\t\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 21 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this, $event)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this, $event)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 22 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addDescriptionManipulator);\n\t\n\t\t  function addDescriptionManipulator(formlyConfig) {\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t\t      if (angular.isDefined(options.templateOptions.description)) {\n\t\t        var el = document.createElement('div');\n\t\t        el.appendChild(angular.element(template)[0]);\n\t\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t\t        if (modelEls) {\n\t\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t\t        }\n\t\t        return el.innerHTML;\n\t\t      } else {\n\t\t        return template;\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n\n/***/ 8:\n/***/ function(module, exports) {\n\n\t/**\n\t * angular-permission\n\t * Route permission and access control as simple as it can get\n\t * @version v2.0.2 - 2016-02-03\n\t * @link http://www.rafaelvidaurre.com\n\t * @author Rafael Vidaurre <narzerus@gmail.com>\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  var permission = angular.module('permission', ['ui.router']);\n\t\n\t  /**\n\t   * This decorator is required to access full state object instead of it's configuration\n\t   * when trying to obtain full toState state object not it's configuration\n\t   * Can be removed when implemented https://github.com/angular-ui/ui-router/issues/13.\n\t   */\n\t  permission.config(['$stateProvider', function ($stateProvider) {\n\t    $stateProvider.decorator('parent', function (state, parentFn) {\n\t      state.self.getState = function () {\n\t        return state;\n\t      };\n\t      return parentFn(state);\n\t    });\n\t  }]);\n\t\n\t  permission.run(['$rootScope', '$state', '$q', 'Authorization', 'PermissionMap', function ($rootScope, $state, $q, Authorization, PermissionMap) {\n\t    $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams, options) {\n\t\n\t      if (toState.$$isAuthorizationFinished) {\n\t        return;\n\t      }\n\t\n\t      if (areSetStatePermissions(toState)) {\n\t        event.preventDefault();\n\t        setStateAuthorizationStatus(true);\n\t\n\t\n\t        if (!areStateEventsDefaultPrevented()) {\n\t          var compensatedPermissionMap = compensatePermissionMap(toState.data.permissions);\n\t          authorizeForState(compensatedPermissionMap);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Checks if state is qualified to be permission based verified\n\t       *\n\t       * @returns {boolean}\n\t       */\n\t      function areSetStatePermissions(state) {\n\t        return angular.isDefined(state.data) && angular.isDefined(state.data.permissions);\n\t      }\n\t\n\t      /**\n\t       * Sets internal state `$$finishedAuthorization` variable to prevent looping\n\t       *\n\t       * @param status {boolean} When true authorization has been already preceded\n\t       */\n\t      function setStateAuthorizationStatus(status) {\n\t        angular.extend(toState, {'$$isAuthorizationFinished': status});\n\t      }\n\t\n\t      /**\n\t       * Checks if state events are not prevented by default\n\t       *\n\t       * @returns {boolean}\n\t       */\n\t      function areStateEventsDefaultPrevented() {\n\t        return isStateChangePermissionStartDefaultPrevented() || isStateChangeStartDefaultPrevented();\n\t      }\n\t\n\t      /**\n\t       * Builds map of permissions resolving passed values to data.permissions and combine them with all its parents\n\t       * keeping the order of permissions from the newest (children) to the oldest (parent)\n\t       *\n\t       * @param statePermissionMap {Object} Current state permission map\n\t       * @returns {{only: Array, except: Array}} Permission map\n\t       */\n\t      function compensatePermissionMap(statePermissionMap) {\n\t        var permissionMap = new PermissionMap({redirectTo: statePermissionMap.redirectTo});\n\t\n\t        var toStatePath = $state\n\t          .get(toState.name)\n\t          .getState().path\n\t          .slice()\n\t          .reverse();\n\t\n\t        angular.forEach(toStatePath, function (state) {\n\t          if (areSetStatePermissions(state)) {\n\t            permissionMap.extendPermissionMap(new PermissionMap(state.data.permissions));\n\t          }\n\t        });\n\t\n\t        return permissionMap;\n\t      }\n\t\n\t      /**\n\t       * Handles state authorization\n\t       *\n\t       * @param permissions {Object} Map of \"only\" or \"except\" permission names\n\t       */\n\t      function authorizeForState(permissions) {\n\t        Authorization\n\t          .authorize(permissions, toParams)\n\t          .then(function () {\n\t            $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams, options);\n\t            goToState(toState.name);\n\t          })\n\t          .catch(function (rejectedPermission) {\n\t            $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams, options);\n\t            permissions.redirectToState(rejectedPermission);\n\t          });\n\t      }\n\t\n\t      /**\n\t       * Redirects to states when permissions are met\n\t       *\n\t       * If authorized, use call state.go without triggering the event.\n\t       * Then trigger $stateChangeSuccess manually to resume the rest of the process\n\t       * Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n\t       */\n\t      function goToState(name) {\n\t        $state\n\t          .go(name, toParams, angular.extend({}, options, {notify: false}))\n\t          .then(function () {\n\t            $rootScope.$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams, options);\n\t          });\n\t      }\n\t\n\t      /**\n\t       * Checks if event $stateChangeStart hasn't been disabled by default\n\t       *\n\t       * @returns {boolean}\n\t       */\n\t      function isStateChangeStartDefaultPrevented() {\n\t        return $rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams, options).defaultPrevented;\n\t      }\n\t\n\t      /**\n\t       * Checks if event $stateChangePermissionStart hasn't been disabled by default\n\t       *\n\t       * @returns {boolean}\n\t       */\n\t      function isStateChangePermissionStartDefaultPrevented() {\n\t        return $rootScope.$broadcast('$stateChangePermissionStart', toState, toParams, options).defaultPrevented;\n\t      }\n\t    });\n\t  }]);\n\t}());\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .factory('PermissionMap', ['$q', '$state', function ($q, $state) {\n\t\n\t      /**\n\t       * Constructs map object instructing authorization service how to handle authorizing\n\t       *\n\t       * @param permissionMap {Object} Map of permissions provided to authorization service\n\t       * @param permissionMap.only {Array} List of exclusive permission/role names allowed for authorization\n\t       * @param permissionMap.except {Array} List of exclusive permission/role names denied for authorization\n\t       * @param permissionMap.redirectTo {String|Function|Object|promise} Handling redirection when rejected\n\t       *   authorization\n\t       * @param [toState] {Object} UI-Router transition state object\n\t       * @param [toParams] {Object} UI-Router transition state params\n\t       * @param [options] {Object} UI-Router transition state options\n\t       * @constructor\n\t       */\n\t      function PermissionMap(permissionMap, toState, toParams, options) {\n\t        this.only = resolvePermissionMapProperty(permissionMap.only, toState, toParams, options);\n\t        this.except = resolvePermissionMapProperty(permissionMap.except, toState, toParams, options);\n\t        this.redirectTo = permissionMap.redirectTo;\n\t      }\n\t\n\t      /**\n\t       * Extends permission map by pushing to it state's permissions\n\t       *\n\t       * @param permissionMap {PermissionMap} Compensated permission map\n\t       */\n\t      PermissionMap.prototype.extendPermissionMap = function (permissionMap) {\n\t        this.only = this.only.concat(permissionMap.only);\n\t        this.except = this.except.concat(permissionMap.except);\n\t      };\n\t\n\t\n\t      /**\n\t       * Redirects to fallback states when permissions fail\n\t       *\n\t       * @param rejectedPermissionName {String} Permission name\n\t       */\n\t      PermissionMap.prototype.redirectToState = function (rejectedPermissionName) {\n\t        if (angular.isFunction(this.redirectTo)) {\n\t          handleFunctionRedirect(this.redirectTo, rejectedPermissionName);\n\t        }\n\t\n\t        if (angular.isObject(this.redirectTo)) {\n\t          handleObjectRedirect(this.redirectTo, rejectedPermissionName);\n\t        }\n\t\n\t        if (angular.isString(this.redirectTo)) {\n\t          handleStringRedirect(this.redirectTo, this.toParams, this.options);\n\t        }\n\t      };\n\t\n\t      /**\n\t       * Handles function based redirection for rejected permissions\n\t       *\n\t       * @param redirectFunction {Function} Redirection function\n\t       * @param permission {String} Rejected permission\n\t       */\n\t      function handleFunctionRedirect(redirectFunction, permission) {\n\t        $q.when(redirectFunction.call(null, permission))\n\t          .then(function (redirectState) {\n\t            if (!angular.isString(redirectState)) {\n\t              throw new TypeError('When used \"redirectTo\" as function, returned value must be string with state name');\n\t            }\n\t            handleStringRedirect(redirectState);\n\t          });\n\t      }\n\t\n\t      /**\n\t       * Handles object based redirection for rejected permissions\n\t       *\n\t       * @param redirectObject {Object} Redirection function\n\t       * @param permission {String} Rejected permission\n\t       */\n\t      function handleObjectRedirect(redirectObject, permission) {\n\t        if (!angular.isDefined(redirectObject['default'])) {\n\t          throw new ReferenceError('When used \"redirectTo\" as object, property \"default\" must be defined');\n\t        }\n\t\n\t        var redirectState = redirectObject[permission];\n\t\n\t        if (!angular.isDefined(redirectState)) {\n\t          redirectState = redirectObject['default'];\n\t        }\n\t\n\t        if (angular.isFunction(redirectState)) {\n\t          handleFunctionRedirect(redirectState, permission);\n\t        }\n\t\n\t        if (angular.isString(redirectState)) {\n\t          handleStringRedirect(redirectState);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Handles string based redirection for rejected permissions\n\t       */\n\t      function handleStringRedirect(state, toParams, options) {\n\t        $state.go(state, toParams, options);\n\t      }\n\t\n\t      /**\n\t       * Handles extraction of permission map \"only\" and \"except\" properties\n\t       * @private\n\t       *\n\t       * @param property {Array|Function|promise} Permission map property \"only\" or \"except\"\n\t       * @param [toState] {Object} UI-Router transition state object\n\t       * @param [toParams] {Object} UI-Router transition state params\n\t       * @param [options] {Object} UI-Router transition state options\n\t       * @returns {Array} Array of permission \"only\" or \"except\" names\n\t       */\n\t      function resolvePermissionMapProperty(property, toState, toParams, options) {\n\t        if (angular.isString(property)) {\n\t          return [property];\n\t        }\n\t\n\t        if (angular.isArray(property)) {\n\t          return property;\n\t        }\n\t\n\t        if (angular.isFunction(property)) {\n\t          return property.call(null, toState, toParams, options);\n\t        }\n\t\n\t        return [];\n\t      }\n\t\n\t      return PermissionMap;\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .factory('Permission', ['$q', function ($q) {\n\t\n\t      /**\n\t       * Permission definition object constructor\n\t       *\n\t       * @param permissionName {String} Name repressing permission\n\t       * @param validationFunction {Function} Function used to check if permission is valid\n\t       * @constructor\n\t       */\n\t      function Permission(permissionName, validationFunction) {\n\t        validateConstructor(permissionName, validationFunction);\n\t\n\t        this.permissionName = permissionName;\n\t        this.validationFunction = validationFunction;\n\t      }\n\t\n\t      /**\n\t       * Checks if permission is still valid\n\t       *\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Promise}\n\t       */\n\t      Permission.prototype.validatePermission = function (toParams) {\n\t        var validationResult = this.validationFunction.call(null, toParams, this.permissionName);\n\t\n\t        if (!angular.isFunction(validationResult.then)) {\n\t          validationResult = wrapInPromise(validationResult, this.permissionName);\n\t        }\n\t\n\t        return validationResult;\n\t      };\n\t\n\t      /**\n\t       * Converts a value into a promise, if the value is truthy it resolves it, otherwise it rejects it\n\t       * @private\n\t       *\n\t       * @param result {Boolean} Function to be wrapped into promise\n\t       * @param permissionName {String} Returned value in promise\n\t       * @return {Promise}\n\t       */\n\t      function wrapInPromise(result, permissionName) {\n\t        var dfd = $q.defer();\n\t\n\t        if (result) {\n\t          dfd.resolve(permissionName);\n\t        } else {\n\t          dfd.reject(permissionName);\n\t        }\n\t\n\t        return dfd.promise;\n\t      }\n\t\n\t      /**\n\t       * Checks if provided permission has accepted parameter types\n\t       * @private\n\t       */\n\t      function validateConstructor(permissionName, validationFunction) {\n\t        if (!angular.isString(permissionName)) {\n\t          throw new TypeError('Parameter \"permissionName\" name must be String');\n\t        }\n\t        if (!angular.isFunction(validationFunction)) {\n\t          throw new TypeError('Parameter \"validationFunction\" must be Function');\n\t        }\n\t      }\n\t\n\t      return Permission;\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .factory('Role', ['$q', 'PermissionStore', function ($q, PermissionStore) {\n\t\n\t      /**\n\t       * Role definition constructor\n\t       *\n\t       * @param roleName {String} Name representing role\n\t       * @param permissionNames {Array} List of permission names representing role\n\t       * @param [validationFunction] {Function} Optional function used to validate if permissions are still valid\n\t       * @constructor\n\t       */\n\t      function Role(roleName, permissionNames, validationFunction) {\n\t        validateConstructor(roleName, permissionNames, validationFunction);\n\t        this.roleName = roleName;\n\t        this.permissionNames = permissionNames || [];\n\t\n\t        if (validationFunction) {\n\t          PermissionStore.defineManyPermissions(permissionNames, validationFunction);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Checks if role is still valid\n\t       *\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Promise} $q.promise object\n\t       */\n\t      Role.prototype.validateRole = function (toParams) {\n\t\n\t        // When set permissions is provided check each of them\n\t        if (this.permissionNames.length) {\n\t          var promises = this.permissionNames.map(function (permissionName) {\n\t            if (PermissionStore.hasPermissionDefinition(permissionName)) {\n\t              var permission = PermissionStore.getPermissionDefinition(permissionName);\n\t              var validationResult = permission.validationFunction.call(null, toParams, permission.permissionName);\n\t\n\t              if (!angular.isFunction(validationResult.then)) {\n\t                validationResult = wrapInPromise(validationResult);\n\t              }\n\t\n\t              return validationResult;\n\t            }\n\t\n\t            return $q.reject(null);\n\t          });\n\t\n\t          return $q.all(promises);\n\t        }\n\t\n\t        // If not call validation function manually\n\t        var validationResult = this.validationFunction.call(null, toParams, this.roleName);\n\t        if (!angular.isFunction(validationResult.then)) {\n\t          validationResult = wrapInPromise(validationResult, this.roleName);\n\t        }\n\t\n\t        return $q.resolve(validationResult);\n\t\n\t      };\n\t\n\t      /**\n\t       * Converts a value into a promise, if the value is truthy it resolves it, otherwise it rejects it\n\t       * @private\n\t       *\n\t       * @param result {Boolean} Function to be wrapped into promise\n\t       * @param roleName {String} Returned value in promise\n\t       * @return {Promise}\n\t       */\n\t      function wrapInPromise(result, roleName) {\n\t        var dfd = $q.defer();\n\t\n\t        if (result) {\n\t          dfd.resolve(roleName);\n\t        } else {\n\t          dfd.reject(roleName);\n\t        }\n\t\n\t        return dfd.promise;\n\t      }\n\t\n\t      /**\n\t       * Checks if provided permission has accepted parameter types\n\t       * @private\n\t       */\n\t      function validateConstructor(roleName, permissionNames, validationFunction) {\n\t        if (!angular.isString(roleName)) {\n\t          throw new TypeError('Parameter \"roleName\" name must be String');\n\t        }\n\t\n\t        if (!angular.isArray(permissionNames)) {\n\t          throw new TypeError('Parameter \"permissionNames\" must be Array');\n\t        }\n\t\n\t        if (!permissionNames.length && !angular.isFunction(validationFunction)) {\n\t          throw new TypeError('Parameter \"validationFunction\" must be provided for empty \"permissionNames\" array');\n\t        }\n\t      }\n\t\n\t      return Role;\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .service('PermissionStore', ['Permission', function (Permission) {\n\t      var permissionStore = {};\n\t\n\t      this.definePermission = definePermission;\n\t      this.defineManyPermissions = defineManyPermissions;\n\t      this.removePermissionDefinition = removePermissionDefinition;\n\t      this.hasPermissionDefinition = hasPermissionDefinition;\n\t      this.getPermissionDefinition = getPermissionDefinition;\n\t      this.getStore = getStore;\n\t      this.clearStore = clearStore;\n\t\n\t      /**\n\t       * Allows to define permission on application configuration\n\t       *\n\t       * @param permissionName {String} Name of defined permission\n\t       * @param validationFunction {Function} Function used to validate if permission is valid\n\t       */\n\t      function definePermission(permissionName, validationFunction) {\n\t        permissionStore[permissionName] = new Permission(permissionName, validationFunction);\n\t      }\n\t\n\t      /**\n\t       * Allows to define set of permissionNames with shared validation function on application configuration\n\t       *\n\t       * @param permissionNames {Array} Set of permission names\n\t       * @param validationFunction {Function} Function used to validate if permission is valid\n\t       */\n\t      function defineManyPermissions(permissionNames, validationFunction) {\n\t        if (!angular.isArray(permissionNames)) {\n\t          throw new TypeError('Parameter \"permissionNames\" name must be Array');\n\t        }\n\t\n\t        angular.forEach(permissionNames, function (permissionName) {\n\t          definePermission(permissionName, validationFunction);\n\t        });\n\t      }\n\t\n\t      /**\n\t       * Deletes permission\n\t       *\n\t       * @param permissionName {String} Name of defined permission\n\t       */\n\t      function removePermissionDefinition(permissionName) {\n\t        delete permissionStore[permissionName];\n\t      }\n\t\n\t      /**\n\t       * Checks if permission exists\n\t       *\n\t       * @param permissionName {String} Name of defined permission\n\t       * @returns {Boolean}\n\t       */\n\t      function hasPermissionDefinition(permissionName) {\n\t        return angular.isDefined(permissionStore[permissionName]);\n\t      }\n\t\n\t      /**\n\t       * Returns permission by it's name\n\t       *\n\t       * @returns {Object} Permissions collection\n\t       */\n\t      function getPermissionDefinition(permissionName) {\n\t        return permissionStore[permissionName];\n\t      }\n\t\n\t      /**\n\t       * Returns all permissions\n\t       *\n\t       * @returns {Object} Permissions collection\n\t       */\n\t      function getStore() {\n\t        return permissionStore;\n\t      }\n\t\n\t      /**\n\t       * Removes all permissions\n\t       */\n\t      function clearStore() {\n\t        permissionStore = {};\n\t      }\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .service('RoleStore', ['Role', function (Role) {\n\t      var roleStore = {};\n\t\n\t      this.defineRole = defineRole;\n\t      this.getRoleDefinition = getRoleDefinition;\n\t      this.hasRoleDefinition = hasRoleDefinition;\n\t      this.removeRoleDefinition = removeRoleDefinition;\n\t      this.getStore = getStore;\n\t      this.clearStore = clearStore;\n\t\n\t      /**\n\t       * Allows to define role\n\t       *\n\t       * @param roleName {String} Name of defined role\n\t       * @param permissions {Array} Set of permission names\n\t       * @param [validationFunction] {Function} Function used to validate if permissions in role are valid\n\t       */\n\t      function defineRole(roleName, permissions, validationFunction) {\n\t        roleStore[roleName] = new Role(roleName, permissions, validationFunction);\n\t      }\n\t\n\t      /**\n\t       * Deletes role from store\n\t       *\n\t       * @param roleName {String} Name of defined permission\n\t       */\n\t      function removeRoleDefinition(roleName) {\n\t        delete roleStore[roleName];\n\t      }\n\t\n\t      /**\n\t       * Checks if role is defined in store\n\t       *\n\t       * @param roleName {String} Name of role\n\t       * @returns {Boolean}\n\t       */\n\t      function hasRoleDefinition(roleName) {\n\t        return angular.isDefined(roleStore[roleName]);\n\t      }\n\t\n\t      /**\n\t       * Returns role definition object by it's name\n\t       *\n\t       * @returns {Object} Role definition object\n\t       */\n\t      function getRoleDefinition(roleName) {\n\t        return roleStore[roleName];\n\t      }\n\t\n\t      /**\n\t       * Returns all role definitions\n\t       *\n\t       * @returns {Object} Defined roles collection\n\t       */\n\t      function getStore() {\n\t        return roleStore;\n\t      }\n\t\n\t      /**\n\t       * Removes all role definitions\n\t       */\n\t      function clearStore() {\n\t        roleStore = {};\n\t      }\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  /**\n\t   * Show/hide elements based on provided permissions\n\t   *\n\t   * @example\n\t   * <div permission only=\"'USER'\"></div>\n\t   * <div permission only=\"['USER','ADMIN']\" except=\"'MANAGER'\"></div>\n\t   * <div permission except=\"'MANAGER'\"></div>\n\t   */\n\t  angular\n\t    .module('permission')\n\t    .directive('permission', ['$log', 'Authorization', 'PermissionMap', function ($log, Authorization, PermissionMap) {\n\t      return {\n\t        restrict: 'A',\n\t        link: function (scope, element, attrs) {\n\t          try {\n\t            Authorization\n\t              .authorize(new PermissionMap({\n\t                only: scope.$eval(attrs.only),\n\t                except: scope.$eval(attrs.except)\n\t              }), null)\n\t              .then(function () {\n\t                element.removeClass('ng-hide');\n\t              })\n\t              .catch(function () {\n\t                element.addClass('ng-hide');\n\t              });\n\t          } catch (e) {\n\t            element.addClass('ng-hide');\n\t            $log.error(e.message);\n\t          }\n\t        }\n\t      };\n\t    }]);\n\t}());\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .service('Authorization', ['$q', 'PermissionMap', 'PermissionStore', 'RoleStore', function ($q, PermissionMap, PermissionStore, RoleStore) {\n\t      this.authorize = authorize;\n\t\n\t      /**\n\t       * Checks if provided permissions are acceptable\n\t       *\n\t       * @param permissionsMap {PermissionMap} Map of permission names\n\t       * @param [toParams] {Object} UI-Router params object\n\t       * @returns {promise} $q.promise object\n\t       */\n\t      function authorize(permissionsMap, toParams) {\n\t        return handleAuthorization(permissionsMap, toParams);\n\t      }\n\t\n\t      /**\n\t       * Handles authorization based on provided permissions map\n\t       * @private\n\t       *\n\t       * @param permissionsMap {Object} Map of permission names\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {promise} $q.promise object\n\t       */\n\t      function handleAuthorization(permissionsMap, toParams) {\n\t        var deferred = $q.defer();\n\t\n\t        var exceptPromises = findMatchingPermissions(permissionsMap.except, toParams);\n\t\n\t        $q.all(exceptPromises)\n\t          .then(function (rejectedPermissions) {\n\t            // If any \"except\" permissions are found reject authorization\n\t            if (rejectedPermissions.length) {\n\t              deferred.reject(rejectedPermissions);\n\t            } else {\n\t              // If none go to checking \"only\" permissions\n\t              return $q.reject(null);\n\t            }\n\t          })\n\t          .catch(function () {\n\t            var onlyPromises = findMatchingPermissions(permissionsMap.only, toParams);\n\t            $q.all(onlyPromises)\n\t              .then(function (resolvedPermissions) {\n\t                deferred.resolve(resolvedPermissions);\n\t              })\n\t              .catch(function (rejectedPermission) {\n\t                deferred.reject(rejectedPermission);\n\t              });\n\t          });\n\t\n\t        return deferred.promise;\n\t      }\n\t\n\t      /**\n\t       * Performs iteration over list of defined permissions looking for matching roles\n\t       * @private\n\t       *\n\t       * @param permissionNames {Array} Set of permission names\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Array} Promise collection\n\t       */\n\t      function findMatchingPermissions(permissionNames, toParams) {\n\t        return permissionNames.map(function (permissionName) {\n\t          if (RoleStore.hasRoleDefinition(permissionName)) {\n\t            return handleRoleValidation(permissionName, toParams);\n\t          }\n\t\n\t          if (PermissionStore.hasPermissionDefinition(permissionName)) {\n\t            return handlePermissionValidation(permissionName, toParams);\n\t          }\n\t\n\t          if (permissionName) {\n\t            return $q.reject(permissionName);\n\t          }\n\t        });\n\t      }\n\t\n\t      /**\n\t       * Executes role validation checking\n\t       * @private\n\t       *\n\t       * @param roleName {String} Store permission key\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Promise}\n\t       */\n\t      function handleRoleValidation(roleName, toParams) {\n\t        var role = RoleStore.getRoleDefinition(roleName);\n\t        return role.validateRole(toParams);\n\t      }\n\t\n\t      /**\n\t       * Executes permission validation checking\n\t       * @private\n\t       *\n\t       * @param permissionName {String} Store permission key\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Promise}\n\t       */\n\t      function handlePermissionValidation(permissionName, toParams) {\n\t        var permission = PermissionStore.getPermissionDefinition(permissionName);\n\t        return permission.validatePermission(toParams);\n\t      }\n\t    }]);\n\t})();\n\n\n/***/ },\n\n/***/ 9:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(16);\n\t\n\tmodule.exports = 'ui.bootstrap';\n\n\n/***/ },\n\n/***/ 10:\n/***/ function(module, exports) {\n\n\t/**\r\n\t * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n\t * @author Mark Lagendijk <mark@lagendijk.info>\r\n\t * @license MIT\r\n\t */\r\n\tangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n\t    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n\t        var self = this;\r\n\t\r\n\t        /**\r\n\t         * Recursively sets the states using $stateProvider.state.\r\n\t         * Child states are defined via a `children` property.\r\n\t         *\r\n\t         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n\t         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n\t         * 3. Sets `parent` property of the descendant states.\r\n\t         *\r\n\t         * @param {Object} state - A regular ui.router state object.\r\n\t         * @param {Array} [state.children] - An optional array of child states.\r\n\t         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n\t         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n\t         * @param {Object} [options] - An optional options object.\r\n\t         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n\t         *     prevents conversion of names to dot notation if true.\r\n\t         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n\t         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n\t         */\r\n\t        this.state = function(state){\r\n\t            var args = Array.prototype.slice.apply(arguments);\r\n\t            var options = {\r\n\t                keepOriginalNames: false,\r\n\t                siblingTraversal: false\r\n\t            };  \r\n\t\r\n\t            if (typeof args[1] === 'boolean') {\r\n\t                options.keepOriginalNames = args[1];\r\n\t            } \r\n\t            else if (typeof args[1] === 'object') {\r\n\t                angular.extend(options, args[1]);\r\n\t            }\r\n\t\r\n\t            if (!options.keepOriginalNames) {\r\n\t                fixStateName(state);\r\n\t            }\r\n\t\r\n\t            $stateProvider.state(state);\r\n\t\r\n\t            if(state.children && state.children.length){\r\n\t                state.children.forEach(function(childState){\r\n\t                    childState.parent = state;\r\n\t                    self.state(childState, options);\r\n\t                });\r\n\t\r\n\t                if (options.siblingTraversal) {\r\n\t                    addSiblings(state);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return self;\r\n\t        };\r\n\t\r\n\t        this.setNestedState = this.state;\r\n\t\r\n\t        self.$get = angular.noop;\r\n\t\r\n\t        /**\r\n\t         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n\t         * @param state\r\n\t         */\r\n\t        function fixStateName(state){\r\n\t            if(state.parent){\r\n\t                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        function addSiblings(state) {\r\n\t            state.children.forEach(function (childState, idx, array) {\r\n\t                if (array[idx + 1]) {\r\n\t                    childState.nextSibling = array[idx + 1].name;\r\n\t                }\r\n\t                if (array[idx - 1]) {\r\n\t                    childState.previousSibling = array[idx - 1].name;\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t    }]);\r\n\n\n/***/ },\n\n/***/ 11:\n/***/ function(module, exports) {\n\n\t/**\n\t * State-based routing for AngularJS\n\t * @version v0.2.18\n\t * @link http://angular-ui.github.com/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n\t  module.exports = 'ui.router';\n\t}\n\t\n\t(function (window, angular, undefined) {\n\t/*jshint globalstrict:true*/\n\t/*global angular:false*/\n\t'use strict';\n\t\n\tvar isDefined = angular.isDefined,\n\t    isFunction = angular.isFunction,\n\t    isString = angular.isString,\n\t    isObject = angular.isObject,\n\t    isArray = angular.isArray,\n\t    forEach = angular.forEach,\n\t    extend = angular.extend,\n\t    copy = angular.copy,\n\t    toJson = angular.toJson;\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n\t}\n\t\n\tfunction merge(dst) {\n\t  forEach(arguments, function(obj) {\n\t    if (obj !== dst) {\n\t      forEach(obj, function(value, key) {\n\t        if (!dst.hasOwnProperty(key)) dst[key] = value;\n\t      });\n\t    }\n\t  });\n\t  return dst;\n\t}\n\t\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Object.keys()`.\n\t *\n\t * @param {Object} object A JavaScript object.\n\t * @return {Array} Returns the keys of the object as an array.\n\t */\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  forEach(object, function(val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Array.prototype.indexOf()`.\n\t *\n\t * @param {Array} array A JavaScript array.\n\t * @param {*} value A value to search the array for.\n\t * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n\t */\n\tfunction indexOf(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Merges a set of parameters with all parameters inherited between the common parents of the\n\t * current state and a given destination state.\n\t *\n\t * @param {Object} currentParams The value of the current state parameters ($stateParams).\n\t * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t * @param {Object} $current Internal definition of object representing the current state.\n\t * @param {Object} $to Internal definition of object representing state to transition to.\n\t */\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i] || !parents[i].params) continue;\n\t    parentParams = objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t  if (!keys) {\n\t    keys = [];\n\t    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t  }\n\t\n\t  for (var i=0; i<keys.length; i++) {\n\t    var k = keys[i];\n\t    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Returns the subset of an object, based on a list of keys.\n\t *\n\t * @param {Array} keys\n\t * @param {Object} values\n\t * @return {Boolean} Returns a subset of `values`.\n\t */\n\tfunction filterByKeys(keys, values) {\n\t  var filtered = {};\n\t\n\t  forEach(keys, function (name) {\n\t    filtered[name] = values[name];\n\t  });\n\t  return filtered;\n\t}\n\t\n\t// like _.indexBy\n\t// when you know that your index values will be unique, or you want last-one-in to win\n\tfunction indexBy(array, propName) {\n\t  var result = {};\n\t  forEach(array, function(item) {\n\t    result[item[propName]] = item;\n\t  });\n\t  return result;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object only containing the whitelisted properties.\n\tfunction pick(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  forEach(keys, function(key) {\n\t    if (key in obj) copy[key] = obj[key];\n\t  });\n\t  return copy;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object omitting the blacklisted properties.\n\tfunction omit(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  for (var key in obj) {\n\t    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n\t  }\n\t  return copy;\n\t}\n\t\n\tfunction pluck(collection, key) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = isFunction(key) ? key(val) : val[key];\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction filter(collection, callback) {\n\t  var array = isArray(collection);\n\t  var result = array ? [] : {};\n\t  forEach(collection, function(val, i) {\n\t    if (callback(val, i)) {\n\t      result[array ? result.length : i] = val;\n\t    }\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction map(collection, callback) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = callback(val, i);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t * \n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t * \n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t * \n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t * \n\t * ## The main module for ui.router \n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes. \n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router - \n\t * \n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t * \n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.state']);\n\t\n\tangular.module('ui.router.compat', ['ui.router']);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$resolve\n\t *\n\t * @requires $q\n\t * @requires $injector\n\t *\n\t * @description\n\t * Manages resolution of (acyclic) graphs of promises.\n\t */\n\t$Resolve.$inject = ['$q', '$injector'];\n\tfunction $Resolve(  $q,    $injector) {\n\t  \n\t  var VISIT_IN_PROGRESS = 1,\n\t      VISIT_DONE = 2,\n\t      NOTHING = {},\n\t      NO_DEPENDENCIES = [],\n\t      NO_LOCALS = NOTHING,\n\t      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\t  \n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#study\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Studies a set of invocables that are likely to be used multiple times.\n\t   * <pre>\n\t   * $resolve.study(invocables)(locals, parent, self)\n\t   * </pre>\n\t   * is equivalent to\n\t   * <pre>\n\t   * $resolve.resolve(invocables, locals, parent, self)\n\t   * </pre>\n\t   * but the former is more efficient (in fact `resolve` just calls `study` \n\t   * internally).\n\t   *\n\t   * @param {object} invocables Invocable objects\n\t   * @return {function} a function to pass in locals, parent and self\n\t   */\n\t  this.study = function (invocables) {\n\t    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\t    var invocableKeys = objectKeys(invocables || {});\n\t    \n\t    // Perform a topological sort of invocables to build an ordered plan\n\t    var plan = [], cycle = [], visited = {};\n\t    function visit(value, key) {\n\t      if (visited[key] === VISIT_DONE) return;\n\t      \n\t      cycle.push(key);\n\t      if (visited[key] === VISIT_IN_PROGRESS) {\n\t        cycle.splice(0, indexOf(cycle, key));\n\t        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n\t      }\n\t      visited[key] = VISIT_IN_PROGRESS;\n\t      \n\t      if (isString(value)) {\n\t        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n\t      } else {\n\t        var params = $injector.annotate(value);\n\t        forEach(params, function (param) {\n\t          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n\t        });\n\t        plan.push(key, value, params);\n\t      }\n\t      \n\t      cycle.pop();\n\t      visited[key] = VISIT_DONE;\n\t    }\n\t    forEach(invocables, visit);\n\t    invocables = cycle = visited = null; // plan is all that's required\n\t    \n\t    function isResolve(value) {\n\t      return isObject(value) && value.then && value.$$promises;\n\t    }\n\t    \n\t    return function (locals, parent, self) {\n\t      if (isResolve(locals) && self === undefined) {\n\t        self = parent; parent = locals; locals = null;\n\t      }\n\t      if (!locals) locals = NO_LOCALS;\n\t      else if (!isObject(locals)) {\n\t        throw new Error(\"'locals' must be an object\");\n\t      }       \n\t      if (!parent) parent = NO_PARENT;\n\t      else if (!isResolve(parent)) {\n\t        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n\t      }\n\t      \n\t      // To complete the overall resolution, we have to wait for the parent\n\t      // promise and for the promise for each invokable in our plan.\n\t      var resolution = $q.defer(),\n\t          result = resolution.promise,\n\t          promises = result.$$promises = {},\n\t          values = extend({}, locals),\n\t          wait = 1 + plan.length/3,\n\t          merged = false;\n\t          \n\t      function done() {\n\t        // Merge parent values we haven't got yet and publish our own $$values\n\t        if (!--wait) {\n\t          if (!merged) merge(values, parent.$$values); \n\t          result.$$values = values;\n\t          result.$$promises = result.$$promises || true; // keep for isResolve()\n\t          delete result.$$inheritedValues;\n\t          resolution.resolve(values);\n\t        }\n\t      }\n\t      \n\t      function fail(reason) {\n\t        result.$$failure = reason;\n\t        resolution.reject(reason);\n\t      }\n\t\n\t      // Short-circuit if parent has already failed\n\t      if (isDefined(parent.$$failure)) {\n\t        fail(parent.$$failure);\n\t        return result;\n\t      }\n\t      \n\t      if (parent.$$inheritedValues) {\n\t        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n\t      }\n\t\n\t      // Merge parent values if the parent has already resolved, or merge\n\t      // parent promises and wait if the parent resolve is still in progress.\n\t      extend(promises, parent.$$promises);\n\t      if (parent.$$values) {\n\t        merged = merge(values, omit(parent.$$values, invocableKeys));\n\t        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n\t        done();\n\t      } else {\n\t        if (parent.$$inheritedValues) {\n\t          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n\t        }        \n\t        parent.then(done, fail);\n\t      }\n\t      \n\t      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n\t      for (var i=0, ii=plan.length; i<ii; i+=3) {\n\t        if (locals.hasOwnProperty(plan[i])) done();\n\t        else invoke(plan[i], plan[i+1], plan[i+2]);\n\t      }\n\t      \n\t      function invoke(key, invocable, params) {\n\t        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n\t        var invocation = $q.defer(), waitParams = 0;\n\t        function onfailure(reason) {\n\t          invocation.reject(reason);\n\t          fail(reason);\n\t        }\n\t        // Wait for any parameter that we have a promise for (either from parent or from this\n\t        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n\t        forEach(params, function (dep) {\n\t          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n\t            waitParams++;\n\t            promises[dep].then(function (result) {\n\t              values[dep] = result;\n\t              if (!(--waitParams)) proceed();\n\t            }, onfailure);\n\t          }\n\t        });\n\t        if (!waitParams) proceed();\n\t        function proceed() {\n\t          if (isDefined(result.$$failure)) return;\n\t          try {\n\t            invocation.resolve($injector.invoke(invocable, self, values));\n\t            invocation.promise.then(function (result) {\n\t              values[key] = result;\n\t              done();\n\t            }, onfailure);\n\t          } catch (e) {\n\t            onfailure(e);\n\t          }\n\t        }\n\t        // Publish promise synchronously; invocations further down in the plan may depend on it.\n\t        promises[key] = invocation.promise;\n\t      }\n\t      \n\t      return result;\n\t    };\n\t  };\n\t  \n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#resolve\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Resolves a set of invocables. An invocable is a function to be invoked via \n\t   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n\t   * An invocable can either return a value directly,\n\t   * or a `$q` promise. If a promise is returned it will be resolved and the \n\t   * resulting value will be used instead. Dependencies of invocables are resolved \n\t   * (in this order of precedence)\n\t   *\n\t   * - from the specified `locals`\n\t   * - from another invocable that is part of this `$resolve` call\n\t   * - from an invocable that is inherited from a `parent` call to `$resolve` \n\t   *   (or recursively\n\t   * - from any ancestor `$resolve` of that parent).\n\t   *\n\t   * The return value of `$resolve` is a promise for an object that contains \n\t   * (in this order of precedence)\n\t   *\n\t   * - any `locals` (if specified)\n\t   * - the resolved return values of all injectables\n\t   * - any values inherited from a `parent` call to `$resolve` (if specified)\n\t   *\n\t   * The promise will resolve after the `parent` promise (if any) and all promises \n\t   * returned by injectables have been resolved. If any invocable \n\t   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n\t   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n\t   * same error. A rejection of a `parent` promise (if specified) will likewise be \n\t   * propagated immediately. Once the `$resolve` promise has been rejected, no \n\t   * further invocables will be called.\n\t   * \n\t   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n\t   * to throw an error. As a special case, an injectable can depend on a parameter \n\t   * with the same name as the injectable, which will be fulfilled from the `parent` \n\t   * injectable of the same name. This allows inherited values to be decorated. \n\t   * Note that in this case any other injectable in the same `$resolve` with the same\n\t   * dependency would see the decorated value, not the inherited value.\n\t   *\n\t   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n\t   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n\t   * exception.\n\t   *\n\t   * Invocables are invoked eagerly as soon as all dependencies are available. \n\t   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n\t   *\n\t   * As a special case, an invocable can be a string, in which case it is taken to \n\t   * be a service name to be passed to `$injector.get()`. This is supported primarily \n\t   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n\t   * routes.\n\t   *\n\t   * @param {object} invocables functions to invoke or \n\t   * `$injector` services to fetch.\n\t   * @param {object} locals  values to make available to the injectables\n\t   * @param {object} parent  a promise returned by another call to `$resolve`.\n\t   * @param {object} self  the `this` for the invoked methods\n\t   * @return {object} Promise for an object that contains the resolved return value\n\t   * of all invocables, as well as any inherited and local values.\n\t   */\n\t  this.resolve = function (invocables, locals, parent, self) {\n\t    return this.study(invocables)(locals, parent, self);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$resolve', $Resolve);\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$templateFactory\n\t *\n\t * @requires $http\n\t * @requires $templateCache\n\t * @requires $injector\n\t *\n\t * @description\n\t * Service. Manages loading of templates.\n\t */\n\t$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n\tfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromConfig\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a configuration object. \n\t   *\n\t   * @param {object} config Configuration object for which to load a template. \n\t   * The following properties are search in the specified order, and the first one \n\t   * that is defined is used to create the template:\n\t   *\n\t   * @param {string|object} config.template html string template or function to \n\t   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n\t   * @param {string|object} config.templateUrl url to load or a function returning \n\t   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n\t   * @param {Function} config.templateProvider function to invoke via \n\t   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n\t   * @param {object} params  Parameters to pass to the template function.\n\t   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n\t   * via a `templateProvider`. Defaults to `{ params: params }`.\n\t   *\n\t   * @return {string|object}  The template html as a string, or a promise for \n\t   * that string,or `null` if no template is configured.\n\t   */\n\t  this.fromConfig = function (config, params, locals) {\n\t    return (\n\t      isDefined(config.template) ? this.fromString(config.template, params) :\n\t      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n\t      null\n\t    );\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromString\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a string or a function returning a string.\n\t   *\n\t   * @param {string|object} template html template as a string or function that \n\t   * returns an html template as a string.\n\t   * @param {object} params Parameters to pass to the template function.\n\t   *\n\t   * @return {string|object} The template html as a string, or a promise for that \n\t   * string.\n\t   */\n\t  this.fromString = function (template, params) {\n\t    return isFunction(template) ? template(params) : template;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromUrl\n\t   * @methodOf ui.router.util.$templateFactory\n\t   * \n\t   * @description\n\t   * Loads a template from the a URL via `$http` and `$templateCache`.\n\t   *\n\t   * @param {string|Function} url url of the template to load, or a function \n\t   * that returns a url.\n\t   * @param {Object} params Parameters to pass to the url function.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromUrl = function (url, params) {\n\t    if (isFunction(url)) url = url(params);\n\t    if (url == null) return null;\n\t    else return $http\n\t        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n\t        .then(function(response) { return response.data; });\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromProvider\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template by invoking an injectable provider function.\n\t   *\n\t   * @param {Function} provider Function to invoke via `$injector.invoke`\n\t   * @param {Object} params Parameters for the template.\n\t   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n\t   * `{ params: params }`.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromProvider = function (provider, params, locals) {\n\t    return $injector.invoke(provider, null, locals || { params: params });\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\t\n\tvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t *\n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon\n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash:\n\t * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n\t *   an existing UrlMatcher\n\t *\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} source  The pattern that was passed into the constructor\n\t *\n\t * @property {string} sourcePath  The path portion of the source property\n\t *\n\t * @property {string} sourceSearch  The search portion of the source property\n\t *\n\t * @property {string} regex  The constructed regex that will be used to match against the url when\n\t *   it is time to determine which url will match.\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tfunction UrlMatcher(pattern, config, parentMatcher) {\n\t  config = extend({ params: {} }, isObject(config) ? config : {});\n\t\n\t  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t  //   '*' name\n\t  //   ':' name\n\t  //   '{' name '}'\n\t  //   '{' name ':' regexp '}'\n\t  // The regular expression is somewhat complicated due to the need to allow curly braces\n\t  // inside the regular expression. The placeholder regexp breaks down as follows:\n\t  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t  //    \\\\.                            - a backslash escape\n\t  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      compiled = '^', last = 0, m,\n\t      segments = this.segments = [],\n\t      parentParams = parentMatcher ? parentMatcher.params : {},\n\t      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n\t      paramNames = [];\n\t\n\t  function addParameter(id, type, config, location) {\n\t    paramNames.push(id);\n\t    if (parentParams[id]) return parentParams[id];\n\t    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    params[id] = new $$UMFP.Param(id, type, config, location);\n\t    return params[id];\n\t  }\n\t\n\t  function quoteRegExp(string, pattern, squash, optional) {\n\t    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!pattern) return result;\n\t    switch(squash) {\n\t      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n\t      case true:\n\t        result = result.replace(/\\/$/, '');\n\t        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t      break;\n\t      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n\t    }\n\t    return result + surroundPattern[0] + pattern + surroundPattern[1];\n\t  }\n\t\n\t  this.source = pattern;\n\t\n\t  // Split into static segments separated by path parameter placeholders.\n\t  // The number of segments is always 1 more than the number of parameters.\n\t  function matchDetails(m, isSearch) {\n\t    var id, regexp, segment, type, cfg, arrayMode;\n\t    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n\t    cfg         = config.params[id];\n\t    segment     = pattern.substring(last, m.index);\n\t    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\t\n\t    if (regexp) {\n\t      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n\t    }\n\t\n\t    return {\n\t      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n\t    };\n\t  }\n\t\n\t  var p, param, segment;\n\t  while ((m = placeholder.exec(pattern))) {\n\t    p = matchDetails(m, false);\n\t    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\t\n\t    param = addParameter(p.id, p.type, p.cfg, \"path\");\n\t    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n\t    segments.push(p.segment);\n\t    last = placeholder.lastIndex;\n\t  }\n\t  segment = pattern.substring(last);\n\t\n\t  // Find any search parameter names and remove them from the last segment\n\t  var i = segment.indexOf('?');\n\t\n\t  if (i >= 0) {\n\t    var search = this.sourceSearch = segment.substring(i);\n\t    segment = segment.substring(0, i);\n\t    this.sourcePath = pattern.substring(0, last + i);\n\t\n\t    if (search.length > 0) {\n\t      last = 0;\n\t      while ((m = searchPlaceholder.exec(search))) {\n\t        p = matchDetails(m, true);\n\t        param = addParameter(p.id, p.type, p.cfg, \"search\");\n\t        last = placeholder.lastIndex;\n\t        // check if ?&\n\t      }\n\t    }\n\t  } else {\n\t    this.sourcePath = pattern;\n\t    this.sourceSearch = '';\n\t  }\n\t\n\t  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n\t  segments.push(segment);\n\t\n\t  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n\t  this.prefix = segments[0];\n\t  this.$$paramNames = paramNames;\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#concat\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns a new matcher for a pattern constructed by appending the path part and adding the\n\t * search parameters of the specified pattern to this pattern. The current pattern is not\n\t * modified. This can be understood as creating a pattern for URLs that are relative to (or\n\t * suffixes of) the current pattern.\n\t *\n\t * @example\n\t * The following two matchers are equivalent:\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').concat('/details?date');\n\t * new UrlMatcher('/user/{id}/details?q&date');\n\t * </pre>\n\t *\n\t * @param {string} pattern  The pattern to append.\n\t * @param {Object} config  An object hash of the configuration for the matcher.\n\t * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n\t */\n\tUrlMatcher.prototype.concat = function (pattern, config) {\n\t  // Because order of search parameters is irrelevant, we can add our own search\n\t  // parameters to the end of the new pattern. Parse the new pattern by itself\n\t  // and then join the bits together, but it's much easier to do this on a string level.\n\t  var defaultConfig = {\n\t    caseInsensitive: $$UMFP.caseInsensitive(),\n\t    strict: $$UMFP.strictMode(),\n\t    squash: $$UMFP.defaultSquashPolicy()\n\t  };\n\t  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n\t};\n\t\n\tUrlMatcher.prototype.toString = function () {\n\t  return this.source;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#exec\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Tests the specified path against this matcher, and returns an object containing the captured\n\t * parameter values, or null if the path does not match. The returned object contains the values\n\t * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t * they are not present in `searchParams`. This means that search parameters are always treated\n\t * as optional.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t *   x: '1', q: 'hello'\n\t * });\n\t * // returns { id: 'bob', q: 'hello', r: null }\n\t * </pre>\n\t *\n\t * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n\t * @returns {Object}  The captured parameter values.\n\t */\n\tUrlMatcher.prototype.exec = function (path, searchParams) {\n\t  var m = this.regexp.exec(path);\n\t  if (!m) return null;\n\t  searchParams = searchParams || {};\n\t\n\t  var paramNames = this.parameters(), nTotal = paramNames.length,\n\t    nPath = this.segments.length - 1,\n\t    values = {}, i, j, cfg, paramName;\n\t\n\t  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\t\n\t  function decodePathArray(string) {\n\t    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n\t    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\t\n\t    var split = reverseString(string).split(/-(?!\\\\)/);\n\t    var allReversed = map(split, reverseString);\n\t    return map(allReversed, unquoteDashes).reverse();\n\t  }\n\t\n\t  var param, paramVal;\n\t  for (i = 0; i < nPath; i++) {\n\t    paramName = paramNames[i];\n\t    param = this.params[paramName];\n\t    paramVal = m[i+1];\n\t    // if the param value matches a pre-replace pair, replace the value before decoding.\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t  for (/**/; i < nTotal; i++) {\n\t    paramName = paramNames[i];\n\t    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n\t    param = this.params[paramName];\n\t    paramVal = searchParams[paramName];\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t\n\t  return values;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#parameters\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns the names of all path and search parameters of this pattern in an unspecified order.\n\t *\n\t * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n\t *    pattern has no parameters, an empty array is returned.\n\t */\n\tUrlMatcher.prototype.parameters = function (param) {\n\t  if (!isDefined(param)) return this.$$paramNames;\n\t  return this.params[param] || null;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#validates\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Checks an object hash of parameters to validate their correctness according to the parameter\n\t * types of this `UrlMatcher`.\n\t *\n\t * @param {Object} params The object hash of parameters to validate.\n\t * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t */\n\tUrlMatcher.prototype.validates = function (params) {\n\t  return this.params.$$validates(params);\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#format\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Creates a URL that matches this pattern by substituting the specified values\n\t * for the path and search parameters. Null values for path parameters are\n\t * treated as empty strings.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t * // returns '/user/bob?q=yes'\n\t * </pre>\n\t *\n\t * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t * @returns {string}  the formatted URL (path and optionally search part).\n\t */\n\tUrlMatcher.prototype.format = function (values) {\n\t  values = values || {};\n\t  var segments = this.segments, params = this.parameters(), paramset = this.params;\n\t  if (!this.validates(values)) return null;\n\t\n\t  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\t\n\t  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n\t    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t  }\n\t\n\t  for (i = 0; i < nTotal; i++) {\n\t    var isPathParam = i < nPath;\n\t    var name = params[i], param = paramset[name], value = param.value(values[name]);\n\t    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n\t    var squash = isDefaultValue ? param.squash : false;\n\t    var encoded = param.type.encode(value);\n\t\n\t    if (isPathParam) {\n\t      var nextSegment = segments[i + 1];\n\t      var isFinalPathParam = i + 1 === nPath;\n\t\n\t      if (squash === false) {\n\t        if (encoded != null) {\n\t          if (isArray(encoded)) {\n\t            result += map(encoded, encodeDashes).join(\"-\");\n\t          } else {\n\t            result += encodeURIComponent(encoded);\n\t          }\n\t        }\n\t        result += nextSegment;\n\t      } else if (squash === true) {\n\t        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n\t        result += nextSegment.match(capture)[1];\n\t      } else if (isString(squash)) {\n\t        result += squash + nextSegment;\n\t      }\n\t\n\t      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n\t    } else {\n\t      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n\t      if (!isArray(encoded)) encoded = [ encoded ];\n\t      if (encoded.length === 0) continue;\n\t      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n\t      result += (search ? '&' : '?') + (name + '=' + encoded);\n\t      search = true;\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:Type\n\t *\n\t * @description\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n\t * information on registering custom types.\n\t *\n\t * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n\t *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t * @example\n\t * <pre>\n\t * {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t * </pre>\n\t *\n\t * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n\t *           coming from a substring of a URL.\n\t *\n\t * @returns {Object}  Returns a new `Type` object.\n\t */\n\tfunction Type(config) {\n\t  extend(this, config);\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#is\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Detects whether a value is of a particular type. Accepts a native (decoded) value\n\t * and determines whether it matches the current `Type` object.\n\t *\n\t * @param {*} val  The value to check.\n\t * @param {string} key  Optional. If the type check is happening in the context of a specific\n\t *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n\t *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n\t * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n\t */\n\tType.prototype.is = function(val, key) {\n\t  return true;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#encode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n\t * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n\t * only needs to be a representation of `val` that has been coerced to a string.\n\t *\n\t * @param {*} val  The value to encode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n\t */\n\tType.prototype.encode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#decode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Converts a parameter value (from URL string or transition param) to a custom/native value.\n\t *\n\t * @param {string} val  The URL parameter value to decode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {*}  Returns a custom representation of the URL parameter value.\n\t */\n\tType.prototype.decode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#equals\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Determines whether two decoded values are equivalent.\n\t *\n\t * @param {*} a  A value to compare against.\n\t * @param {*} b  A value to compare against.\n\t * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n\t */\n\tType.prototype.equals = function(a, b) {\n\t  return a == b;\n\t};\n\t\n\tType.prototype.$subPattern = function() {\n\t  var sub = this.pattern.toString();\n\t  return sub.substr(1, sub.length - 2);\n\t};\n\t\n\tType.prototype.pattern = /.*/;\n\t\n\tType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\t\n\t/** Given an encoded string, or a decoded object, returns a decoded object */\n\tType.prototype.$normalize = function(val) {\n\t  return this.is(val) ? val : this.decode(val);\n\t};\n\t\n\t/*\n\t * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t * e.g.:\n\t * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t * - url: \"/path?queryParam=1&queryParam=2\n\t * - $stateParams.queryParam will be [1, 2]\n\t * if `mode` is \"auto\", then\n\t * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t */\n\tType.prototype.$asArray = function(mode, isSearch) {\n\t  if (!mode) return this;\n\t  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\t\n\t  function ArrayType(type, mode) {\n\t    function bindTo(type, callbackName) {\n\t      return function() {\n\t        return type[callbackName].apply(type, arguments);\n\t      };\n\t    }\n\t\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t      switch(val.length) {\n\t        case 0: return undefined;\n\t        case 1: return mode === \"auto\" ? val[0] : val;\n\t        default: return val;\n\t      }\n\t    }\n\t    function falsey(val) { return !val; }\n\t\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t      return function handleArray(val) {\n\t        if (isArray(val) && val.length === 0) return val;\n\t        val = arrayWrap(val);\n\t        var result = map(val, callback);\n\t        if (allTruthyMode === true)\n\t          return filter(result, falsey).length === 0;\n\t        return arrayUnwrap(result);\n\t      };\n\t    }\n\t\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t      return function handleArray(val1, val2) {\n\t        var left = arrayWrap(val1), right = arrayWrap(val2);\n\t        if (left.length !== right.length) return false;\n\t        for (var i = 0; i < left.length; i++) {\n\t          if (!callback(left[i], right[i])) return false;\n\t        }\n\t        return true;\n\t      };\n\t    }\n\t\n\t    this.encode = arrayHandler(bindTo(type, 'encode'));\n\t    this.decode = arrayHandler(bindTo(type, 'decode'));\n\t    this.is     = arrayHandler(bindTo(type, 'is'), true);\n\t    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n\t    this.pattern = type.pattern;\n\t    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n\t    this.name = type.name;\n\t    this.$arrayMode = mode;\n\t  }\n\t\n\t  return new ArrayType(this, mode);\n\t};\n\t\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$urlMatcherFactory\n\t *\n\t * @description\n\t * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n\t * is also available to providers under the name `$urlMatcherFactoryProvider`.\n\t */\n\tfunction $UrlMatcherFactory() {\n\t  $$UMFP = this;\n\t\n\t  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\t\n\t  // Use tildes to pre-encode slashes.\n\t  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n\t  // and bidirectional encoding/decoding fails.\n\t  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n\t  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n\t  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\t\n\t  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n\t    \"string\": {\n\t      encode: valToString,\n\t      decode: valFromString,\n\t      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n\t      // In 0.2.x, string params are optional by default for backwards compat\n\t      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n\t      pattern: /[^/]*/\n\t    },\n\t    \"int\": {\n\t      encode: valToString,\n\t      decode: function(val) { return parseInt(val, 10); },\n\t      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n\t      pattern: /\\d+/\n\t    },\n\t    \"bool\": {\n\t      encode: function(val) { return val ? 1 : 0; },\n\t      decode: function(val) { return parseInt(val, 10) !== 0; },\n\t      is: function(val) { return val === true || val === false; },\n\t      pattern: /0|1/\n\t    },\n\t    \"date\": {\n\t      encode: function (val) {\n\t        if (!this.is(val))\n\t          return undefined;\n\t        return [ val.getFullYear(),\n\t          ('0' + (val.getMonth() + 1)).slice(-2),\n\t          ('0' + val.getDate()).slice(-2)\n\t        ].join(\"-\");\n\t      },\n\t      decode: function (val) {\n\t        if (this.is(val)) return val;\n\t        var match = this.capture.exec(val);\n\t        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t      },\n\t      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n\t      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t    },\n\t    \"json\": {\n\t      encode: angular.toJson,\n\t      decode: angular.fromJson,\n\t      is: angular.isObject,\n\t      equals: angular.equals,\n\t      pattern: /[^/]*/\n\t    },\n\t    \"any\": { // does not encode/decode\n\t      encode: angular.identity,\n\t      decode: angular.identity,\n\t      equals: angular.equals,\n\t      pattern: /.*/\n\t    }\n\t  };\n\t\n\t  function getDefaultConfig() {\n\t    return {\n\t      strict: isStrictMode,\n\t      caseInsensitive: isCaseInsensitive\n\t    };\n\t  }\n\t\n\t  function isInjectable(value) {\n\t    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n\t  }\n\t\n\t  /**\n\t   * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t   */\n\t  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n\t    if (!isInjectable(config.value)) return config.value;\n\t    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t    return injector.invoke(config.value);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t   *\n\t   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t   * @returns {boolean} the current value of caseInsensitive\n\t   */\n\t  this.caseInsensitive = function(value) {\n\t    if (isDefined(value))\n\t      isCaseInsensitive = value;\n\t    return isCaseInsensitive;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#strictMode\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t   *\n\t   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n\t   * @returns {boolean} the current value of strictMode\n\t   */\n\t  this.strictMode = function(value) {\n\t    if (isDefined(value))\n\t      isStrictMode = value;\n\t    return isStrictMode;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Sets the default behavior when generating or matching URLs with default parameter values.\n\t   *\n\t   * @param {string} value A string that defines the default parameter URL squashing behavior.\n\t   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t   *             the parameter value from the URL and replace it with this string.\n\t   */\n\t  this.defaultSquashPolicy = function(value) {\n\t    if (!isDefined(value)) return defaultSquashPolicy;\n\t    if (value !== true && value !== false && !isString(value))\n\t      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t    defaultSquashPolicy = value;\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#compile\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n\t   *\n\t   * @param {string} pattern  The URL pattern.\n\t   * @param {Object} config  The config object hash.\n\t   * @returns {UrlMatcher}  The UrlMatcher.\n\t   */\n\t  this.compile = function (pattern, config) {\n\t    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#isMatcher\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n\t   *\n\t   * @param {Object} object  The object to perform the type check against.\n\t   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n\t   *          implementing all the same methods.\n\t   */\n\t  this.isMatcher = function (o) {\n\t    if (!isObject(o)) return false;\n\t    var result = true;\n\t\n\t    forEach(UrlMatcher.prototype, function(val, name) {\n\t      if (isFunction(val)) {\n\t        result = result && (isDefined(o[name]) && isFunction(o[name]));\n\t      }\n\t    });\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#type\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n\t   * generate URLs with typed parameters.\n\t   *\n\t   * @param {string} name  The type name.\n\t   * @param {Object|Function} definition   The type definition. See\n\t   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n\t   *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   *\n\t   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n\t   *\n\t   * @example\n\t   * This is a simple example of a custom type that encodes and decodes items from an\n\t   * array, using the array index as the URL-encoded value:\n\t   *\n\t   * <pre>\n\t   * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t   *\n\t   * $urlMatcherFactoryProvider.type('listItem', {\n\t   *   encode: function(item) {\n\t   *     // Represent the list item in the URL using its corresponding index\n\t   *     return list.indexOf(item);\n\t   *   },\n\t   *   decode: function(item) {\n\t   *     // Look up the list item by index\n\t   *     return list[parseInt(item, 10)];\n\t   *   },\n\t   *   is: function(item) {\n\t   *     // Ensure the item is valid by checking to see that it appears\n\t   *     // in the list\n\t   *     return list.indexOf(item) > -1;\n\t   *   }\n\t   * });\n\t   *\n\t   * $stateProvider.state('list', {\n\t   *   url: \"/list/{item:listItem}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     console.log($stateParams.item);\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t   * $state.go('list', { item: \"Ringo\" });\n\t   * </pre>\n\t   *\n\t   * This is a more complex example of a type that relies on dependency injection to\n\t   * interact with services, and uses the parameter name from the URL to infer how to\n\t   * handle encoding and decoding parameter values:\n\t   *\n\t   * <pre>\n\t   * // Defines a custom type that gets a value from a service,\n\t   * // where each service gets different types of values from\n\t   * // a backend API:\n\t   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n\t   *\n\t   *   // Matches up services to URL parameter names\n\t   *   var services = {\n\t   *     user: Users,\n\t   *     post: Posts\n\t   *   };\n\t   *\n\t   *   return {\n\t   *     encode: function(object) {\n\t   *       // Represent the object in the URL using its unique ID\n\t   *       return object.id;\n\t   *     },\n\t   *     decode: function(value, key) {\n\t   *       // Look up the object by ID, using the parameter\n\t   *       // name (key) to call the correct service\n\t   *       return services[key].findById(value);\n\t   *     },\n\t   *     is: function(object, key) {\n\t   *       // Check that object is a valid dbObject\n\t   *       return angular.isObject(object) && object.id && services[key];\n\t   *     }\n\t   *     equals: function(a, b) {\n\t   *       // Check the equality of decoded objects by comparing\n\t   *       // their unique IDs\n\t   *       return a.id === b.id;\n\t   *     }\n\t   *   };\n\t   * });\n\t   *\n\t   * // In a config() block, you can then attach URLs with\n\t   * // type-annotated parameters:\n\t   * $stateProvider.state('users', {\n\t   *   url: \"/users\",\n\t   *   // ...\n\t   * }).state('users.item', {\n\t   *   url: \"/{user:dbObject}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     // $stateParams.user will now be an object returned from\n\t   *     // the Users service\n\t   *   },\n\t   *   // ...\n\t   * });\n\t   * </pre>\n\t   */\n\t  this.type = function (name, definition, definitionFn) {\n\t    if (!isDefined(definition)) return $types[name];\n\t    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t\n\t    $types[name] = new Type(extend({ name: name }, definition));\n\t    if (definitionFn) {\n\t      typeQueue.push({ name: name, def: definitionFn });\n\t      if (!enqueue) flushTypeQueue();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n\t  function flushTypeQueue() {\n\t    while(typeQueue.length) {\n\t      var type = typeQueue.shift();\n\t      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t      angular.extend($types[type.name], injector.invoke(type.def));\n\t    }\n\t  }\n\t\n\t  // Register default types. Store them in the prototype of $types.\n\t  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n\t  $types = inherit($types, {});\n\t\n\t  /* No need to document $get, since it returns this */\n\t  this.$get = ['$injector', function ($injector) {\n\t    injector = $injector;\n\t    enqueue = false;\n\t    flushTypeQueue();\n\t\n\t    forEach(defaultTypes, function(type, name) {\n\t      if (!$types[name]) $types[name] = new Type(type);\n\t    });\n\t    return this;\n\t  }];\n\t\n\t  this.Param = function Param(id, type, config, location) {\n\t    var self = this;\n\t    config = unwrapShorthand(config);\n\t    type = getType(config, type, location);\n\t    var arrayMode = getArrayMode();\n\t    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n\t    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n\t      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n\t    var isOptional = config.value !== undefined;\n\t    var squash = getSquashPolicy(config, isOptional);\n\t    var replace = getReplace(config, arrayMode, isOptional, squash);\n\t\n\t    function unwrapShorthand(config) {\n\t      var keys = isObject(config) ? objectKeys(config) : [];\n\t      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n\t                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n\t      if (isShorthand) config = { value: config };\n\t      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n\t      return config;\n\t    }\n\t\n\t    function getType(config, urlType, location) {\n\t      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n\t      if (urlType) return urlType;\n\t      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\t\n\t      if (angular.isString(config.type))\n\t        return $types[config.type];\n\t      if (config.type instanceof Type)\n\t        return config.type;\n\t      return new Type(config.type);\n\t    }\n\t\n\t    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t    function getArrayMode() {\n\t      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n\t      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t    }\n\t\n\t    /**\n\t     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t     */\n\t    function getSquashPolicy(config, isOptional) {\n\t      var squash = config.squash;\n\t      if (!isOptional || squash === false) return false;\n\t      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n\t      if (squash === true || isString(squash)) return squash;\n\t      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t    }\n\t\n\t    function getReplace(config, arrayMode, isOptional, squash) {\n\t      var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t      ];\n\t      replace = isArray(config.replace) ? config.replace : [];\n\t      if (isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t      configuredKeys = map(replace, function(item) { return item.from; } );\n\t      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n\t    }\n\t\n\t    /**\n\t     * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t     */\n\t    function $$getDefaultValue() {\n\t      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t      var defaultValue = injector.invoke(config.$$fn);\n\t      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n\t        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n\t      return defaultValue;\n\t    }\n\t\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    function $value(value) {\n\t      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n\t      function $replace(value) {\n\t        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n\t        return replacement.length ? replacement[0] : value;\n\t      }\n\t      value = $replace(value);\n\t      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n\t    }\n\t\n\t    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\t\n\t    extend(this, {\n\t      id: id,\n\t      type: type,\n\t      location: location,\n\t      array: arrayMode,\n\t      squash: squash,\n\t      replace: replace,\n\t      isOptional: isOptional,\n\t      value: $value,\n\t      dynamic: undefined,\n\t      config: config,\n\t      toString: toString\n\t    });\n\t  };\n\t\n\t  function ParamSet(params) {\n\t    extend(this, params || {});\n\t  }\n\t\n\t  ParamSet.prototype = {\n\t    $$new: function() {\n\t      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n\t    },\n\t    $$keys: function () {\n\t      var keys = [], chain = [], parent = this,\n\t        ignore = objectKeys(ParamSet.prototype);\n\t      while (parent) { chain.push(parent); parent = parent.$$parent; }\n\t      chain.reverse();\n\t      forEach(chain, function(paramset) {\n\t        forEach(objectKeys(paramset), function(key) {\n\t            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n\t        });\n\t      });\n\t      return keys;\n\t    },\n\t    $$values: function(paramValues) {\n\t      var values = {}, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        values[key] = self[key].value(paramValues && paramValues[key]);\n\t      });\n\t      return values;\n\t    },\n\t    $$equals: function(paramValues1, paramValues2) {\n\t      var equal = true, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n\t        if (!self[key].type.equals(left, right)) equal = false;\n\t      });\n\t      return equal;\n\t    },\n\t    $$validates: function $$validate(paramValues) {\n\t      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n\t      for (i = 0; i < keys.length; i++) {\n\t        param = this[keys[i]];\n\t        rawVal = paramValues[keys[i]];\n\t        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n\t          break; // There was no parameter value, but the param is optional\n\t        normalized = param.type.$normalize(rawVal);\n\t        if (!param.type.is(normalized))\n\t          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n\t        encoded = param.type.encode(normalized);\n\t        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n\t          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t      }\n\t      return true;\n\t    },\n\t    $$parent: undefined\n\t  };\n\t\n\t  this.ParamSet = ParamSet;\n\t}\n\t\n\t// Register as a provider so it's available to other providers\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\tangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`. \n\t * When `$location` changes it runs through a list of rules one by one until a \n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\t$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n\tfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n\t  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\t\n\t  // Returns a string that is a prefix of all strings matching the RegExp\n\t  function regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t  }\n\t\n\t  // Interpolates matched values into a String.replace()-style pattern\n\t  function interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t      return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#rule\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t   * specific URLs.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // Here's an example of how you might allow case insensitive urls\n\t   *   $urlRouterProvider.rule(function ($injector, $location) {\n\t   *     var path = $location.path(),\n\t   *         normalized = path.toLowerCase();\n\t   *\n\t   *     if (path !== normalized) {\n\t   *       return normalized;\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {function} rule Handler function that takes `$injector` and `$location`\n\t   * services as arguments. You can use them to return a valid path as a string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.rule = function (rule) {\n\t    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    rules.push(rule);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouterProvider#otherwise\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines a path that is used when an invalid route is requested.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // if the path doesn't match any of the urls you configured\n\t   *   // otherwise will take care of routing the user to the\n\t   *   // specified url\n\t   *   $urlRouterProvider.otherwise('/index');\n\t   *\n\t   *   // Example of using function rule as param\n\t   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t   *     return '/a/valid/url';\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|function} rule The url path you want to redirect to or a function \n\t   * rule that returns the url path. The function version is passed two params: \n\t   * `$injector` and `$location` services, and must return a url string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.otherwise = function (rule) {\n\t    if (isString(rule)) {\n\t      var redirect = rule;\n\t      rule = function () { return redirect; };\n\t    }\n\t    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    otherwise = rule;\n\t    return this;\n\t  };\n\t\n\t\n\t  function handleIfMatch($injector, handler, match) {\n\t    if (!match) return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match });\n\t    return isDefined(result) ? result : true;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#when\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Registers a handler for a given url matching. \n\t   * \n\t   * If the handler is a string, it is\n\t   * treated as a redirect, and is interpolated according to the syntax of match\n\t   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t   *\n\t   * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t   * matches. You have the option of inject the match object as `$match`.\n\t   *\n\t   * The handler can return\n\t   *\n\t   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t   *   will continue trying to find another one that matches.\n\t   * - **string** which is treated as a redirect and passed to `$location.url()`\n\t   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t   *     if ($state.$current.navigable !== state ||\n\t   *         !equalForKeys($match, $stateParams) {\n\t   *      $state.transitionTo(state, $match, false);\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} what The incoming path that you want to redirect.\n\t   * @param {string|function} handler The path you want to redirect your user to.\n\t   */\n\t  this.when = function (what, handler) {\n\t    var redirect, handlerIsString = isString(handler);\n\t    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\t\n\t    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n\t      throw new Error(\"invalid 'handler' in when()\");\n\t\n\t    var strategies = {\n\t      matcher: function (what, handler) {\n\t        if (handlerIsString) {\n\t          redirect = $urlMatcherFactory.compile(handler);\n\t          handler = ['$match', function ($match) { return redirect.format($match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n\t        }, {\n\t          prefix: isString(what.prefix) ? what.prefix : ''\n\t        });\n\t      },\n\t      regex: function (what, handler) {\n\t        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\t\n\t        if (handlerIsString) {\n\t          redirect = handler;\n\t          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path()));\n\t        }, {\n\t          prefix: regExpPrefix(what)\n\t        });\n\t      }\n\t    };\n\t\n\t    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\t\n\t    for (var n in check) {\n\t      if (check[n]) return this.rule(strategies[n](what, handler));\n\t    }\n\t\n\t    throw new Error(\"invalid 'what' in when()\");\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Disables (or enables) deferring location change interception.\n\t   *\n\t   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t   * defer a transition but maintain the current URL), call this method at configuration time.\n\t   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t   * `$locationChangeSuccess` event handler.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *\n\t   *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t   *   // this allows you to configure custom behavior in between\n\t   *   // location changes and route synchronization:\n\t   *   $urlRouterProvider.deferIntercept();\n\t   *\n\t   * }).run(function ($rootScope, $urlRouter, UserService) {\n\t   *\n\t   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t   *     // UserService is an example service for managing user state\n\t   *     if (UserService.isLoggedIn()) return;\n\t   *\n\t   *     // Prevent $urlRouter's default handler from firing\n\t   *     e.preventDefault();\n\t   *\n\t   *     UserService.handleLogin().then(function() {\n\t   *       // Once the user has logged in, sync the current URL\n\t   *       // to the router:\n\t   *       $urlRouter.sync();\n\t   *     });\n\t   *   });\n\t   *\n\t   *   // Configures $urlRouter's listener *after* your custom listener\n\t   *   $urlRouter.listen();\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t            no parameter is equivalent to `true`.\n\t   */\n\t  this.deferIntercept = function (defer) {\n\t    if (defer === undefined) defer = true;\n\t    interceptDeferred = defer;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouter\n\t   *\n\t   * @requires $location\n\t   * @requires $rootScope\n\t   * @requires $injector\n\t   * @requires $browser\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n\t  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\t\n\t    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\t\n\t    function appendBasePath(url, isHtml5, absolute) {\n\t      if (baseHref === '/') return url;\n\t      if (isHtml5) return baseHref.slice(0, -1) + url;\n\t      if (absolute) return baseHref.slice(1) + url;\n\t      return url;\n\t    }\n\t\n\t    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t    function update(evt) {\n\t      if (evt && evt.defaultPrevented) return;\n\t      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n\t      lastPushedUrl = undefined;\n\t      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n\t      //if (ignoreUpdate) return true;\n\t\n\t      function check(rule) {\n\t        var handled = rule($injector, $location);\n\t\n\t        if (!handled) return false;\n\t        if (isString(handled)) $location.replace().url(handled);\n\t        return true;\n\t      }\n\t      var n = rules.length, i;\n\t\n\t      for (i = 0; i < n; i++) {\n\t        if (check(rules[i])) return;\n\t      }\n\t      // always check otherwise last to allow dynamic updates to the set of rules\n\t      if (otherwise) check(otherwise);\n\t    }\n\t\n\t    function listen() {\n\t      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n\t      return listener;\n\t    }\n\t\n\t    if (!interceptDeferred) listen();\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#sync\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t       * with the transition by calling `$urlRouter.sync()`.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * angular.module('app', ['ui.router'])\n\t       *   .run(function($rootScope, $urlRouter) {\n\t       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t       *       // Halt state change from even starting\n\t       *       evt.preventDefault();\n\t       *       // Perform custom logic\n\t       *       var meetsRequirement = ...\n\t       *       // Continue with the update and state transition if logic allows\n\t       *       if (meetsRequirement) $urlRouter.sync();\n\t       *     });\n\t       * });\n\t       * </pre>\n\t       */\n\t      sync: function() {\n\t        update();\n\t      },\n\t\n\t      listen: function() {\n\t        return listen();\n\t      },\n\t\n\t      update: function(read) {\n\t        if (read) {\n\t          location = $location.url();\n\t          return;\n\t        }\n\t        if ($location.url() === location) return;\n\t\n\t        $location.url(location);\n\t        $location.replace();\n\t      },\n\t\n\t      push: function(urlMatcher, params, options) {\n\t         var url = urlMatcher.format(params || {});\n\t\n\t        // Handle the special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t            url += '#' + params['#'];\n\t        }\n\t\n\t        $location.url(url);\n\t        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n\t        if (options && options.replace) $location.replace();\n\t      },\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#href\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * A URL generation method that returns the compiled URL for a given\n\t       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t       *   person: \"bob\"\n\t       * });\n\t       * // $bob == \"/about/bob\";\n\t       * </pre>\n\t       *\n\t       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t       * @param {object=} options Options object. The options are:\n\t       *\n\t       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t       *\n\t       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t       */\n\t      href: function(urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params)) return null;\n\t\n\t        var isHtml5 = $locationProvider.html5Mode();\n\t        if (angular.isObject(isHtml5)) {\n\t          isHtml5 = isHtml5.enabled;\n\t        }\n\t\n\t        isHtml5 = isHtml5 && $sniffer.history;\n\t        \n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t\n\t        if (!isHtml5 && url !== null) {\n\t          url = \"#\" + $locationProvider.hashPrefix() + url;\n\t        }\n\t\n\t        // Handle special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t          url += '#' + params['#'];\n\t        }\n\t\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\n\t        if (!options.absolute || !url) {\n\t          return url;\n\t        }\n\t\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\n\t        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\t$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n\tfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\t\n\t  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\t\n\t  // Builds state properties from definition passed to registerState()\n\t  var stateBuilder = {\n\t\n\t    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n\t    // state.children = [];\n\t    // if (parent) parent.children.push(state);\n\t    parent: function(state) {\n\t      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n\t      // regex matches any valid composite state name\n\t      // would match \"contact.list\" but not \"contacts\"\n\t      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n\t      return compositeName ? findState(compositeName[1]) : root;\n\t    },\n\t\n\t    // inherit 'data' from parent and override by own values (if any)\n\t    data: function(state) {\n\t      if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = inherit(state.parent.data, state.data);\n\t      }\n\t      return state.data;\n\t    },\n\t\n\t    // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t    url: function(state) {\n\t      var url = state.url, config = { params: state.params || {} };\n\t\n\t      if (isString(url)) {\n\t        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n\t        return (state.parent.navigable || root).url.concat(url, config);\n\t      }\n\t\n\t      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n\t      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t    },\n\t\n\t    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t    navigable: function(state) {\n\t      return state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    },\n\t\n\t    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n\t    ownParams: function(state) {\n\t      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n\t      forEach(state.params || {}, function(config, id) {\n\t        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n\t      });\n\t      return params;\n\t    },\n\t\n\t    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n\t    params: function(state) {\n\t      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n\t      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n\t    },\n\t\n\t    // If there is no explicit multi-view configuration, make one up so we don't have\n\t    // to handle both cases in the view directive later. Note that having an explicit\n\t    // 'views' property will mean the default unnamed view properties are ignored. This\n\t    // is also a good time to resolve view names to absolute names, so everything is a\n\t    // straight lookup at link time.\n\t    views: function(state) {\n\t      var views = {};\n\t\n\t      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n\t        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n\t        views[name] = view;\n\t      });\n\t      return views;\n\t    },\n\t\n\t    // Keep a full path from the root down to this state as this is needed for state activation.\n\t    path: function(state) {\n\t      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n\t    },\n\t\n\t    // Speed up $state.contains() as it's used a lot\n\t    includes: function(state) {\n\t      var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t      includes[state.name] = true;\n\t      return includes;\n\t    },\n\t\n\t    $delegates: {}\n\t  };\n\t\n\t  function isRelative(stateName) {\n\t    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t  }\n\t\n\t  function findState(stateOrName, base) {\n\t    if (!stateOrName) return undefined;\n\t\n\t    var isStr = isString(stateOrName),\n\t        name  = isStr ? stateOrName : stateOrName.name,\n\t        path  = isRelative(name);\n\t\n\t    if (path) {\n\t      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n\t      base = findState(base);\n\t      \n\t      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\t\n\t      for (; i < pathLength; i++) {\n\t        if (rel[i] === \"\" && i === 0) {\n\t          current = base;\n\t          continue;\n\t        }\n\t        if (rel[i] === \"^\") {\n\t          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n\t          current = current.parent;\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t      rel = rel.slice(i).join(\".\");\n\t      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n\t    }\n\t    var state = states[name];\n\t\n\t    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t      return state;\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function queueState(parentName, state) {\n\t    if (!queue[parentName]) {\n\t      queue[parentName] = [];\n\t    }\n\t    queue[parentName].push(state);\n\t  }\n\t\n\t  function flushQueuedChildren(parentName) {\n\t    var queued = queue[parentName] || [];\n\t    while(queued.length) {\n\t      registerState(queued.shift());\n\t    }\n\t  }\n\t\n\t  function registerState(state) {\n\t    // Wrap a new object around the state so we can store our private details easily.\n\t    state = inherit(state, {\n\t      self: state,\n\t      resolve: state.resolve || {},\n\t      toString: function() { return this.name; }\n\t    });\n\t\n\t    var name = state.name;\n\t    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n\t    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\t\n\t    // Get parent name\n\t    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n\t        : (isString(state.parent)) ? state.parent\n\t        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n\t        : '';\n\t\n\t    // If parent is not registered yet, add state to queue and register later\n\t    if (parentName && !states[parentName]) {\n\t      return queueState(parentName, state.self);\n\t    }\n\t\n\t    for (var key in stateBuilder) {\n\t      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n\t    }\n\t    states[name] = state;\n\t\n\t    // Register the state in the global state list and with $urlRouter if necessary.\n\t    if (!state[abstractKey] && state.url) {\n\t      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n\t          $state.transitionTo(state, $match, { inherit: true, location: false });\n\t        }\n\t      }]);\n\t    }\n\t\n\t    // Register any queued children\n\t    flushQueuedChildren(name);\n\t\n\t    return state;\n\t  }\n\t\n\t  // Checks text to see if it looks like a glob.\n\t  function isGlob (text) {\n\t    return text.indexOf('*') > -1;\n\t  }\n\t\n\t  // Returns true if glob matches current $state name.\n\t  function doesStateMatchGlob (glob) {\n\t    var globSegments = glob.split('.'),\n\t        segments = $state.$current.name.split('.');\n\t\n\t    //match single stars\n\t    for (var i = 0, l = globSegments.length; i < l; i++) {\n\t      if (globSegments[i] === '*') {\n\t        segments[i] = '*';\n\t      }\n\t    }\n\t\n\t    //match greedy starts\n\t    if (globSegments[0] === '**') {\n\t       segments = segments.slice(indexOf(segments, globSegments[1]));\n\t       segments.unshift('**');\n\t    }\n\t    //match greedy ends\n\t    if (globSegments[globSegments.length - 1] === '**') {\n\t       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n\t       segments.push('**');\n\t    }\n\t\n\t    if (globSegments.length != segments.length) {\n\t      return false;\n\t    }\n\t\n\t    return segments.join('') === globSegments.join('');\n\t  }\n\t\n\t\n\t  // Implicit root state that is always active\n\t  root = registerState({\n\t    name: '',\n\t    url: '^',\n\t    views: null,\n\t    'abstract': true\n\t  });\n\t  root.navigable = null;\n\t\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#decorator\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Allows you to extend (carefully) or override (at your own peril) the \n\t   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n\t   * to add custom functionality to ui-router, for example inferring templateUrl \n\t   * based on the state name.\n\t   *\n\t   * When passing only a name, it returns the current (original or decorated) builder\n\t   * function that matches `name`.\n\t   *\n\t   * The builder functions that can be decorated are listed below. Though not all\n\t   * necessarily have a good use case for decoration, that is up to you to decide.\n\t   *\n\t   * In addition, users can attach custom decorators, which will generate new \n\t   * properties within the state's internal definition. There is currently no clear \n\t   * use-case for this beyond accessing internal states (i.e. $state.$current), \n\t   * however, expect this to become increasingly relevant as we introduce additional \n\t   * meta-programming features.\n\t   *\n\t   * **Warning**: Decorators should not be interdependent because the order of \n\t   * execution of the builder functions in non-deterministic. Builder functions \n\t   * should only be dependent on the state definition object and super function.\n\t   *\n\t   *\n\t   * Existing builder functions and current return values:\n\t   *\n\t   * - **parent** `{object}` - returns the parent state object.\n\t   * - **data** `{object}` - returns state data, including any inherited data that is not\n\t   *   overridden by own values (if any).\n\t   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t   *   or `null`.\n\t   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n\t   *   navigable).\n\t   * - **params** `{object}` - returns an array of state params that are ensured to \n\t   *   be a super-set of parent's params.\n\t   * - **views** `{object}` - returns a views object where each key is an absolute view \n\t   *   name (i.e. \"viewName@stateName\") and each value is the config object \n\t   *   (template, controller) for the view. Even when you don't use the views object \n\t   *   explicitly on a state config, one is still created for you internally.\n\t   *   So by decorating this builder function you have access to decorating template \n\t   *   and controller properties.\n\t   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n\t   *   not including any params defined by ancestor states.\n\t   * - **path** `{string}` - returns the full path from the root down to this state. \n\t   *   Needed for state activation.\n\t   * - **includes** `{object}` - returns an object that includes every state that \n\t   *   would pass a `$state.includes()` test.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Override the internal 'views' builder with a function that takes the state\n\t   * // definition, and a reference to the internal function being overridden:\n\t   * $stateProvider.decorator('views', function (state, parent) {\n\t   *   var result = {},\n\t   *       views = parent(state);\n\t   *\n\t   *   angular.forEach(views, function (config, name) {\n\t   *     var autoName = (state.name + '.' + name).replace('.', '/');\n\t   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t   *     result[name] = config;\n\t   *   });\n\t   *   return result;\n\t   * });\n\t   *\n\t   * $stateProvider.state('home', {\n\t   *   views: {\n\t   *     'contact.list': { controller: 'ListController' },\n\t   *     'contact.item': { controller: 'ItemController' }\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * $state.go('home');\n\t   * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t   * // and /partials/home/contact/item.html, respectively.\n\t   * </pre>\n\t   *\n\t   * @param {string} name The name of the builder function to decorate. \n\t   * @param {object} func A function that is responsible for decorating the original \n\t   * builder function. The function receives two parameters:\n\t   *\n\t   *   - `{object}` - state - The state config object.\n\t   *   - `{object}` - super - The original builder function.\n\t   *\n\t   * @return {object} $stateProvider - $stateProvider instance\n\t   */\n\t  this.decorator = decorator;\n\t  function decorator(name, func) {\n\t    /*jshint validthis: true */\n\t    if (isString(name) && !isDefined(func)) {\n\t      return stateBuilder[name];\n\t    }\n\t    if (!isFunction(func) || !isString(name)) {\n\t      return this;\n\t    }\n\t    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n\t      stateBuilder.$delegates[name] = stateBuilder[name];\n\t    }\n\t    stateBuilder[name] = func;\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#state\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Registers a state configuration under a given state name. The stateConfig object\n\t   * has the following acceptable properties.\n\t   *\n\t   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t   * @param {object} stateConfig State configuration object.\n\t   * @param {string|function=} stateConfig.template\n\t   * <a id='template'></a>\n\t   *   html template as a string or a function that returns\n\t   *   an html template as a string which should be used by the uiView directives. This property \n\t   *   takes precedence over templateUrl.\n\t   *   \n\t   *   If `template` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t   *     applying the current state\n\t   *\n\t   * <pre>template:\n\t   *   \"<h1>inline template definition</h1>\" +\n\t   *   \"<div ui-view></div>\"</pre>\n\t   * <pre>template: function(params) {\n\t   *       return \"<h1>generated template</h1>\"; }</pre>\n\t   * </div>\n\t   *\n\t   * @param {string|function=} stateConfig.templateUrl\n\t   * <a id='templateUrl'></a>\n\t   *\n\t   *   path or function that returns a path to an html\n\t   *   template that should be used by uiView.\n\t   *   \n\t   *   If `templateUrl` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n\t   *     applying the current state\n\t   *\n\t   * <pre>templateUrl: \"home.html\"</pre>\n\t   * <pre>templateUrl: function(params) {\n\t   *     return myTemplates[params.pageId]; }</pre>\n\t   *\n\t   * @param {function=} stateConfig.templateProvider\n\t   * <a id='templateProvider'></a>\n\t   *    Provider function that returns HTML content string.\n\t   * <pre> templateProvider:\n\t   *       function(MyTemplateService, params) {\n\t   *         return MyTemplateService.getTemplate(params.pageId);\n\t   *       }</pre>\n\t   *\n\t   * @param {string|function=} stateConfig.controller\n\t   * <a id='controller'></a>\n\t   *\n\t   *  Controller fn that should be associated with newly\n\t   *   related scope or the name of a registered controller if passed as a string.\n\t   *   Optionally, the ControllerAs may be declared here.\n\t   * <pre>controller: \"MyRegisteredController\"</pre>\n\t   * <pre>controller:\n\t   *     \"MyRegisteredController as fooCtrl\"}</pre>\n\t   * <pre>controller: function($scope, MyService) {\n\t   *     $scope.data = MyService.getData(); }</pre>\n\t   *\n\t   * @param {function=} stateConfig.controllerProvider\n\t   * <a id='controllerProvider'></a>\n\t   *\n\t   * Injectable provider function that returns the actual controller or string.\n\t   * <pre>controllerProvider:\n\t   *   function(MyResolveData) {\n\t   *     if (MyResolveData.foo)\n\t   *       return \"FooCtrl\"\n\t   *     else if (MyResolveData.bar)\n\t   *       return \"BarCtrl\";\n\t   *     else return function($scope) {\n\t   *       $scope.baz = \"Qux\";\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {string=} stateConfig.controllerAs\n\t   * <a id='controllerAs'></a>\n\t   * \n\t   * A controller alias name. If present the controller will be\n\t   *   published to scope under the controllerAs name.\n\t   * <pre>controllerAs: \"myCtrl\"</pre>\n\t   *\n\t   * @param {string|object=} stateConfig.parent\n\t   * <a id='parent'></a>\n\t   * Optionally specifies the parent state of this state.\n\t   *\n\t   * <pre>parent: 'parentState'</pre>\n\t   * <pre>parent: parentState // JS variable</pre>\n\t   *\n\t   * @param {object=} stateConfig.resolve\n\t   * <a id='resolve'></a>\n\t   *\n\t   * An optional map&lt;string, function&gt; of dependencies which\n\t   *   should be injected into the controller. If any of these dependencies are promises, \n\t   *   the router will wait for them all to be resolved before the controller is instantiated.\n\t   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n\t   *   and the values of the resolved promises are injected into any controllers that reference them.\n\t   *   If any  of the promises are rejected the $stateChangeError event is fired.\n\t   *\n\t   *   The map object is:\n\t   *   \n\t   *   - key - {string}: name of dependency to be injected into controller\n\t   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n\t   *     it is injected and return value it treated as dependency. If result is a promise, it is \n\t   *     resolved before its value is injected into controller.\n\t   *\n\t   * <pre>resolve: {\n\t   *     myResolve1:\n\t   *       function($http, $stateParams) {\n\t   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n\t   *       }\n\t   *     }</pre>\n\t   *\n\t   * @param {string=} stateConfig.url\n\t   * <a id='url'></a>\n\t   *\n\t   *   A url fragment with optional parameters. When a state is navigated or\n\t   *   transitioned to, the `$stateParams` service will be populated with any \n\t   *   parameters that were passed.\n\t   *\n\t   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n\t   *   more details on acceptable patterns )\n\t   *\n\t   * examples:\n\t   * <pre>url: \"/home\"\n\t   * url: \"/users/:userid\"\n\t   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n\t   * url: \"/books/{categoryid:int}\"\n\t   * url: \"/books/{publishername:string}/{categoryid:int}\"\n\t   * url: \"/messages?before&after\"\n\t   * url: \"/messages?{before:date}&{after:date}\"\n\t   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n\t   * </pre>\n\t   *\n\t   * @param {object=} stateConfig.views\n\t   * <a id='views'></a>\n\t   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n\t   * manually/explicitly.\n\t   *\n\t   * Examples:\n\t   *\n\t   * Targets three named `ui-view`s in the parent state's template\n\t   * <pre>views: {\n\t   *     header: {\n\t   *       controller: \"headerCtrl\",\n\t   *       templateUrl: \"header.html\"\n\t   *     }, body: {\n\t   *       controller: \"bodyCtrl\",\n\t   *       templateUrl: \"body.html\"\n\t   *     }, footer: {\n\t   *       controller: \"footCtrl\",\n\t   *       templateUrl: \"footer.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n\t   * <pre>views: {\n\t   *     'header@top': {\n\t   *       controller: \"msgHeaderCtrl\",\n\t   *       templateUrl: \"msgHeader.html\"\n\t   *     }, 'body': {\n\t   *       controller: \"messagesCtrl\",\n\t   *       templateUrl: \"messages.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.abstract=false]\n\t   * <a id='abstract'></a>\n\t   * An abstract state will never be directly activated,\n\t   *   but can provide inherited properties to its common children states.\n\t   * <pre>abstract: true</pre>\n\t   *\n\t   * @param {function=} stateConfig.onEnter\n\t   * <a id='onEnter'></a>\n\t   *\n\t   * Callback function for when a state is entered. Good way\n\t   *   to trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onEnter: function(MyService, $stateParams) {\n\t   *     MyService.foo($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {function=} stateConfig.onExit\n\t   * <a id='onExit'></a>\n\t   *\n\t   * Callback function for when a state is exited. Good way to\n\t   *   trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onExit: function(MyService, $stateParams) {\n\t   *     MyService.cleanup($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n\t   * <a id='reloadOnSearch'></a>\n\t   *\n\t   * If `false`, will not retrigger the same state\n\t   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n\t   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t   * <pre>reloadOnSearch: false</pre>\n\t   *\n\t   * @param {object=} stateConfig.data\n\t   * <a id='data'></a>\n\t   *\n\t   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n\t   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n\t   *   the entire subtree via prototypal inheritance.\n\t   *\n\t   * <pre>data: {\n\t   *     requiredRole: 'foo'\n\t   * } </pre>\n\t   *\n\t   * @param {object=} stateConfig.params\n\t   * <a id='params'></a>\n\t   *\n\t   * A map which optionally configures parameters declared in the `url`, or\n\t   *   defines additional non-url parameters.  For each parameter being\n\t   *   configured, add a configuration object keyed to the name of the parameter.\n\t   *\n\t   *   Each parameter configuration object may contain the following properties:\n\t   *\n\t   *   - ** value ** - {object|function=}: specifies the default value for this\n\t   *     parameter.  This implicitly sets this parameter as optional.\n\t   *\n\t   *     When UI-Router routes to a state and no value is\n\t   *     specified for this parameter in the URL or transition, the\n\t   *     default value will be used instead.  If `value` is a function,\n\t   *     it will be injected and invoked, and the return value used.\n\t   *\n\t   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n\t   *     is treated as \"the default value is `null`\".\n\t   *\n\t   *     *Shorthand*: If you only need to configure the default value of the\n\t   *     parameter, you may use a shorthand syntax.   In the **`params`**\n\t   *     map, instead mapping the param name to a full parameter configuration\n\t   *     object, simply set map it to the default parameter value, e.g.:\n\t   *\n\t   * <pre>// define a parameter's default value\n\t   * params: {\n\t   *     param1: { value: \"defaultValue\" }\n\t   * }\n\t   * // shorthand default values\n\t   * params: {\n\t   *     param1: \"defaultValue\",\n\t   *     param2: \"param2Default\"\n\t   * }</pre>\n\t   *\n\t   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n\t   *     treated as an array of values.  If you specified a Type, the value will be\n\t   *     treated as an array of the specified Type.  Note: query parameter values\n\t   *     default to a special `\"auto\"` mode.\n\t   *\n\t   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n\t   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n\t   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n\t   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n\t   *     value (e.g.: `{ foo: '1' }`).\n\t   *\n\t   * <pre>params: {\n\t   *     param1: { array: true }\n\t   * }</pre>\n\t   *\n\t   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n\t   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n\t   *     configured default squash policy.\n\t   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n\t   *\n\t   *   There are three squash settings:\n\t   *\n\t   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n\t   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n\t   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n\t   *       This can allow for cleaner looking URLs.\n\t   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n\t   *\n\t   * <pre>params: {\n\t   *     param1: {\n\t   *       value: \"defaultId\",\n\t   *       squash: true\n\t   * } }\n\t   * // squash \"defaultValue\" to \"~\"\n\t   * params: {\n\t   *     param1: {\n\t   *       value: \"defaultValue\",\n\t   *       squash: \"~\"\n\t   * } }\n\t   * </pre>\n\t   *\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Some state name examples\n\t   *\n\t   * // stateName can be a single top-level name (must be unique).\n\t   * $stateProvider.state(\"home\", {});\n\t   *\n\t   * // Or it can be a nested state name. This state is a child of the\n\t   * // above \"home\" state.\n\t   * $stateProvider.state(\"home.newest\", {});\n\t   *\n\t   * // Nest states as deeply as needed.\n\t   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t   *\n\t   * // state() returns $stateProvider, so you can chain state declarations.\n\t   * $stateProvider\n\t   *   .state(\"home\", {})\n\t   *   .state(\"about\", {})\n\t   *   .state(\"contacts\", {});\n\t   * </pre>\n\t   *\n\t   */\n\t  this.state = state;\n\t  function state(name, definition) {\n\t    /*jshint validthis: true */\n\t    if (isObject(name)) definition = name;\n\t    else definition.name = name;\n\t    registerState(definition);\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$state\n\t   *\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires ui.router.state.$view\n\t   * @requires $injector\n\t   * @requires ui.router.util.$resolve\n\t   * @requires ui.router.state.$stateParams\n\t   * @requires ui.router.router.$urlRouter\n\t   *\n\t   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n\t   * you'd like to test against the current active state.\n\t   * @property {object} current A reference to the state's config object. However \n\t   * you passed it in. Useful for accessing custom data.\n\t   * @property {object} transition Currently pending transition. A promise that'll \n\t   * resolve or reject.\n\t   *\n\t   * @description\n\t   * `$state` service is responsible for representing states as well as transitioning\n\t   * between them. It also provides interfaces to ask for current state or even states\n\t   * you're coming from.\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n\t  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\t\n\t    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n\t    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n\t    var TransitionAborted = $q.reject(new Error('transition aborted'));\n\t    var TransitionFailed = $q.reject(new Error('transition failed'));\n\t\n\t    // Handles the case where a state which is the target of a transition is not found, and the user\n\t    // can optionally retry or defer the transition\n\t    function handleRedirect(redirect, state, params, options) {\n\t      /**\n\t       * @ngdoc event\n\t       * @name ui.router.state.$state#$stateNotFound\n\t       * @eventOf ui.router.state.$state\n\t       * @eventType broadcast on root scope\n\t       * @description\n\t       * Fired when a requested state **cannot be found** using the provided state name during transition.\n\t       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n\t       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n\t       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n\t       *\n\t       * @param {Object} event Event object.\n\t       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n\t       * @param {State} fromState Current state object.\n\t       * @param {Object} fromParams Current state params.\n\t       *\n\t       * @example\n\t       *\n\t       * <pre>\n\t       * // somewhere, assume lazy.state has not been defined\n\t       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n\t       *\n\t       * // somewhere else\n\t       * $scope.$on('$stateNotFound',\n\t       * function(event, unfoundState, fromState, fromParams){\n\t       *     console.log(unfoundState.to); // \"lazy.state\"\n\t       *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t       *     console.log(unfoundState.options); // {inherit:false} + default options\n\t       * })\n\t       * </pre>\n\t       */\n\t      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\t\n\t      if (evt.defaultPrevented) {\n\t        $urlRouter.update();\n\t        return TransitionAborted;\n\t      }\n\t\n\t      if (!evt.retry) {\n\t        return null;\n\t      }\n\t\n\t      // Allow the handler to return a promise to defer state lookup retry\n\t      if (options.$retry) {\n\t        $urlRouter.update();\n\t        return TransitionFailed;\n\t      }\n\t      var retryTransition = $state.transition = $q.when(evt.retry);\n\t\n\t      retryTransition.then(function() {\n\t        if (retryTransition !== $state.transition) return TransitionSuperseded;\n\t        redirect.options.$retry = true;\n\t        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n\t      }, function() {\n\t        return TransitionAborted;\n\t      });\n\t      $urlRouter.update();\n\t\n\t      return retryTransition;\n\t    }\n\t\n\t    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\t\n\t    $state = {\n\t      params: {},\n\t      current: root.self,\n\t      $current: root,\n\t      transition: null\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state. All resolves are re-resolved,\n\t     * controllers reinstantiated, and events re-fired.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t     * @example\n\t     * <pre>\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n\t     * //and current state is 'contacts.detail.item'\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.reload = function reload(state) {\n\t      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls \n\t     * `$state.transitionTo` internally but automatically sets options to \n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n\t     * This allows you to easily use an absolute or relative to path and specify \n\t     * only the parameters you'd like to update (while letting unspecified parameters \n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state, \n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n\t     * defined parameters. Only parameters specified in the state definition can be overridden, new \n\t     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n\t     *    have changed.  It will reload the resolves and views of the current state and parent states.\n\t     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n\t     *    the transition reloads the resolves and views for that matched state, and all its children states.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    $state.go = function go(to, params, options) {\n\t      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *    if String, then will reload the state with the name given in reload, and any children.\n\t     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.transitionTo = function transitionTo(to, toParams, options) {\n\t      toParams = toParams || {};\n\t      options = extend({\n\t        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n\t      }, options || {});\n\t\n\t      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n\t      var evt, toState = findState(to, options.relative);\n\t\n\t      // Store the hash param for later (since it will be stripped out by various methods)\n\t      var hash = toParams['#'];\n\t\n\t      if (!isDefined(toState)) {\n\t        var redirect = { to: to, toParams: toParams, options: options };\n\t        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\t\n\t        if (redirectResult) {\n\t          return redirectResult;\n\t        }\n\t\n\t        // Always retry once if the $stateNotFound was not prevented\n\t        // (handles either redirect changed or state lazy-definition)\n\t        to = redirect.to;\n\t        toParams = redirect.toParams;\n\t        options = redirect.options;\n\t        toState = findState(to, options.relative);\n\t\n\t        if (!isDefined(toState)) {\n\t          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n\t          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n\t        }\n\t      }\n\t      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n\t      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n\t      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\t\n\t      toParams = toState.params.$$values(toParams);\n\t      to = toState;\n\t\n\t      var toPath = to.path;\n\t\n\t      // Starting from the root of the path, keep all levels that haven't changed\n\t      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\t\n\t      if (!options.reload) {\n\t        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      } else if (isString(options.reload) || isObject(options.reload)) {\n\t        if (isObject(options.reload) && !options.reload.name) {\n\t          throw new Error('Invalid reload state object');\n\t        }\n\t        \n\t        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n\t        if (options.reload && !reloadState) {\n\t          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        }\n\t\n\t        while (state && state === fromPath[keep] && state !== reloadState) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      }\n\t\n\t      // If we're going to the same state and all locals are kept, we've got nothing to do.\n\t      // But clear 'transition', as we still want to cancel any other pending transitions.\n\t      // TODO: We may not want to bump 'transition' if we're called from a location change\n\t      // that we've initiated ourselves, because we might accidentally abort a legitimate\n\t      // transition initiated from code?\n\t      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n\t        if (hash) toParams['#'] = hash;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n\t        if (options.location && to.navigable && to.navigable.url) {\n\t          $urlRouter.push(to.navigable.url, toParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t          $urlRouter.update(true);\n\t        }\n\t        $state.transition = null;\n\t        return $q.when($state.current);\n\t      }\n\t\n\t      // Filter parameters before we pass them to event handlers etc.\n\t      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\t      \n\t      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n\t      if (hash) toParams['#'] = hash;\n\t      \n\t      // Broadcast start event and cancel the transition if requested\n\t      if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeStart\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n\t         * to prevent the transition from happening and then the transition promise will be\n\t         * rejected with a `'transition prevented'` value.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $rootScope.$on('$stateChangeStart',\n\t         * function(event, toState, toParams, fromState, fromParams){\n\t         *     event.preventDefault();\n\t         *     // transitionTo() promise will be rejected with\n\t         *     // a 'transition prevented' error\n\t         * })\n\t         * </pre>\n\t         */\n\t        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n\t          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n\t          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n\t          if ($state.transition == null) $urlRouter.update();\n\t          return TransitionPrevented;\n\t        }\n\t      }\n\t\n\t      // Resolve locals for the remaining states, but don't update any global state just\n\t      // yet -- if anything fails to resolve the current state needs to remain untouched.\n\t      // We also set up an inheritance chain for the locals here. This allows the view directive\n\t      // to quickly look up the correct definition for each view in the current state. Even\n\t      // though we create the locals object itself outside resolveState(), it is initially\n\t      // empty and gets filled asynchronously. We need to keep track of the promise for the\n\t      // (fully resolved) current locals, and pass this down the chain.\n\t      var resolved = $q.when(locals);\n\t\n\t      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n\t        locals = toLocals[l] = inherit(locals);\n\t        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n\t      }\n\t\n\t      // Once everything is resolved, we are ready to perform the actual transition\n\t      // and return a promise for the new state. We also keep track of what the\n\t      // current promise is, so that we can detect overlapping transitions and\n\t      // keep only the outcome of the last transition.\n\t      var transition = $state.transition = resolved.then(function () {\n\t        var l, entering, exiting;\n\t\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Exit 'from' states not kept\n\t        for (l = fromPath.length - 1; l >= keep; l--) {\n\t          exiting = fromPath[l];\n\t          if (exiting.self.onExit) {\n\t            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n\t          }\n\t          exiting.locals = null;\n\t        }\n\t\n\t        // Enter 'to' states not kept\n\t        for (l = keep; l < toPath.length; l++) {\n\t          entering = toPath[l];\n\t          entering.locals = toLocals[l];\n\t          if (entering.self.onEnter) {\n\t            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n\t          }\n\t        }\n\t\n\t        // Run it again, to catch any transitions in callbacks\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Update globals in $state\n\t        $state.$current = to;\n\t        $state.current = to.self;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        $state.transition = null;\n\t\n\t        if (options.location && to.navigable) {\n\t          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t        }\n\t\n\t        if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeSuccess\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired once the state transition is **complete**.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         */\n\t          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n\t        }\n\t        $urlRouter.update(true);\n\t\n\t        return $state.current;\n\t      }, function (error) {\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        $state.transition = null;\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeError\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when an **error occurs** during transition. It's important to note that if you\n\t         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t         * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t         * catch **ALL** errors.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         * @param {Error} error The resolve error object.\n\t         */\n\t        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\t\n\t        if (!evt.defaultPrevented) {\n\t            $urlRouter.update();\n\t        }\n\t\n\t        return $q.reject(error);\n\t      });\n\t\n\t      return transition;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be\n\t     * tested for strict equality against the current active params object, so all params\n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     * test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    $state.is = function is(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) { return undefined; }\n\t      if ($state.$current !== state) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t     * .includes will test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    $state.includes = function includes(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      if (isString(stateOrName) && isGlob(stateOrName)) {\n\t        if (!doesStateMatchGlob(stateOrName)) {\n\t          return false;\n\t        }\n\t        stateOrName = $state.$current.name;\n\t      }\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t      if (!isDefined(state)) { return undefined; }\n\t      if (!isDefined($state.$current.includes[state.name])) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n\t    };\n\t\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     * \n\t     * @returns {string} compiled state url\n\t     */\n\t    $state.href = function href(stateOrName, params, options) {\n\t      options = extend({\n\t        lossy:    true,\n\t        inherit:  true,\n\t        absolute: false,\n\t        relative: $state.$current\n\t      }, options || {});\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) return null;\n\t      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\t      \n\t      var nav = (state && options.lossy) ? state.navigable : state;\n\t\n\t      if (!nav || nav.url === undefined || nav.url === null) {\n\t        return null;\n\t      }\n\t      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n\t        absolute: options.absolute\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#get\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Returns the state configuration object for any specific state or all states.\n\t     *\n\t     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n\t     * the requested state. If not provided, returns an array of ALL state configs.\n\t     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n\t     * @returns {Object|Array} State configuration object or array of all objects.\n\t     */\n\t    $state.get = function (stateOrName, context) {\n\t      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n\t      var state = findState(stateOrName, context || $state.$current);\n\t      return (state && state.self) ? state.self : null;\n\t    };\n\t\n\t    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n\t      // Make a restricted $stateParams with only the parameters that apply to this state if\n\t      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n\t      // we also need $stateParams to be available for any $injector calls we make during the\n\t      // dependency resolution process.\n\t      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n\t      var locals = { $stateParams: $stateParams };\n\t\n\t      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n\t      // We're also including $stateParams in this; that way the parameters are restricted\n\t      // to the set that should be visible to the state, and are independent of when we update\n\t      // the global $state and $stateParams values.\n\t      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n\t      var promises = [dst.resolve.then(function (globals) {\n\t        dst.globals = globals;\n\t      })];\n\t      if (inherited) promises.push(inherited);\n\t\n\t      function resolveViews() {\n\t        var viewsPromises = [];\n\t\n\t        // Resolve template and dependencies for all views.\n\t        forEach(state.views, function (view, name) {\n\t          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n\t          injectables.$template = [ function () {\n\t            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n\t          }];\n\t\n\t          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n\t            // References to the controller (only instantiated at link time)\n\t            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n\t              var injectLocals = angular.extend({}, injectables, dst.globals);\n\t              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n\t            } else {\n\t              result.$$controller = view.controller;\n\t            }\n\t            // Provide access to the state itself for internal use\n\t            result.$$state = state;\n\t            result.$$controllerAs = view.controllerAs;\n\t            dst[name] = result;\n\t          }));\n\t        });\n\t\n\t        return $q.all(viewsPromises).then(function(){\n\t          return dst.globals;\n\t        });\n\t      }\n\t\n\t      // Wait for all the promises and then return the activation object\n\t      return $q.all(promises).then(resolveViews).then(function (values) {\n\t        return dst;\n\t      });\n\t    }\n\t\n\t    return $state;\n\t  }\n\t\n\t  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n\t    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n\t    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n\t      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n\t      function notSearchParam(key) {\n\t        return fromAndToState.params[key].location != \"search\";\n\t      }\n\t      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n\t      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n\t      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n\t      return nonQueryParamSet.$$equals(fromParams, toParams);\n\t    }\n\t\n\t    // If reload was not explicitly requested\n\t    // and we're transitioning to the same state we're already in\n\t    // and    the locals didn't change\n\t    //     or they changed in a way that doesn't merit reloading\n\t    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n\t    // Then return true.\n\t    if (!options.reload && to === from &&\n\t      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .factory('$stateParams', function () { return {}; })\n\t  .provider('$state', $StateProvider);\n\t\n\t\n\t$ViewProvider.$inject = [];\n\tfunction $ViewProvider() {\n\t\n\t  this.$get = $get;\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$view\n\t   *\n\t   * @requires ui.router.util.$templateFactory\n\t   * @requires $rootScope\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  $get.$inject = ['$rootScope', '$templateFactory'];\n\t  function $get(   $rootScope,   $templateFactory) {\n\t    return {\n\t      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.state.$view#load\n\t       * @methodOf ui.router.state.$view\n\t       *\n\t       * @description\n\t       *\n\t       * @param {string} name name\n\t       * @param {object} options option object.\n\t       */\n\t      load: function load(name, options) {\n\t        var result, defaults = {\n\t          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n\t        };\n\t        options = extend(defaults, options);\n\t\n\t        if (options.view) {\n\t          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n\t        }\n\t        return result;\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state').provider('$view', $ViewProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t\n\t  var useAnchorScroll = false;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t   * @methodOf ui.router.state.$uiViewScrollProvider\n\t   *\n\t   * @description\n\t   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t   * scrolling based on the url anchor.\n\t   */\n\t  this.useAnchorScroll = function () {\n\t    useAnchorScroll = true;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$uiViewScroll\n\t   *\n\t   * @requires $anchorScroll\n\t   * @requires $timeout\n\t   *\n\t   * @description\n\t   * When called with a jqLite element, it scrolls the element into view (after a\n\t   * `$timeout` so the DOM has time to refresh).\n\t   *\n\t   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t   */\n\t  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t    if (useAnchorScroll) {\n\t      return $anchorScroll;\n\t    }\n\t\n\t    return function ($element) {\n\t      return $timeout(function () {\n\t        $element[0].scrollIntoView();\n\t      }, 0, false);\n\t    };\n\t  }];\n\t}\n\t\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\tvar ngMajorVer = angular.version.major;\n\tvar ngMinorVer = angular.version.minor;\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-view\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $compile\n\t * @requires $controller\n\t * @requires $injector\n\t * @requires ui.router.state.$uiViewScroll\n\t * @requires $document\n\t *\n\t * @restrict ECA\n\t *\n\t * @description\n\t * The ui-view directive tells $state where to place your templates.\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n\t * will be applied to the ui-view)\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t * \n\t * @example\n\t * A view can be unnamed or named. \n\t * <pre>\n\t * <!-- Unnamed -->\n\t * <div ui-view></div> \n\t * \n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * </pre>\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a \n\t * single view and it is unnamed then you can populate it like so:\n\t * <pre>\n\t * <div ui-view></div> \n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * </pre>\n\t * \n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n\t * config property, by name, in this case an empty name:\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * But typically you'll only use the views property if you name your view or have more than one view \n\t * in the same template. There's not really a compelling reason to name a view if its the only one, \n\t * but you could if you wanted, like so:\n\t * <pre>\n\t * <div ui-view=\"main\"></div>\n\t * </pre> \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * Really though, you'll use views to set up multiple views:\n\t * <pre>\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div> \n\t * <div ui-view=\"data\"></div> \n\t * </pre>\n\t * \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * <pre>\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * </pre>\n\t */\n\t$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\n\tfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\t\n\t  function getService() {\n\t    return ($injector.has) ? function(service) {\n\t      return $injector.has(service) ? $injector.get(service) : null;\n\t    } : function(service) {\n\t      try {\n\t        return $injector.get(service);\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var service = getService(),\n\t      $animator = service('$animator'),\n\t      $animate = service('$animate');\n\t\n\t  // Returns a set of DOM manipulation functions based on which Angular version\n\t  // it should use\n\t  function getRenderer(attrs, scope) {\n\t    var statics = {\n\t      enter: function (element, target, cb) { target.after(element); cb(); },\n\t      leave: function (element, cb) { element.remove(); cb(); }\n\t    };\n\t\n\t    if (!!attrs.noanimation) return statics;\n\t\n\t    function animEnabled(element) {\n\t      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n\t      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n\t      return (!!$animator);\n\t    }\n\t\n\t    // ng 1.2+\n\t    if ($animate) {\n\t      return {\n\t        enter: function(element, target, cb) {\n\t          if (!animEnabled(element)) {\n\t            statics.enter(element, target, cb);\n\t          } else if (angular.version.minor > 2) {\n\t            $animate.enter(element, null, target).then(cb);\n\t          } else {\n\t            $animate.enter(element, null, target, cb);\n\t          }\n\t        },\n\t        leave: function(element, cb) {\n\t          if (!animEnabled(element)) {\n\t            statics.leave(element, cb);\n\t          } else if (angular.version.minor > 2) {\n\t            $animate.leave(element).then(cb);\n\t          } else {\n\t            $animate.leave(element, cb);\n\t          }\n\t        }\n\t      };\n\t    }\n\t\n\t    // ng 1.1.5\n\t    if ($animator) {\n\t      var animate = $animator && $animator(scope, attrs);\n\t\n\t      return {\n\t        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n\t        leave: function(element, cb) { animate.leave(element); cb(); }\n\t      };\n\t    }\n\t\n\t    return statics;\n\t  }\n\t\n\t  var directive = {\n\t    restrict: 'ECA',\n\t    terminal: true,\n\t    priority: 400,\n\t    transclude: 'element',\n\t    compile: function (tElement, tAttrs, $transclude) {\n\t      return function (scope, $element, attrs) {\n\t        var previousEl, currentEl, currentScope, latestLocals,\n\t            onloadExp     = attrs.onload || '',\n\t            autoScrollExp = attrs.autoscroll,\n\t            renderer      = getRenderer(attrs, scope);\n\t\n\t        scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        updateView(true);\n\t\n\t        function cleanupLastView() {\n\t          var _previousEl = previousEl;\n\t          var _currentScope = currentScope;\n\t\n\t          if (_currentScope) {\n\t            _currentScope._willBeDestroyed = true;\n\t          }\n\t\n\t          function cleanOld() {\n\t            if (_previousEl) {\n\t              _previousEl.remove();\n\t            }\n\t\n\t            if (_currentScope) {\n\t              _currentScope.$destroy();\n\t            }\n\t          }\n\t\n\t          if (currentEl) {\n\t            renderer.leave(currentEl, function() {\n\t              cleanOld();\n\t              previousEl = null;\n\t            });\n\t\n\t            previousEl = currentEl;\n\t          } else {\n\t            cleanOld();\n\t            previousEl = null;\n\t          }\n\t\n\t          currentEl = null;\n\t          currentScope = null;\n\t        }\n\t\n\t        function updateView(firstTime) {\n\t          var newScope,\n\t              name            = getUiViewName(scope, attrs, $element, $interpolate),\n\t              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\t\n\t          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n\t          newScope = scope.$new();\n\t          latestLocals = $state.$current.locals[name];\n\t\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoading\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           *\n\t           * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          newScope.$emit('$viewContentLoading', name);\n\t\n\t          var clone = $transclude(newScope, function(clone) {\n\t            renderer.enter(clone, $element, function onUiViewEnter() {\n\t              if(currentScope) {\n\t                currentScope.$emit('$viewContentAnimationEnded');\n\t              }\n\t\n\t              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                $uiViewScroll(clone);\n\t              }\n\t            });\n\t            cleanupLastView();\n\t          });\n\t\n\t          currentEl = clone;\n\t          currentScope = newScope;\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          currentScope.$emit('$viewContentLoaded', name);\n\t          currentScope.$eval(onloadExp);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  return directive;\n\t}\n\t\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\n\tfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n\t  return {\n\t    restrict: 'ECA',\n\t    priority: -400,\n\t    compile: function (tElement) {\n\t      var initial = tElement.html();\n\t      return function (scope, $element, attrs) {\n\t        var current = $state.$current,\n\t            name = getUiViewName(scope, attrs, $element, $interpolate),\n\t            locals  = current && current.locals[name];\n\t\n\t        if (! locals) {\n\t          return;\n\t        }\n\t\n\t        $element.data('$uiView', { name: name, state: locals.$$state });\n\t        $element.html(locals.$template ? locals.$template : initial);\n\t\n\t        var link = $compile($element.contents());\n\t\n\t        if (locals.$$controller) {\n\t          locals.$scope = scope;\n\t          locals.$element = $element;\n\t          var controller = $controller(locals.$$controller, locals);\n\t          if (locals.$$controllerAs) {\n\t            scope[locals.$$controllerAs] = controller;\n\t          }\n\t          $element.data('$ngControllerController', controller);\n\t          $element.children().data('$ngControllerController', controller);\n\t        }\n\t\n\t        link(scope);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Shared ui-view code for both directives:\n\t * Given scope, element, and its attributes, return the view's name\n\t */\n\tfunction getUiViewName(scope, attrs, element, $interpolate) {\n\t  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n\t  var inherited = element.inheritedData('$uiView');\n\t  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n\t}\n\t\n\tangular.module('ui.router.state').directive('uiView', $ViewDirective);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\tfunction parseStateRef(ref, current) {\n\t  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n\t  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t  return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t\n\tfunction stateContext(el) {\n\t  var stateData = el.parent().inheritedData('$uiView');\n\t\n\t  if (stateData && stateData.state && stateData.state.name) {\n\t    return stateData.state;\n\t  }\n\t}\n\t\n\tfunction getTypeInfo(el) {\n\t  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n\t  var isForm = el[0].nodeName === \"FORM\";\n\t\n\t  return {\n\t    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n\t    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n\t    clickable: !isForm\n\t  };\n\t}\n\t\n\tfunction clickHook(el, $state, $timeout, type, current) {\n\t  return function(e) {\n\t    var button = e.which || e.button, target = current();\n\t\n\t    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n\t      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t      var transition = $timeout(function() {\n\t        $state.go(target.state, target.params, target.options);\n\t      });\n\t      e.preventDefault();\n\t\n\t      // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\t\n\t      e.preventDefault = function() {\n\t        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\tfunction defaultOpts(el, $state) {\n\t  return { relative: stateContext(el) || $state.$current, inherit: true };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $timeout\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n\t * URL, the directive will automatically generate & update the `href` attribute via\n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n\t * the link will trigger a state transition with optional parameters.\n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative\n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the\n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * @example\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n\t * following template:\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n\t */\n\t$StateRefDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n\t      var def    = { state: ref.state, href: null, params: null };\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t\n\t      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\t\n\t      var update = function(val) {\n\t        if (val) def.params = angular.copy(val);\n\t        def.href = $state.href(ref.state, def.params, def.options);\n\t\n\t        if (active) active.$$addStateInfo(ref.state, def.params);\n\t        if (def.href !== null) attrs.$set(type.attr, def.href);\n\t      };\n\t\n\t      if (ref.paramExpr) {\n\t        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n\t        def.params = angular.copy(scope.$eval(ref.paramExpr));\n\t      }\n\t      update();\n\t\n\t      if (!type.clickable) return;\n\t      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-state\n\t *\n\t * @requires ui.router.state.uiSref\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n\t * params and override options.\n\t *\n\t * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n\t * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n\t */\n\t$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDynamicDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n\t      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n\t      var def    = { state: null, params: null, options: null, href: null };\n\t\n\t      function runStateRefLink (group) {\n\t        def.state = group[0]; def.params = group[1]; def.options = group[2];\n\t        def.href = $state.href(def.state, def.params, def.options);\n\t\n\t        if (active) active.$$addStateInfo(def.state, def.params);\n\t        if (def.href) attrs.$set(type.attr, def.href);\n\t      }\n\t\n\t      scope.$watch(watch, runStateRefLink, true);\n\t      runStateRefLink(scope.$eval(watch));\n\t\n\t      if (!type.clickable) return;\n\t      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n\t    }\n\t  };\n\t}\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use\n\t * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n\t *\n\t * @example\n\t * Given the following template:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * It is also possible to pass ui-sref-active an expression that evaluates\n\t * to an object hash, whose keys represent active class names and whose\n\t * values represent the respective state names/globs.\n\t * ui-sref-active will match if the current active state **includes** any of\n\t * the specified state names/globs, even the abstract ones.\n\t *\n\t * @Example\n\t * Given the following template, with \"admin\" being an abstract state:\n\t * <pre>\n\t * <div ui-sref-active=\"{'active': 'admin.*'}\">\n\t *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n\t * </div>\n\t * </pre>\n\t *\n\t * When the current state is \"admin.roles\" the \"active\" class will be applied\n\t * to both the <div> and <a> elements. It is important to note that the state\n\t * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active-eq\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n\t * when the exact target state used in the `ui-sref` is active; no child states.\n\t *\n\t */\n\t$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n\tfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n\t  return  {\n\t    restrict: \"A\",\n\t    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n\t      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\t\n\t      // There probably isn't much point in $observing this\n\t      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t      // slight difference in logic routing\n\t      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\t\n\t      try {\n\t        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n\t      } catch (e) {\n\t        // Do nothing. uiSrefActive is not a valid expression.\n\t        // Fall back to using $interpolate below\n\t      }\n\t      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n\t      if (isObject(uiSrefActive)) {\n\t        forEach(uiSrefActive, function(stateOrName, activeClass) {\n\t          if (isString(stateOrName)) {\n\t            var ref = parseStateRef(stateOrName, $state.current.name);\n\t            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n\t          }\n\t        });\n\t      }\n\t\n\t      // Allow uiSref to communicate with uiSrefActive[Equals]\n\t      this.$$addStateInfo = function (newState, newParams) {\n\t        // we already got an explicit state provided by ui-sref-active, so we\n\t        // shadow the one that comes from ui-sref\n\t        if (isObject(uiSrefActive) && states.length > 0) {\n\t          return;\n\t        }\n\t        addState(newState, newParams, uiSrefActive);\n\t        update();\n\t      };\n\t\n\t      $scope.$on('$stateChangeSuccess', update);\n\t\n\t      function addState(stateName, stateParams, activeClass) {\n\t        var state = $state.get(stateName, stateContext($element));\n\t        var stateHash = createStateHash(stateName, stateParams);\n\t\n\t        states.push({\n\t          state: state || { name: stateName },\n\t          params: stateParams,\n\t          hash: stateHash\n\t        });\n\t\n\t        activeClasses[stateHash] = activeClass;\n\t      }\n\t\n\t      /**\n\t       * @param {string} state\n\t       * @param {Object|string} [params]\n\t       * @return {string}\n\t       */\n\t      function createStateHash(state, params) {\n\t        if (!isString(state)) {\n\t          throw new Error('state should be a string');\n\t        }\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        params = $scope.$eval(params);\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        return state;\n\t      }\n\t\n\t      // Update route state\n\t      function update() {\n\t        for (var i = 0; i < states.length; i++) {\n\t          if (anyMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeClasses[states[i].hash]);\n\t          } else {\n\t            removeClass($element, activeClasses[states[i].hash]);\n\t          }\n\t\n\t          if (exactMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeEqClass);\n\t          } else {\n\t            removeClass($element, activeEqClass);\n\t          }\n\t        }\n\t      }\n\t\n\t      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n\t      function removeClass(el, className) { el.removeClass(className); }\n\t      function anyMatch(state, params) { return $state.includes(state.name, params); }\n\t      function exactMatch(state, params) { return $state.is(state.name, params); }\n\t\n\t      update();\n\t    }]\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .directive('uiSref', $StateRefDirective)\n\t  .directive('uiSrefActive', $StateRefActiveDirective)\n\t  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n\t  .directive('uiState', $StateRefDynamicDirective);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t  var isFilter = function (state, params) {\n\t    return $state.is(state, params);\n\t  };\n\t  isFilter.$stateful = true;\n\t  return isFilter;\n\t}\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t  var includesFilter = function (state, params, options) {\n\t    return $state.includes(state, params, options);\n\t  };\n\t  includesFilter.$stateful = true;\n\t  return  includesFilter;\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .filter('isState', $IsStateFilter)\n\t  .filter('includedByState', $IncludedByStateFilter);\n\t})(window, window.angular);\n\n/***/ },\n\n/***/ 12:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t  'use strict';\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (root.hasOwnProperty('angular')) {\n\t    // Browser globals (root is window), we don't register it.\n\t    factory(root.angular);\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = factory(require('angular'));\n\t  }\n\t}(this , function (angular) {\n\t    'use strict';\n\t\n\t    // In cases where Angular does not get passed or angular is a truthy value\n\t    // but misses .module we can fall back to using window.\n\t    angular = (angular && angular.module ) ? angular : window.angular;\n\t\n\t    /**\n\t     * @ngdoc overview\n\t     * @name ngStorage\n\t     */\n\t\n\t    return angular.module('ngStorage', [])\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$localStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$localStorage', _storageProvider('localStorage'))\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$sessionStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\t\n\t    function _storageProvider(storageType) {\n\t        return function () {\n\t          var storageKeyPrefix = 'ngStorage-';\n\t\n\t          this.setKeyPrefix = function (prefix) {\n\t            if (typeof prefix !== 'string') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n\t            }\n\t            storageKeyPrefix = prefix;\n\t          };\n\t\n\t          var serializer = angular.toJson;\n\t          var deserializer = angular.fromJson;\n\t\n\t          this.setSerializer = function (s) {\n\t            if (typeof s !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n\t            }\n\t\n\t            serializer = s;\n\t          };\n\t\n\t          this.setDeserializer = function (d) {\n\t            if (typeof d !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n\t            }\n\t\n\t            deserializer = d;\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.get = function (key) {\n\t            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.set = function (key, value) {\n\t            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n\t          };\n\t\n\t          this.$get = [\n\t              '$rootScope',\n\t              '$window',\n\t              '$log',\n\t              '$timeout',\n\t              '$document',\n\t\n\t              function(\n\t                  $rootScope,\n\t                  $window,\n\t                  $log,\n\t                  $timeout,\n\t                  $document\n\t              ){\n\t                function isStorageSupported(storageType) {\n\t\n\t                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n\t                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n\t                    // that error and allow execution to continue.\n\t\n\t                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n\t                    // when \"Block cookies\": \"Always block\" is turned on\n\t                    var supported;\n\t                    try {\n\t                        supported = $window[storageType];\n\t                    }\n\t                    catch (err) {\n\t                        supported = false;\n\t                    }\n\t\n\t                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n\t                    // is available, but trying to call .setItem throws an exception below:\n\t                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n\t                    if (supported && storageType === 'localStorage') {\n\t                        var key = '__' + Math.round(Math.random() * 1e7);\n\t\n\t                        try {\n\t                            localStorage.setItem(key, key);\n\t                            localStorage.removeItem(key);\n\t                        }\n\t                        catch (err) {\n\t                            supported = false;\n\t                        }\n\t                    }\n\t\n\t                    return supported;\n\t                }\n\t\n\t                // The magic number 10 is used which only works for some keyPrefixes...\n\t                // See https://github.com/gsklee/ngStorage/issues/137\n\t                var prefixLength = storageKeyPrefix.length;\n\t\n\t                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n\t                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n\t                    $storage = {\n\t                        $default: function(items) {\n\t                            for (var k in items) {\n\t                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n\t                            }\n\t\n\t                            $storage.$sync();\n\t                            return $storage;\n\t                        },\n\t                        $reset: function(items) {\n\t                            for (var k in $storage) {\n\t                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n\t                            }\n\t\n\t                            return $storage.$default(items);\n\t                        },\n\t                        $sync: function () {\n\t                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n\t                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n\t                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n\t                            }\n\t                        },\n\t                        $apply: function() {\n\t                            var temp$storage;\n\t\n\t                            _debounce = null;\n\t\n\t                            if (!angular.equals($storage, _last$storage)) {\n\t                                temp$storage = angular.copy(_last$storage);\n\t                                angular.forEach($storage, function(v, k) {\n\t                                    if (angular.isDefined(v) && '$' !== k[0]) {\n\t                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n\t                                        delete temp$storage[k];\n\t                                    }\n\t                                });\n\t\n\t                                for (var k in temp$storage) {\n\t                                    webStorage.removeItem(storageKeyPrefix + k);\n\t                                }\n\t\n\t                                _last$storage = angular.copy($storage);\n\t                            }\n\t                        }\n\t                    },\n\t                    _last$storage,\n\t                    _debounce;\n\t\n\t                $storage.$sync();\n\t\n\t                _last$storage = angular.copy($storage);\n\t\n\t                $rootScope.$watch(function() {\n\t                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n\t                });\n\t\n\t                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n\t                $window.addEventListener && $window.addEventListener('storage', function(event) {\n\t                    if (!event.key) {\n\t                      return;\n\t                    }\n\t\n\t                    // Reference doc.\n\t                    var doc = $document[0];\n\t\n\t                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n\t                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\t\n\t                        _last$storage = angular.copy($storage);\n\t\n\t                        $rootScope.$apply();\n\t                    }\n\t                });\n\t\n\t                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n\t                    $storage.$apply();\n\t                });\n\t\n\t                return $storage;\n\t              }\n\t          ];\n\t      };\n\t    }\n\t\n\t}));\n\n\n/***/ },\n\n/***/ 13:\n/***/ function(module, exports) {\n\n\t/**\n\t * oclazyload - Load modules on demand (lazy load) with angularJS\n\t * @version v1.0.9\n\t * @link https://github.com/ocombe/ocLazyLoad\n\t * @license MIT\n\t * @author Olivier Combe <olivier.combe@gmail.com>\n\t */\n\t(function (angular, window) {\n\t    'use strict';\n\t\n\t    var regModules = ['ng', 'oc.lazyLoad'],\n\t        regInvokes = {},\n\t        regConfigs = [],\n\t        modulesToLoad = [],\n\t        // modules to load from angular.module or other sources\n\t    realModules = [],\n\t        // real modules called from angular.module\n\t    recordDeclarations = [],\n\t        broadcast = angular.noop,\n\t        runBlocks = {},\n\t        justLoaded = [];\n\t\n\t    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\t\n\t    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n\t        var modules = {},\n\t            providers = {\n\t            $controllerProvider: $controllerProvider,\n\t            $compileProvider: $compileProvider,\n\t            $filterProvider: $filterProvider,\n\t            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n\t            $injector: $injector,\n\t            $animateProvider: $animateProvider\n\t        },\n\t            debug = false,\n\t            events = false,\n\t            moduleCache = [],\n\t            modulePromises = {};\n\t\n\t        moduleCache.push = function (value) {\n\t            if (this.indexOf(value) === -1) {\n\t                Array.prototype.push.apply(this, arguments);\n\t            }\n\t        };\n\t\n\t        this.config = function (config) {\n\t            // If we want to define modules configs\n\t            if (angular.isDefined(config.modules)) {\n\t                if (angular.isArray(config.modules)) {\n\t                    angular.forEach(config.modules, function (moduleConfig) {\n\t                        modules[moduleConfig.name] = moduleConfig;\n\t                    });\n\t                } else {\n\t                    modules[config.modules.name] = config.modules;\n\t                }\n\t            }\n\t\n\t            if (angular.isDefined(config.debug)) {\n\t                debug = config.debug;\n\t            }\n\t\n\t            if (angular.isDefined(config.events)) {\n\t                events = config.events;\n\t            }\n\t        };\n\t\n\t        /**\n\t         * Get the list of existing registered modules\n\t         * @param element\n\t         */\n\t        this._init = function _init(element) {\n\t            // this is probably useless now because we override angular.bootstrap\n\t            if (modulesToLoad.length === 0) {\n\t                var elements = [element],\n\t                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n\t                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n\t                    append = function append(elm) {\n\t                    return elm && elements.push(elm);\n\t                };\n\t\n\t                angular.forEach(names, function (name) {\n\t                    names[name] = true;\n\t                    append(document.getElementById(name));\n\t                    name = name.replace(':', '\\\\:');\n\t                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n\t                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n\t                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n\t                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n\t                    }\n\t                });\n\t\n\t                angular.forEach(elements, function (elm) {\n\t                    if (modulesToLoad.length === 0) {\n\t                        var className = ' ' + element.className + ' ';\n\t                        var match = NG_APP_CLASS_REGEXP.exec(className);\n\t                        if (match) {\n\t                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n\t                        } else {\n\t                            angular.forEach(elm.attributes, function (attr) {\n\t                                if (modulesToLoad.length === 0 && names[attr.name]) {\n\t                                    modulesToLoad.push(attr.value);\n\t                                }\n\t                            });\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t\n\t            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n\t                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n\t            }\n\t\n\t            var addReg = function addReg(moduleName) {\n\t                if (regModules.indexOf(moduleName) === -1) {\n\t                    // register existing modules\n\t                    regModules.push(moduleName);\n\t                    var mainModule = angular.module(moduleName);\n\t\n\t                    // register existing components (directives, services, ...)\n\t                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n\t                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\t\n\t                    angular.forEach(mainModule.requires, addReg);\n\t                }\n\t            };\n\t\n\t            angular.forEach(modulesToLoad, function (moduleName) {\n\t                addReg(moduleName);\n\t            });\n\t\n\t            modulesToLoad = []; // reset for next bootstrap\n\t            recordDeclarations.pop(); // wait for the next lazy load\n\t        };\n\t\n\t        /**\n\t         * Like JSON.stringify but that doesn't throw on circular references\n\t         * @param obj\n\t         */\n\t        var stringify = function stringify(obj) {\n\t            try {\n\t                return JSON.stringify(obj);\n\t            } catch (e) {\n\t                var cache = [];\n\t                return JSON.stringify(obj, function (key, value) {\n\t                    if (angular.isObject(value) && value !== null) {\n\t                        if (cache.indexOf(value) !== -1) {\n\t                            // Circular reference found, discard key\n\t                            return;\n\t                        }\n\t                        // Store value in our collection\n\t                        cache.push(value);\n\t                    }\n\t                    return value;\n\t                });\n\t            }\n\t        };\n\t\n\t        var hashCode = function hashCode(str) {\n\t            var hash = 0,\n\t                i,\n\t                chr,\n\t                len;\n\t            if (str.length == 0) {\n\t                return hash;\n\t            }\n\t            for (i = 0, len = str.length; i < len; i++) {\n\t                chr = str.charCodeAt(i);\n\t                hash = (hash << 5) - hash + chr;\n\t                hash |= 0; // Convert to 32bit integer\n\t            }\n\t            return hash;\n\t        };\n\t\n\t        function _register(providers, registerModules, params) {\n\t            if (registerModules) {\n\t                var k,\n\t                    moduleName,\n\t                    moduleFn,\n\t                    tempRunBlocks = [];\n\t                for (k = registerModules.length - 1; k >= 0; k--) {\n\t                    moduleName = registerModules[k];\n\t                    if (!angular.isString(moduleName)) {\n\t                        moduleName = getModuleName(moduleName);\n\t                    }\n\t                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n\t                        continue;\n\t                    }\n\t                    // new if not registered\n\t                    var newModule = regModules.indexOf(moduleName) === -1;\n\t                    moduleFn = ngModuleFct(moduleName);\n\t                    if (newModule) {\n\t                        regModules.push(moduleName);\n\t                        _register(providers, moduleFn.requires, params);\n\t                    }\n\t                    if (moduleFn._runBlocks.length > 0) {\n\t                        // new run blocks detected! Replace the old ones (if existing)\n\t                        runBlocks[moduleName] = [];\n\t                        while (moduleFn._runBlocks.length > 0) {\n\t                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n\t                        }\n\t                    }\n\t                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n\t                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n\t                    }\n\t                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n\t                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n\t                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n\t                    registerModules.pop();\n\t                    justLoaded.push(moduleName);\n\t                }\n\t                // execute the run blocks at the end\n\t                var instanceInjector = providers.getInstanceInjector();\n\t                angular.forEach(tempRunBlocks, function (fn) {\n\t                    instanceInjector.invoke(fn);\n\t                });\n\t            }\n\t        }\n\t\n\t        function _registerInvokeList(args, moduleName) {\n\t            var invokeList = args[2][0],\n\t                type = args[1],\n\t                newInvoke = false;\n\t            if (angular.isUndefined(regInvokes[moduleName])) {\n\t                regInvokes[moduleName] = {};\n\t            }\n\t            if (angular.isUndefined(regInvokes[moduleName][type])) {\n\t                regInvokes[moduleName][type] = {};\n\t            }\n\t            var onInvoke = function onInvoke(invokeName, invoke) {\n\t                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n\t                    regInvokes[moduleName][type][invokeName] = [];\n\t                }\n\t                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n\t                    newInvoke = true;\n\t                    regInvokes[moduleName][type][invokeName].push(invoke);\n\t                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n\t                }\n\t            };\n\t\n\t            function checkHashes(potentialNew, invokes) {\n\t                var isNew = true,\n\t                    newHash;\n\t                if (invokes.length) {\n\t                    newHash = signature(potentialNew);\n\t                    angular.forEach(invokes, function (invoke) {\n\t                        isNew = isNew && signature(invoke) !== newHash;\n\t                    });\n\t                }\n\t                return isNew;\n\t            }\n\t\n\t            function signature(data) {\n\t                if (angular.isArray(data)) {\n\t                    // arrays are objects, we need to test for it first\n\t                    return hashCode(data.toString());\n\t                } else if (angular.isObject(data)) {\n\t                    // constants & values for example\n\t                    return hashCode(stringify(data));\n\t                } else {\n\t                    if (angular.isDefined(data) && data !== null) {\n\t                        return hashCode(data.toString());\n\t                    } else {\n\t                        // null & undefined constants\n\t                        return data;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (angular.isString(invokeList)) {\n\t                onInvoke(invokeList, args[2][1]);\n\t            } else if (angular.isObject(invokeList)) {\n\t                angular.forEach(invokeList, function (invoke, key) {\n\t                    if (angular.isString(invoke)) {\n\t                        // decorators for example\n\t                        onInvoke(invoke, invokeList[1]);\n\t                    } else {\n\t                        // components registered as object lists {\"componentName\": function() {}}\n\t                        onInvoke(key, invoke);\n\t                    }\n\t                });\n\t            } else {\n\t                return false;\n\t            }\n\t            return newInvoke;\n\t        }\n\t\n\t        function _invokeQueue(providers, queue, moduleName, reconfig) {\n\t            if (!queue) {\n\t                return;\n\t            }\n\t\n\t            var i, len, args, provider;\n\t            for (i = 0, len = queue.length; i < len; i++) {\n\t                args = queue[i];\n\t                if (angular.isArray(args)) {\n\t                    if (providers !== null) {\n\t                        if (providers.hasOwnProperty(args[0])) {\n\t                            provider = providers[args[0]];\n\t                        } else {\n\t                            throw new Error('unsupported provider ' + args[0]);\n\t                        }\n\t                    }\n\t                    var isNew = _registerInvokeList(args, moduleName);\n\t                    if (args[1] !== 'invoke') {\n\t                        if (isNew && angular.isDefined(provider)) {\n\t                            provider[args[1]].apply(provider, args[2]);\n\t                        }\n\t                    } else {\n\t                        // config block\n\t                        var callInvoke = function callInvoke(fct) {\n\t                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n\t                            if (invoked === -1 || reconfig) {\n\t                                if (invoked === -1) {\n\t                                    regConfigs.push(moduleName + '-' + fct);\n\t                                }\n\t                                if (angular.isDefined(provider)) {\n\t                                    provider[args[1]].apply(provider, args[2]);\n\t                                }\n\t                            }\n\t                        };\n\t                        if (angular.isFunction(args[2][0])) {\n\t                            callInvoke(args[2][0]);\n\t                        } else if (angular.isArray(args[2][0])) {\n\t                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n\t                                if (angular.isFunction(args[2][0][j])) {\n\t                                    callInvoke(args[2][0][j]);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function getModuleName(module) {\n\t            var moduleName = null;\n\t            if (angular.isString(module)) {\n\t                moduleName = module;\n\t            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n\t                moduleName = module.name;\n\t            }\n\t            return moduleName;\n\t        }\n\t\n\t        function moduleExists(moduleName) {\n\t            if (!angular.isString(moduleName)) {\n\t                return false;\n\t            }\n\t            try {\n\t                return ngModuleFct(moduleName);\n\t            } catch (e) {\n\t                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t\n\t        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n\t            var instanceInjector,\n\t                filesCache = $cacheFactory('ocLazyLoad');\n\t\n\t            if (!debug) {\n\t                $log = {};\n\t                $log['error'] = angular.noop;\n\t                $log['warn'] = angular.noop;\n\t                $log['info'] = angular.noop;\n\t            }\n\t\n\t            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n\t            providers.getInstanceInjector = function () {\n\t                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n\t            };\n\t\n\t            broadcast = function broadcast(eventName, params) {\n\t                if (events) {\n\t                    $rootScope.$broadcast(eventName, params);\n\t                }\n\t                if (debug) {\n\t                    $log.info(eventName, params);\n\t                }\n\t            };\n\t\n\t            function reject(e) {\n\t                var deferred = $q.defer();\n\t                $log.error(e.message);\n\t                deferred.reject(e);\n\t                return deferred.promise;\n\t            }\n\t\n\t            return {\n\t                _broadcast: broadcast,\n\t\n\t                _$log: $log,\n\t\n\t                /**\n\t                 * Returns the files cache used by the loaders to store the files currently loading\n\t                 * @returns {*}\n\t                 */\n\t                _getFilesCache: function getFilesCache() {\n\t                    return filesCache;\n\t                },\n\t\n\t                /**\n\t                 * Let the service know that it should monitor angular.module because files are loading\n\t                 * @param watch boolean\n\t                 */\n\t                toggleWatch: function toggleWatch(watch) {\n\t                    if (watch) {\n\t                        recordDeclarations.push(true);\n\t                    } else {\n\t                        recordDeclarations.pop();\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Let you get a module config object\n\t                 * @param moduleName String the name of the module\n\t                 * @returns {*}\n\t                 */\n\t                getModuleConfig: function getModuleConfig(moduleName) {\n\t                    if (!angular.isString(moduleName)) {\n\t                        throw new Error('You need to give the name of the module to get');\n\t                    }\n\t                    if (!modules[moduleName]) {\n\t                        return null;\n\t                    }\n\t                    return angular.copy(modules[moduleName]);\n\t                },\n\t\n\t                /**\n\t                 * Let you define a module config object\n\t                 * @param moduleConfig Object the module config object\n\t                 * @returns {*}\n\t                 */\n\t                setModuleConfig: function setModuleConfig(moduleConfig) {\n\t                    if (!angular.isObject(moduleConfig)) {\n\t                        throw new Error('You need to give the module config object to set');\n\t                    }\n\t                    modules[moduleConfig.name] = moduleConfig;\n\t                    return moduleConfig;\n\t                },\n\t\n\t                /**\n\t                 * Returns the list of loaded modules\n\t                 * @returns {string[]}\n\t                 */\n\t                getModules: function getModules() {\n\t                    return regModules;\n\t                },\n\t\n\t                /**\n\t                 * Let you check if a module has been loaded into Angular or not\n\t                 * @param modulesNames String/Object a module name, or a list of module names\n\t                 * @returns {boolean}\n\t                 */\n\t                isLoaded: function isLoaded(modulesNames) {\n\t                    var moduleLoaded = function moduleLoaded(module) {\n\t                        var isLoaded = regModules.indexOf(module) > -1;\n\t                        if (!isLoaded) {\n\t                            isLoaded = !!moduleExists(module);\n\t                        }\n\t                        return isLoaded;\n\t                    };\n\t                    if (angular.isString(modulesNames)) {\n\t                        modulesNames = [modulesNames];\n\t                    }\n\t                    if (angular.isArray(modulesNames)) {\n\t                        var i, len;\n\t                        for (i = 0, len = modulesNames.length; i < len; i++) {\n\t                            if (!moduleLoaded(modulesNames[i])) {\n\t                                return false;\n\t                            }\n\t                        }\n\t                        return true;\n\t                    } else {\n\t                        throw new Error('You need to define the module(s) name(s)');\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Given a module, return its name\n\t                 * @param module\n\t                 * @returns {String}\n\t                 */\n\t                _getModuleName: getModuleName,\n\t\n\t                /**\n\t                 * Returns a module if it exists\n\t                 * @param moduleName\n\t                 * @returns {module}\n\t                 */\n\t                _getModule: function getModule(moduleName) {\n\t                    try {\n\t                        return ngModuleFct(moduleName);\n\t                    } catch (e) {\n\t                        // this error message really suxx\n\t                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n\t                        }\n\t                        throw e;\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Check if a module exists and returns it if it does\n\t                 * @param moduleName\n\t                 * @returns {boolean}\n\t                 */\n\t                moduleExists: moduleExists,\n\t\n\t                /**\n\t                 * Load the dependencies, and might try to load new files depending on the config\n\t                 * @param moduleName (String or Array of Strings)\n\t                 * @param localParams\n\t                 * @returns {*}\n\t                 * @private\n\t                 */\n\t                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n\t                    var loadedModule,\n\t                        requires,\n\t                        diff,\n\t                        promisesList = [],\n\t                        self = this;\n\t\n\t                    moduleName = self._getModuleName(moduleName);\n\t\n\t                    if (moduleName === null) {\n\t                        return $q.when();\n\t                    } else {\n\t                        try {\n\t                            loadedModule = self._getModule(moduleName);\n\t                        } catch (e) {\n\t                            return reject(e);\n\t                        }\n\t                        // get unloaded requires\n\t                        requires = self.getRequires(loadedModule);\n\t                    }\n\t\n\t                    angular.forEach(requires, function (requireEntry) {\n\t                        // If no configuration is provided, try and find one from a previous load.\n\t                        // If there isn't one, bail and let the normal flow run\n\t                        if (angular.isString(requireEntry)) {\n\t                            var config = self.getModuleConfig(requireEntry);\n\t                            if (config === null) {\n\t                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n\t                                return;\n\t                            }\n\t                            requireEntry = config;\n\t                            // ignore the name because it's probably not a real module name\n\t                            config.name = undefined;\n\t                        }\n\t\n\t                        // Check if this dependency has been loaded previously\n\t                        if (self.moduleExists(requireEntry.name)) {\n\t                            // compare against the already loaded module to see if the new definition adds any new files\n\t                            diff = requireEntry.files.filter(function (n) {\n\t                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n\t                            });\n\t\n\t                            // If the module was redefined, advise via the console\n\t                            if (diff.length !== 0) {\n\t                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n\t                            }\n\t\n\t                            // Push everything to the file loader, it will weed out the duplicates.\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                            return;\n\t                        } else if (angular.isArray(requireEntry)) {\n\t                            var files = [];\n\t                            angular.forEach(requireEntry, function (entry) {\n\t                                // let's check if the entry is a file name or a config name\n\t                                var config = self.getModuleConfig(entry);\n\t                                if (config === null) {\n\t                                    files.push(entry);\n\t                                } else if (config.files) {\n\t                                    files = files.concat(config.files);\n\t                                }\n\t                            });\n\t                            if (files.length > 0) {\n\t                                requireEntry = {\n\t                                    files: files\n\t                                };\n\t                            }\n\t                        } else if (angular.isObject(requireEntry)) {\n\t                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n\t                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n\t                                self.setModuleConfig(requireEntry);\n\t                                moduleCache.push(requireEntry['name']);\n\t                            }\n\t                        }\n\t\n\t                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n\t                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                        }\n\t                    });\n\t\n\t                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n\t                    return $q.all(promisesList);\n\t                },\n\t\n\t                /**\n\t                 * Inject new modules into Angular\n\t                 * @param moduleName\n\t                 * @param localParams\n\t                 * @param real\n\t                 */\n\t                inject: function inject(moduleName) {\n\t                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\t\n\t                    var self = this,\n\t                        deferred = $q.defer();\n\t                    if (angular.isDefined(moduleName) && moduleName !== null) {\n\t                        if (angular.isArray(moduleName)) {\n\t                            var promisesList = [];\n\t                            angular.forEach(moduleName, function (module) {\n\t                                promisesList.push(self.inject(module, localParams, real));\n\t                            });\n\t                            return $q.all(promisesList);\n\t                        } else {\n\t                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n\t                        }\n\t                    }\n\t                    if (modulesToLoad.length > 0) {\n\t                        var res = modulesToLoad.slice(); // clean copy\n\t                        var loadNext = function loadNext(moduleName) {\n\t                            moduleCache.push(moduleName);\n\t                            modulePromises[moduleName] = deferred.promise;\n\t                            self._loadDependencies(moduleName, localParams).then(function success() {\n\t                                try {\n\t                                    justLoaded = [];\n\t                                    _register(providers, moduleCache, localParams);\n\t                                } catch (e) {\n\t                                    self._$log.error(e.message);\n\t                                    deferred.reject(e);\n\t                                    return;\n\t                                }\n\t\n\t                                if (modulesToLoad.length > 0) {\n\t                                    loadNext(modulesToLoad.shift()); // load the next in list\n\t                                } else {\n\t                                        deferred.resolve(res); // everything has been loaded, resolve\n\t                                    }\n\t                            }, function error(err) {\n\t                                deferred.reject(err);\n\t                            });\n\t                        };\n\t\n\t                        // load the first in list\n\t                        loadNext(modulesToLoad.shift());\n\t                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n\t                        return modulePromises[localParams.name];\n\t                    } else {\n\t                        deferred.resolve();\n\t                    }\n\t                    return deferred.promise;\n\t                },\n\t\n\t                /**\n\t                 * Get the list of required modules/services/... for this module\n\t                 * @param module\n\t                 * @returns {Array}\n\t                 */\n\t                getRequires: function getRequires(module) {\n\t                    var requires = [];\n\t                    angular.forEach(module.requires, function (requireModule) {\n\t                        if (regModules.indexOf(requireModule) === -1) {\n\t                            requires.push(requireModule);\n\t                        }\n\t                    });\n\t                    return requires;\n\t                },\n\t\n\t                /**\n\t                 * Invoke the new modules & component by their providers\n\t                 * @param providers\n\t                 * @param queue\n\t                 * @param moduleName\n\t                 * @param reconfig\n\t                 * @private\n\t                 */\n\t                _invokeQueue: _invokeQueue,\n\t\n\t                /**\n\t                 * Check if a module has been invoked and registers it if not\n\t                 * @param args\n\t                 * @param moduleName\n\t                 * @returns {boolean} is new\n\t                 */\n\t                _registerInvokeList: _registerInvokeList,\n\t\n\t                /**\n\t                 * Register a new module and loads it, executing the run/config blocks if needed\n\t                 * @param providers\n\t                 * @param registerModules\n\t                 * @param params\n\t                 * @private\n\t                 */\n\t                _register: _register,\n\t\n\t                /**\n\t                 * Add a module name to the list of modules that will be loaded in the next inject\n\t                 * @param name\n\t                 * @param force\n\t                 * @private\n\t                 */\n\t                _addToLoadList: _addToLoadList,\n\t\n\t                /**\n\t                 * Unregister modules (you shouldn't have to use this)\n\t                 * @param modules\n\t                 */\n\t                _unregister: function _unregister(modules) {\n\t                    if (angular.isDefined(modules)) {\n\t                        if (angular.isArray(modules)) {\n\t                            angular.forEach(modules, function (module) {\n\t                                regInvokes[module] = undefined;\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            };\n\t        }];\n\t\n\t        // Let's get the list of loaded modules & components\n\t        this._init(angular.element(window.document));\n\t    }]);\n\t\n\t    var bootstrapFct = angular.bootstrap;\n\t    angular.bootstrap = function (element, modules, config) {\n\t        // we use slice to make a clean copy\n\t        angular.forEach(modules.slice(), function (module) {\n\t            _addToLoadList(module, true, true);\n\t        });\n\t        return bootstrapFct(element, modules, config);\n\t    };\n\t\n\t    var _addToLoadList = function _addToLoadList(name, force, real) {\n\t        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n\t            modulesToLoad.push(name);\n\t            if (real) {\n\t                realModules.push(name);\n\t            }\n\t        }\n\t    };\n\t\n\t    var ngModuleFct = angular.module;\n\t    angular.module = function (name, requires, configFn) {\n\t        _addToLoadList(name, false, true);\n\t        return ngModuleFct(name, requires, configFn);\n\t    };\n\t\n\t    // CommonJS package manager support:\n\t    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n\t        module.exports = 'oc.lazyLoad';\n\t    }\n\t})(angular, window);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\n\t        return {\n\t            restrict: 'A',\n\t            terminal: true,\n\t            priority: 1000,\n\t            compile: function compile(element, attrs) {\n\t                // we store the content and remove it before compilation\n\t                var content = element[0].innerHTML;\n\t                element.html('');\n\t\n\t                return function ($scope, $element, $attr) {\n\t                    var model = $parse($attr.ocLazyLoad);\n\t                    $scope.$watch(function () {\n\t                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n\t                    }, function (moduleName) {\n\t                        if (angular.isDefined(moduleName)) {\n\t                            $ocLazyLoad.load(moduleName).then(function () {\n\t                                // Attach element contents to DOM and then compile them.\n\t                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\n\t                                // of the compiled contents when attaching to the parent DOM.\n\t                                $animate.enter(content, $element);\n\t                                // get the new content & compile it\n\t                                $compile($element.contents())($scope);\n\t                            });\n\t                        }\n\t                    }, true);\n\t                };\n\t            }\n\t        };\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n\t            var uaCssChecked = false,\n\t                useCssLoadPatch = false,\n\t                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\t\n\t            /**\r\n\t             * Load a js/css file\r\n\t             * @param type\r\n\t             * @param path\r\n\t             * @param params\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.buildElement = function buildElement(type, path, params) {\n\t                var deferred = $q.defer(),\n\t                    el,\n\t                    loaded,\n\t                    filesCache = $delegate._getFilesCache(),\n\t                    cacheBuster = function cacheBuster(url) {\n\t                    var dc = new Date().getTime();\n\t                    if (url.indexOf('?') >= 0) {\n\t                        if (url.substring(0, url.length - 1) === '&') {\n\t                            return url + '_dc=' + dc;\n\t                        }\n\t                        return url + '&_dc=' + dc;\n\t                    } else {\n\t                        return url + '?_dc=' + dc;\n\t                    }\n\t                };\n\t\n\t                // Store the promise early so the file load can be detected by other parallel lazy loads\n\t                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n\t                // as it causes false positive load results.\n\t                if (angular.isUndefined(filesCache.get(path))) {\n\t                    filesCache.put(path, deferred.promise);\n\t                }\n\t\n\t                // Switch in case more content types are added later\n\t                switch (type) {\n\t                    case 'css':\n\t                        el = $window.document.createElement('link');\n\t                        el.type = 'text/css';\n\t                        el.rel = 'stylesheet';\n\t                        el.href = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    case 'js':\n\t                        el = $window.document.createElement('script');\n\t                        el.src = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    default:\n\t                        filesCache.remove(path);\n\t                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n\t                        break;\n\t                }\n\t                el.onload = el['onreadystatechange'] = function (e) {\n\t                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n\t                    el.onload = el['onreadystatechange'] = null;\n\t                    loaded = 1;\n\t                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n\t                    deferred.resolve();\n\t                };\n\t                el.onerror = function () {\n\t                    filesCache.remove(path);\n\t                    deferred.reject(new Error('Unable to load ' + path));\n\t                };\n\t                el.async = params.serie ? 0 : 1;\n\t\n\t                var insertBeforeElem = anchor.lastChild;\n\t                if (params.insertBefore) {\n\t                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n\t                    if (element && element.length > 0) {\n\t                        insertBeforeElem = element[0];\n\t                    }\n\t                }\n\t                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\t\n\t                /*\r\n\t                 The event load or readystatechange doesn't fire in:\r\n\t                 - iOS < 6       (default mobile browser)\r\n\t                 - Android < 4.4 (default mobile browser)\r\n\t                 - Safari < 6    (desktop browser)\r\n\t                 */\n\t                if (type == 'css') {\n\t                    if (!uaCssChecked) {\n\t                        var ua = $window.navigator.userAgent.toLowerCase();\n\t\n\t                        // iOS < 6\n\t                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n\t                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n\t                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n\t                            useCssLoadPatch = iOSVersion < 6;\n\t                        } else if (ua.indexOf(\"android\") > -1) {\n\t                            // Android < 4.4\n\t                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n\t                            useCssLoadPatch = androidVersion < 4.4;\n\t                        } else if (ua.indexOf('safari') > -1) {\n\t                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n\t                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n\t                        }\n\t                    }\n\t\n\t                    if (useCssLoadPatch) {\n\t                        var tries = 1000; // * 20 = 20000 miliseconds\n\t                        var interval = $interval(function () {\n\t                            try {\n\t                                el.sheet.cssRules;\n\t                                $interval.cancel(interval);\n\t                                el.onload();\n\t                            } catch (e) {\n\t                                if (--tries <= 0) {\n\t                                    el.onerror();\n\t                                }\n\t                            }\n\t                        }, 20);\n\t                    }\n\t                }\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\r\n\t             * The function that loads new files\r\n\t             * @param config\r\n\t             * @param params\r\n\t             * @returns {*}\r\n\t             */\n\t            $delegate.filesLoader = function filesLoader(config) {\n\t                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var cssFiles = [],\n\t                    templatesFiles = [],\n\t                    jsFiles = [],\n\t                    promises = [],\n\t                    cachePromise = null,\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                $delegate.toggleWatch(true); // start watching angular.module calls\n\t\n\t                angular.extend(params, config);\n\t\n\t                var pushFile = function pushFile(path) {\n\t                    var file_type = null,\n\t                        m;\n\t                    if (angular.isObject(path)) {\n\t                        file_type = path.type;\n\t                        path = path.path;\n\t                    }\n\t                    cachePromise = filesCache.get(path);\n\t                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\t\n\t                        // always check for requirejs syntax just in case\n\t                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n\t                            // Detect file type using preceding type declaration (ala requireJS)\n\t                            file_type = m[1];\n\t                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n\t                        }\n\t\n\t                        if (!file_type) {\n\t                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n\t                                // Detect file type via file extension\n\t                                file_type = m[1];\n\t                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\n\t                                // requirejs\n\t                                file_type = 'js';\n\t                            } else {\n\t                                $delegate._$log.error('File type could not be determined. ' + path);\n\t                                return;\n\t                            }\n\t                        }\n\t\n\t                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n\t                            cssFiles.push(path);\n\t                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n\t                            templatesFiles.push(path);\n\t                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n\t                            jsFiles.push(path);\n\t                        } else {\n\t                            $delegate._$log.error('File type is not valid. ' + path);\n\t                        }\n\t                    } else if (cachePromise) {\n\t                        promises.push(cachePromise);\n\t                    }\n\t                };\n\t\n\t                if (params.serie) {\n\t                    pushFile(params.files.shift());\n\t                } else {\n\t                    angular.forEach(params.files, function (path) {\n\t                        pushFile(path);\n\t                    });\n\t                }\n\t\n\t                if (cssFiles.length > 0) {\n\t                    var cssDeferred = $q.defer();\n\t                    $delegate.cssLoader(cssFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            cssDeferred.reject(err);\n\t                        } else {\n\t                            cssDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(cssDeferred.promise);\n\t                }\n\t\n\t                if (templatesFiles.length > 0) {\n\t                    var templatesDeferred = $q.defer();\n\t                    $delegate.templatesLoader(templatesFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            templatesDeferred.reject(err);\n\t                        } else {\n\t                            templatesDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(templatesDeferred.promise);\n\t                }\n\t\n\t                if (jsFiles.length > 0) {\n\t                    var jsDeferred = $q.defer();\n\t                    $delegate.jsLoader(jsFiles, function (err) {\n\t                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\n\t                            $delegate._$log.error(err);\n\t                            jsDeferred.reject(err);\n\t                        } else {\n\t                            jsDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(jsDeferred.promise);\n\t                }\n\t\n\t                if (promises.length === 0) {\n\t                    var deferred = $q.defer(),\n\t                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n\t                    $delegate._$log.error(err);\n\t                    deferred.reject(err);\n\t                    return deferred.promise;\n\t                } else if (params.serie && params.files.length > 0) {\n\t                    return $q.all(promises).then(function () {\n\t                        return $delegate.filesLoader(config, params);\n\t                    });\n\t                } else {\n\t                    return $q.all(promises)['finally'](function (res) {\n\t                        $delegate.toggleWatch(false); // stop watching angular.module calls\n\t                        return res;\n\t                    });\n\t                }\n\t            };\n\t\n\t            /**\r\n\t             * Load a module or a list of modules into Angular\r\n\t             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n\t             * @param params Object optional parameters\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.load = function (originalModule) {\n\t                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var self = this,\n\t                    config = null,\n\t                    deferredList = [],\n\t                    deferred = $q.defer(),\n\t                    errText;\n\t\n\t                // clean copy\n\t                var module = angular.copy(originalModule);\n\t                var params = angular.copy(originalParams);\n\t\n\t                // If module is an array, break it down\n\t                if (angular.isArray(module)) {\n\t                    // Resubmit each entry as a single module\n\t                    angular.forEach(module, function (m) {\n\t                        deferredList.push(self.load(m, params));\n\t                    });\n\t\n\t                    // Resolve the promise once everything has loaded\n\t                    $q.all(deferredList).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t\n\t                    return deferred.promise;\n\t                }\n\t\n\t                // Get or Set a configuration depending on what was passed in\n\t                if (angular.isString(module)) {\n\t                    config = self.getModuleConfig(module);\n\t                    if (!config) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    }\n\t                } else if (angular.isObject(module)) {\n\t                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n\t                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    } else {\n\t                        config = self.setModuleConfig(module);\n\t                    }\n\t                }\n\t\n\t                if (config === null) {\n\t                    var moduleName = self._getModuleName(module);\n\t                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n\t                    $delegate._$log.error(errText);\n\t                    deferred.reject(new Error(errText));\n\t                    return deferred.promise;\n\t                } else {\n\t                    // deprecated\n\t                    if (angular.isDefined(config.template)) {\n\t                        if (angular.isUndefined(config.files)) {\n\t                            config.files = [];\n\t                        }\n\t                        if (angular.isString(config.template)) {\n\t                            config.files.push(config.template);\n\t                        } else if (angular.isArray(config.template)) {\n\t                            config.files.concat(config.template);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                var localParams = angular.extend({}, params, config);\n\t\n\t                // if someone used an external loader and called the load function with just the module name\n\t                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n\t                    return $delegate.inject(config.name, localParams, true);\n\t                }\n\t\n\t                $delegate.filesLoader(config, localParams).then(function () {\n\t                    $delegate.inject(null, localParams).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t                }, function (err) {\n\t                    deferred.reject(err);\n\t                });\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            // return the patched service\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * cssLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite cssLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.cssLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('css', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.cssLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * jsLoader function\n\t             * @type Function\n\t             * @param paths array list of js files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite jsLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.jsLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('js', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.jsLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n\t            /**\n\t             * templatesLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters for $http\n\t             * because the user can overwrite templatesLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.templatesLoader = function (paths, callback, params) {\n\t                var promises = [],\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                angular.forEach(paths, function (url) {\n\t                    var deferred = $q.defer();\n\t                    promises.push(deferred.promise);\n\t                    $http.get(url, params).success(function (data) {\n\t                        if (angular.isString(data) && data.length > 0) {\n\t                            angular.forEach(angular.element(data), function (node) {\n\t                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n\t                                    $templateCache.put(node.id, node.innerHTML);\n\t                                }\n\t                            });\n\t                        }\n\t                        if (angular.isUndefined(filesCache.get(url))) {\n\t                            filesCache.put(url, true);\n\t                        }\n\t                        deferred.resolve();\n\t                    }).error(function (err) {\n\t                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n\t                    });\n\t                });\n\t                return $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t// Array.indexOf polyfill for IE8\n\tif (!Array.prototype.indexOf) {\n\t    Array.prototype.indexOf = function (searchElement, fromIndex) {\n\t        var k;\n\t\n\t        // 1. Let O be the result of calling ToObject passing\n\t        //    the this value as the argument.\n\t        if (this == null) {\n\t            throw new TypeError('\"this\" is null or not defined');\n\t        }\n\t\n\t        var O = Object(this);\n\t\n\t        // 2. Let lenValue be the result of calling the Get\n\t        //    internal method of O with the argument \"length\".\n\t        // 3. Let len be ToUint32(lenValue).\n\t        var len = O.length >>> 0;\n\t\n\t        // 4. If len is 0, return -1.\n\t        if (len === 0) {\n\t            return -1;\n\t        }\n\t\n\t        // 5. If argument fromIndex was passed let n be\n\t        //    ToInteger(fromIndex); else let n be 0.\n\t        var n = +fromIndex || 0;\n\t\n\t        if (Math.abs(n) === Infinity) {\n\t            n = 0;\n\t        }\n\t\n\t        // 6. If n >= len, return -1.\n\t        if (n >= len) {\n\t            return -1;\n\t        }\n\t\n\t        // 7. If n >= 0, then Let k be n.\n\t        // 8. Else, n<0, Let k be len - abs(n).\n\t        //    If k is less than 0, then let k be 0.\n\t        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\t\n\t        // 9. Repeat, while k < len\n\t        while (k < len) {\n\t            // a. Let Pk be ToString(k).\n\t            //   This is implicit for LHS operands of the in operator\n\t            // b. Let kPresent be the result of calling the\n\t            //    HasProperty internal method of O with argument Pk.\n\t            //   This step can be combined with c\n\t            // c. If kPresent is true, then\n\t            //    i.  Let elementK be the result of calling the Get\n\t            //        internal method of O with the argument ToString(k).\n\t            //   ii.  Let same be the result of applying the\n\t            //        Strict Equality Comparison Algorithm to\n\t            //        searchElement and elementK.\n\t            //  iii.  If same is true, return k.\n\t            if (k in O && O[k] === searchElement) {\n\t                return k;\n\t            }\n\t            k++;\n\t        }\n\t        return -1;\n\t    };\n\t}\n\n/***/ },\n\n/***/ 14:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */\n\t;(function(root) {\n\t\n\t\t// Detect free variables `exports`\n\t\tvar freeExports = typeof exports == 'object' && exports;\n\t\n\t\t// Detect free variable `module`\n\t\tvar freeModule = typeof module == 'object' && module &&\n\t\t\tmodule.exports == freeExports && module;\n\t\n\t\t// Detect free variable `global`, from Node.js or Browserified code,\n\t\t// and use it as `root`\n\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\t\troot = freeGlobal;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\n\t\t// Taken from https://mths.be/punycode\n\t\tfunction ucs2decode(string) {\n\t\t\tvar output = [];\n\t\t\tvar counter = 0;\n\t\t\tvar length = string.length;\n\t\t\tvar value;\n\t\t\tvar extra;\n\t\t\twhile (counter < length) {\n\t\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\t\toutput.push(value);\n\t\t\t\t\t\tcounter--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\t// Taken from https://mths.be/punycode\n\t\tfunction ucs2encode(array) {\n\t\t\tvar length = array.length;\n\t\t\tvar index = -1;\n\t\t\tvar value;\n\t\t\tvar output = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvalue = array[index];\n\t\t\t\tif (value > 0xFFFF) {\n\t\t\t\t\tvalue -= 0x10000;\n\t\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t\t}\n\t\t\t\toutput += stringFromCharCode(value);\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\tfunction checkScalarValue(codePoint) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t\t' is not a scalar value'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tfunction createByte(codePoint, shift) {\n\t\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t\t}\n\t\n\t\tfunction encodeCodePoint(codePoint) {\n\t\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\t\treturn stringFromCharCode(codePoint);\n\t\t\t}\n\t\t\tvar symbol = '';\n\t\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t\t}\n\t\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\t\tsymbol += createByte(codePoint, 6);\n\t\t\t}\n\t\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\t\tsymbol += createByte(codePoint, 6);\n\t\t\t}\n\t\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\t\treturn symbol;\n\t\t}\n\t\n\t\tfunction utf8encode(string) {\n\t\t\tvar codePoints = ucs2decode(string);\n\t\t\tvar length = codePoints.length;\n\t\t\tvar index = -1;\n\t\t\tvar codePoint;\n\t\t\tvar byteString = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tcodePoint = codePoints[index];\n\t\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t\t}\n\t\t\treturn byteString;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tfunction readContinuationByte() {\n\t\t\tif (byteIndex >= byteCount) {\n\t\t\t\tthrow Error('Invalid byte index');\n\t\t\t}\n\t\n\t\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\t\tbyteIndex++;\n\t\n\t\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\t\treturn continuationByte & 0x3F;\n\t\t\t}\n\t\n\t\t\t// If we end up here, its not a continuation byte\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t\n\t\tfunction decodeSymbol() {\n\t\t\tvar byte1;\n\t\t\tvar byte2;\n\t\t\tvar byte3;\n\t\t\tvar byte4;\n\t\t\tvar codePoint;\n\t\n\t\t\tif (byteIndex > byteCount) {\n\t\t\t\tthrow Error('Invalid byte index');\n\t\t\t}\n\t\n\t\t\tif (byteIndex == byteCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\t// Read first byte\n\t\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\t\tbyteIndex++;\n\t\n\t\t\t// 1-byte sequence (no continuation bytes)\n\t\t\tif ((byte1 & 0x80) == 0) {\n\t\t\t\treturn byte1;\n\t\t\t}\n\t\n\t\t\t// 2-byte sequence\n\t\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\t\tvar byte2 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\t\tif (codePoint >= 0x80) {\n\t\t\t\t\treturn codePoint;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\t\tbyte2 = readContinuationByte();\n\t\t\t\tbyte3 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\t\treturn codePoint;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// 4-byte sequence\n\t\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\t\tbyte2 = readContinuationByte();\n\t\t\t\tbyte3 = readContinuationByte();\n\t\t\t\tbyte4 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\t\treturn codePoint;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthrow Error('Invalid UTF-8 detected');\n\t\t}\n\t\n\t\tvar byteArray;\n\t\tvar byteCount;\n\t\tvar byteIndex;\n\t\tfunction utf8decode(byteString) {\n\t\t\tbyteArray = ucs2decode(byteString);\n\t\t\tbyteCount = byteArray.length;\n\t\t\tbyteIndex = 0;\n\t\t\tvar codePoints = [];\n\t\t\tvar tmp;\n\t\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\t\tcodePoints.push(tmp);\n\t\t\t}\n\t\t\treturn ucs2encode(codePoints);\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tvar utf8 = {\n\t\t\t'version': '2.0.0',\n\t\t\t'encode': utf8encode,\n\t\t\t'decode': utf8decode\n\t\t};\n\t\n\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t// like the following:\n\t\tif (\n\t\t\ttrue\n\t\t) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn utf8;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\t\tfreeModule.exports = utf8;\n\t\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\t\tvar object = {};\n\t\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\t\tfor (var key in utf8) {\n\t\t\t\t\thasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // in Rhino or a web browser\n\t\t\troot.utf8 = utf8;\n\t\t}\n\t\n\t}(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(131)(module), (function() { return this; }())))\n\n/***/ },\n\n/***/ 15:\n/***/ function(module, exports) {\n\n\t'use strict';\n\tangular.module(\"ngLocale\", [], [\"$provide\", function($provide) {\n\tvar PLURAL_CATEGORY = {ZERO: \"zero\", ONE: \"one\", TWO: \"two\", FEW: \"few\", MANY: \"many\", OTHER: \"other\"};\n\tfunction getDecimals(n) {\n\t  n = n + '';\n\t  var i = n.indexOf('.');\n\t  return (i == -1) ? 0 : n.length - i - 1;\n\t}\n\t\n\tfunction getVF(n, opt_precision) {\n\t  var v = opt_precision;\n\t\n\t  if (undefined === v) {\n\t    v = Math.min(getDecimals(n), 3);\n\t  }\n\t\n\t  var base = Math.pow(10, v);\n\t  var f = ((n * base) | 0) % base;\n\t  return {v: v, f: f};\n\t}\n\t\n\t$provide.value(\"$locale\", {\n\t  \"DATETIME_FORMATS\": {\n\t    \"AMPMS\": [\n\t      \"vorm.\",\n\t      \"nachm.\"\n\t    ],\n\t    \"DAY\": [\n\t      \"Sonntag\",\n\t      \"Montag\",\n\t      \"Dienstag\",\n\t      \"Mittwoch\",\n\t      \"Donnerstag\",\n\t      \"Freitag\",\n\t      \"Samstag\"\n\t    ],\n\t    \"ERANAMES\": [\n\t      \"v. Chr.\",\n\t      \"n. Chr.\"\n\t    ],\n\t    \"ERAS\": [\n\t      \"v. Chr.\",\n\t      \"n. Chr.\"\n\t    ],\n\t    \"FIRSTDAYOFWEEK\": 0,\n\t    \"MONTH\": [\n\t      \"Januar\",\n\t      \"Februar\",\n\t      \"M\\u00e4rz\",\n\t      \"April\",\n\t      \"Mai\",\n\t      \"Juni\",\n\t      \"Juli\",\n\t      \"August\",\n\t      \"September\",\n\t      \"Oktober\",\n\t      \"November\",\n\t      \"Dezember\"\n\t    ],\n\t    \"SHORTDAY\": [\n\t      \"So.\",\n\t      \"Mo.\",\n\t      \"Di.\",\n\t      \"Mi.\",\n\t      \"Do.\",\n\t      \"Fr.\",\n\t      \"Sa.\"\n\t    ],\n\t    \"SHORTMONTH\": [\n\t      \"Jan.\",\n\t      \"Feb.\",\n\t      \"M\\u00e4rz\",\n\t      \"Apr.\",\n\t      \"Mai\",\n\t      \"Juni\",\n\t      \"Juli\",\n\t      \"Aug.\",\n\t      \"Sep.\",\n\t      \"Okt.\",\n\t      \"Nov.\",\n\t      \"Dez.\"\n\t    ],\n\t    \"STANDALONEMONTH\": [\n\t      \"Januar\",\n\t      \"Februar\",\n\t      \"M\\u00e4rz\",\n\t      \"April\",\n\t      \"Mai\",\n\t      \"Juni\",\n\t      \"Juli\",\n\t      \"August\",\n\t      \"September\",\n\t      \"Oktober\",\n\t      \"November\",\n\t      \"Dezember\"\n\t    ],\n\t    \"WEEKENDRANGE\": [\n\t      5,\n\t      6\n\t    ],\n\t    \"fullDate\": \"EEEE, d. MMMM y\",\n\t    \"longDate\": \"d. MMMM y\",\n\t    \"medium\": \"dd.MM.y HH:mm:ss\",\n\t    \"mediumDate\": \"dd.MM.y\",\n\t    \"mediumTime\": \"HH:mm:ss\",\n\t    \"short\": \"dd.MM.yy HH:mm\",\n\t    \"shortDate\": \"dd.MM.yy\",\n\t    \"shortTime\": \"HH:mm\"\n\t  },\n\t  \"NUMBER_FORMATS\": {\n\t    \"CURRENCY_SYM\": \"\\u20ac\",\n\t    \"DECIMAL_SEP\": \",\",\n\t    \"GROUP_SEP\": \".\",\n\t    \"PATTERNS\": [\n\t      {\n\t        \"gSize\": 3,\n\t        \"lgSize\": 3,\n\t        \"maxFrac\": 3,\n\t        \"minFrac\": 0,\n\t        \"minInt\": 1,\n\t        \"negPre\": \"-\",\n\t        \"negSuf\": \"\",\n\t        \"posPre\": \"\",\n\t        \"posSuf\": \"\"\n\t      },\n\t      {\n\t        \"gSize\": 3,\n\t        \"lgSize\": 3,\n\t        \"maxFrac\": 2,\n\t        \"minFrac\": 2,\n\t        \"minInt\": 1,\n\t        \"negPre\": \"-\",\n\t        \"negSuf\": \"\\u00a0\\u00a4\",\n\t        \"posPre\": \"\",\n\t        \"posSuf\": \"\\u00a0\\u00a4\"\n\t      }\n\t    ]\n\t  },\n\t  \"id\": \"de-de\",\n\t  \"pluralCat\": function(n, opt_precision) {  var i = n | 0;  var vf = getVF(n, opt_precision);  if (i == 1 && vf.v == 0) {    return PLURAL_CATEGORY.ONE;  }  return PLURAL_CATEGORY.OTHER;}\n\t});\n\t}]);\n\n\n/***/ },\n\n/***/ 16:\n/***/ function(module, exports) {\n\n\t/*\n\t * angular-ui-bootstrap\n\t * http://angular-ui.github.io/bootstrap/\n\t\n\t * Version: 1.1.2 - 2016-02-01\n\t * License: MIT\n\t */angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.debounce\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\n\tangular.module(\"ui.bootstrap.tpls\", [\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/popup.html\",\"uib/template/datepicker/year.html\",\"uib/template/modal/backdrop.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]);\n\tangular.module('ui.bootstrap.collapse', [])\n\t\n\t  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {\n\t    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n\t    return {\n\t      link: function(scope, element, attrs) {\n\t        var expandingExpr = $parse(attrs.expanding),\n\t            expandedExpr = $parse(attrs.expanded),\n\t            collapsingExpr = $parse(attrs.collapsing),\n\t            collapsedExpr = $parse(attrs.collapsed);\n\t\n\t        if (!scope.$eval(attrs.uibCollapse)) {\n\t          element.addClass('in')\n\t            .addClass('collapse')\n\t            .attr('aria-expanded', true)\n\t            .attr('aria-hidden', false)\n\t            .css({height: 'auto'});\n\t        }\n\t\n\t        function expand() {\n\t          if (element.hasClass('collapse') && element.hasClass('in')) {\n\t            return;\n\t          }\n\t\n\t          $q.resolve(expandingExpr(scope))\n\t            .then(function() {\n\t              element.removeClass('collapse')\n\t                .addClass('collapsing')\n\t                .attr('aria-expanded', true)\n\t                .attr('aria-hidden', false);\n\t\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  addClass: 'in',\n\t                  easing: 'ease',\n\t                  to: { height: element[0].scrollHeight + 'px' }\n\t                }).start()['finally'](expandDone);\n\t              } else {\n\t                $animate.addClass(element, 'in', {\n\t                  to: { height: element[0].scrollHeight + 'px' }\n\t                }).then(expandDone);\n\t              }\n\t            });\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse')\n\t            .css({height: 'auto'});\n\t          expandedExpr(scope);\n\t        }\n\t\n\t        function collapse() {\n\t          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n\t            return collapseDone();\n\t          }\n\t\n\t          $q.resolve(collapsingExpr(scope))\n\t            .then(function() {\n\t              element\n\t                // IMPORTANT: The height must be set before adding \"collapsing\" class.\n\t                // Otherwise, the browser attempts to animate from height 0 (in\n\t                // collapsing class) to the given height here.\n\t                .css({height: element[0].scrollHeight + 'px'})\n\t                // initially all panel collapse have the collapse class, this removal\n\t                // prevents the animation from jumping to collapsed state\n\t                .removeClass('collapse')\n\t                .addClass('collapsing')\n\t                .attr('aria-expanded', false)\n\t                .attr('aria-hidden', true);\n\t\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  removeClass: 'in',\n\t                  to: {height: '0'}\n\t                }).start()['finally'](collapseDone);\n\t              } else {\n\t                $animate.removeClass(element, 'in', {\n\t                  to: {height: '0'}\n\t                }).then(collapseDone);\n\t              }\n\t            });\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse');\n\t          collapsedExpr(scope);\n\t        }\n\t\n\t        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\t\n\t.constant('uibAccordionConfig', {\n\t  closeOthers: true\n\t})\n\t\n\t.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n\t  // This array keeps track of the accordion groups\n\t  this.groups = [];\n\t\n\t  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n\t  this.closeOthers = function(openGroup) {\n\t    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n\t      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n\t    if (closeOthers) {\n\t      angular.forEach(this.groups, function(group) {\n\t        if (group !== openGroup) {\n\t          group.isOpen = false;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  // This is called from the accordion-group directive to add itself to the accordion\n\t  this.addGroup = function(groupScope) {\n\t    var that = this;\n\t    this.groups.push(groupScope);\n\t\n\t    groupScope.$on('$destroy', function(event) {\n\t      that.removeGroup(groupScope);\n\t    });\n\t  };\n\t\n\t  // This is called from the accordion-group directive when to remove itself\n\t  this.removeGroup = function(group) {\n\t    var index = this.groups.indexOf(group);\n\t    if (index !== -1) {\n\t      this.groups.splice(index, 1);\n\t    }\n\t  };\n\t}])\n\t\n\t// The accordion directive simply sets up the directive controller\n\t// and adds an accordion CSS class to itself element.\n\t.directive('uibAccordion', function() {\n\t  return {\n\t    controller: 'UibAccordionController',\n\t    controllerAs: 'accordion',\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/accordion/accordion.html';\n\t    }\n\t  };\n\t})\n\t\n\t// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n\t.directive('uibAccordionGroup', function() {\n\t  return {\n\t    require: '^uibAccordion',         // We need this directive to be inside an accordion\n\t    transclude: true,              // It transcludes the contents of the directive into the template\n\t    replace: true,                // The element containing the directive will be replaced with the template\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';\n\t    },\n\t    scope: {\n\t      heading: '@',               // Interpolate the heading attribute onto this scope\n\t      isOpen: '=?',\n\t      isDisabled: '=?'\n\t    },\n\t    controller: function() {\n\t      this.setHeading = function(element) {\n\t        this.heading = element;\n\t      };\n\t    },\n\t    link: function(scope, element, attrs, accordionCtrl) {\n\t      accordionCtrl.addGroup(scope);\n\t\n\t      scope.openClass = attrs.openClass || 'panel-open';\n\t      scope.panelClass = attrs.panelClass || 'panel-default';\n\t      scope.$watch('isOpen', function(value) {\n\t        element.toggleClass(scope.openClass, !!value);\n\t        if (value) {\n\t          accordionCtrl.closeOthers(scope);\n\t        }\n\t      });\n\t\n\t      scope.toggleOpen = function($event) {\n\t        if (!scope.isDisabled) {\n\t          if (!$event || $event.which === 32) {\n\t            scope.isOpen = !scope.isOpen;\n\t          }\n\t        }\n\t      };\n\t\n\t      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t      scope.headingId = id + '-tab';\n\t      scope.panelId = id + '-panel';\n\t    }\n\t  };\n\t})\n\t\n\t// Use accordion-heading below an accordion-group to provide a heading containing HTML\n\t.directive('uibAccordionHeading', function() {\n\t  return {\n\t    transclude: true,   // Grab the contents to be used as the heading\n\t    template: '',       // In effect remove this element!\n\t    replace: true,\n\t    require: '^uibAccordionGroup',\n\t    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n\t      // Pass the heading to the accordion-group controller\n\t      // so that it can be transcluded into the right place in the template\n\t      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n\t    }\n\t  };\n\t})\n\t\n\t// Use in the accordion-group template to indicate where you want the heading to be transcluded\n\t// You must provide the property on the accordion-group controller that will hold the transcluded element\n\t.directive('uibAccordionTransclude', function() {\n\t  return {\n\t    require: '^uibAccordionGroup',\n\t    link: function(scope, element, attrs, controller) {\n\t      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n\t        if (heading) {\n\t          element.find('span').html('');\n\t          element.find('span').append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.alert', [])\n\t\n\t.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n\t  $scope.closeable = !!$attrs.close;\n\t\n\t  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n\t    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\t\n\t  if (dismissOnTimeout) {\n\t    $timeout(function() {\n\t      $scope.close();\n\t    }, parseInt(dismissOnTimeout, 10));\n\t  }\n\t}])\n\t\n\t.directive('uibAlert', function() {\n\t  return {\n\t    controller: 'UibAlertController',\n\t    controllerAs: 'alert',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/alert/alert.html';\n\t    },\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@',\n\t      close: '&'\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.buttons', [])\n\t\n\t.constant('uibButtonConfig', {\n\t  activeClass: 'active',\n\t  toggleEvent: 'click'\n\t})\n\t\n\t.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n\t  this.activeClass = buttonConfig.activeClass || 'active';\n\t  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n\t}])\n\t\n\t.directive('uibBtnRadio', ['$parse', function($parse) {\n\t  return {\n\t    require: ['uibBtnRadio', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'buttons',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      var uncheckableExpr = $parse(attrs.uibUncheckable);\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n\t            ngModelCtrl.$render();\n\t          });\n\t        }\n\t      });\n\t\n\t      if (attrs.uibUncheckable) {\n\t        scope.$watch(uncheckableExpr, function(uncheckable) {\n\t          attrs.$set('uncheckable', uncheckable ? '' : null);\n\t        });\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibBtnCheckbox', function() {\n\t  return {\n\t    require: ['uibBtnCheckbox', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'button',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      function getTrueValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t      }\n\t\n\t      function getFalseValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t      }\n\t\n\t      function getCheckboxValue(attribute, defaultValue) {\n\t        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n\t      }\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        scope.$apply(function() {\n\t          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t          ngModelCtrl.$render();\n\t        });\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.carousel', [])\n\t\n\t.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {\n\t  var self = this,\n\t    slides = self.slides = $scope.slides = [],\n\t    SLIDE_DIRECTION = 'uib-slideDirection',\n\t    currentIndex = -1,\n\t    currentInterval, isPlaying, bufferedTransitions = [];\n\t  self.currentSlide = null;\n\t\n\t  var destroyed = false;\n\t\n\t  self.addSlide = function(slide, element) {\n\t    slide.$element = element;\n\t    slides.push(slide);\n\t    //if this is the first slide or the slide is set to active, select it\n\t    if (slides.length === 1 || slide.active) {\n\t      if ($scope.$currentTransition) {\n\t        $scope.$currentTransition = null;\n\t      }\n\t\n\t      self.select(slides[slides.length - 1]);\n\t      if (slides.length === 1) {\n\t        $scope.play();\n\t      }\n\t    } else {\n\t      slide.active = false;\n\t    }\n\t  };\n\t\n\t  self.getCurrentIndex = function() {\n\t    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {\n\t      return +self.currentSlide.index;\n\t    }\n\t    return currentIndex;\n\t  };\n\t\n\t  self.next = $scope.next = function() {\n\t    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\t\n\t    if (newIndex === 0 && $scope.noWrap()) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(getSlideByIndex(newIndex), 'next');\n\t  };\n\t\n\t  self.prev = $scope.prev = function() {\n\t    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\t\n\t    if ($scope.noWrap() && newIndex === slides.length - 1) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(getSlideByIndex(newIndex), 'prev');\n\t  };\n\t\n\t  self.removeSlide = function(slide) {\n\t    if (angular.isDefined(slide.index)) {\n\t      slides.sort(function(a, b) {\n\t        return +a.index > +b.index;\n\t      });\n\t    }\n\t\n\t    var bufferedIndex = bufferedTransitions.indexOf(slide);\n\t    if (bufferedIndex !== -1) {\n\t      bufferedTransitions.splice(bufferedIndex, 1);\n\t    }\n\t    //get the index of the slide inside the carousel\n\t    var index = slides.indexOf(slide);\n\t    slides.splice(index, 1);\n\t    $timeout(function() {\n\t      if (slides.length > 0 && slide.active) {\n\t        if (index >= slides.length) {\n\t          self.select(slides[index - 1]);\n\t        } else {\n\t          self.select(slides[index]);\n\t        }\n\t      } else if (currentIndex > index) {\n\t        currentIndex--;\n\t      }\n\t    });\n\t\n\t    //clean the currentSlide when no more slide\n\t    if (slides.length === 0) {\n\t      self.currentSlide = null;\n\t      clearBufferedTransitions();\n\t    }\n\t  };\n\t\n\t  /* direction: \"prev\" or \"next\" */\n\t  self.select = $scope.select = function(nextSlide, direction) {\n\t    var nextIndex = $scope.indexOfSlide(nextSlide);\n\t    //Decide direction if it's not given\n\t    if (direction === undefined) {\n\t      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n\t    }\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {\n\t      goNext(nextSlide, nextIndex, direction);\n\t    } else if (nextSlide && nextSlide !== self.currentSlide && $scope.$currentTransition) {\n\t      bufferedTransitions.push(nextSlide);\n\t      nextSlide.active = false;\n\t    }\n\t  };\n\t\n\t  /* Allow outside people to call indexOf on slides array */\n\t  $scope.indexOfSlide = function(slide) {\n\t    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);\n\t  };\n\t\n\t  $scope.isActive = function(slide) {\n\t    return self.currentSlide === slide;\n\t  };\n\t\n\t  $scope.pause = function() {\n\t    if (!$scope.noPause) {\n\t      isPlaying = false;\n\t      resetTimer();\n\t    }\n\t  };\n\t\n\t  $scope.play = function() {\n\t    if (!isPlaying) {\n\t      isPlaying = true;\n\t      restartTimer();\n\t    }\n\t  };\n\t\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t    resetTimer();\n\t  });\n\t\n\t  $scope.$watch('noTransition', function(noTransition) {\n\t    $animate.enabled($element, !noTransition);\n\t  });\n\t\n\t  $scope.$watch('interval', restartTimer);\n\t\n\t  $scope.$watchCollection('slides', resetTransition);\n\t\n\t  function clearBufferedTransitions() {\n\t    while (bufferedTransitions.length) {\n\t      bufferedTransitions.shift();\n\t    }\n\t  }\n\t\n\t  function getSlideByIndex(index) {\n\t    if (angular.isUndefined(slides[index].index)) {\n\t      return slides[index];\n\t    }\n\t    for (var i = 0, l = slides.length; i < l; ++i) {\n\t      if (slides[i].index === index) {\n\t        return slides[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  function goNext(slide, index, direction) {\n\t    if (destroyed) { return; }\n\t\n\t    angular.extend(slide, {direction: direction, active: true});\n\t    angular.extend(self.currentSlide || {}, {direction: direction, active: false});\n\t    if ($animate.enabled($element) && !$scope.$currentTransition &&\n\t      slide.$element && self.slides.length > 1) {\n\t      slide.$element.data(SLIDE_DIRECTION, slide.direction);\n\t      if (self.currentSlide && self.currentSlide.$element) {\n\t        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);\n\t      }\n\t\n\t      $scope.$currentTransition = true;\n\t      $animate.on('addClass', slide.$element, function(element, phase) {\n\t        if (phase === 'close') {\n\t          $scope.$currentTransition = null;\n\t          $animate.off('addClass', element);\n\t          if (bufferedTransitions.length) {\n\t            var nextSlide = bufferedTransitions.pop();\n\t            var nextIndex = $scope.indexOfSlide(nextSlide);\n\t            var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n\t            clearBufferedTransitions();\n\t\n\t            goNext(nextSlide, nextIndex, nextDirection);\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    self.currentSlide = slide;\n\t    currentIndex = index;\n\t\n\t    //every time you change slides, reset the timer\n\t    restartTimer();\n\t  }\n\t\n\t  function resetTimer() {\n\t    if (currentInterval) {\n\t      $interval.cancel(currentInterval);\n\t      currentInterval = null;\n\t    }\n\t  }\n\t\n\t  function resetTransition(slides) {\n\t    if (!slides.length) {\n\t      $scope.$currentTransition = null;\n\t      clearBufferedTransitions();\n\t    }\n\t  }\n\t\n\t  function restartTimer() {\n\t    resetTimer();\n\t    var interval = +$scope.interval;\n\t    if (!isNaN(interval) && interval > 0) {\n\t      currentInterval = $interval(timerFn, interval);\n\t    }\n\t  }\n\t\n\t  function timerFn() {\n\t    var interval = +$scope.interval;\n\t    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n\t      $scope.next();\n\t    } else {\n\t      $scope.pause();\n\t    }\n\t  }\n\t}])\n\t\n\t.directive('uibCarousel', function() {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'UibCarouselController',\n\t    controllerAs: 'carousel',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/carousel/carousel.html';\n\t    },\n\t    scope: {\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '=',\n\t      noWrap: '&'\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibSlide', function() {\n\t  return {\n\t    require: '^uibCarousel',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/carousel/slide.html';\n\t    },\n\t    scope: {\n\t      active: '=?',\n\t      actual: '=?',\n\t      index: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          carouselCtrl.select(scope);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.animation('.item', ['$animateCss',\n\tfunction($animateCss) {\n\t  var SLIDE_DIRECTION = 'uib-slideDirection';\n\t\n\t  function removeClass(element, className, callback) {\n\t    element.removeClass(className);\n\t    if (callback) {\n\t      callback();\n\t    }\n\t  }\n\t\n\t  return {\n\t    beforeAddClass: function(element, className, done) {\n\t      if (className === 'active') {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction === 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element,\n\t          directionClass + ' ' + direction, done);\n\t        element.addClass(direction);\n\t\n\t        $animateCss(element, {addClass: directionClass})\n\t          .start()\n\t          .done(removeClassFn);\n\t\n\t        return function() {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    },\n\t    beforeRemoveClass: function (element, className, done) {\n\t      if (className === 'active') {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction === 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\t\n\t        $animateCss(element, {addClass: directionClass})\n\t          .start()\n\t          .done(removeClassFn);\n\t\n\t        return function() {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.dateparser', [])\n\t\n\t.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {\n\t  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n\t  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\t\n\t  var localeId;\n\t  var formatCodeToRegex;\n\t\n\t  this.init = function() {\n\t    localeId = $locale.id;\n\t\n\t    this.parsers = {};\n\t    this.formatters = {};\n\t\n\t    formatCodeToRegex = [\n\t      {\n\t        key: 'yyyy',\n\t        regex: '\\\\d{4}',\n\t        apply: function(value) { this.year = +value; },\n\t        formatter: function(date) {\n\t          var _date = new Date();\n\t          _date.setFullYear(Math.abs(date.getFullYear()));\n\t          return dateFilter(_date, 'yyyy');\n\t        }\n\t      },\n\t      {\n\t        key: 'yy',\n\t        regex: '\\\\d{2}',\n\t        apply: function(value) { this.year = +value + 2000; },\n\t        formatter: function(date) {\n\t          var _date = new Date();\n\t          _date.setFullYear(Math.abs(date.getFullYear()));\n\t          return dateFilter(_date, 'yy');\n\t        }\n\t      },\n\t      {\n\t        key: 'y',\n\t        regex: '\\\\d{1,4}',\n\t        apply: function(value) { this.year = +value; },\n\t        formatter: function(date) {\n\t          var _date = new Date();\n\t          _date.setFullYear(Math.abs(date.getFullYear()));\n\t          return dateFilter(_date, 'y');\n\t        }\n\t      },\n\t      {\n\t        key: 'M!',\n\t        regex: '0?[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; },\n\t        formatter: function(date) {\n\t          var value = date.getMonth();\n\t          if (/^[0-9]$/.test(value)) {\n\t            return dateFilter(date, 'MM');\n\t          }\n\t\n\t          return dateFilter(date, 'M');\n\t        }\n\t      },\n\t      {\n\t        key: 'MMMM',\n\t        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },\n\t        formatter: function(date) { return dateFilter(date, 'MMMM'); }\n\t      },\n\t      {\n\t        key: 'MMM',\n\t        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },\n\t        formatter: function(date) { return dateFilter(date, 'MMM'); }\n\t      },\n\t      {\n\t        key: 'MM',\n\t        regex: '0[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; },\n\t        formatter: function(date) { return dateFilter(date, 'MM'); }\n\t      },\n\t      {\n\t        key: 'M',\n\t        regex: '[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; },\n\t        formatter: function(date) { return dateFilter(date, 'M'); }\n\t      },\n\t      {\n\t        key: 'd!',\n\t        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; },\n\t        formatter: function(date) {\n\t          var value = date.getDate();\n\t          if (/^[1-9]$/.test(value)) {\n\t            return dateFilter(date, 'dd');\n\t          }\n\t\n\t          return dateFilter(date, 'd');\n\t        }\n\t      },\n\t      {\n\t        key: 'dd',\n\t        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'dd'); }\n\t      },\n\t      {\n\t        key: 'd',\n\t        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'd'); }\n\t      },\n\t      {\n\t        key: 'EEEE',\n\t        regex: $locale.DATETIME_FORMATS.DAY.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'EEEE'); }\n\t      },\n\t      {\n\t        key: 'EEE',\n\t        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'EEE'); }\n\t      },\n\t      {\n\t        key: 'HH',\n\t        regex: '(?:0|1)[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'HH'); }\n\t      },\n\t      {\n\t        key: 'hh',\n\t        regex: '0[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'hh'); }\n\t      },\n\t      {\n\t        key: 'H',\n\t        regex: '1?[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'H'); }\n\t      },\n\t      {\n\t        key: 'h',\n\t        regex: '[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'h'); }\n\t      },\n\t      {\n\t        key: 'mm',\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'mm'); }\n\t      },\n\t      {\n\t        key: 'm',\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'm'); }\n\t      },\n\t      {\n\t        key: 'sss',\n\t        regex: '[0-9][0-9][0-9]',\n\t        apply: function(value) { this.milliseconds = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'sss'); }\n\t      },\n\t      {\n\t        key: 'ss',\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'ss'); }\n\t      },\n\t      {\n\t        key: 's',\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; },\n\t        formatter: function(date) { return dateFilter(date, 's'); }\n\t      },\n\t      {\n\t        key: 'a',\n\t        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n\t        apply: function(value) {\n\t          if (this.hours === 12) {\n\t            this.hours = 0;\n\t          }\n\t\n\t          if (value === 'PM') {\n\t            this.hours += 12;\n\t          }\n\t        },\n\t        formatter: function(date) { return dateFilter(date, 'a'); }\n\t      },\n\t      {\n\t        key: 'Z',\n\t        regex: '[+-]\\\\d{4}',\n\t        apply: function(value) {\n\t          var matches = value.match(/([+-])(\\d{2})(\\d{2})/),\n\t            sign = matches[1],\n\t            hours = matches[2],\n\t            minutes = matches[3];\n\t          this.hours += toInt(sign + hours);\n\t          this.minutes += toInt(sign + minutes);\n\t        },\n\t        formatter: function(date) {\n\t          return dateFilter(date, 'Z');\n\t        }\n\t      },\n\t      {\n\t        key: 'ww',\n\t        regex: '[0-4][0-9]|5[0-3]',\n\t        formatter: function(date) { return dateFilter(date, 'ww'); }\n\t      },\n\t      {\n\t        key: 'w',\n\t        regex: '[0-9]|[1-4][0-9]|5[0-3]',\n\t        formatter: function(date) { return dateFilter(date, 'w'); }\n\t      },\n\t      {\n\t        key: 'GGGG',\n\t        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\\s/g, '\\\\s'),\n\t        formatter: function(date) { return dateFilter(date, 'GGGG'); }\n\t      },\n\t      {\n\t        key: 'GGG',\n\t        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'GGG'); }\n\t      },\n\t      {\n\t        key: 'GG',\n\t        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'GG'); }\n\t      },\n\t      {\n\t        key: 'G',\n\t        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'G'); }\n\t      }\n\t    ];\n\t  };\n\t\n\t  this.init();\n\t\n\t  function createParser(format, func) {\n\t    var map = [], regex = format.split('');\n\t\n\t    // check for literal values\n\t    var quoteIndex = format.indexOf('\\'');\n\t    if (quoteIndex > -1) {\n\t      var inLiteral = false;\n\t      format = format.split('');\n\t      for (var i = quoteIndex; i < format.length; i++) {\n\t        if (inLiteral) {\n\t          if (format[i] === '\\'') {\n\t            if (i + 1 < format.length && format[i+1] === '\\'') { // escaped single quote\n\t              format[i+1] = '$';\n\t              regex[i+1] = '';\n\t            } else { // end of literal\n\t              regex[i] = '';\n\t              inLiteral = false;\n\t            }\n\t          }\n\t          format[i] = '$';\n\t        } else {\n\t          if (format[i] === '\\'') { // start of literal\n\t            format[i] = '$';\n\t            regex[i] = '';\n\t            inLiteral = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      format = format.join('');\n\t    }\n\t\n\t    angular.forEach(formatCodeToRegex, function(data) {\n\t      var index = format.indexOf(data.key);\n\t\n\t      if (index > -1) {\n\t        format = format.split('');\n\t\n\t        regex[index] = '(' + data.regex + ')';\n\t        format[index] = '$'; // Custom symbol to define consumed part of format\n\t        for (var i = index + 1, n = index + data.key.length; i < n; i++) {\n\t          regex[i] = '';\n\t          format[i] = '$';\n\t        }\n\t        format = format.join('');\n\t\n\t        map.push({\n\t          index: index,\n\t          key: data.key,\n\t          apply: data[func],\n\t          matcher: data.regex\n\t        });\n\t      }\n\t    });\n\t\n\t    return {\n\t      regex: new RegExp('^' + regex.join('') + '$'),\n\t      map: orderByFilter(map, 'index')\n\t    };\n\t  }\n\t\n\t  this.filter = function(date, format) {\n\t    if (!angular.isDate(date) || isNaN(date) || !format) {\n\t      return '';\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t\n\t    if ($locale.id !== localeId) {\n\t      this.init();\n\t    }\n\t\n\t    if (!this.formatters[format]) {\n\t      this.formatters[format] = createParser(format, 'formatter');\n\t    }\n\t\n\t    var parser = this.formatters[format],\n\t      map = parser.map;\n\t\n\t    var _format = format;\n\t\n\t    return map.reduce(function(str, mapper, i) {\n\t      var match = _format.match(new RegExp('(.*)' + mapper.key));\n\t      if (match && angular.isString(match[1])) {\n\t        str += match[1];\n\t        _format = _format.replace(match[1] + mapper.key, '');\n\t      }\n\t\n\t      if (mapper.apply) {\n\t        return str + mapper.apply.call(null, date);\n\t      }\n\t\n\t      return str;\n\t    }, '');\n\t  };\n\t\n\t  this.parse = function(input, format, baseDate) {\n\t    if (!angular.isString(input) || !format) {\n\t      return input;\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\t\n\t    if ($locale.id !== localeId) {\n\t      this.init();\n\t    }\n\t\n\t    if (!this.parsers[format]) {\n\t      this.parsers[format] = createParser(format, 'apply');\n\t    }\n\t\n\t    var parser = this.parsers[format],\n\t        regex = parser.regex,\n\t        map = parser.map,\n\t        results = input.match(regex),\n\t        tzOffset = false;\n\t    if (results && results.length) {\n\t      var fields, dt;\n\t      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n\t        fields = {\n\t          year: baseDate.getFullYear(),\n\t          month: baseDate.getMonth(),\n\t          date: baseDate.getDate(),\n\t          hours: baseDate.getHours(),\n\t          minutes: baseDate.getMinutes(),\n\t          seconds: baseDate.getSeconds(),\n\t          milliseconds: baseDate.getMilliseconds()\n\t        };\n\t      } else {\n\t        if (baseDate) {\n\t          $log.warn('dateparser:', 'baseDate is not a valid date');\n\t        }\n\t        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n\t      }\n\t\n\t      for (var i = 1, n = results.length; i < n; i++) {\n\t        var mapper = map[i - 1];\n\t        if (mapper.matcher === 'Z') {\n\t          tzOffset = true;\n\t        }\n\t\n\t        if (mapper.apply) {\n\t          mapper.apply.call(fields, results[i]);\n\t        }\n\t      }\n\t\n\t      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :\n\t        Date.prototype.setFullYear;\n\t      var timesetter = tzOffset ? Date.prototype.setUTCHours :\n\t        Date.prototype.setHours;\n\t\n\t      if (isValid(fields.year, fields.month, fields.date)) {\n\t        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {\n\t          dt = new Date(baseDate);\n\t          datesetter.call(dt, fields.year, fields.month, fields.date);\n\t          timesetter.call(dt, fields.hours, fields.minutes,\n\t            fields.seconds, fields.milliseconds);\n\t        } else {\n\t          dt = new Date(0);\n\t          datesetter.call(dt, fields.year, fields.month, fields.date);\n\t          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,\n\t            fields.seconds || 0, fields.milliseconds || 0);\n\t        }\n\t      }\n\t\n\t      return dt;\n\t    }\n\t  };\n\t\n\t  // Check if date is valid for specific month (and year for February).\n\t  // Month: 0 = Jan, 1 = Feb, etc\n\t  function isValid(year, month, date) {\n\t    if (date < 1) {\n\t      return false;\n\t    }\n\t\n\t    if (month === 1 && date > 28) {\n\t      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);\n\t    }\n\t\n\t    if (month === 3 || month === 5 || month === 8 || month === 10) {\n\t      return date < 31;\n\t    }\n\t\n\t    return true;\n\t  }\n\t\n\t  function toInt(str) {\n\t    return parseInt(str, 10);\n\t  }\n\t\n\t  this.toTimezone = toTimezone;\n\t  this.fromTimezone = fromTimezone;\n\t  this.timezoneToOffset = timezoneToOffset;\n\t  this.addDateMinutes = addDateMinutes;\n\t  this.convertTimezoneToLocal = convertTimezoneToLocal;\n\t\n\t  function toTimezone(date, timezone) {\n\t    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;\n\t  }\n\t\n\t  function fromTimezone(date, timezone) {\n\t    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;\n\t  }\n\t\n\t  //https://github.com/angular/angular.js/blob/4daafd3dbe6a80d578f5a31df1bb99c77559543e/src/Angular.js#L1207\n\t  function timezoneToOffset(timezone, fallback) {\n\t    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\n\t    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n\t  }\n\t\n\t  function addDateMinutes(date, minutes) {\n\t    date = new Date(date.getTime());\n\t    date.setMinutes(date.getMinutes() + minutes);\n\t    return date;\n\t  }\n\t\n\t  function convertTimezoneToLocal(date, timezone, reverse) {\n\t    reverse = reverse ? -1 : 1;\n\t    var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());\n\t    return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));\n\t  }\n\t}]);\n\t\n\t// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to\n\t// at most one element.\n\tangular.module('ui.bootstrap.isClass', [])\n\t.directive('uibIsClass', [\n\t         '$animate',\n\tfunction ($animate) {\n\t  //                    11111111          22222222\n\t  var ON_REGEXP = /^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/;\n\t  //                    11111111           22222222\n\t  var IS_REGEXP = /^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;\n\t\n\t  var dataPerTracked = {};\n\t\n\t  return {\n\t    restrict: 'A',\n\t    compile: function (tElement, tAttrs) {\n\t      var linkedScopes = [];\n\t      var instances = [];\n\t      var expToData = {};\n\t      var lastActivated = null;\n\t      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);\n\t      var onExp = onExpMatches[2];\n\t      var expsStr = onExpMatches[1];\n\t      var exps = expsStr.split(',');\n\t\n\t      return linkFn;\n\t\n\t      function linkFn(scope, element, attrs) {\n\t        linkedScopes.push(scope);\n\t        instances.push({\n\t          scope: scope,\n\t          element: element\n\t        });\n\t\n\t        exps.forEach(function (exp, k) {\n\t          addForExp(exp, scope);\n\t        });\n\t\n\t        scope.$on('$destroy', removeScope);\n\t      }\n\t\n\t      function addForExp(exp, scope) {\n\t        var matches = exp.match(IS_REGEXP);\n\t        var clazz = scope.$eval(matches[1]);\n\t        var compareWithExp = matches[2];\n\t        var data = expToData[exp];\n\t        if (!data) {\n\t          var watchFn = function (compareWithVal) {\n\t            var newActivated = null;\n\t            instances.some(function (instance) {\n\t              var thisVal = instance.scope.$eval(onExp);\n\t              if (thisVal === compareWithVal) {\n\t                newActivated = instance;\n\t                return true;\n\t              }\n\t            });\n\t            if (data.lastActivated !== newActivated) {\n\t              if (data.lastActivated) {\n\t                $animate.removeClass(data.lastActivated.element, clazz);\n\t              }\n\t              if (newActivated) {\n\t                $animate.addClass(newActivated.element, clazz);\n\t              }\n\t              data.lastActivated = newActivated;\n\t            }\n\t          };\n\t          expToData[exp] = data = {\n\t            lastActivated: null,\n\t            scope: scope,\n\t            watchFn: watchFn,\n\t            compareWithExp: compareWithExp,\n\t            watcher: scope.$watch(compareWithExp, watchFn)\n\t          };\n\t        }\n\t        data.watchFn(scope.$eval(compareWithExp));\n\t      }\n\t\n\t      function removeScope(e) {\n\t        var removedScope = e.targetScope;\n\t        var index = linkedScopes.indexOf(removedScope);\n\t        linkedScopes.splice(index, 1);\n\t        instances.splice(index, 1);\n\t        if (linkedScopes.length) {\n\t          var newWatchScope = linkedScopes[0];\n\t          angular.forEach(expToData, function (data) {\n\t            if (data.scope === removedScope) {\n\t              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);\n\t              data.scope = newWatchScope;\n\t            }\n\t          });\n\t        }\n\t        else {\n\t          expToData = {};\n\t        }\n\t      }\n\t    }\n\t  };\n\t}]);\n\tangular.module('ui.bootstrap.position', [])\n\t\n\t/**\n\t * A set of utility methods for working with the DOM.\n\t * It is meant to be used where we need to absolute-position elements in\n\t * relation to another element (this is the case for tooltips, popovers,\n\t * typeahead suggestions etc.).\n\t */\n\t  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n\t    /**\n\t     * Used by scrollbarWidth() function to cache scrollbar's width.\n\t     * Do not access this variable directly, use scrollbarWidth() instead.\n\t     */\n\t    var SCROLLBAR_WIDTH;\n\t    var OVERFLOW_REGEX = {\n\t      normal: /(auto|scroll)/,\n\t      hidden: /(auto|scroll|hidden)/\n\t    };\n\t    var PLACEMENT_REGEX = {\n\t      auto: /\\s?auto?\\s?/i,\n\t      primary: /^(top|bottom|left|right)$/,\n\t      secondary: /^(top|bottom|left|right|center)$/,\n\t      vertical: /^(top|bottom)$/\n\t    };\n\t\n\t    return {\n\t\n\t      /**\n\t       * Provides a raw DOM element from a jQuery/jQLite element.\n\t       *\n\t       * @param {element} elem - The element to convert.\n\t       *\n\t       * @returns {element} A HTML element.\n\t       */\n\t      getRawNode: function(elem) {\n\t        return elem[0] || elem;\n\t      },\n\t\n\t      /**\n\t       * Provides a parsed number for a style property.  Strips\n\t       * units and casts invalid numbers to 0.\n\t       *\n\t       * @param {string} value - The style value to parse.\n\t       *\n\t       * @returns {number} A valid number.\n\t       */\n\t      parseStyle: function(value) {\n\t        value = parseFloat(value);\n\t        return isFinite(value) ? value : 0;\n\t      },\n\t\n\t      /**\n\t       * Provides the closest positioned ancestor.\n\t       *\n\t       * @param {element} element - The element to get the offest parent for.\n\t       *\n\t       * @returns {element} The closest positioned ancestor.\n\t       */\n\t      offsetParent: function(elem) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var offsetParent = elem.offsetParent || $document[0].documentElement;\n\t\n\t        function isStaticPositioned(el) {\n\t          return ($window.getComputedStyle(el).position || 'static') === 'static';\n\t        }\n\t\n\t        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {\n\t          offsetParent = offsetParent.offsetParent;\n\t        }\n\t\n\t        return offsetParent || $document[0].documentElement;\n\t      },\n\t\n\t      /**\n\t       * Provides the scrollbar width, concept from TWBS measureScrollbar()\n\t       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js\n\t       *\n\t       * @returns {number} The width of the browser scollbar.\n\t       */\n\t      scrollbarWidth: function() {\n\t        if (angular.isUndefined(SCROLLBAR_WIDTH)) {\n\t          var scrollElem = angular.element('<div style=\"position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;\"></div>');\n\t          $document.find('body').append(scrollElem);\n\t          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;\n\t          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;\n\t          scrollElem.remove();\n\t        }\n\t\n\t        return SCROLLBAR_WIDTH;\n\t      },\n\t\n\t      /**\n\t       * Provides the closest scrollable ancestor.\n\t       * A port of the jQuery UI scrollParent method:\n\t       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js\n\t       *\n\t       * @param {element} elem - The element to find the scroll parent of.\n\t       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n\t       *   default is false.\n\t       *\n\t       * @returns {element} A HTML element.\n\t       */\n\t      scrollParent: function(elem, includeHidden) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n\t        var documentEl = $document[0].documentElement;\n\t        var elemStyle = $window.getComputedStyle(elem);\n\t        var excludeStatic = elemStyle.position === 'absolute';\n\t        var scrollParent = elem.parentElement || documentEl;\n\t\n\t        if (scrollParent === documentEl || elemStyle.position === 'fixed') {\n\t          return documentEl;\n\t        }\n\t\n\t        while (scrollParent.parentElement && scrollParent !== documentEl) {\n\t          var spStyle = $window.getComputedStyle(scrollParent);\n\t          if (excludeStatic && spStyle.position !== 'static') {\n\t            excludeStatic = false;\n\t          }\n\t\n\t          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {\n\t            break;\n\t          }\n\t          scrollParent = scrollParent.parentElement;\n\t        }\n\t\n\t        return scrollParent;\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's position function:\n\t       * http://api.jquery.com/position/ - distance to closest positioned\n\t       * ancestor.  Does not account for margins by default like jQuery position.\n\t       *\n\t       * @param {element} elem - The element to caclulate the position on.\n\t       * @param {boolean=} [includeMargins=false] - Should margins be accounted\n\t       * for, default is false.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**width**: the width of the element</li>\n\t       *     <li>**height**: the height of the element</li>\n\t       *     <li>**top**: distance to top edge of offset parent</li>\n\t       *     <li>**left**: distance to left edge of offset parent</li>\n\t       *   </ul>\n\t       */\n\t      position: function(elem, includeMagins) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var elemOffset = this.offset(elem);\n\t        if (includeMagins) {\n\t          var elemStyle = $window.getComputedStyle(elem);\n\t          elemOffset.top -= this.parseStyle(elemStyle.marginTop);\n\t          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);\n\t        }\n\t        var parent = this.offsetParent(elem);\n\t        var parentOffset = {top: 0, left: 0};\n\t\n\t        if (parent !== $document[0].documentElement) {\n\t          parentOffset = this.offset(parent);\n\t          parentOffset.top += parent.clientTop - parent.scrollTop;\n\t          parentOffset.left += parent.clientLeft - parent.scrollLeft;\n\t        }\n\t\n\t        return {\n\t          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),\n\t          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),\n\t          top: Math.round(elemOffset.top - parentOffset.top),\n\t          left: Math.round(elemOffset.left - parentOffset.left)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's offset function:\n\t       * http://api.jquery.com/offset/ - distance to viewport.  Does\n\t       * not account for borders, margins, or padding on the body\n\t       * element.\n\t       *\n\t       * @param {element} elem - The element to calculate the offset on.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**width**: the width of the element</li>\n\t       *     <li>**height**: the height of the element</li>\n\t       *     <li>**top**: distance to top edge of viewport</li>\n\t       *     <li>**right**: distance to bottom edge of viewport</li>\n\t       *   </ul>\n\t       */\n\t      offset: function(elem) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var elemBCR = elem.getBoundingClientRect();\n\t        return {\n\t          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),\n\t          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),\n\t          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),\n\t          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides offset distance to the closest scrollable ancestor\n\t       * or viewport.  Accounts for border and scrollbar width.\n\t       *\n\t       * Right and bottom dimensions represent the distance to the\n\t       * respective edge of the viewport element.  If the element\n\t       * edge extends beyond the viewport, a negative value will be\n\t       * reported.\n\t       *\n\t       * @param {element} elem - The element to get the viewport offset for.\n\t       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead\n\t       * of the first scrollable element, default is false.\n\t       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element\n\t       * be accounted for, default is true.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**top**: distance to the top content edge of viewport element</li>\n\t       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>\n\t       *     <li>**left**: distance to the left content edge of viewport element</li>\n\t       *     <li>**right**: distance to the right content edge of viewport element</li>\n\t       *   </ul>\n\t       */\n\t      viewportOffset: function(elem, useDocument, includePadding) {\n\t        elem = this.getRawNode(elem);\n\t        includePadding = includePadding !== false ? true : false;\n\t\n\t        var elemBCR = elem.getBoundingClientRect();\n\t        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};\n\t\n\t        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);\n\t        var offsetParentBCR = offsetParent.getBoundingClientRect();\n\t\n\t        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;\n\t        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;\n\t        if (offsetParent === $document[0].documentElement) {\n\t          offsetBCR.top += $window.pageYOffset;\n\t          offsetBCR.left += $window.pageXOffset;\n\t        }\n\t        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;\n\t        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;\n\t\n\t        if (includePadding) {\n\t          var offsetParentStyle = $window.getComputedStyle(offsetParent);\n\t          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);\n\t          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);\n\t          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);\n\t          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);\n\t        }\n\t\n\t        return {\n\t          top: Math.round(elemBCR.top - offsetBCR.top),\n\t          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),\n\t          left: Math.round(elemBCR.left - offsetBCR.left),\n\t          right: Math.round(offsetBCR.right - elemBCR.right)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides an array of placement values parsed from a placement string.\n\t       * Along with the 'auto' indicator, supported placement strings are:\n\t       *   <ul>\n\t       *     <li>top: element on top, horizontally centered on host element.</li>\n\t       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>\n\t       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>\n\t       *     <li>bottom: element on bottom, horizontally centered on host element.</li>\n\t       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>\n\t       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>\n\t       *     <li>left: element on left, vertically centered on host element.</li>\n\t       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>\n\t       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>\n\t       *     <li>right: element on right, vertically centered on host element.</li>\n\t       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>\n\t       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>\n\t       *   </ul>\n\t       * A placement string with an 'auto' indicator is expected to be\n\t       * space separated from the placement, i.e: 'auto bottom-left'  If\n\t       * the primary and secondary placement values do not match 'top,\n\t       * bottom, left, right' then 'top' will be the primary placement and\n\t       * 'center' will be the secondary placement.  If 'auto' is passed, true\n\t       * will be returned as the 3rd value of the array.\n\t       *\n\t       * @param {string} placement - The placement string to parse.\n\t       *\n\t       * @returns {array} An array with the following values\n\t       * <ul>\n\t       *   <li>**[0]**: The primary placement.</li>\n\t       *   <li>**[1]**: The secondary placement.</li>\n\t       *   <li>**[2]**: If auto is passed: true, else undefined.</li>\n\t       * </ul>\n\t       */\n\t      parsePlacement: function(placement) {\n\t        var autoPlace = PLACEMENT_REGEX.auto.test(placement);\n\t        if (autoPlace) {\n\t          placement = placement.replace(PLACEMENT_REGEX.auto, '');\n\t        }\n\t\n\t        placement = placement.split('-');\n\t\n\t        placement[0] = placement[0] || 'top';\n\t        if (!PLACEMENT_REGEX.primary.test(placement[0])) {\n\t          placement[0] = 'top';\n\t        }\n\t\n\t        placement[1] = placement[1] || 'center';\n\t        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {\n\t          placement[1] = 'center';\n\t        }\n\t\n\t        if (autoPlace) {\n\t          placement[2] = true;\n\t        } else {\n\t          placement[2] = false;\n\t        }\n\t\n\t        return placement;\n\t      },\n\t\n\t      /**\n\t       * Provides coordinates for an element to be positioned relative to\n\t       * another element.  Passing 'auto' as part of the placement parameter\n\t       * will enable smart placement - where the element fits. i.e:\n\t       * 'auto left-top' will check to see if there is enough space to the left\n\t       * of the hostElem to fit the targetElem, if not place right (same for secondary\n\t       * top placement).  Available space is calculated using the viewportOffset\n\t       * function.\n\t       *\n\t       * @param {element} hostElem - The element to position against.\n\t       * @param {element} targetElem - The element to position.\n\t       * @param {string=} [placement=top] - The placement for the targetElem,\n\t       *   default is 'top'. 'center' is assumed as secondary placement for\n\t       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:\n\t       *   <ul>\n\t       *     <li>top</li>\n\t       *     <li>top-right</li>\n\t       *     <li>top-left</li>\n\t       *     <li>bottom</li>\n\t       *     <li>bottom-left</li>\n\t       *     <li>bottom-right</li>\n\t       *     <li>left</li>\n\t       *     <li>left-top</li>\n\t       *     <li>left-bottom</li>\n\t       *     <li>right</li>\n\t       *     <li>right-top</li>\n\t       *     <li>right-bottom</li>\n\t       *   </ul>\n\t       * @param {boolean=} [appendToBody=false] - Should the top and left values returned\n\t       *   be calculated from the body element, default is false.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**top**: Value for targetElem top.</li>\n\t       *     <li>**left**: Value for targetElem left.</li>\n\t       *     <li>**placement**: The resolved placement.</li>\n\t       *   </ul>\n\t       */\n\t      positionElements: function(hostElem, targetElem, placement, appendToBody) {\n\t        hostElem = this.getRawNode(hostElem);\n\t        targetElem = this.getRawNode(targetElem);\n\t\n\t        // need to read from prop to support tests.\n\t        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');\n\t        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');\n\t\n\t        placement = this.parsePlacement(placement);\n\t\n\t        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);\n\t        var targetElemPos = {top: 0, left: 0, placement: ''};\n\t\n\t        if (placement[2]) {\n\t          var viewportOffset = this.viewportOffset(hostElem);\n\t\n\t          var targetElemStyle = $window.getComputedStyle(targetElem);\n\t          var adjustedSize = {\n\t            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),\n\t            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))\n\t          };\n\t\n\t          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :\n\t                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :\n\t                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :\n\t                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :\n\t                         placement[0];\n\t\n\t          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :\n\t                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :\n\t                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :\n\t                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :\n\t                         placement[1];\n\t\n\t          if (placement[1] === 'center') {\n\t            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n\t              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;\n\t              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {\n\t                placement[1] = 'left';\n\t              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {\n\t                placement[1] = 'right';\n\t              }\n\t            } else {\n\t              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;\n\t              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {\n\t                placement[1] = 'top';\n\t              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {\n\t                placement[1] = 'bottom';\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        switch (placement[0]) {\n\t          case 'top':\n\t            targetElemPos.top = hostElemPos.top - targetHeight;\n\t            break;\n\t          case 'bottom':\n\t            targetElemPos.top = hostElemPos.top + hostElemPos.height;\n\t            break;\n\t          case 'left':\n\t            targetElemPos.left = hostElemPos.left - targetWidth;\n\t            break;\n\t          case 'right':\n\t            targetElemPos.left = hostElemPos.left + hostElemPos.width;\n\t            break;\n\t        }\n\t\n\t        switch (placement[1]) {\n\t          case 'top':\n\t            targetElemPos.top = hostElemPos.top;\n\t            break;\n\t          case 'bottom':\n\t            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;\n\t            break;\n\t          case 'left':\n\t            targetElemPos.left = hostElemPos.left;\n\t            break;\n\t          case 'right':\n\t            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;\n\t            break;\n\t          case 'center':\n\t            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n\t              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;\n\t            } else {\n\t              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;\n\t            }\n\t            break;\n\t        }\n\t\n\t        targetElemPos.top = Math.round(targetElemPos.top);\n\t        targetElemPos.left = Math.round(targetElemPos.left);\n\t        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];\n\t\n\t        return targetElemPos;\n\t      },\n\t\n\t      /**\n\t      * Provides a way for positioning tooltip & dropdown\n\t      * arrows when using placement options beyond the standard\n\t      * left, right, top, or bottom.\n\t      *\n\t      * @param {element} elem - The tooltip/dropdown element.\n\t      * @param {string} placement - The placement for the elem.\n\t      */\n\t      positionArrow: function(elem, placement) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');\n\t        if (!innerElem) {\n\t          return;\n\t        }\n\t\n\t        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');\n\t\n\t        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');\n\t        if (!arrowElem) {\n\t          return;\n\t        }\n\t\n\t        placement = this.parsePlacement(placement);\n\t        if (placement[1] === 'center') {\n\t          // no adjustment necessary - just reset styles\n\t          angular.element(arrowElem).css({top: '', bottom: '', right: '', left: '', margin: ''});\n\t          return;\n\t        }\n\t\n\t        var borderProp = 'border-' + placement[0] + '-width';\n\t        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];\n\t\n\t        var borderRadiusProp = 'border-';\n\t        if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n\t          borderRadiusProp += placement[0] + '-' + placement[1];\n\t        } else {\n\t          borderRadiusProp += placement[1] + '-' + placement[0];\n\t        }\n\t        borderRadiusProp += '-radius';\n\t        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];\n\t\n\t        var arrowCss = {\n\t          top: 'auto',\n\t          bottom: 'auto',\n\t          left: 'auto',\n\t          right: 'auto',\n\t          margin: 0\n\t        };\n\t\n\t        switch (placement[0]) {\n\t          case 'top':\n\t            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t          case 'bottom':\n\t            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t          case 'left':\n\t            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t          case 'right':\n\t            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t        }\n\t\n\t        arrowCss[placement[1]] = borderRadius;\n\t\n\t        angular.element(arrowElem).css(arrowCss);\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position'])\n\t\n\t.value('$datepickerSuppressError', false)\n\t\n\t.constant('uibDatepickerConfig', {\n\t  datepickerMode: 'day',\n\t  formatDay: 'dd',\n\t  formatMonth: 'MMMM',\n\t  formatYear: 'yyyy',\n\t  formatDayHeader: 'EEE',\n\t  formatDayTitle: 'MMMM yyyy',\n\t  formatMonthTitle: 'yyyy',\n\t  maxDate: null,\n\t  maxMode: 'year',\n\t  minDate: null,\n\t  minMode: 'day',\n\t  ngModelOptions: {},\n\t  shortcutPropagation: false,\n\t  showWeeks: true,\n\t  yearColumns: 5,\n\t  yearRows: 4\n\t})\n\t\n\t.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', 'uibDateParser',\n\t  function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerSuppressError, dateParser) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;\n\t      ngModelOptions = {},\n\t      watchListeners = [];\n\t\n\t  // Modes chain\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  if ($attrs.datepickerOptions) {\n\t    angular.forEach([\n\t      'formatDay',\n\t      'formatDayHeader',\n\t      'formatDayTitle',\n\t      'formatMonth',\n\t      'formatMonthTitle',\n\t      'formatYear',\n\t      'initDate',\n\t      'maxDate',\n\t      'maxMode',\n\t      'minDate',\n\t      'minMode',\n\t      'showWeeks',\n\t      'shortcutPropagation',\n\t      'startingDay',\n\t      'yearColumns',\n\t      'yearRows'\n\t    ], function(key) {\n\t      switch (key) {\n\t        case 'formatDay':\n\t        case 'formatDayHeader':\n\t        case 'formatDayTitle':\n\t        case 'formatMonth':\n\t        case 'formatMonthTitle':\n\t        case 'formatYear':\n\t          self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];\n\t          break;\n\t        case 'showWeeks':\n\t        case 'shortcutPropagation':\n\t        case 'yearColumns':\n\t        case 'yearRows':\n\t          self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n\t            $scope.datepickerOptions[key] : datepickerConfig[key];\n\t          break;\n\t        case 'startingDay':\n\t          if (angular.isDefined($scope.datepickerOptions.startingDay)) {\n\t            self.startingDay = $scope.datepickerOptions.startingDay;\n\t          } else if (angular.isNumber(datepickerConfig.startingDay)) {\n\t            self.startingDay = datepickerConfig.startingDay;\n\t          } else {\n\t            self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n\t          }\n\t\n\t          break;\n\t        case 'maxDate':\n\t        case 'minDate':\n\t          if ($scope.datepickerOptions[key]) {\n\t            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n\t              if (value) {\n\t                if (angular.isDate(value)) {\n\t                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n\t                } else {\n\t                  self[key] = new Date(dateFilter(value, 'medium'));\n\t                }\n\t              } else {\n\t                self[key] = null;\n\t              }\n\t\n\t              self.refreshView();\n\t            });\n\t          } else {\n\t            self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;\n\t          }\n\t\n\t          break;\n\t        case 'maxMode':\n\t        case 'minMode':\n\t          if ($scope.datepickerOptions[key]) {\n\t            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n\t              self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];\n\t              if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||\n\t                key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {\n\t                $scope.datepickerMode = self[key];\n\t              }\n\t            });\n\t          } else {\n\t            self[key] = $scope[key] = datepickerConfig[key] || null;\n\t          }\n\t\n\t          break;\n\t        case 'initDate':\n\t          if ($scope.datepickerOptions.initDate) {\n\t            this.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();\n\t            $scope.$watch(function() { return $scope.datepickerOptions.initDate; }, function(initDate) {\n\t              if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t                self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n\t                self.refreshView();\n\t              }\n\t            });\n\t          } else {\n\t            this.activeDate = new Date();\n\t          }\n\t      }\n\t    });\n\t  } else {\n\t    // Interpolated configuration attributes\n\t    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle'], function(key) {\n\t      self[key] = angular.isDefined($attrs[key]) ? $interpolate($attrs[key])($scope.$parent) : datepickerConfig[key];\n\t    });\n\t\n\t    // Evaled configuration attributes\n\t    angular.forEach(['showWeeks', 'yearRows', 'yearColumns', 'shortcutPropagation'], function(key) {\n\t      self[key] = angular.isDefined($attrs[key]) ?\n\t        $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];\n\t    });\n\t\n\t    if (angular.isDefined($attrs.startingDay)) {\n\t      self.startingDay = $scope.$parent.$eval($attrs.startingDay);\n\t    } else if (angular.isNumber(datepickerConfig.startingDay)) {\n\t      self.startingDay = datepickerConfig.startingDay;\n\t    } else {\n\t      self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n\t    }\n\t\n\t    // Watchable date attributes\n\t    angular.forEach(['minDate', 'maxDate'], function(key) {\n\t      if ($attrs[key]) {\n\t        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {\n\t          if (value) {\n\t            if (angular.isDate(value)) {\n\t              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n\t            } else {\n\t              self[key] = new Date(dateFilter(value, 'medium'));\n\t            }\n\t          } else {\n\t            self[key] = null;\n\t          }\n\t\n\t          self.refreshView();\n\t        }));\n\t      } else {\n\t        self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;\n\t      }\n\t    });\n\t\n\t    angular.forEach(['minMode', 'maxMode'], function(key) {\n\t      if ($attrs[key]) {\n\t        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {\n\t          self[key] = $scope[key] = angular.isDefined(value) ? value : $attrs[key];\n\t          if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||\n\t            key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {\n\t            $scope.datepickerMode = self[key];\n\t          }\n\t        }));\n\t      } else {\n\t        self[key] = $scope[key] = datepickerConfig[key] || null;\n\t      }\n\t    });\n\t\n\t    if (angular.isDefined($attrs.initDate)) {\n\t      this.activeDate = dateParser.fromTimezone($scope.$parent.$eval($attrs.initDate), ngModelOptions.timezone) || new Date();\n\t      watchListeners.push($scope.$parent.$watch($attrs.initDate, function(initDate) {\n\t        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n\t          self.refreshView();\n\t        }\n\t      }));\n\t    } else {\n\t      this.activeDate = new Date();\n\t    }\n\t  }\n\t\n\t  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t\n\t  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n\t  if (angular.isDefined($attrs.ngDisabled)) {\n\t    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {\n\t      $scope.disabled = disabled;\n\t      self.refreshView();\n\t    }));\n\t  }\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;\n\t\n\t    if (ngModelCtrl.$modelValue) {\n\t      this.activeDate = ngModelCtrl.$modelValue;\n\t    }\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if (ngModelCtrl.$viewValue) {\n\t      var date = new Date(ngModelCtrl.$viewValue),\n\t          isValid = !isNaN(date);\n\t\n\t      if (isValid) {\n\t        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);\n\t      } else if (!$datepickerSuppressError) {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object');\n\t      }\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if (this.element) {\n\t      $scope.selectedDt = null;\n\t      this._refreshView();\n\t      if ($scope.activeDt) {\n\t        $scope.activeDateId = $scope.activeDt.uid;\n\t      }\n\t\n\t      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t      date = dateParser.fromTimezone(date, ngModelOptions.timezone);\n\t      ngModelCtrl.$setValidity('dateDisabled', !date ||\n\t        this.element && !this.isDisabled(date));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t    model = dateParser.fromTimezone(model, ngModelOptions.timezone);\n\t    var dt = {\n\t      date: date,\n\t      label: dateParser.filter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0,\n\t      customClass: this.customClass(date) || null\n\t    };\n\t\n\t    if (model && this.compare(date, model) === 0) {\n\t      $scope.selectedDt = dt;\n\t    }\n\t\n\t    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {\n\t      $scope.activeDt = dt;\n\t    }\n\t\n\t    return dt;\n\t  };\n\t\n\t  this.isDisabled = function(date) {\n\t    return $scope.disabled ||\n\t      this.minDate && this.compare(date, this.minDate) < 0 ||\n\t      this.maxDate && this.compare(date, this.maxDate) > 0 ||\n\t      $attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  this.customClass = function(date) {\n\t    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  $scope.select = function(date) {\n\t    if ($scope.datepickerMode === self.minMode) {\n\t      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n\t      dt = dateParser.toTimezone(dt, ngModelOptions.timezone);\n\t      ngModelCtrl.$setViewValue(dt);\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n\t    }\n\t  };\n\t\n\t  $scope.move = function(direction) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function(direction) {\n\t    direction = direction || 1;\n\t\n\t    if ($scope.datepickerMode === self.maxMode && direction === 1 ||\n\t      $scope.datepickerMode === self.minMode && direction === -1) {\n\t      return;\n\t    }\n\t\n\t    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\t\n\t  var focusElement = function() {\n\t    self.element[0].focus();\n\t  };\n\t\n\t  // Listen for focus requests from popup directive\n\t  $scope.$on('uib:datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function(evt) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    if (!self.shortcutPropagation) {\n\t      evt.stopPropagation();\n\t    }\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if (self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t\n\t  $scope.$on(\"$destroy\", function() {\n\t    //Clear all watch listeners on destroy\n\t    while (watchListeners.length) {\n\t      watchListeners.shift()();\n\t    }\n\t  });\n\t}])\n\t\n\t.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\t\n\t  this.step = { months: 1 };\n\t  this.element = $element;\n\t  function getDaysInMonth(year, month) {\n\t    return month === 1 && year % 4 === 0 &&\n\t      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];\n\t  }\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    scope.showWeeks = ctrl.showWeeks;\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this.getDates = function(startDate, n) {\n\t    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n\t    while (i < n) {\n\t      date = new Date(current);\n\t      dates[i++] = date;\n\t      current.setDate(current.getDate() + 1);\n\t    }\n\t    return dates;\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var year = this.activeDate.getFullYear(),\n\t      month = this.activeDate.getMonth(),\n\t      firstDayOfMonth = new Date(this.activeDate);\n\t\n\t    firstDayOfMonth.setFullYear(year, month, 1);\n\t\n\t    var difference = this.startingDay - firstDayOfMonth.getDay(),\n\t      numDisplayedFromPreviousMonth = difference > 0 ?\n\t        7 - difference : - difference,\n\t      firstDate = new Date(firstDayOfMonth);\n\t\n\t    if (numDisplayedFromPreviousMonth > 0) {\n\t      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n\t    }\n\t\n\t    // 42 is the number of days on a six-week calendar\n\t    var days = this.getDates(firstDate, 42);\n\t    for (var i = 0; i < 42; i ++) {\n\t      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n\t        secondary: days[i].getMonth() !== month,\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.labels = new Array(7);\n\t    for (var j = 0; j < 7; j++) {\n\t      scope.labels[j] = {\n\t        abbr: dateFilter(days[j].date, this.formatDayHeader),\n\t        full: dateFilter(days[j].date, 'EEEE')\n\t      };\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n\t    scope.rows = this.split(days, 7);\n\t\n\t    if (scope.showWeeks) {\n\t      scope.weekNumbers = [];\n\t      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n\t          numWeeks = scope.rows.length;\n\t      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n\t        scope.weekNumbers.push(\n\t          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n\t      }\n\t    }\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\n\t    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n\t    _date1.setFullYear(date1.getFullYear());\n\t    _date2.setFullYear(date2.getFullYear());\n\t    return _date1 - _date2;\n\t  };\n\t\n\t  function getISO8601WeekNumber(date) {\n\t    var checkDate = new Date(date);\n\t    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n\t    var time = checkDate.getTime();\n\t    checkDate.setMonth(0); // Compare with Jan 1\n\t    checkDate.setDate(1);\n\t    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t  }\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getDate();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;\n\t    } else if (key === 'up') {\n\t      date = date - 7;\n\t    } else if (key === 'right') {\n\t      date = date + 1;\n\t    } else if (key === 'down') {\n\t      date = date + 7;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setMonth(month, 1);\n\t      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n\t    } else if (key === 'home') {\n\t      date = 1;\n\t    } else if (key === 'end') {\n\t      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n\t    }\n\t    this.activeDate.setDate(date);\n\t  };\n\t}])\n\t\n\t.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  this.step = { years: 1 };\n\t  this.element = $element;\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var months = new Array(12),\n\t        year = this.activeDate.getFullYear(),\n\t        date;\n\t\n\t    for (var i = 0; i < 12; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(year, i, 1);\n\t      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n\t    scope.rows = this.split(months, 3);\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    var _date1 = new Date(date1.getFullYear(), date1.getMonth());\n\t    var _date2 = new Date(date2.getFullYear(), date2.getMonth());\n\t    _date1.setFullYear(date1.getFullYear());\n\t    _date2.setFullYear(date2.getFullYear());\n\t    return _date1 - _date2;\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getMonth();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;\n\t    } else if (key === 'up') {\n\t      date = date - 3;\n\t    } else if (key === 'right') {\n\t      date = date + 1;\n\t    } else if (key === 'down') {\n\t      date = date + 3;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setFullYear(year);\n\t    } else if (key === 'home') {\n\t      date = 0;\n\t    } else if (key === 'end') {\n\t      date = 11;\n\t    }\n\t    this.activeDate.setMonth(date);\n\t  };\n\t}])\n\t\n\t.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var columns, range;\n\t  this.element = $element;\n\t\n\t  function getStartingYear(year) {\n\t    return parseInt((year - 1) / range, 10) * range + 1;\n\t  }\n\t\n\t  this.yearpickerInit = function() {\n\t    columns = this.yearColumns;\n\t    range = this.yearRows * columns;\n\t    this.step = { years: range };\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var years = new Array(range), date;\n\t\n\t    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(start + i, 0, 1);\n\t      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n\t    scope.rows = this.split(years, columns);\n\t    scope.columns = columns;\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return date1.getFullYear() - date2.getFullYear();\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getFullYear();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;\n\t    } else if (key === 'up') {\n\t      date = date - columns;\n\t    } else if (key === 'right') {\n\t      date = date + 1;\n\t    } else if (key === 'down') {\n\t      date = date + columns;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      date += (key === 'pageup' ? - 1 : 1) * range;\n\t    } else if (key === 'home') {\n\t      date = getStartingYear(this.activeDate.getFullYear());\n\t    } else if (key === 'end') {\n\t      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n\t    }\n\t    this.activeDate.setFullYear(date);\n\t  };\n\t}])\n\t\n\t.directive('uibDatepicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';\n\t    },\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      datepickerOptions: '=?',\n\t      dateDisabled: '&',\n\t      customClass: '&',\n\t      shortcutPropagation: '&?'\n\t    },\n\t    require: ['uibDatepicker', '^ngModel'],\n\t    controller: 'UibDatepickerController',\n\t    controllerAs: 'datepicker',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      datepickerCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDaypicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/day.html';\n\t    },\n\t    require: ['^uibDatepicker', 'uibDaypicker'],\n\t    controller: 'UibDaypickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0],\n\t        daypickerCtrl = ctrls[1];\n\t\n\t      daypickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibMonthpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/month.html';\n\t    },\n\t    require: ['^uibDatepicker', 'uibMonthpicker'],\n\t    controller: 'UibMonthpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0],\n\t        monthpickerCtrl = ctrls[1];\n\t\n\t      monthpickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibYearpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/year.html';\n\t    },\n\t    require: ['^uibDatepicker', 'uibYearpicker'],\n\t    controller: 'UibYearpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ctrl = ctrls[0];\n\t      angular.extend(ctrl, ctrls[1]);\n\t      ctrl.yearpickerInit();\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t})\n\t\n\t.constant('uibDatepickerPopupConfig', {\n\t  altInputFormats: [],\n\t  appendToBody: false,\n\t  clearText: 'Clear',\n\t  closeOnDateSelection: true,\n\t  closeText: 'Done',\n\t  currentText: 'Today',\n\t  datepickerPopup: 'yyyy-MM-dd',\n\t  datepickerPopupTemplateUrl: 'uib/template/datepicker/popup.html',\n\t  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',\n\t  html5Types: {\n\t    date: 'yyyy-MM-dd',\n\t    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n\t    'month': 'yyyy-MM'\n\t  },\n\t  onOpenFocus: true,\n\t  showButtonBar: true\n\t})\n\t\n\t.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig',\n\tfunction(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig) {\n\t  var cache = {},\n\t    isHtml5DateInput = false;\n\t  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n\t    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,\n\t    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];\n\t\n\t  scope.watchData = {};\n\t\n\t  this.init = function(_ngModel_) {\n\t    ngModel = _ngModel_;\n\t    ngModelOptions = _ngModel_.$options || datepickerConfig.ngModelOptions;\n\t    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n\t    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n\t    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n\t    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;\n\t    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\t    altInputFormats = angular.isDefined(attrs.altInputFormats) ? scope.$parent.$eval(attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;\n\t\n\t    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\t\n\t    if (datepickerPopupConfig.html5Types[attrs.type]) {\n\t      dateFormat = datepickerPopupConfig.html5Types[attrs.type];\n\t      isHtml5DateInput = true;\n\t    } else {\n\t      dateFormat = attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n\t      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n\t        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n\t        // Invalidate the $modelValue to ensure that formatters re-run\n\t        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n\t        if (newDateFormat !== dateFormat) {\n\t          dateFormat = newDateFormat;\n\t          ngModel.$modelValue = null;\n\t\n\t          if (!dateFormat) {\n\t            throw new Error('uibDatepickerPopup must have a date format specified.');\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    if (!dateFormat) {\n\t      throw new Error('uibDatepickerPopup must have a date format specified.');\n\t    }\n\t\n\t    if (isHtml5DateInput && attrs.uibDatepickerPopup) {\n\t      throw new Error('HTML5 date input types do not support custom formats.');\n\t    }\n\t\n\t    // popup element used to display calendar\n\t    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n\t    scope.ngModelOptions = angular.copy(ngModelOptions);\n\t    scope.ngModelOptions.timezone = null;\n\t    popupEl.attr({\n\t      'ng-model': 'date',\n\t      'ng-model-options': 'ngModelOptions',\n\t      'ng-change': 'dateSelection(date)',\n\t      'template-url': datepickerPopupTemplateUrl\n\t    });\n\t\n\t    // datepicker element\n\t    datepickerEl = angular.element(popupEl.children()[0]);\n\t    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\t\n\t    if (isHtml5DateInput) {\n\t      if (attrs.type === 'month') {\n\t        datepickerEl.attr('datepicker-mode', '\"month\"');\n\t        datepickerEl.attr('min-mode', 'month');\n\t      }\n\t    }\n\t\n\t    if (scope.datepickerOptions) {\n\t      angular.forEach(scope.datepickerOptions, function(value, option) {\n\t        // Ignore this options, will be managed later\n\t        if (['minDate', 'maxDate', 'minMode', 'maxMode', 'initDate', 'datepickerMode'].indexOf(option) === -1) {\n\t          datepickerEl.attr(cameltoDash(option), value);\n\t        } else {\n\t          datepickerEl.attr(cameltoDash(option), 'datepickerOptions.' + option);\n\t        }\n\t      });\n\t    }\n\t\n\t    angular.forEach(['minMode', 'maxMode', 'datepickerMode', 'shortcutPropagation'], function(key) {\n\t      if (attrs[key]) {\n\t        var getAttribute = $parse(attrs[key]);\n\t        var propConfig = {\n\t          get: function() {\n\t            return getAttribute(scope.$parent);\n\t          }\n\t        };\n\t\n\t        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\t\n\t        // Propagate changes from datepicker to outside\n\t        if (key === 'datepickerMode') {\n\t          var setAttribute = getAttribute.assign;\n\t          propConfig.set = function(v) {\n\t            setAttribute(scope.$parent, v);\n\t          };\n\t        }\n\t\n\t        Object.defineProperty(scope.watchData, key, propConfig);\n\t      }\n\t    });\n\t\n\t    angular.forEach(['minDate', 'maxDate', 'initDate'], function(key) {\n\t      if (attrs[key]) {\n\t        var getAttribute = $parse(attrs[key]);\n\t\n\t        watchListeners.push(scope.$parent.$watch(getAttribute, function(value) {\n\t          if (key === 'minDate' || key === 'maxDate') {\n\t            if (value === null) {\n\t              cache[key] = null;\n\t            } else if (angular.isDate(value)) {\n\t              cache[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n\t            } else {\n\t              cache[key] = new Date(dateFilter(value, 'medium'));\n\t            }\n\t\n\t            scope.watchData[key] = value === null ? null : cache[key];\n\t          } else {\n\t            scope.watchData[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n\t          }\n\t        }));\n\t\n\t        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\t      }\n\t    });\n\t\n\t    if (attrs.dateDisabled) {\n\t      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n\t    }\n\t\n\t    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRows', 'yearColumns'], function(key) {\n\t      if (angular.isDefined(attrs[key])) {\n\t        datepickerEl.attr(cameltoDash(key), attrs[key]);\n\t      }\n\t    });\n\t\n\t    if (attrs.customClass) {\n\t      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n\t    }\n\t\n\t    if (!isHtml5DateInput) {\n\t      // Internal API to maintain the correct ng-invalid-[key] class\n\t      ngModel.$$parserName = 'date';\n\t      ngModel.$validators.date = validator;\n\t      ngModel.$parsers.unshift(parseDate);\n\t      ngModel.$formatters.push(function(value) {\n\t        if (ngModel.$isEmpty(value)) {\n\t          scope.date = value;\n\t          return value;\n\t        }\n\t\n\t        scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);\n\t\n\t        if (angular.isNumber(scope.date)) {\n\t          scope.date = new Date(scope.date);\n\t        }\n\t\n\t        return dateParser.filter(scope.date, dateFormat);\n\t      });\n\t    } else {\n\t      ngModel.$formatters.push(function(value) {\n\t        scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);\n\t        return value;\n\t      });\n\t    }\n\t\n\t    // Detect changes in the view from the text box\n\t    ngModel.$viewChangeListeners.push(function() {\n\t      scope.date = parseDateString(ngModel.$viewValue);\n\t    });\n\t\n\t    element.on('keydown', inputKeydownBind);\n\t\n\t    $popup = $compile(popupEl)(scope);\n\t    // Prevent jQuery cache memory leak (template is now redundant after linking)\n\t    popupEl.remove();\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    scope.$on('$destroy', function() {\n\t      if (scope.isOpen === true) {\n\t        if (!$rootScope.$$phase) {\n\t          scope.$apply(function() {\n\t            scope.isOpen = false;\n\t          });\n\t        }\n\t      }\n\t\n\t      $popup.remove();\n\t      element.off('keydown', inputKeydownBind);\n\t      $document.off('click', documentClickBind);\n\t\n\t      //Clear all watch listeners on destroy\n\t      while (watchListeners.length) {\n\t        watchListeners.shift()();\n\t      }\n\t    });\n\t  };\n\t\n\t  scope.getText = function(key) {\n\t    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n\t  };\n\t\n\t  scope.isDisabled = function(date) {\n\t    if (date === 'today') {\n\t      date = new Date();\n\t    }\n\t\n\t    return scope.watchData.minDate && scope.compare(date, cache.minDate) < 0 ||\n\t        scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0;\n\t  };\n\t\n\t  scope.compare = function(date1, date2) {\n\t    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n\t  };\n\t\n\t  // Inner change\n\t  scope.dateSelection = function(dt) {\n\t    if (angular.isDefined(dt)) {\n\t      scope.date = dt;\n\t    }\n\t    var date = scope.date ? dateParser.filter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n\t    element.val(date);\n\t    ngModel.$setViewValue(date);\n\t\n\t    if (closeOnDateSelection) {\n\t      scope.isOpen = false;\n\t      element[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.keydown = function(evt) {\n\t    if (evt.which === 27) {\n\t      evt.stopPropagation();\n\t      scope.isOpen = false;\n\t      element[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.select = function(date) {\n\t    if (date === 'today') {\n\t      var today = new Date();\n\t      if (angular.isDate(scope.date)) {\n\t        date = new Date(scope.date);\n\t        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n\t      } else {\n\t        date = new Date(today.setHours(0, 0, 0, 0));\n\t      }\n\t    }\n\t    scope.dateSelection(date);\n\t  };\n\t\n\t  scope.close = function() {\n\t    scope.isOpen = false;\n\t    element[0].focus();\n\t  };\n\t\n\t  scope.disabled = angular.isDefined(attrs.disabled) || false;\n\t  if (attrs.ngDisabled) {\n\t    watchListeners.push(scope.$parent.$watch($parse(attrs.ngDisabled), function(disabled) {\n\t      scope.disabled = disabled;\n\t    }));\n\t  }\n\t\n\t  scope.$watch('isOpen', function(value) {\n\t    if (value) {\n\t      if (!scope.disabled) {\n\t        scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t        scope.position.top = scope.position.top + element.prop('offsetHeight');\n\t\n\t        $timeout(function() {\n\t          if (onOpenFocus) {\n\t            scope.$broadcast('uib:datepicker.focus');\n\t          }\n\t          $document.on('click', documentClickBind);\n\t        }, 0, false);\n\t      } else {\n\t        scope.isOpen = false;\n\t      }\n\t    } else {\n\t      $document.off('click', documentClickBind);\n\t    }\n\t  });\n\t\n\t  function cameltoDash(string) {\n\t    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n\t  }\n\t\n\t  function parseDateString(viewValue) {\n\t    var date = dateParser.parse(viewValue, dateFormat, scope.date);\n\t    if (isNaN(date)) {\n\t      for (var i = 0; i < altInputFormats.length; i++) {\n\t        date = dateParser.parse(viewValue, altInputFormats[i], scope.date);\n\t        if (!isNaN(date)) {\n\t          return date;\n\t        }\n\t      }\n\t    }\n\t    return date;\n\t  }\n\t\n\t  function parseDate(viewValue) {\n\t    if (angular.isNumber(viewValue)) {\n\t      // presumably timestamp to date object\n\t      viewValue = new Date(viewValue);\n\t    }\n\t\n\t    if (!viewValue) {\n\t      return null;\n\t    }\n\t\n\t    if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n\t      return viewValue;\n\t    }\n\t\n\t    if (angular.isString(viewValue)) {\n\t      var date = parseDateString(viewValue);\n\t      if (!isNaN(date)) {\n\t        return dateParser.toTimezone(date, ngModelOptions.timezone);\n\t      }\n\t    }\n\t\n\t    return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;\n\t  }\n\t\n\t  function validator(modelValue, viewValue) {\n\t    var value = modelValue || viewValue;\n\t\n\t    if (!attrs.ngRequired && !value) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isNumber(value)) {\n\t      value = new Date(value);\n\t    }\n\t\n\t    if (!value) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isDate(value) && !isNaN(value)) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isString(value)) {\n\t      return !isNaN(parseDateString(viewValue));\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function documentClickBind(event) {\n\t    if (!scope.isOpen && scope.disabled) {\n\t      return;\n\t    }\n\t\n\t    var popup = $popup[0];\n\t    var dpContainsTarget = element[0].contains(event.target);\n\t    // The popup node may not be an element node\n\t    // In some browsers (IE) only element nodes have the 'contains' function\n\t    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n\t    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n\t      scope.$apply(function() {\n\t        scope.isOpen = false;\n\t      });\n\t    }\n\t  }\n\t\n\t  function inputKeydownBind(evt) {\n\t    if (evt.which === 27 && scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      scope.$apply(function() {\n\t        scope.isOpen = false;\n\t      });\n\t      element[0].focus();\n\t    } else if (evt.which === 40 && !scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      scope.$apply(function() {\n\t        scope.isOpen = true;\n\t      });\n\t    }\n\t  }\n\t}])\n\t\n\t.directive('uibDatepickerPopup', function() {\n\t  return {\n\t    require: ['ngModel', 'uibDatepickerPopup'],\n\t    controller: 'UibDatepickerPopupController',\n\t    scope: {\n\t      datepickerOptions: '=?',\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&',\n\t      customClass: '&'\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ngModel = ctrls[0],\n\t        ctrl = ctrls[1];\n\t\n\t      ctrl.init(ngModel);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDatepickerPopupWrap', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/popup.html';\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.debounce', [])\n\t/**\n\t * A helper, internal service that debounces a function\n\t */\n\t  .factory('$$debounce', ['$timeout', function($timeout) {\n\t    return function(callback, debounceTime) {\n\t      var timeoutPromise;\n\t\n\t      return function() {\n\t        var self = this;\n\t        var args = Array.prototype.slice.call(arguments);\n\t        if (timeoutPromise) {\n\t          $timeout.cancel(timeoutPromise);\n\t        }\n\t\n\t        timeoutPromise = $timeout(function() {\n\t          callback.apply(self, args);\n\t        }, debounceTime);\n\t      };\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\t\n\t.constant('uibDropdownConfig', {\n\t  appendToOpenClass: 'uib-dropdown-open',\n\t  openClass: 'open'\n\t})\n\t\n\t.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n\t  var openScope = null;\n\t\n\t  this.open = function(dropdownScope) {\n\t    if (!openScope) {\n\t      $document.on('click', closeDropdown);\n\t      $document.on('keydown', keybindFilter);\n\t    }\n\t\n\t    if (openScope && openScope !== dropdownScope) {\n\t      openScope.isOpen = false;\n\t    }\n\t\n\t    openScope = dropdownScope;\n\t  };\n\t\n\t  this.close = function(dropdownScope) {\n\t    if (openScope === dropdownScope) {\n\t      openScope = null;\n\t      $document.off('click', closeDropdown);\n\t      $document.off('keydown', keybindFilter);\n\t    }\n\t  };\n\t\n\t  var closeDropdown = function(evt) {\n\t    // This method may still be called during the same mouse event that\n\t    // unbound this event handler. So check openScope before proceeding.\n\t    if (!openScope) { return; }\n\t\n\t    if (evt && openScope.getAutoClose() === 'disabled') { return; }\n\t\n\t    if (evt && evt.which === 3) { return; }\n\t\n\t    var toggleElement = openScope.getToggleElement();\n\t    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    var dropdownElement = openScope.getDropdownElement();\n\t    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n\t      dropdownElement && dropdownElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    openScope.isOpen = false;\n\t\n\t    if (!$rootScope.$$phase) {\n\t      openScope.$apply();\n\t    }\n\t  };\n\t\n\t  var keybindFilter = function(evt) {\n\t    if (evt.which === 27) {\n\t      openScope.focusToggleElement();\n\t      closeDropdown();\n\t    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      openScope.focusDropdownEntry(evt.which);\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n\t  var self = this,\n\t    scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t    templateScope,\n\t    appendToOpenClass = dropdownConfig.appendToOpenClass,\n\t    openClass = dropdownConfig.openClass,\n\t    getIsOpen,\n\t    setIsOpen = angular.noop,\n\t    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n\t    appendToBody = false,\n\t    appendTo = null,\n\t    keynavEnabled = false,\n\t    selectedOption = null,\n\t    body = $document.find('body');\n\t\n\t  $element.addClass('dropdown');\n\t\n\t  this.init = function() {\n\t    if ($attrs.isOpen) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t\n\t    if (angular.isDefined($attrs.dropdownAppendTo)) {\n\t      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);\n\t      if (appendToEl) {\n\t        appendTo = angular.element(appendToEl);\n\t      }\n\t    }\n\t\n\t    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n\t    keynavEnabled = angular.isDefined($attrs.keyboardNav);\n\t\n\t    if (appendToBody && !appendTo) {\n\t      appendTo = body;\n\t    }\n\t\n\t    if (appendTo && self.dropdownMenu) {\n\t      appendTo.append(self.dropdownMenu);\n\t      $element.on('$destroy', function handleDestroyEvent() {\n\t        self.dropdownMenu.remove();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function(open) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.getAutoClose = function() {\n\t    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n\t  };\n\t\n\t  scope.getElement = function() {\n\t    return $element;\n\t  };\n\t\n\t  scope.isKeynavEnabled = function() {\n\t    return keynavEnabled;\n\t  };\n\t\n\t  scope.focusDropdownEntry = function(keyCode) {\n\t    var elems = self.dropdownMenu ? //If append to body is used.\n\t      angular.element(self.dropdownMenu).find('a') :\n\t      $element.find('ul').eq(0).find('a');\n\t\n\t    switch (keyCode) {\n\t      case 40: {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = 0;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === elems.length - 1 ?\n\t            self.selectedOption :\n\t            self.selectedOption + 1;\n\t        }\n\t        break;\n\t      }\n\t      case 38: {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = elems.length - 1;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === 0 ?\n\t            0 : self.selectedOption - 1;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    elems[self.selectedOption].focus();\n\t  };\n\t\n\t  scope.getDropdownElement = function() {\n\t    return self.dropdownMenu;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if (self.toggleElement) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function(isOpen, wasOpen) {\n\t    if (appendTo && self.dropdownMenu) {\n\t      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),\n\t        css,\n\t        rightalign;\n\t\n\t      css = {\n\t        top: pos.top + 'px',\n\t        display: isOpen ? 'block' : 'none'\n\t      };\n\t\n\t      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n\t      if (!rightalign) {\n\t        css.left = pos.left + 'px';\n\t        css.right = 'auto';\n\t      } else {\n\t        css.left = 'auto';\n\t        css.right = window.innerWidth -\n\t          (pos.left + $element.prop('offsetWidth')) + 'px';\n\t      }\n\t\n\t      // Need to adjust our positioning to be relative to the appendTo container\n\t      // if it's not the body element\n\t      if (!appendToBody) {\n\t        var appendOffset = $position.offset(appendTo);\n\t\n\t        css.top = pos.top - appendOffset.top + 'px';\n\t\n\t        if (!rightalign) {\n\t          css.left = pos.left - appendOffset.left + 'px';\n\t        } else {\n\t          css.right = window.innerWidth -\n\t            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';\n\t        }\n\t      }\n\t\n\t      self.dropdownMenu.css(css);\n\t    }\n\t\n\t    var openContainer = appendTo ? appendTo : $element;\n\t\n\t    $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {\n\t      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t        toggleInvoker($scope, { open: !!isOpen });\n\t      }\n\t    });\n\t\n\t    if (isOpen) {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n\t          templateScope = scope.$new();\n\t          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n\t            var newEl = dropdownElement;\n\t            self.dropdownMenu.replaceWith(newEl);\n\t            self.dropdownMenu = newEl;\n\t          });\n\t        });\n\t      }\n\t\n\t      scope.focusToggleElement();\n\t      uibDropdownService.open(scope);\n\t    } else {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        if (templateScope) {\n\t          templateScope.$destroy();\n\t        }\n\t        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n\t        self.dropdownMenu.replaceWith(newEl);\n\t        self.dropdownMenu = newEl;\n\t      }\n\t\n\t      uibDropdownService.close(scope);\n\t      self.selectedOption = null;\n\t    }\n\t\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen($scope, isOpen);\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    if (scope.getAutoClose() !== 'disabled') {\n\t      scope.isOpen = false;\n\t    }\n\t  });\n\t}])\n\t\n\t.directive('uibDropdown', function() {\n\t  return {\n\t    controller: 'UibDropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      dropdownCtrl.init();\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownMenu', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-menu');\n\t\n\t      var tplUrl = attrs.templateUrl;\n\t      if (tplUrl) {\n\t        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n\t      }\n\t\n\t      if (!dropdownCtrl.dropdownMenu) {\n\t        dropdownCtrl.dropdownMenu = element;\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownToggle', function() {\n\t  return {\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-toggle');\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if (!element.hasClass('disabled') && !attrs.disabled) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.stackedMap', [])\n\t/**\n\t * A helper, internal data structure that acts as a map but also allows getting / removing\n\t * elements in the LIFO order\n\t */\n\t  .factory('$$stackedMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var stack = [];\n\t\n\t        return {\n\t          add: function(key, value) {\n\t            stack.push({\n\t              key: key,\n\t              value: value\n\t            });\n\t          },\n\t          get: function(key) {\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key === stack[i].key) {\n\t                return stack[i];\n\t              }\n\t            }\n\t          },\n\t          keys: function() {\n\t            var keys = [];\n\t            for (var i = 0; i < stack.length; i++) {\n\t              keys.push(stack[i].key);\n\t            }\n\t            return keys;\n\t          },\n\t          top: function() {\n\t            return stack[stack.length - 1];\n\t          },\n\t          remove: function(key) {\n\t            var idx = -1;\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key === stack[i].key) {\n\t                idx = i;\n\t                break;\n\t              }\n\t            }\n\t            return stack.splice(idx, 1)[0];\n\t          },\n\t          removeTop: function() {\n\t            return stack.splice(stack.length - 1, 1)[0];\n\t          },\n\t          length: function() {\n\t            return stack.length;\n\t          }\n\t        };\n\t      }\n\t    };\n\t  });\n\tangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n\t/**\n\t * A helper, internal data structure that stores all references attached to key\n\t */\n\t  .factory('$$multiMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var map = {};\n\t\n\t        return {\n\t          entries: function() {\n\t            return Object.keys(map).map(function(key) {\n\t              return {\n\t                key: key,\n\t                value: map[key]\n\t              };\n\t            });\n\t          },\n\t          get: function(key) {\n\t            return map[key];\n\t          },\n\t          hasKey: function(key) {\n\t            return !!map[key];\n\t          },\n\t          keys: function() {\n\t            return Object.keys(map);\n\t          },\n\t          put: function(key, value) {\n\t            if (!map[key]) {\n\t              map[key] = [];\n\t            }\n\t\n\t            map[key].push(value);\n\t          },\n\t          remove: function(key, value) {\n\t            var values = map[key];\n\t\n\t            if (!values) {\n\t              return;\n\t            }\n\t\n\t            var idx = values.indexOf(value);\n\t\n\t            if (idx !== -1) {\n\t              values.splice(idx, 1);\n\t            }\n\t\n\t            if (!values.length) {\n\t              delete map[key];\n\t            }\n\t          }\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t/**\n\t * Pluggable resolve mechanism for the modal resolve resolution\n\t * Supports UI Router's $resolve service\n\t */\n\t  .provider('$uibResolve', function() {\n\t    var resolve = this;\n\t    this.resolver = null;\n\t\n\t    this.setResolver = function(resolver) {\n\t      this.resolver = resolver;\n\t    };\n\t\n\t    this.$get = ['$injector', '$q', function($injector, $q) {\n\t      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;\n\t      return {\n\t        resolve: function(invocables, locals, parent, self) {\n\t          if (resolver) {\n\t            return resolver.resolve(invocables, locals, parent, self);\n\t          }\n\t\n\t          var promises = [];\n\t\n\t          angular.forEach(invocables, function(value) {\n\t            if (angular.isFunction(value) || angular.isArray(value)) {\n\t              promises.push($q.resolve($injector.invoke(value)));\n\t            } else if (angular.isString(value)) {\n\t              promises.push($q.resolve($injector.get(value)));\n\t            } else {\n\t              promises.push($q.resolve(value));\n\t            }\n\t          });\n\t\n\t          return $q.all(promises).then(function(resolves) {\n\t            var resolveObj = {};\n\t            var resolveIter = 0;\n\t            angular.forEach(invocables, function(value, key) {\n\t              resolveObj[key] = resolves[resolveIter++];\n\t            });\n\t\n\t            return resolveObj;\n\t          });\n\t        }\n\t      };\n\t    }];\n\t  })\n\t\n\t/**\n\t * A helper directive for the $modal service. It creates a backdrop element.\n\t */\n\t  .directive('uibModalBackdrop', ['$animateCss', '$injector', '$uibModalStack',\n\t  function($animateCss, $injector, $modalStack) {\n\t    return {\n\t      replace: true,\n\t      templateUrl: 'uib/template/modal/backdrop.html',\n\t      compile: function(tElement, tAttrs) {\n\t        tElement.addClass(tAttrs.backdropClass);\n\t        return linkFn;\n\t      }\n\t    };\n\t\n\t    function linkFn(scope, element, attrs) {\n\t      if (attrs.modalInClass) {\n\t        $animateCss(element, {\n\t          addClass: attrs.modalInClass\n\t        }).start();\n\t\n\t        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t          var done = setIsAsync();\n\t          if (scope.modalOptions.animation) {\n\t            $animateCss(element, {\n\t              removeClass: attrs.modalInClass\n\t            }).start().then(done);\n\t          } else {\n\t            done();\n\t          }\n\t        });\n\t      }\n\t    }\n\t  }])\n\t\n\t  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animate', '$animateCss', '$document',\n\t  function($modalStack, $q, $animate, $animateCss, $document) {\n\t    return {\n\t      scope: {\n\t        index: '@'\n\t      },\n\t      replace: true,\n\t      transclude: true,\n\t      templateUrl: function(tElement, tAttrs) {\n\t        return tAttrs.templateUrl || 'uib/template/modal/window.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        element.addClass(attrs.windowClass || '');\n\t        element.addClass(attrs.windowTopClass || '');\n\t        scope.size = attrs.size;\n\t\n\t        scope.close = function(evt) {\n\t          var modal = $modalStack.getTop();\n\t          if (modal && modal.value.backdrop &&\n\t            modal.value.backdrop !== 'static' &&\n\t            evt.target === evt.currentTarget) {\n\t            evt.preventDefault();\n\t            evt.stopPropagation();\n\t            $modalStack.dismiss(modal.key, 'backdrop click');\n\t          }\n\t        };\n\t\n\t        // moved from template to fix issue #2280\n\t        element.on('click', scope.close);\n\t\n\t        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n\t        // We can detect that by using this property in the template associated with this directive and then use\n\t        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n\t        scope.$isRendered = true;\n\t\n\t        // Deferred object that will be resolved when this modal is render.\n\t        var modalRenderDeferObj = $q.defer();\n\t        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n\t        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n\t        attrs.$observe('modalRender', function(value) {\n\t          if (value === 'true') {\n\t            modalRenderDeferObj.resolve();\n\t          }\n\t        });\n\t\n\t        modalRenderDeferObj.promise.then(function() {\n\t          var animationPromise = null;\n\t\n\t          if (attrs.modalInClass) {\n\t            animationPromise = $animateCss(element, {\n\t              addClass: attrs.modalInClass\n\t            }).start();\n\t\n\t            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t              var done = setIsAsync();\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  removeClass: attrs.modalInClass\n\t                }).start().then(done);\n\t              } else {\n\t                $animate.removeClass(element, attrs.modalInClass).then(done);\n\t              }\n\t            });\n\t          }\n\t\n\t\n\t          $q.when(animationPromise).then(function() {\n\t            /**\n\t             * If something within the freshly-opened modal already has focus (perhaps via a\n\t             * directive that causes focus). then no need to try and focus anything.\n\t             */\n\t            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {\n\t              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n\t              /**\n\t               * Auto-focusing of a freshly-opened modal element causes any child elements\n\t               * with the autofocus attribute to lose focus. This is an issue on touch\n\t               * based devices which will show and then hide the onscreen keyboard.\n\t               * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t               * the modal element if the modal does not contain an autofocus element.\n\t               */\n\t              if (inputWithAutofocus) {\n\t                inputWithAutofocus.focus();\n\t              } else {\n\t                element[0].focus();\n\t              }\n\t            }\n\t          });\n\t\n\t          // Notify {@link $modalStack} that modal is rendered.\n\t          var modal = $modalStack.getTop();\n\t          if (modal) {\n\t            $modalStack.modalRendered(modal.key);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('uibModalAnimationClass', function() {\n\t    return {\n\t      compile: function(tElement, tAttrs) {\n\t        if (tAttrs.modalAnimation) {\n\t          tElement.addClass(tAttrs.uibModalAnimationClass);\n\t        }\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibModalTransclude', function() {\n\t    return {\n\t      link: function(scope, element, attrs, controller, transclude) {\n\t        transclude(scope.$parent, function(clone) {\n\t          element.empty();\n\t          element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  })\n\t\n\t  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',\n\t    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap',\n\t    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap) {\n\t      var OPENED_MODAL_CLASS = 'modal-open';\n\t\n\t      var backdropDomEl, backdropScope;\n\t      var openedWindows = $$stackedMap.createNew();\n\t      var openedClasses = $$multiMap.createNew();\n\t      var $modalStack = {\n\t        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n\t      };\n\t\n\t      //Modal focus behavior\n\t      var focusableElementList;\n\t      var focusIndex = 0;\n\t      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n\t        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n\t        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\t\n\t      function backdropIndex() {\n\t        var topBackdropIndex = -1;\n\t        var opened = openedWindows.keys();\n\t        for (var i = 0; i < opened.length; i++) {\n\t          if (openedWindows.get(opened[i]).value.backdrop) {\n\t            topBackdropIndex = i;\n\t          }\n\t        }\n\t        return topBackdropIndex;\n\t      }\n\t\n\t      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n\t        if (backdropScope) {\n\t          backdropScope.index = newBackdropIndex;\n\t        }\n\t      });\n\t\n\t      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n\t        var modalWindow = openedWindows.get(modalInstance).value;\n\t        var appendToElement = modalWindow.appendTo;\n\t\n\t        //clean up the stack\n\t        openedWindows.remove(modalInstance);\n\t\n\t        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n\t          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n\t          openedClasses.remove(modalBodyClass, modalInstance);\n\t          appendToElement.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n\t          toggleTopWindowClass(true);\n\t        }, modalWindow.closedDeferred);\n\t        checkRemoveBackdrop();\n\t\n\t        //move focus to specified element if available, or else to body\n\t        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n\t          elementToReceiveFocus.focus();\n\t        } else if (appendToElement.focus) {\n\t          appendToElement.focus();\n\t        }\n\t      }\n\t\n\t      // Add or remove \"windowTopClass\" from the top window in the stack\n\t      function toggleTopWindowClass(toggleSwitch) {\n\t        var modalWindow;\n\t\n\t        if (openedWindows.length() > 0) {\n\t          modalWindow = openedWindows.top().value;\n\t          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n\t        }\n\t      }\n\t\n\t      function checkRemoveBackdrop() {\n\t        //remove backdrop if no longer needed\n\t        if (backdropDomEl && backdropIndex() === -1) {\n\t          var backdropScopeRef = backdropScope;\n\t          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n\t            backdropScopeRef = null;\n\t          });\n\t          backdropDomEl = undefined;\n\t          backdropScope = undefined;\n\t        }\n\t      }\n\t\n\t      function removeAfterAnimate(domEl, scope, done, closedDeferred) {\n\t        var asyncDeferred;\n\t        var asyncPromise = null;\n\t        var setIsAsync = function() {\n\t          if (!asyncDeferred) {\n\t            asyncDeferred = $q.defer();\n\t            asyncPromise = asyncDeferred.promise;\n\t          }\n\t\n\t          return function asyncDone() {\n\t            asyncDeferred.resolve();\n\t          };\n\t        };\n\t        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\t\n\t        // Note that it's intentional that asyncPromise might be null.\n\t        // That's when setIsAsync has not been called during the\n\t        // NOW_CLOSING_EVENT broadcast.\n\t        return $q.when(asyncPromise).then(afterAnimating);\n\t\n\t        function afterAnimating() {\n\t          if (afterAnimating.done) {\n\t            return;\n\t          }\n\t          afterAnimating.done = true;\n\t\n\t          $animateCss(domEl, {\n\t            event: 'leave'\n\t          }).start().then(function() {\n\t            domEl.remove();\n\t            if (closedDeferred) {\n\t              closedDeferred.resolve();\n\t            }\n\t          });\n\t\n\t          scope.$destroy();\n\t          if (done) {\n\t            done();\n\t          }\n\t        }\n\t      }\n\t\n\t      $document.on('keydown', keydownListener);\n\t\n\t      $rootScope.$on('$destroy', function() {\n\t        $document.off('keydown', keydownListener);\n\t      });\n\t\n\t      function keydownListener(evt) {\n\t        if (evt.isDefaultPrevented()) {\n\t          return evt;\n\t        }\n\t\n\t        var modal = openedWindows.top();\n\t        if (modal) {\n\t          switch (evt.which) {\n\t            case 27: {\n\t              if (modal.value.keyboard) {\n\t                evt.preventDefault();\n\t                $rootScope.$apply(function() {\n\t                  $modalStack.dismiss(modal.key, 'escape key press');\n\t                });\n\t              }\n\t              break;\n\t            }\n\t            case 9: {\n\t              $modalStack.loadFocusElementList(modal);\n\t              var focusChanged = false;\n\t              if (evt.shiftKey) {\n\t                if ($modalStack.isFocusInFirstItem(evt) || $modalStack.isModalFocused(evt, modal)) {\n\t                  focusChanged = $modalStack.focusLastFocusableElement();\n\t                }\n\t              } else {\n\t                if ($modalStack.isFocusInLastItem(evt)) {\n\t                  focusChanged = $modalStack.focusFirstFocusableElement();\n\t                }\n\t              }\n\t\n\t              if (focusChanged) {\n\t                evt.preventDefault();\n\t                evt.stopPropagation();\n\t              }\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      $modalStack.open = function(modalInstance, modal) {\n\t        var modalOpener = $document[0].activeElement,\n\t          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\t\n\t        toggleTopWindowClass(false);\n\t\n\t        openedWindows.add(modalInstance, {\n\t          deferred: modal.deferred,\n\t          renderDeferred: modal.renderDeferred,\n\t          closedDeferred: modal.closedDeferred,\n\t          modalScope: modal.scope,\n\t          backdrop: modal.backdrop,\n\t          keyboard: modal.keyboard,\n\t          openedClass: modal.openedClass,\n\t          windowTopClass: modal.windowTopClass,\n\t          animation: modal.animation,\n\t          appendTo: modal.appendTo\n\t        });\n\t\n\t        openedClasses.put(modalBodyClass, modalInstance);\n\t\n\t        var appendToElement = modal.appendTo,\n\t            currBackdropIndex = backdropIndex();\n\t\n\t        if (!appendToElement.length) {\n\t          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');\n\t        }\n\t\n\t        if (currBackdropIndex >= 0 && !backdropDomEl) {\n\t          backdropScope = $rootScope.$new(true);\n\t          backdropScope.modalOptions = modal;\n\t          backdropScope.index = currBackdropIndex;\n\t          backdropDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n\t          backdropDomEl.attr('backdrop-class', modal.backdropClass);\n\t          if (modal.animation) {\n\t            backdropDomEl.attr('modal-animation', 'true');\n\t          }\n\t          $compile(backdropDomEl)(backdropScope);\n\t          $animate.enter(backdropDomEl, appendToElement);\n\t        }\n\t\n\t        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n\t        angularDomEl.attr({\n\t          'template-url': modal.windowTemplateUrl,\n\t          'window-class': modal.windowClass,\n\t          'window-top-class': modal.windowTopClass,\n\t          'size': modal.size,\n\t          'index': openedWindows.length() - 1,\n\t          'animate': 'animate'\n\t        }).html(modal.content);\n\t        if (modal.animation) {\n\t          angularDomEl.attr('modal-animation', 'true');\n\t        }\n\t\n\t        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement)\n\t          .then(function() {\n\t            $animate.addClass(appendToElement, modalBodyClass);\n\t          });\n\t\n\t        openedWindows.top().value.modalDomEl = angularDomEl;\n\t        openedWindows.top().value.modalOpener = modalOpener;\n\t\n\t        $modalStack.clearFocusListCache();\n\t      };\n\t\n\t      function broadcastClosing(modalWindow, resultOrReason, closing) {\n\t        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n\t      }\n\t\n\t      $modalStack.close = function(modalInstance, result) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.resolve(result);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismiss = function(modalInstance, reason) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.reject(reason);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismissAll = function(reason) {\n\t        var topModal = this.getTop();\n\t        while (topModal && this.dismiss(topModal.key, reason)) {\n\t          topModal = this.getTop();\n\t        }\n\t      };\n\t\n\t      $modalStack.getTop = function() {\n\t        return openedWindows.top();\n\t      };\n\t\n\t      $modalStack.modalRendered = function(modalInstance) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.renderDeferred.resolve();\n\t        }\n\t      };\n\t\n\t      $modalStack.focusFirstFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[0].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t      $modalStack.focusLastFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[focusableElementList.length - 1].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isModalFocused = function(evt, modalWindow) {\n\t        if (evt && modalWindow) {\n\t          var modalDomEl = modalWindow.value.modalDomEl;\n\t          if (modalDomEl && modalDomEl.length) {\n\t            return (evt.target || evt.srcElement) === modalDomEl[0];\n\t          }\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInFirstItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) === focusableElementList[0];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInLastItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) === focusableElementList[focusableElementList.length - 1];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.clearFocusListCache = function() {\n\t        focusableElementList = [];\n\t        focusIndex = 0;\n\t      };\n\t\n\t      $modalStack.loadFocusElementList = function(modalWindow) {\n\t        if (focusableElementList === undefined || !focusableElementList.length) {\n\t          if (modalWindow) {\n\t            var modalDomE1 = modalWindow.value.modalDomEl;\n\t            if (modalDomE1 && modalDomE1.length) {\n\t              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      return $modalStack;\n\t    }])\n\t\n\t  .provider('$uibModal', function() {\n\t    var $modalProvider = {\n\t      options: {\n\t        animation: true,\n\t        backdrop: true, //can also be false or 'static'\n\t        keyboard: true\n\t      },\n\t      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',\n\t        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {\n\t          var $modal = {};\n\t\n\t          function getTemplatePromise(options) {\n\t            return options.template ? $q.when(options.template) :\n\t              $templateRequest(angular.isFunction(options.templateUrl) ?\n\t                options.templateUrl() : options.templateUrl);\n\t          }\n\t\n\t          var promiseChain = null;\n\t          $modal.getPromiseChain = function() {\n\t            return promiseChain;\n\t          };\n\t\n\t          $modal.open = function(modalOptions) {\n\t            var modalResultDeferred = $q.defer();\n\t            var modalOpenedDeferred = $q.defer();\n\t            var modalClosedDeferred = $q.defer();\n\t            var modalRenderDeferred = $q.defer();\n\t\n\t            //prepare an instance of a modal to be injected into controllers and returned to a caller\n\t            var modalInstance = {\n\t              result: modalResultDeferred.promise,\n\t              opened: modalOpenedDeferred.promise,\n\t              closed: modalClosedDeferred.promise,\n\t              rendered: modalRenderDeferred.promise,\n\t              close: function (result) {\n\t                return $modalStack.close(modalInstance, result);\n\t              },\n\t              dismiss: function (reason) {\n\t                return $modalStack.dismiss(modalInstance, reason);\n\t              }\n\t            };\n\t\n\t            //merge and clean up options\n\t            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n\t            modalOptions.resolve = modalOptions.resolve || {};\n\t            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);\n\t\n\t            //verify options\n\t            if (!modalOptions.template && !modalOptions.templateUrl) {\n\t              throw new Error('One of template or templateUrl options is required.');\n\t            }\n\t\n\t            var templateAndResolvePromise =\n\t              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);\n\t\n\t            function resolveWithTemplate() {\n\t              return templateAndResolvePromise;\n\t            }\n\t\n\t            // Wait for the resolution of the existing promise chain.\n\t            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n\t            // Then add to $modalStack and resolve opened.\n\t            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n\t            var samePromise;\n\t            samePromise = promiseChain = $q.all([promiseChain])\n\t              .then(resolveWithTemplate, resolveWithTemplate)\n\t              .then(function resolveSuccess(tplAndVars) {\n\t                var providedScope = modalOptions.scope || $rootScope;\n\t\n\t                var modalScope = providedScope.$new();\n\t                modalScope.$close = modalInstance.close;\n\t                modalScope.$dismiss = modalInstance.dismiss;\n\t\n\t                modalScope.$on('$destroy', function() {\n\t                  if (!modalScope.$$uibDestructionScheduled) {\n\t                    modalScope.$dismiss('$uibUnscheduledDestruction');\n\t                  }\n\t                });\n\t\n\t                var ctrlInstance, ctrlLocals = {};\n\t\n\t                //controllers\n\t                if (modalOptions.controller) {\n\t                  ctrlLocals.$scope = modalScope;\n\t                  ctrlLocals.$uibModalInstance = modalInstance;\n\t                  angular.forEach(tplAndVars[1], function(value, key) {\n\t                    ctrlLocals[key] = value;\n\t                  });\n\t\n\t                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n\t                  if (modalOptions.controllerAs) {\n\t                    if (modalOptions.bindToController) {\n\t                      ctrlInstance.$close = modalScope.$close;\n\t                      ctrlInstance.$dismiss = modalScope.$dismiss;\n\t                      angular.extend(ctrlInstance, providedScope);\n\t                    }\n\t\n\t                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n\t                  }\n\t                }\n\t\n\t                $modalStack.open(modalInstance, {\n\t                  scope: modalScope,\n\t                  deferred: modalResultDeferred,\n\t                  renderDeferred: modalRenderDeferred,\n\t                  closedDeferred: modalClosedDeferred,\n\t                  content: tplAndVars[0],\n\t                  animation: modalOptions.animation,\n\t                  backdrop: modalOptions.backdrop,\n\t                  keyboard: modalOptions.keyboard,\n\t                  backdropClass: modalOptions.backdropClass,\n\t                  windowTopClass: modalOptions.windowTopClass,\n\t                  windowClass: modalOptions.windowClass,\n\t                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n\t                  size: modalOptions.size,\n\t                  openedClass: modalOptions.openedClass,\n\t                  appendTo: modalOptions.appendTo\n\t                });\n\t                modalOpenedDeferred.resolve(true);\n\t\n\t            }, function resolveError(reason) {\n\t              modalOpenedDeferred.reject(reason);\n\t              modalResultDeferred.reject(reason);\n\t            })['finally'](function() {\n\t              if (promiseChain === samePromise) {\n\t                promiseChain = null;\n\t              }\n\t            });\n\t\n\t            return modalInstance;\n\t          };\n\t\n\t          return $modal;\n\t        }\n\t      ]\n\t    };\n\t\n\t    return $modalProvider;\n\t  });\n\t\n\tangular.module('ui.bootstrap.paging', [])\n\t/**\n\t * Helper internal service for generating common controller code between the\n\t * pager and pagination components\n\t */\n\t.factory('uibPaging', ['$parse', function($parse) {\n\t  return {\n\t    create: function(ctrl, $scope, $attrs) {\n\t      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl\n\t      ctrl._watchers = [];\n\t\n\t      ctrl.init = function(ngModelCtrl, config) {\n\t        ctrl.ngModelCtrl = ngModelCtrl;\n\t        ctrl.config = config;\n\t\n\t        ngModelCtrl.$render = function() {\n\t          ctrl.render();\n\t        };\n\t\n\t        if ($attrs.itemsPerPage) {\n\t          ctrl._watchers.push($scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n\t            ctrl.itemsPerPage = parseInt(value, 10);\n\t            $scope.totalPages = ctrl.calculateTotalPages();\n\t            ctrl.updatePage();\n\t          }));\n\t        } else {\n\t          ctrl.itemsPerPage = config.itemsPerPage;\n\t        }\n\t\n\t        $scope.$watch('totalItems', function(newTotal, oldTotal) {\n\t          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {\n\t            $scope.totalPages = ctrl.calculateTotalPages();\n\t            ctrl.updatePage();\n\t          }\n\t        });\n\t      };\n\t\n\t      ctrl.calculateTotalPages = function() {\n\t        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);\n\t        return Math.max(totalPages || 0, 1);\n\t      };\n\t\n\t      ctrl.render = function() {\n\t        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;\n\t      };\n\t\n\t      $scope.selectPage = function(page, evt) {\n\t        if (evt) {\n\t          evt.preventDefault();\n\t        }\n\t\n\t        var clickAllowed = !$scope.ngDisabled || !evt;\n\t        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t          if (evt && evt.target) {\n\t            evt.target.blur();\n\t          }\n\t          ctrl.ngModelCtrl.$setViewValue(page);\n\t          ctrl.ngModelCtrl.$render();\n\t        }\n\t      };\n\t\n\t      $scope.getText = function(key) {\n\t        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];\n\t      };\n\t\n\t      $scope.noPrevious = function() {\n\t        return $scope.page === 1;\n\t      };\n\t\n\t      $scope.noNext = function() {\n\t        return $scope.page === $scope.totalPages;\n\t      };\n\t\n\t      ctrl.updatePage = function() {\n\t        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable\n\t\n\t        if ($scope.page > $scope.totalPages) {\n\t          $scope.selectPage($scope.totalPages);\n\t        } else {\n\t          ctrl.ngModelCtrl.$render();\n\t        }\n\t      };\n\t\n\t      $scope.$on('$destroy', function() {\n\t        while (ctrl._watchers.length) {\n\t          ctrl._watchers.shift()();\n\t        }\n\t      });\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])\n\t\n\t.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {\n\t  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;\n\t\n\t  uibPaging.create(this, $scope, $attrs);\n\t}])\n\t\n\t.constant('uibPagerConfig', {\n\t  itemsPerPage: 10,\n\t  previousText: ' Previous',\n\t  nextText: 'Next ',\n\t  align: true\n\t})\n\t\n\t.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {\n\t  return {\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      ngDisabled: '='\n\t    },\n\t    require: ['uibPager', '?ngModel'],\n\t    controller: 'UibPagerController',\n\t    controllerAs: 'pager',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/pager/pager.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t        return; // do nothing if no ng-model\n\t      }\n\t\n\t      paginationCtrl.init(ngModelCtrl, uibPagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])\n\t.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {\n\t  var ctrl = this;\n\t  // Setup configuration parameters\n\t  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,\n\t    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,\n\t    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,\n\t    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers;\n\t  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;\n\t  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;\n\t\n\t  uibPaging.create(this, $scope, $attrs);\n\t\n\t  if ($attrs.maxSize) {\n\t    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {\n\t      maxSize = parseInt(value, 10);\n\t      ctrl.render();\n\t    }));\n\t  }\n\t\n\t  // Create page object used in template\n\t  function makePage(number, text, isActive) {\n\t    return {\n\t      number: number,\n\t      text: text,\n\t      active: isActive\n\t    };\n\t  }\n\t\n\t  function getPages(currentPage, totalPages) {\n\t    var pages = [];\n\t\n\t    // Default page limits\n\t    var startPage = 1, endPage = totalPages;\n\t    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\t\n\t    // recompute if maxSize\n\t    if (isMaxSized) {\n\t      if (rotate) {\n\t        // Current page is displayed in the middle of the visible ones\n\t        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\n\t        endPage = startPage + maxSize - 1;\n\t\n\t        // Adjust if limit is exceeded\n\t        if (endPage > totalPages) {\n\t          endPage = totalPages;\n\t          startPage = endPage - maxSize + 1;\n\t        }\n\t      } else {\n\t        // Visible pages are paginated with maxSize\n\t        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;\n\t\n\t        // Adjust last page if limit is exceeded\n\t        endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t      }\n\t    }\n\t\n\t    // Add page number links\n\t    for (var number = startPage; number <= endPage; number++) {\n\t      var page = makePage(number, number, number === currentPage);\n\t      pages.push(page);\n\t    }\n\t\n\t    // Add links to move between page sets\n\t    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {\n\t      if (startPage > 1) {\n\t        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning\n\t        var previousPageSet = makePage(startPage - 1, '...', false);\n\t        pages.unshift(previousPageSet);\n\t      }\n\t        if (boundaryLinkNumbers) {\n\t          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential\n\t            var secondPageLink = makePage(2, '2', false);\n\t            pages.unshift(secondPageLink);\n\t          }\n\t          //add the first page\n\t          var firstPageLink = makePage(1, '1', false);\n\t          pages.unshift(firstPageLink);\n\t        }\n\t      }\n\t\n\t      if (endPage < totalPages) {\n\t        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end\n\t        var nextPageSet = makePage(endPage + 1, '...', false);\n\t        pages.push(nextPageSet);\n\t      }\n\t        if (boundaryLinkNumbers) {\n\t          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential\n\t            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);\n\t            pages.push(secondToLastPageLink);\n\t          }\n\t          //add the last page\n\t          var lastPageLink = makePage(totalPages, totalPages, false);\n\t          pages.push(lastPageLink);\n\t        }\n\t      }\n\t    }\n\t    return pages;\n\t  }\n\t\n\t  var originalRender = this.render;\n\t  this.render = function() {\n\t    originalRender();\n\t    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {\n\t      $scope.pages = getPages($scope.page, $scope.totalPages);\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('uibPaginationConfig', {\n\t  itemsPerPage: 10,\n\t  boundaryLinks: false,\n\t  boundaryLinkNumbers: false,\n\t  directionLinks: true,\n\t  firstText: 'First',\n\t  previousText: 'Previous',\n\t  nextText: 'Next',\n\t  lastText: 'Last',\n\t  rotate: true,\n\t  forceEllipses: false\n\t})\n\t\n\t.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {\n\t  return {\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@',\n\t      ngDisabled:'='\n\t    },\n\t    require: ['uibPagination', '?ngModel'],\n\t    controller: 'UibPaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/pagination/pagination.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html tooltips, and selector delegation.\n\t */\n\tangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\t\n\t/**\n\t * The $tooltip service creates tooltip- and popover-like directives as well as\n\t * houses global options for them.\n\t */\n\t.provider('$uibTooltip', function() {\n\t  // The default options tooltip and popover.\n\t  var defaultOptions = {\n\t    placement: 'top',\n\t    placementClassPrefix: '',\n\t    animation: true,\n\t    popupDelay: 0,\n\t    popupCloseDelay: 0,\n\t    useContentExp: false\n\t  };\n\t\n\t  // Default hide triggers for each show trigger\n\t  var triggerMap = {\n\t    'mouseenter': 'mouseleave',\n\t    'click': 'click',\n\t    'outsideClick': 'outsideClick',\n\t    'focus': 'blur',\n\t    'none': ''\n\t  };\n\t\n\t  // The options specified to the provider globally.\n\t  var globalOptions = {};\n\t\n\t  /**\n\t   * `options({})` allows global configuration of all tooltips in the\n\t   * application.\n\t   *\n\t   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n\t   *     // place tooltips left instead of top by default\n\t   *     $tooltipProvider.options( { placement: 'left' } );\n\t   *   });\n\t   */\n\t\tthis.options = function(value) {\n\t\t\tangular.extend(globalOptions, value);\n\t\t};\n\t\n\t  /**\n\t   * This allows you to extend the set of trigger mappings available. E.g.:\n\t   *\n\t   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n\t   */\n\t  this.setTriggers = function setTriggers(triggers) {\n\t    angular.extend(triggerMap, triggers);\n\t  };\n\t\n\t  /**\n\t   * This is a helper function for translating camel-case to snake_case.\n\t   */\n\t  function snake_case(name) {\n\t    var regexp = /[A-Z]/g;\n\t    var separator = '-';\n\t    return name.replace(regexp, function(letter, pos) {\n\t      return (pos ? separator : '') + letter.toLowerCase();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns the actual instance of the $tooltip service.\n\t   * TODO support multiple triggers\n\t   */\n\t  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n\t    var openedTooltips = $$stackedMap.createNew();\n\t    $document.on('keypress', keypressListener);\n\t\n\t    $rootScope.$on('$destroy', function() {\n\t      $document.off('keypress', keypressListener);\n\t    });\n\t\n\t    function keypressListener(e) {\n\t      if (e.which === 27) {\n\t        var last = openedTooltips.top();\n\t        if (last) {\n\t          last.value.close();\n\t          openedTooltips.removeTop();\n\t          last = null;\n\t        }\n\t      }\n\t    }\n\t\n\t    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n\t      options = angular.extend({}, defaultOptions, globalOptions, options);\n\t\n\t      /**\n\t       * Returns an object of show and hide triggers.\n\t       *\n\t       * If a trigger is supplied,\n\t       * it is used to show the tooltip; otherwise, it will use the `trigger`\n\t       * option passed to the `$tooltipProvider.options` method; else it will\n\t       * default to the trigger supplied to this directive factory.\n\t       *\n\t       * The hide trigger is based on the show trigger. If the `trigger` option\n\t       * was passed to the `$tooltipProvider.options` method, it will use the\n\t       * mapped trigger from `triggerMap` or the passed trigger if the map is\n\t       * undefined; otherwise, it uses the `triggerMap` value of the show\n\t       * trigger; else it will just use the show trigger.\n\t       */\n\t      function getTriggers(trigger) {\n\t        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n\t        var hide = show.map(function(trigger) {\n\t          return triggerMap[trigger] || trigger;\n\t        });\n\t        return {\n\t          show: show,\n\t          hide: hide\n\t        };\n\t      }\n\t\n\t      var directiveName = snake_case(ttType);\n\t\n\t      var startSym = $interpolate.startSymbol();\n\t      var endSym = $interpolate.endSymbol();\n\t      var template =\n\t        '<div '+ directiveName + '-popup '+\n\t          'title=\"' + startSym + 'title' + endSym + '\" '+\n\t          (options.useContentExp ?\n\t            'content-exp=\"contentExp()\" ' :\n\t            'content=\"' + startSym + 'content' + endSym + '\" ') +\n\t          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n\t          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n\t          'animation=\"animation\" ' +\n\t          'is-open=\"isOpen\"' +\n\t          'origin-scope=\"origScope\" ' +\n\t          'style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"' +\n\t          '>' +\n\t        '</div>';\n\t\n\t      return {\n\t        compile: function(tElem, tAttrs) {\n\t          var tooltipLinker = $compile(template);\n\t\n\t          return function link(scope, element, attrs, tooltipCtrl) {\n\t            var tooltip;\n\t            var tooltipLinkedScope;\n\t            var transitionTimeout;\n\t            var showTimeout;\n\t            var hideTimeout;\n\t            var positionTimeout;\n\t            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n\t            var triggers = getTriggers(undefined);\n\t            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n\t            var ttScope = scope.$new(true);\n\t            var repositionScheduled = false;\n\t            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n\t            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n\t            var observers = [];\n\t\n\t            var positionTooltip = function() {\n\t              // check if tooltip exists and is not empty\n\t              if (!tooltip || !tooltip.html()) { return; }\n\t\n\t              if (!positionTimeout) {\n\t                positionTimeout = $timeout(function() {\n\t                  // Reset the positioning.\n\t                  tooltip.css({ top: 0, left: 0 });\n\t\n\t                  // Now set the calculated positioning.\n\t                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n\t                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px', visibility: 'visible' });\n\t\n\t                  // If the placement class is prefixed, still need\n\t                  // to remove the TWBS standard class.\n\t                  if (options.placementClassPrefix) {\n\t                    tooltip.removeClass('top bottom left right');\n\t                  }\n\t\n\t                  tooltip.removeClass(\n\t                    options.placementClassPrefix + 'top ' +\n\t                    options.placementClassPrefix + 'top-left ' +\n\t                    options.placementClassPrefix + 'top-right ' +\n\t                    options.placementClassPrefix + 'bottom ' +\n\t                    options.placementClassPrefix + 'bottom-left ' +\n\t                    options.placementClassPrefix + 'bottom-right ' +\n\t                    options.placementClassPrefix + 'left ' +\n\t                    options.placementClassPrefix + 'left-top ' +\n\t                    options.placementClassPrefix + 'left-bottom ' +\n\t                    options.placementClassPrefix + 'right ' +\n\t                    options.placementClassPrefix + 'right-top ' +\n\t                    options.placementClassPrefix + 'right-bottom');\n\t\n\t                  var placement = ttPosition.placement.split('-');\n\t                  tooltip.addClass(placement[0] + ' ' + options.placementClassPrefix + ttPosition.placement);\n\t                  $position.positionArrow(tooltip, ttPosition.placement);\n\t\n\t                  positionTimeout = null;\n\t                }, 0, false);\n\t              }\n\t            };\n\t\n\t            // Set up the correct scope to allow transclusion later\n\t            ttScope.origScope = scope;\n\t\n\t            // By default, the tooltip is not open.\n\t            // TODO add ability to start tooltip opened\n\t            ttScope.isOpen = false;\n\t            openedTooltips.add(ttScope, {\n\t              close: hide\n\t            });\n\t\n\t            function toggleTooltipBind() {\n\t              if (!ttScope.isOpen) {\n\t                showTooltipBind();\n\t              } else {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip with delay if specified, otherwise show it immediately\n\t            function showTooltipBind() {\n\t              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n\t                return;\n\t              }\n\t\n\t              cancelHide();\n\t              prepareTooltip();\n\t\n\t              if (ttScope.popupDelay) {\n\t                // Do nothing if the tooltip was already scheduled to pop-up.\n\t                // This happens if show is triggered multiple times before any hide is triggered.\n\t                if (!showTimeout) {\n\t                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n\t                }\n\t              } else {\n\t                show();\n\t              }\n\t            }\n\t\n\t            function hideTooltipBind() {\n\t              cancelShow();\n\t\n\t              if (ttScope.popupCloseDelay) {\n\t                if (!hideTimeout) {\n\t                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n\t                }\n\t              } else {\n\t                hide();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip popup element.\n\t            function show() {\n\t              cancelShow();\n\t              cancelHide();\n\t\n\t              // Don't show empty tooltips.\n\t              if (!ttScope.content) {\n\t                return angular.noop;\n\t              }\n\t\n\t              createTooltip();\n\t\n\t              // And show the tooltip.\n\t              ttScope.$evalAsync(function() {\n\t                ttScope.isOpen = true;\n\t                assignIsOpen(true);\n\t                positionTooltip();\n\t              });\n\t            }\n\t\n\t            function cancelShow() {\n\t              if (showTimeout) {\n\t                $timeout.cancel(showTimeout);\n\t                showTimeout = null;\n\t              }\n\t\n\t              if (positionTimeout) {\n\t                $timeout.cancel(positionTimeout);\n\t                positionTimeout = null;\n\t              }\n\t            }\n\t\n\t            // Hide the tooltip popup element.\n\t            function hide() {\n\t              if (!ttScope) {\n\t                return;\n\t              }\n\t\n\t              // First things first: we don't show it anymore.\n\t              ttScope.$evalAsync(function() {\n\t                if (ttScope) {\n\t                  ttScope.isOpen = false;\n\t                  assignIsOpen(false);\n\t                  // And now we remove it from the DOM. However, if we have animation, we\n\t                  // need to wait for it to expire beforehand.\n\t                  // FIXME: this is a placeholder for a port of the transitions library.\n\t                  // The fade transition in TWBS is 150ms.\n\t                  if (ttScope.animation) {\n\t                    if (!transitionTimeout) {\n\t                      transitionTimeout = $timeout(removeTooltip, 150, false);\n\t                    }\n\t                  } else {\n\t                    removeTooltip();\n\t                  }\n\t                }\n\t              });\n\t            }\n\t\n\t            function cancelHide() {\n\t              if (hideTimeout) {\n\t                $timeout.cancel(hideTimeout);\n\t                hideTimeout = null;\n\t              }\n\t\n\t              if (transitionTimeout) {\n\t                $timeout.cancel(transitionTimeout);\n\t                transitionTimeout = null;\n\t              }\n\t            }\n\t\n\t            function createTooltip() {\n\t              // There can only be one tooltip element per directive shown at once.\n\t              if (tooltip) {\n\t                return;\n\t              }\n\t\n\t              tooltipLinkedScope = ttScope.$new();\n\t              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n\t                if (appendToBody) {\n\t                  $document.find('body').append(tooltip);\n\t                } else {\n\t                  element.after(tooltip);\n\t                }\n\t              });\n\t\n\t              prepObservers();\n\t            }\n\t\n\t            function removeTooltip() {\n\t              cancelShow();\n\t              cancelHide();\n\t              unregisterObservers();\n\t\n\t              if (tooltip) {\n\t                tooltip.remove();\n\t                tooltip = null;\n\t              }\n\t              if (tooltipLinkedScope) {\n\t                tooltipLinkedScope.$destroy();\n\t                tooltipLinkedScope = null;\n\t              }\n\t            }\n\t\n\t            /**\n\t             * Set the initial scope values. Once\n\t             * the tooltip is created, the observers\n\t             * will be added to keep things in sync.\n\t             */\n\t            function prepareTooltip() {\n\t              ttScope.title = attrs[prefix + 'Title'];\n\t              if (contentParse) {\n\t                ttScope.content = contentParse(scope);\n\t              } else {\n\t                ttScope.content = attrs[ttType];\n\t              }\n\t\n\t              ttScope.popupClass = attrs[prefix + 'Class'];\n\t              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\t\n\t              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n\t              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n\t              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n\t              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n\t            }\n\t\n\t            function assignIsOpen(isOpen) {\n\t              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n\t                isOpenParse.assign(scope, isOpen);\n\t              }\n\t            }\n\t\n\t            ttScope.contentExp = function() {\n\t              return ttScope.content;\n\t            };\n\t\n\t            /**\n\t             * Observe the relevant attributes.\n\t             */\n\t            attrs.$observe('disabled', function(val) {\n\t              if (val) {\n\t                cancelShow();\n\t              }\n\t\n\t              if (val && ttScope.isOpen) {\n\t                hide();\n\t              }\n\t            });\n\t\n\t            if (isOpenParse) {\n\t              scope.$watch(isOpenParse, function(val) {\n\t                if (ttScope && !val === ttScope.isOpen) {\n\t                  toggleTooltipBind();\n\t                }\n\t              });\n\t            }\n\t\n\t            function prepObservers() {\n\t              observers.length = 0;\n\t\n\t              if (contentParse) {\n\t                observers.push(\n\t                  scope.$watch(contentParse, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    }\n\t                  })\n\t                );\n\t\n\t                observers.push(\n\t                  tooltipLinkedScope.$watch(function() {\n\t                    if (!repositionScheduled) {\n\t                      repositionScheduled = true;\n\t                      tooltipLinkedScope.$$postDigest(function() {\n\t                        repositionScheduled = false;\n\t                        if (ttScope && ttScope.isOpen) {\n\t                          positionTooltip();\n\t                        }\n\t                      });\n\t                    }\n\t                  })\n\t                );\n\t              } else {\n\t                observers.push(\n\t                  attrs.$observe(ttType, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    } else {\n\t                      positionTooltip();\n\t                    }\n\t                  })\n\t                );\n\t              }\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Title', function(val) {\n\t                  ttScope.title = val;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Placement', function(val) {\n\t                  ttScope.placement = val ? val : options.placement;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t            }\n\t\n\t            function unregisterObservers() {\n\t              if (observers.length) {\n\t                angular.forEach(observers, function(observer) {\n\t                  observer();\n\t                });\n\t                observers.length = 0;\n\t              }\n\t            }\n\t\n\t            // hide tooltips/popovers for outsideClick trigger\n\t            function bodyHideTooltipBind(e) {\n\t              if (!ttScope || !ttScope.isOpen || !tooltip) {\n\t                return;\n\t              }\n\t              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked\n\t              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            var unregisterTriggers = function() {\n\t              triggers.show.forEach(function(trigger) {\n\t                if (trigger === 'outsideClick') {\n\t                  element.off('click', toggleTooltipBind);\n\t                } else {\n\t                  element.off(trigger, showTooltipBind);\n\t                  element.off(trigger, toggleTooltipBind);\n\t                }\n\t              });\n\t              triggers.hide.forEach(function(trigger) {\n\t                if (trigger === 'outsideClick') {\n\t                  $document.off('click', bodyHideTooltipBind);\n\t                } else {\n\t                  element.off(trigger, hideTooltipBind);\n\t                }\n\t              });\n\t            };\n\t\n\t            function prepTriggers() {\n\t              var val = attrs[prefix + 'Trigger'];\n\t              unregisterTriggers();\n\t\n\t              triggers = getTriggers(val);\n\t\n\t              if (triggers.show !== 'none') {\n\t                triggers.show.forEach(function(trigger, idx) {\n\t                  if (trigger === 'outsideClick') {\n\t                    element.on('click', toggleTooltipBind);\n\t                    $document.on('click', bodyHideTooltipBind);\n\t                  } else if (trigger === triggers.hide[idx]) {\n\t                    element.on(trigger, toggleTooltipBind);\n\t                  } else if (trigger) {\n\t                    element.on(trigger, showTooltipBind);\n\t                    element.on(triggers.hide[idx], hideTooltipBind);\n\t                  }\n\t\n\t                  element.on('keypress', function(e) {\n\t                    if (e.which === 27) {\n\t                      hideTooltipBind();\n\t                    }\n\t                  });\n\t                });\n\t              }\n\t            }\n\t\n\t            prepTriggers();\n\t\n\t            var animation = scope.$eval(attrs[prefix + 'Animation']);\n\t            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\t\n\t            var appendToBodyVal;\n\t            var appendKey = prefix + 'AppendToBody';\n\t            if (appendKey in attrs && attrs[appendKey] === undefined) {\n\t              appendToBodyVal = true;\n\t            } else {\n\t              appendToBodyVal = scope.$eval(attrs[appendKey]);\n\t            }\n\t\n\t            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\t            \n\t            // Make sure tooltip is destroyed and removed.\n\t            scope.$on('$destroy', function onDestroyTooltip() {\n\t              unregisterTriggers();\n\t              removeTooltip();\n\t              openedTooltips.remove(ttScope);\n\t              ttScope = null;\n\t            });\n\t          };\n\t        }\n\t      };\n\t    };\n\t  }];\n\t})\n\t\n\t// This is mostly ngInclude code but with a custom scope\n\t.directive('uibTooltipTemplateTransclude', [\n\t         '$animate', '$sce', '$compile', '$templateRequest',\n\tfunction ($animate, $sce, $compile, $templateRequest) {\n\t  return {\n\t    link: function(scope, elem, attrs) {\n\t      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\t\n\t      var changeCounter = 0,\n\t        currentScope,\n\t        previousElement,\n\t        currentElement;\n\t\n\t      var cleanupLastIncludeContent = function() {\n\t        if (previousElement) {\n\t          previousElement.remove();\n\t          previousElement = null;\n\t        }\n\t\n\t        if (currentScope) {\n\t          currentScope.$destroy();\n\t          currentScope = null;\n\t        }\n\t\n\t        if (currentElement) {\n\t          $animate.leave(currentElement).then(function() {\n\t            previousElement = null;\n\t          });\n\t          previousElement = currentElement;\n\t          currentElement = null;\n\t        }\n\t      };\n\t\n\t      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n\t        var thisChangeId = ++changeCounter;\n\t\n\t        if (src) {\n\t          //set the 2nd param to true to ignore the template request error so that the inner\n\t          //contents and scope can be cleaned up.\n\t          $templateRequest(src, true).then(function(response) {\n\t            if (thisChangeId !== changeCounter) { return; }\n\t            var newScope = origScope.$new();\n\t            var template = response;\n\t\n\t            var clone = $compile(template)(newScope, function(clone) {\n\t              cleanupLastIncludeContent();\n\t              $animate.enter(clone, elem);\n\t            });\n\t\n\t            currentScope = newScope;\n\t            currentElement = clone;\n\t\n\t            currentScope.$emit('$includeContentLoaded', src);\n\t          }, function() {\n\t            if (thisChangeId === changeCounter) {\n\t              cleanupLastIncludeContent();\n\t              scope.$emit('$includeContentError', src);\n\t            }\n\t          });\n\t          scope.$emit('$includeContentRequested', src);\n\t        } else {\n\t          cleanupLastIncludeContent();\n\t        }\n\t      });\n\t\n\t      scope.$on('$destroy', cleanupLastIncludeContent);\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * Note that it's intentional that these classes are *not* applied through $animate.\n\t * They must not be animated as they're expected to be present on the tooltip on\n\t * initialization.\n\t */\n\t.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attrs) {\n\t      // need to set the primary position so the\n\t      // arrow has space during position measure.\n\t      // tooltip.positionTooltip()\n\t      if (scope.placement) {\n\t        // // There are no top-left etc... classes\n\t        // // in TWBS, so we need the primary position.\n\t        var position = $uibPosition.parsePlacement(scope.placement);\n\t        element.addClass(position[0]);\n\t      } else {\n\t        element.addClass('top');\n\t      }\n\t\n\t      if (scope.popupClass) {\n\t        element.addClass(scope.popupClass);\n\t      }\n\t\n\t      if (scope.animation()) {\n\t        element.addClass(attrs.tooltipAnimationClass);\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTooltipPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/tooltip/tooltip-popup.html'\n\t  };\n\t})\n\t\n\t.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n\t}])\n\t\n\t.directive('uibTooltipTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'\n\t  };\n\t})\n\t\n\t.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibTooltipHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'\n\t  };\n\t})\n\t\n\t.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: popup delay, animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, and selector delegatation.\n\t */\n\tangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\t\n\t.directive('uibPopoverTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'uib/template/popover/popover-template.html'\n\t  };\n\t})\n\t\n\t.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/popover/popover-html.html'\n\t  };\n\t})\n\t\n\t.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/popover/popover.html'\n\t  };\n\t})\n\t\n\t.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopover', 'popover', 'click');\n\t}]);\n\t\n\tangular.module('ui.bootstrap.progressbar', [])\n\t\n\t.constant('uibProgressConfig', {\n\t  animate: true,\n\t  max: 100\n\t})\n\t\n\t.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n\t  var self = this,\n\t      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t  this.bars = [];\n\t  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\t\n\t  this.addBar = function(bar, element, attrs) {\n\t    if (!animate) {\n\t      element.css({'transition': 'none'});\n\t    }\n\t\n\t    this.bars.push(bar);\n\t\n\t    bar.max = $scope.max;\n\t    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\t\n\t    bar.$watch('value', function(value) {\n\t      bar.recalculatePercentage();\n\t    });\n\t\n\t    bar.recalculatePercentage = function() {\n\t      var totalPercentage = self.bars.reduce(function(total, bar) {\n\t        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\t        return total + bar.percent;\n\t      }, 0);\n\t\n\t      if (totalPercentage > 100) {\n\t        bar.percent -= totalPercentage - 100;\n\t      }\n\t    };\n\t\n\t    bar.$on('$destroy', function() {\n\t      element = null;\n\t      self.removeBar(bar);\n\t    });\n\t  };\n\t\n\t  this.removeBar = function(bar) {\n\t    this.bars.splice(this.bars.indexOf(bar), 1);\n\t    this.bars.forEach(function (bar) {\n\t      bar.recalculatePercentage();\n\t    });\n\t  };\n\t\n\t  $scope.$watch('max', function(max) {\n\t    self.bars.forEach(function(bar) {\n\t      bar.max = $scope.max;\n\t      bar.recalculatePercentage();\n\t    });\n\t  });\n\t}])\n\t\n\t.directive('uibProgress', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    require: 'uibProgress',\n\t    scope: {\n\t      max: '=?'\n\t    },\n\t    templateUrl: 'uib/template/progressbar/progress.html'\n\t  };\n\t})\n\t\n\t.directive('uibBar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    require: '^uibProgress',\n\t    scope: {\n\t      value: '=',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'uib/template/progressbar/bar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, element, attrs);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibProgressbar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    scope: {\n\t      value: '=',\n\t      max: '=?',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'uib/template/progressbar/progressbar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.rating', [])\n\t\n\t.constant('uibRatingConfig', {\n\t  max: 5,\n\t  stateOn: null,\n\t  stateOff: null,\n\t  titles : ['one', 'two', 'three', 'four', 'five']\n\t})\n\t\n\t.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n\t  var ngModelCtrl = { $setViewValue: angular.noop };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.push(function(value) {\n\t      if (angular.isNumber(value) && value << 0 !== value) {\n\t        value = Math.round(value);\n\t      }\n\t\n\t      return value;\n\t    });\n\t\n\t    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n\t    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\t    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n\t    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n\t      tmpTitles : ratingConfig.titles;\n\t\n\t    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n\t      $scope.$parent.$eval($attrs.ratingStates) :\n\t      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n\t    $scope.range = this.buildTemplateObjects(ratingStates);\n\t  };\n\t\n\t  this.buildTemplateObjects = function(states) {\n\t    for (var i = 0, n = states.length; i < n; i++) {\n\t      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n\t    }\n\t    return states;\n\t  };\n\t\n\t  this.getTitle = function(index) {\n\t    if (index >= this.titles.length) {\n\t      return index + 1;\n\t    }\n\t\n\t    return this.titles[index];\n\t  };\n\t\n\t  $scope.rate = function(value) {\n\t    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n\t      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.enter = function(value) {\n\t    if (!$scope.readonly) {\n\t      $scope.value = value;\n\t    }\n\t    $scope.onHover({value: value});\n\t  };\n\t\n\t  $scope.reset = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t    $scope.onLeave();\n\t  };\n\t\n\t  $scope.onKeydown = function(evt) {\n\t    if (/(37|38|39|40)/.test(evt.which)) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n\t    }\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t  };\n\t}])\n\t\n\t.directive('uibRating', function() {\n\t  return {\n\t    require: ['uibRating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'UibRatingController',\n\t    templateUrl: 'uib/template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      ratingCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.tabs', [])\n\t\n\t.controller('UibTabsetController', ['$scope', function ($scope) {\n\t  var ctrl = this,\n\t      tabs = ctrl.tabs = $scope.tabs = [];\n\t\n\t  ctrl.select = function(selectedTab) {\n\t    angular.forEach(tabs, function(tab) {\n\t      if (tab.active && tab !== selectedTab) {\n\t        tab.active = false;\n\t        tab.onDeselect();\n\t        selectedTab.selectCalled = false;\n\t      }\n\t    });\n\t    selectedTab.active = true;\n\t    // only call select if it has not already been called\n\t    if (!selectedTab.selectCalled) {\n\t      selectedTab.onSelect();\n\t      selectedTab.selectCalled = true;\n\t    }\n\t  };\n\t\n\t  ctrl.addTab = function addTab(tab) {\n\t    tabs.push(tab);\n\t    // we can't run the select function on the first tab\n\t    // since that would select it twice\n\t    if (tabs.length === 1 && tab.active !== false) {\n\t      tab.active = true;\n\t    } else if (tab.active) {\n\t      ctrl.select(tab);\n\t    } else {\n\t      tab.active = false;\n\t    }\n\t  };\n\t\n\t  ctrl.removeTab = function removeTab(tab) {\n\t    var index = tabs.indexOf(tab);\n\t    //Select a new tab if the tab to be removed is selected and not destroyed\n\t    if (tab.active && tabs.length > 1 && !destroyed) {\n\t      //If this is the last tab, select the previous tab. else, the next tab.\n\t      var newActiveIndex = index === tabs.length - 1 ? index - 1 : index + 1;\n\t      ctrl.select(tabs[newActiveIndex]);\n\t    }\n\t    tabs.splice(index, 1);\n\t  };\n\t\n\t  var destroyed;\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t  });\n\t}])\n\t\n\t.directive('uibTabset', function() {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@'\n\t    },\n\t    controller: 'UibTabsetController',\n\t    templateUrl: 'uib/template/tabs/tabset.html',\n\t    link: function(scope, element, attrs) {\n\t      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n\t      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTab', ['$parse', function($parse) {\n\t  return {\n\t    require: '^uibTabset',\n\t    replace: true,\n\t    templateUrl: 'uib/template/tabs/tab.html',\n\t    transclude: true,\n\t    scope: {\n\t      active: '=?',\n\t      heading: '@',\n\t      onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t                          //once it inserts the tab's content into the dom\n\t      onDeselect: '&deselect'\n\t    },\n\t    controller: function() {\n\t      //Empty controller so other directives can require being 'under' a tab\n\t    },\n\t    controllerAs: 'tab',\n\t    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          tabsetCtrl.select(scope);\n\t        }\n\t      });\n\t\n\t      scope.disabled = false;\n\t      if (attrs.disable) {\n\t        scope.$parent.$watch($parse(attrs.disable), function(value) {\n\t          scope.disabled = !! value;\n\t        });\n\t      }\n\t\n\t      scope.select = function() {\n\t        if (!scope.disabled) {\n\t          scope.active = true;\n\t        }\n\t      };\n\t\n\t      tabsetCtrl.addTab(scope);\n\t      scope.$on('$destroy', function() {\n\t        tabsetCtrl.removeTab(scope);\n\t      });\n\t\n\t      //We need to transclude later, once the content container is ready.\n\t      //when this link happens, we're inside a tab heading.\n\t      scope.$transcludeFn = transclude;\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTabHeadingTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^uibTab',\n\t    link: function(scope, elm) {\n\t      scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t        if (heading) {\n\t          elm.html('');\n\t          elm.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTabContentTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^uibTabset',\n\t    link: function(scope, elm, attrs) {\n\t      var tab = scope.$eval(attrs.uibTabContentTransclude);\n\t\n\t      //Now our tab is ready to be transcluded: both the tab heading area\n\t      //and the tab content area are loaded.  Transclude 'em both.\n\t      tab.$transcludeFn(tab.$parent, function(contents) {\n\t        angular.forEach(contents, function(node) {\n\t          if (isTabHeading(node)) {\n\t            //Let tabHeadingTransclude know.\n\t            tab.headingElement = node;\n\t          } else {\n\t            elm.append(node);\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t\n\t  function isTabHeading(node) {\n\t    return node.tagName && (\n\t      node.hasAttribute('uib-tab-heading') ||\n\t      node.hasAttribute('data-uib-tab-heading') ||\n\t      node.hasAttribute('x-uib-tab-heading') ||\n\t      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n\t    );\n\t  }\n\t});\n\t\n\tangular.module('ui.bootstrap.timepicker', [])\n\t\n\t.constant('uibTimepickerConfig', {\n\t  hourStep: 1,\n\t  minuteStep: 1,\n\t  secondStep: 1,\n\t  showMeridian: true,\n\t  showSeconds: false,\n\t  meridians: null,\n\t  readonlyInput: false,\n\t  mousewheel: true,\n\t  arrowkeys: true,\n\t  showSpinners: true,\n\t  templateUrl: 'uib/template/timepicker/timepicker.html'\n\t})\n\t\n\t.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n\t  var selected = new Date(),\n\t    watchers = [],\n\t    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\t\n\t  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n\t  $element.removeAttr('tabindex');\n\t\n\t  this.init = function(ngModelCtrl_, inputs) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.unshift(function(modelValue) {\n\t      return modelValue ? new Date(modelValue) : null;\n\t    });\n\t\n\t    var hoursInputEl = inputs.eq(0),\n\t        minutesInputEl = inputs.eq(1),\n\t        secondsInputEl = inputs.eq(2);\n\t\n\t    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\t\n\t    if (mousewheel) {\n\t      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n\t    }\n\t\n\t    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n\t    if (arrowkeys) {\n\t      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n\t    }\n\t\n\t    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n\t    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n\t  };\n\t\n\t  var hourStep = timepickerConfig.hourStep;\n\t  if ($attrs.hourStep) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n\t      hourStep = +value;\n\t    }));\n\t  }\n\t\n\t  var minuteStep = timepickerConfig.minuteStep;\n\t  if ($attrs.minuteStep) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n\t      minuteStep = +value;\n\t    }));\n\t  }\n\t\n\t  var min;\n\t  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {\n\t    var dt = new Date(value);\n\t    min = isNaN(dt) ? undefined : dt;\n\t  }));\n\t\n\t  var max;\n\t  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {\n\t    var dt = new Date(value);\n\t    max = isNaN(dt) ? undefined : dt;\n\t  }));\n\t\n\t  var disabled = false;\n\t  if ($attrs.ngDisabled) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {\n\t      disabled = value;\n\t    }));\n\t  }\n\t\n\t  $scope.noIncrementHours = function() {\n\t    var incrementedSelected = addMinutes(selected, hourStep * 60);\n\t    return disabled || incrementedSelected > max ||\n\t      incrementedSelected < selected && incrementedSelected < min;\n\t  };\n\t\n\t  $scope.noDecrementHours = function() {\n\t    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n\t    return disabled || decrementedSelected < min ||\n\t      decrementedSelected > selected && decrementedSelected > max;\n\t  };\n\t\n\t  $scope.noIncrementMinutes = function() {\n\t    var incrementedSelected = addMinutes(selected, minuteStep);\n\t    return disabled || incrementedSelected > max ||\n\t      incrementedSelected < selected && incrementedSelected < min;\n\t  };\n\t\n\t  $scope.noDecrementMinutes = function() {\n\t    var decrementedSelected = addMinutes(selected, -minuteStep);\n\t    return disabled || decrementedSelected < min ||\n\t      decrementedSelected > selected && decrementedSelected > max;\n\t  };\n\t\n\t  $scope.noIncrementSeconds = function() {\n\t    var incrementedSelected = addSeconds(selected, secondStep);\n\t    return disabled || incrementedSelected > max ||\n\t      incrementedSelected < selected && incrementedSelected < min;\n\t  };\n\t\n\t  $scope.noDecrementSeconds = function() {\n\t    var decrementedSelected = addSeconds(selected, -secondStep);\n\t    return disabled || decrementedSelected < min ||\n\t      decrementedSelected > selected && decrementedSelected > max;\n\t  };\n\t\n\t  $scope.noToggleMeridian = function() {\n\t    if (selected.getHours() < 12) {\n\t      return disabled || addMinutes(selected, 12 * 60) > max;\n\t    }\n\t\n\t    return disabled || addMinutes(selected, -12 * 60) < min;\n\t  };\n\t\n\t  var secondStep = timepickerConfig.secondStep;\n\t  if ($attrs.secondStep) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {\n\t      secondStep = +value;\n\t    }));\n\t  }\n\t\n\t  $scope.showSeconds = timepickerConfig.showSeconds;\n\t  if ($attrs.showSeconds) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {\n\t      $scope.showSeconds = !!value;\n\t    }));\n\t  }\n\t\n\t  // 12H / 24H mode\n\t  $scope.showMeridian = timepickerConfig.showMeridian;\n\t  if ($attrs.showMeridian) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n\t      $scope.showMeridian = !!value;\n\t\n\t      if (ngModelCtrl.$error.time) {\n\t        // Evaluate from template\n\t        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n\t        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t          selected.setHours(hours);\n\t          refresh();\n\t        }\n\t      } else {\n\t        updateTemplate();\n\t      }\n\t    }));\n\t  }\n\t\n\t  // Get $scope.hours in 24H mode if valid\n\t  function getHoursFromTemplate() {\n\t    var hours = +$scope.hours;\n\t    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :\n\t      hours >= 0 && hours < 24;\n\t    if (!valid) {\n\t      return undefined;\n\t    }\n\t\n\t    if ($scope.showMeridian) {\n\t      if (hours === 12) {\n\t        hours = 0;\n\t      }\n\t      if ($scope.meridian === meridians[1]) {\n\t        hours = hours + 12;\n\t      }\n\t    }\n\t    return hours;\n\t  }\n\t\n\t  function getMinutesFromTemplate() {\n\t    var minutes = +$scope.minutes;\n\t    return minutes >= 0 && minutes < 60 ? minutes : undefined;\n\t  }\n\t\n\t  function getSecondsFromTemplate() {\n\t    var seconds = +$scope.seconds;\n\t    return seconds >= 0 && seconds < 60 ? seconds : undefined;\n\t  }\n\t\n\t  function pad(value) {\n\t    if (value === null) {\n\t      return '';\n\t    }\n\t\n\t    return angular.isDefined(value) && value.toString().length < 2 ?\n\t      '0' + value : value.toString();\n\t  }\n\t\n\t  // Respond on mousewheel spin\n\t  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n\t    var isScrollingUp = function(e) {\n\t      if (e.originalEvent) {\n\t        e = e.originalEvent;\n\t      }\n\t      //pick correct delta variable depending on event\n\t      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;\n\t      return e.detail || delta > 0;\n\t    };\n\t\n\t    hoursInputEl.bind('mousewheel wheel', function(e) {\n\t      if (!disabled) {\n\t        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n\t      }\n\t      e.preventDefault();\n\t    });\n\t\n\t    minutesInputEl.bind('mousewheel wheel', function(e) {\n\t      if (!disabled) {\n\t        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n\t      }\n\t      e.preventDefault();\n\t    });\n\t\n\t     secondsInputEl.bind('mousewheel wheel', function(e) {\n\t      if (!disabled) {\n\t        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());\n\t      }\n\t      e.preventDefault();\n\t    });\n\t  };\n\t\n\t  // Respond on up/down arrowkeys\n\t  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n\t    hoursInputEl.bind('keydown', function(e) {\n\t      if (!disabled) {\n\t        if (e.which === 38) { // up\n\t          e.preventDefault();\n\t          $scope.incrementHours();\n\t          $scope.$apply();\n\t        } else if (e.which === 40) { // down\n\t          e.preventDefault();\n\t          $scope.decrementHours();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    });\n\t\n\t    minutesInputEl.bind('keydown', function(e) {\n\t      if (!disabled) {\n\t        if (e.which === 38) { // up\n\t          e.preventDefault();\n\t          $scope.incrementMinutes();\n\t          $scope.$apply();\n\t        } else if (e.which === 40) { // down\n\t          e.preventDefault();\n\t          $scope.decrementMinutes();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    });\n\t\n\t    secondsInputEl.bind('keydown', function(e) {\n\t      if (!disabled) {\n\t        if (e.which === 38) { // up\n\t          e.preventDefault();\n\t          $scope.incrementSeconds();\n\t          $scope.$apply();\n\t        } else if (e.which === 40) { // down\n\t          e.preventDefault();\n\t          $scope.decrementSeconds();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    });\n\t  };\n\t\n\t  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n\t    if ($scope.readonlyInput) {\n\t      $scope.updateHours = angular.noop;\n\t      $scope.updateMinutes = angular.noop;\n\t      $scope.updateSeconds = angular.noop;\n\t      return;\n\t    }\n\t\n\t    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {\n\t      ngModelCtrl.$setViewValue(null);\n\t      ngModelCtrl.$setValidity('time', false);\n\t      if (angular.isDefined(invalidHours)) {\n\t        $scope.invalidHours = invalidHours;\n\t      }\n\t\n\t      if (angular.isDefined(invalidMinutes)) {\n\t        $scope.invalidMinutes = invalidMinutes;\n\t      }\n\t\n\t      if (angular.isDefined(invalidSeconds)) {\n\t        $scope.invalidSeconds = invalidSeconds;\n\t      }\n\t    };\n\t\n\t    $scope.updateHours = function() {\n\t      var hours = getHoursFromTemplate(),\n\t        minutes = getMinutesFromTemplate();\n\t\n\t      ngModelCtrl.$setDirty();\n\t\n\t      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t        selected.setHours(hours);\n\t        selected.setMinutes(minutes);\n\t        if (selected < min || selected > max) {\n\t          invalidate(true);\n\t        } else {\n\t          refresh('h');\n\t        }\n\t      } else {\n\t        invalidate(true);\n\t      }\n\t    };\n\t\n\t    hoursInputEl.bind('blur', function(e) {\n\t      ngModelCtrl.$setTouched();\n\t      if ($scope.hours === null || $scope.hours === '') {\n\t        invalidate(true);\n\t      } else if (!$scope.invalidHours && $scope.hours < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.hours = pad($scope.hours);\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateMinutes = function() {\n\t      var minutes = getMinutesFromTemplate(),\n\t        hours = getHoursFromTemplate();\n\t\n\t      ngModelCtrl.$setDirty();\n\t\n\t      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n\t        selected.setHours(hours);\n\t        selected.setMinutes(minutes);\n\t        if (selected < min || selected > max) {\n\t          invalidate(undefined, true);\n\t        } else {\n\t          refresh('m');\n\t        }\n\t      } else {\n\t        invalidate(undefined, true);\n\t      }\n\t    };\n\t\n\t    minutesInputEl.bind('blur', function(e) {\n\t      ngModelCtrl.$setTouched();\n\t      if ($scope.minutes === null) {\n\t        invalidate(undefined, true);\n\t      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.minutes = pad($scope.minutes);\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateSeconds = function() {\n\t      var seconds = getSecondsFromTemplate();\n\t\n\t      ngModelCtrl.$setDirty();\n\t\n\t      if (angular.isDefined(seconds)) {\n\t        selected.setSeconds(seconds);\n\t        refresh('s');\n\t      } else {\n\t        invalidate(undefined, undefined, true);\n\t      }\n\t    };\n\t\n\t    secondsInputEl.bind('blur', function(e) {\n\t      if (!$scope.invalidSeconds && $scope.seconds < 10) {\n\t        $scope.$apply( function() {\n\t          $scope.seconds = pad($scope.seconds);\n\t        });\n\t      }\n\t    });\n\t\n\t  };\n\t\n\t  this.render = function() {\n\t    var date = ngModelCtrl.$viewValue;\n\t\n\t    if (isNaN(date)) {\n\t      ngModelCtrl.$setValidity('time', false);\n\t      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t    } else {\n\t      if (date) {\n\t        selected = date;\n\t      }\n\t\n\t      if (selected < min || selected > max) {\n\t        ngModelCtrl.$setValidity('time', false);\n\t        $scope.invalidHours = true;\n\t        $scope.invalidMinutes = true;\n\t      } else {\n\t        makeValid();\n\t      }\n\t      updateTemplate();\n\t    }\n\t  };\n\t\n\t  // Call internally when we know that model is valid.\n\t  function refresh(keyboardChange) {\n\t    makeValid();\n\t    ngModelCtrl.$setViewValue(new Date(selected));\n\t    updateTemplate(keyboardChange);\n\t  }\n\t\n\t  function makeValid() {\n\t    ngModelCtrl.$setValidity('time', true);\n\t    $scope.invalidHours = false;\n\t    $scope.invalidMinutes = false;\n\t    $scope.invalidSeconds = false;\n\t  }\n\t\n\t  function updateTemplate(keyboardChange) {\n\t    if (!ngModelCtrl.$modelValue) {\n\t      $scope.hours = null;\n\t      $scope.minutes = null;\n\t      $scope.seconds = null;\n\t      $scope.meridian = meridians[0];\n\t    } else {\n\t      var hours = selected.getHours(),\n\t        minutes = selected.getMinutes(),\n\t        seconds = selected.getSeconds();\n\t\n\t      if ($scope.showMeridian) {\n\t        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system\n\t      }\n\t\n\t      $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n\t      if (keyboardChange !== 'm') {\n\t        $scope.minutes = pad(minutes);\n\t      }\n\t      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t\n\t      if (keyboardChange !== 's') {\n\t        $scope.seconds = pad(seconds);\n\t      }\n\t      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t    }\n\t  }\n\t\n\t  function addSecondsToSelected(seconds) {\n\t    selected = addSeconds(selected, seconds);\n\t    refresh();\n\t  }\n\t\n\t  function addMinutes(selected, minutes) {\n\t    return addSeconds(selected, minutes*60);\n\t  }\n\t\n\t  function addSeconds(date, seconds) {\n\t    var dt = new Date(date.getTime() + seconds * 1000);\n\t    var newDate = new Date(date);\n\t    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());\n\t    return newDate;\n\t  }\n\t\n\t  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n\t    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\t\n\t  $scope.incrementHours = function() {\n\t    if (!$scope.noIncrementHours()) {\n\t      addSecondsToSelected(hourStep * 60 * 60);\n\t    }\n\t  };\n\t\n\t  $scope.decrementHours = function() {\n\t    if (!$scope.noDecrementHours()) {\n\t      addSecondsToSelected(-hourStep * 60 * 60);\n\t    }\n\t  };\n\t\n\t  $scope.incrementMinutes = function() {\n\t    if (!$scope.noIncrementMinutes()) {\n\t      addSecondsToSelected(minuteStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.decrementMinutes = function() {\n\t    if (!$scope.noDecrementMinutes()) {\n\t      addSecondsToSelected(-minuteStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.incrementSeconds = function() {\n\t    if (!$scope.noIncrementSeconds()) {\n\t      addSecondsToSelected(secondStep);\n\t    }\n\t  };\n\t\n\t  $scope.decrementSeconds = function() {\n\t    if (!$scope.noDecrementSeconds()) {\n\t      addSecondsToSelected(-secondStep);\n\t    }\n\t  };\n\t\n\t  $scope.toggleMeridian = function() {\n\t    var minutes = getMinutesFromTemplate(),\n\t        hours = getHoursFromTemplate();\n\t\n\t    if (!$scope.noToggleMeridian()) {\n\t      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n\t        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));\n\t      } else {\n\t        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];\n\t      }\n\t    }\n\t  };\n\t\n\t  $scope.blur = function() {\n\t    ngModelCtrl.$setTouched();\n\t  };\n\t\n\t  $scope.$on('$destroy', function() {\n\t    while (watchers.length) {\n\t      watchers.shift()();\n\t    }\n\t  });\n\t}])\n\t\n\t.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {\n\t  return {\n\t    require: ['uibTimepicker', '?^ngModel'],\n\t    controller: 'UibTimepickerController',\n\t    controllerAs: 'timepicker',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || uibTimepickerConfig.templateUrl;\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (ngModelCtrl) {\n\t        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])\n\t\n\t/**\n\t * A helper service that can parse typeahead's syntax (string provided by users)\n\t * Extracted to a separate service for ease of unit testing\n\t */\n\t  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n\t    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n\t    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\t    return {\n\t      parse: function(input) {\n\t        var match = input.match(TYPEAHEAD_REGEXP);\n\t        if (!match) {\n\t          throw new Error(\n\t            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n\t              ' but got \"' + input + '\".');\n\t        }\n\t\n\t        return {\n\t          itemName: match[3],\n\t          source: $parse(match[4]),\n\t          viewMapper: $parse(match[2] || match[1]),\n\t          modelMapper: $parse(match[1])\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',\n\t    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {\n\t    var HOT_KEYS = [9, 13, 27, 38, 40];\n\t    var eventDebounceTime = 200;\n\t    var modelCtrl, ngModelOptions;\n\t    //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t    //minimal no of characters that needs to be entered before typeahead kicks-in\n\t    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n\t    if (!minLength && minLength !== 0) {\n\t      minLength = 1;\n\t    }\n\t\n\t    //minimal wait time after last character typed before typeahead kicks-in\n\t    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t    //should it restrict model values to the ones selected from the popup only?\n\t    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {\n\t      isEditable = newVal !== false;\n\t    });\n\t\n\t    //binding to a variable that indicates if matches are being retrieved asynchronously\n\t    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t    //a callback executed when a match is selected\n\t    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t    //should it select highlighted popup value when losing focus?\n\t    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\t\n\t    //binding to a variable that indicates if there were no results after the query is completed\n\t    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\t\n\t    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t    var appendTo = attrs.typeaheadAppendTo ?\n\t      originalScope.$eval(attrs.typeaheadAppendTo) : null;\n\t\n\t    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\t\n\t    //If input matches an item of the list exactly, select it automatically\n\t    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\t\n\t    //binding to a variable that indicates if dropdown is open\n\t    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;\n\t\n\t    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;\n\t\n\t    //INTERNAL VARIABLES\n\t\n\t    //model setter executed upon match selection\n\t    var parsedModel = $parse(attrs.ngModel);\n\t    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n\t    var $setModelValue = function(scope, newValue) {\n\t      if (angular.isFunction(parsedModel(originalScope)) &&\n\t        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n\t        return invokeModelSetter(scope, {$$$p: newValue});\n\t      }\n\t\n\t      return parsedModel.assign(scope, newValue);\n\t    };\n\t\n\t    //expressions used by typeahead\n\t    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\t\n\t    var hasFocus;\n\t\n\t    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n\t    //mousedown & mouseup events\n\t    //Issue #3699\n\t    var selected;\n\t\n\t    //create a child scope for the typeahead directive so we are not polluting original scope\n\t    //with typeahead-specific data (matches, query etc.)\n\t    var scope = originalScope.$new();\n\t    var offDestroy = originalScope.$on('$destroy', function() {\n\t      scope.$destroy();\n\t    });\n\t    scope.$on('$destroy', offDestroy);\n\t\n\t    // WAI-ARIA\n\t    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t    element.attr({\n\t      'aria-autocomplete': 'list',\n\t      'aria-expanded': false,\n\t      'aria-owns': popupId\n\t    });\n\t\n\t    var inputsContainer, hintInputElem;\n\t    //add read-only input to show hint\n\t    if (showHint) {\n\t      inputsContainer = angular.element('<div></div>');\n\t      inputsContainer.css('position', 'relative');\n\t      element.after(inputsContainer);\n\t      hintInputElem = element.clone();\n\t      hintInputElem.attr('placeholder', '');\n\t      hintInputElem.val('');\n\t      hintInputElem.css({\n\t        'position': 'absolute',\n\t        'top': '0px',\n\t        'left': '0px',\n\t        'border-color': 'transparent',\n\t        'box-shadow': 'none',\n\t        'opacity': 1,\n\t        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',\n\t        'color': '#999'\n\t      });\n\t      element.css({\n\t        'position': 'relative',\n\t        'vertical-align': 'top',\n\t        'background-color': 'transparent'\n\t      });\n\t      inputsContainer.append(hintInputElem);\n\t      hintInputElem.after(element);\n\t    }\n\t\n\t    //pop-up element used to display matches\n\t    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n\t    popUpEl.attr({\n\t      id: popupId,\n\t      matches: 'matches',\n\t      active: 'activeIdx',\n\t      select: 'select(activeIdx, evt)',\n\t      'move-in-progress': 'moveInProgress',\n\t      query: 'query',\n\t      position: 'position',\n\t      'assign-is-open': 'assignIsOpen(isOpen)',\n\t      debounce: 'debounceUpdate'\n\t    });\n\t    //custom item template\n\t    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t    }\n\t\n\t    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n\t      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n\t    }\n\t\n\t    var resetHint = function() {\n\t      if (showHint) {\n\t        hintInputElem.val('');\n\t      }\n\t    };\n\t\n\t    var resetMatches = function() {\n\t      scope.matches = [];\n\t      scope.activeIdx = -1;\n\t      element.attr('aria-expanded', false);\n\t      resetHint();\n\t    };\n\t\n\t    var getMatchId = function(index) {\n\t      return popupId + '-option-' + index;\n\t    };\n\t\n\t    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t    // This attribute is added or removed automatically when the `activeIdx` changes.\n\t    scope.$watch('activeIdx', function(index) {\n\t      if (index < 0) {\n\t        element.removeAttr('aria-activedescendant');\n\t      } else {\n\t        element.attr('aria-activedescendant', getMatchId(index));\n\t      }\n\t    });\n\t\n\t    var inputIsExactMatch = function(inputValue, index) {\n\t      if (scope.matches.length > index && inputValue) {\n\t        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    var getMatchesAsync = function(inputValue, evt) {\n\t      var locals = {$viewValue: inputValue};\n\t      isLoadingSetter(originalScope, true);\n\t      isNoResultsSetter(originalScope, false);\n\t      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t        //it might happen that several async queries were in progress if a user were typing fast\n\t        //but we are interested only in responses that correspond to the current view value\n\t        var onCurrentRequest = inputValue === modelCtrl.$viewValue;\n\t        if (onCurrentRequest && hasFocus) {\n\t          if (matches && matches.length > 0) {\n\t            scope.activeIdx = focusFirst ? 0 : -1;\n\t            isNoResultsSetter(originalScope, false);\n\t            scope.matches.length = 0;\n\t\n\t            //transform labels\n\t            for (var i = 0; i < matches.length; i++) {\n\t              locals[parserResult.itemName] = matches[i];\n\t              scope.matches.push({\n\t                id: getMatchId(i),\n\t                label: parserResult.viewMapper(scope, locals),\n\t                model: matches[i]\n\t              });\n\t            }\n\t\n\t            scope.query = inputValue;\n\t            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t            //due to other elements being rendered\n\t            recalculatePosition();\n\t\n\t            element.attr('aria-expanded', true);\n\t\n\t            //Select the single remaining option if user input matches\n\t            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n\t              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n\t                $$debounce(function() {\n\t                  scope.select(0, evt);\n\t                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n\t              } else {\n\t                scope.select(0, evt);\n\t              }\n\t            }\n\t\n\t            if (showHint) {\n\t              var firstLabel = scope.matches[0].label;\n\t              if (angular.isString(inputValue) &&\n\t                inputValue.length > 0 &&\n\t                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {\n\t                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));\n\t              } else {\n\t                hintInputElem.val('');\n\t              }\n\t            }\n\t          } else {\n\t            resetMatches();\n\t            isNoResultsSetter(originalScope, true);\n\t          }\n\t        }\n\t        if (onCurrentRequest) {\n\t          isLoadingSetter(originalScope, false);\n\t        }\n\t      }, function() {\n\t        resetMatches();\n\t        isLoadingSetter(originalScope, false);\n\t        isNoResultsSetter(originalScope, true);\n\t      });\n\t    };\n\t\n\t    // bind events only if appendToBody params exist - performance feature\n\t    if (appendToBody) {\n\t      angular.element($window).on('resize', fireRecalculating);\n\t      $document.find('body').on('scroll', fireRecalculating);\n\t    }\n\t\n\t    // Declare the debounced function outside recalculating for\n\t    // proper debouncing\n\t    var debouncedRecalculate = $$debounce(function() {\n\t      // if popup is visible\n\t      if (scope.matches.length) {\n\t        recalculatePosition();\n\t      }\n\t\n\t      scope.moveInProgress = false;\n\t    }, eventDebounceTime);\n\t\n\t    // Default progress type\n\t    scope.moveInProgress = false;\n\t\n\t    function fireRecalculating() {\n\t      if (!scope.moveInProgress) {\n\t        scope.moveInProgress = true;\n\t        scope.$digest();\n\t      }\n\t\n\t      debouncedRecalculate();\n\t    }\n\t\n\t    // recalculate actual position and set new values to scope\n\t    // after digest loop is popup in right position\n\t    function recalculatePosition() {\n\t      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t      scope.position.top += element.prop('offsetHeight');\n\t    }\n\t\n\t    //we need to propagate user's query so we can higlight matches\n\t    scope.query = undefined;\n\t\n\t    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t    var timeoutPromise;\n\t\n\t    var scheduleSearchWithTimeout = function(inputValue) {\n\t      timeoutPromise = $timeout(function() {\n\t        getMatchesAsync(inputValue);\n\t      }, waitTime);\n\t    };\n\t\n\t    var cancelPreviousTimeout = function() {\n\t      if (timeoutPromise) {\n\t        $timeout.cancel(timeoutPromise);\n\t      }\n\t    };\n\t\n\t    resetMatches();\n\t\n\t    scope.assignIsOpen = function (isOpen) {\n\t      isOpenSetter(originalScope, isOpen);\n\t    };\n\t\n\t    scope.select = function(activeIdx, evt) {\n\t      //called from within the $digest() cycle\n\t      var locals = {};\n\t      var model, item;\n\t\n\t      selected = true;\n\t      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t      model = parserResult.modelMapper(originalScope, locals);\n\t      $setModelValue(originalScope, model);\n\t      modelCtrl.$setValidity('editable', true);\n\t      modelCtrl.$setValidity('parse', true);\n\t\n\t      onSelectCallback(originalScope, {\n\t        $item: item,\n\t        $model: model,\n\t        $label: parserResult.viewMapper(originalScope, locals),\n\t        $event: evt\n\t      });\n\t\n\t      resetMatches();\n\t\n\t      //return focus to the input element if a match was selected via a mouse click event\n\t      // use timeout to avoid $rootScope:inprog error\n\t      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n\t        $timeout(function() { element[0].focus(); }, 0, false);\n\t      }\n\t    };\n\t\n\t    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t    element.on('keydown', function(evt) {\n\t      //typeahead is open and an \"interesting\" key was pressed\n\t      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t        return;\n\t      }\n\t\n\t      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n\t      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n\t        resetMatches();\n\t        scope.$digest();\n\t        return;\n\t      }\n\t\n\t      evt.preventDefault();\n\t      var target;\n\t      switch (evt.which) {\n\t        case 9:\n\t        case 13:\n\t          scope.$apply(function () {\n\t            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n\t              $$debounce(function() {\n\t                scope.select(scope.activeIdx, evt);\n\t              }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n\t            } else {\n\t              scope.select(scope.activeIdx, evt);\n\t            }\n\t          });\n\t          break;\n\t        case 27:\n\t          evt.stopPropagation();\n\t\n\t          resetMatches();\n\t          scope.$digest();\n\t          break;\n\t        case 38:\n\t          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n\t          scope.$digest();\n\t          target = popUpEl.find('li')[scope.activeIdx];\n\t          target.parentNode.scrollTop = target.offsetTop;\n\t          break;\n\t        case 40:\n\t          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t          scope.$digest();\n\t          target = popUpEl.find('li')[scope.activeIdx];\n\t          target.parentNode.scrollTop = target.offsetTop;\n\t          break;\n\t      }\n\t    });\n\t\n\t    element.bind('focus', function (evt) {\n\t      hasFocus = true;\n\t      if (minLength === 0 && !modelCtrl.$viewValue) {\n\t        $timeout(function() {\n\t          getMatchesAsync(modelCtrl.$viewValue, evt);\n\t        }, 0);\n\t      }\n\t    });\n\t\n\t    element.bind('blur', function(evt) {\n\t      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n\t        selected = true;\n\t        scope.$apply(function() {\n\t          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {\n\t            $$debounce(function() {\n\t              scope.select(scope.activeIdx, evt);\n\t            }, scope.debounceUpdate.blur);\n\t          } else {\n\t            scope.select(scope.activeIdx, evt);\n\t          }\n\t        });\n\t      }\n\t      if (!isEditable && modelCtrl.$error.editable) {\n\t        modelCtrl.$viewValue = '';\n\t        element.val('');\n\t      }\n\t      hasFocus = false;\n\t      selected = false;\n\t    });\n\t\n\t    // Keep reference to click handler to unbind it.\n\t    var dismissClickHandler = function(evt) {\n\t      // Issue #3973\n\t      // Firefox treats right click as a click on document\n\t      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n\t        resetMatches();\n\t        if (!$rootScope.$$phase) {\n\t          scope.$digest();\n\t        }\n\t      }\n\t    };\n\t\n\t    $document.on('click', dismissClickHandler);\n\t\n\t    originalScope.$on('$destroy', function() {\n\t      $document.off('click', dismissClickHandler);\n\t      if (appendToBody || appendTo) {\n\t        $popup.remove();\n\t      }\n\t\n\t      if (appendToBody) {\n\t        angular.element($window).off('resize', fireRecalculating);\n\t        $document.find('body').off('scroll', fireRecalculating);\n\t      }\n\t      // Prevent jQuery cache memory leak\n\t      popUpEl.remove();\n\t\n\t      if (showHint) {\n\t          inputsContainer.remove();\n\t      }\n\t    });\n\t\n\t    var $popup = $compile(popUpEl)(scope);\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else if (appendTo) {\n\t      angular.element(appendTo).eq(0).append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    this.init = function(_modelCtrl, _ngModelOptions) {\n\t      modelCtrl = _modelCtrl;\n\t      ngModelOptions = _ngModelOptions;\n\t\n\t      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);\n\t\n\t      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t      modelCtrl.$parsers.unshift(function(inputValue) {\n\t        hasFocus = true;\n\t\n\t        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n\t          if (waitTime > 0) {\n\t            cancelPreviousTimeout();\n\t            scheduleSearchWithTimeout(inputValue);\n\t          } else {\n\t            getMatchesAsync(inputValue);\n\t          }\n\t        } else {\n\t          isLoadingSetter(originalScope, false);\n\t          cancelPreviousTimeout();\n\t          resetMatches();\n\t        }\n\t\n\t        if (isEditable) {\n\t          return inputValue;\n\t        }\n\t\n\t        if (!inputValue) {\n\t          // Reset in case user had typed something previously.\n\t          modelCtrl.$setValidity('editable', true);\n\t          return null;\n\t        }\n\t\n\t        modelCtrl.$setValidity('editable', false);\n\t        return undefined;\n\t      });\n\t\n\t      modelCtrl.$formatters.push(function(modelValue) {\n\t        var candidateViewValue, emptyViewValue;\n\t        var locals = {};\n\t\n\t        // The validity may be set to false via $parsers (see above) if\n\t        // the model is restricted to selected values. If the model\n\t        // is set manually it is considered to be valid.\n\t        if (!isEditable) {\n\t          modelCtrl.$setValidity('editable', true);\n\t        }\n\t\n\t        if (inputFormatter) {\n\t          locals.$model = modelValue;\n\t          return inputFormatter(originalScope, locals);\n\t        }\n\t\n\t        //it might happen that we don't have enough info to properly render input value\n\t        //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t        locals[parserResult.itemName] = modelValue;\n\t        candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t        locals[parserResult.itemName] = undefined;\n\t        emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n\t      });\n\t    };\n\t  }])\n\t\n\t  .directive('uibTypeahead', function() {\n\t    return {\n\t      controller: 'UibTypeaheadController',\n\t      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n\t      link: function(originalScope, element, attrs, ctrls) {\n\t        ctrls[2].init(ctrls[0], ctrls[1]);\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {\n\t    return {\n\t      scope: {\n\t        matches: '=',\n\t        query: '=',\n\t        active: '=',\n\t        position: '&',\n\t        moveInProgress: '=',\n\t        select: '&',\n\t        assignIsOpen: '&',\n\t        debounce: '&'\n\t      },\n\t      replace: true,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function() {\n\t          var isDropdownOpen = scope.matches.length > 0;\n\t          scope.assignIsOpen({ isOpen: isDropdownOpen });\n\t          return isDropdownOpen;\n\t        };\n\t\n\t        scope.isActive = function(matchIdx) {\n\t          return scope.active === matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function(matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function(activeIdx, evt) {\n\t          var debounce = scope.debounce();\n\t          if (angular.isNumber(debounce) || angular.isObject(debounce)) {\n\t            $$debounce(function() {\n\t              scope.select({activeIdx: activeIdx, evt: evt});\n\t            }, angular.isNumber(debounce) ? debounce : debounce['default']);\n\t          } else {\n\t            scope.select({activeIdx: activeIdx, evt: evt});\n\t          }\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n\t    return {\n\t      scope: {\n\t        index: '=',\n\t        match: '=',\n\t        query: '='\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';\n\t        $templateRequest(tplUrl).then(function(tplContent) {\n\t          var tplEl = angular.element(tplContent.trim());\n\t          element.replaceWith(tplEl);\n\t          $compile(tplEl)(scope);\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n\t    var isSanitizePresent;\n\t    isSanitizePresent = $injector.has('$sanitize');\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      // Regex: capture the whole query string and replace it with the string that will be used to match\n\t      // the results, for example if the capture is \"a\" the result will be \\a\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    function containsHtml(matchItem) {\n\t      return /<.*>/g.test(matchItem);\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      if (!isSanitizePresent && containsHtml(matchItem)) {\n\t        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n\t      }\n\t      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n\t      if (!isSanitizePresent) {\n\t        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n\t      }\n\t      return matchItem;\n\t    };\n\t  }]);\n\t\n\tangular.module(\"uib/template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/accordion/accordion-group.html\",\n\t    \"<div class=\\\"panel\\\" ng-class=\\\"panelClass || 'panel-default'\\\">\\n\" +\n\t    \"  <div role=\\\"tab\\\" id=\\\"{{::headingId}}\\\" aria-selected=\\\"{{isOpen}}\\\" class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n\t    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n\t    \"      <a role=\\\"button\\\" data-toggle=\\\"collapse\\\" href aria-expanded=\\\"{{isOpen}}\\\" aria-controls=\\\"{{::panelId}}\\\" tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n\t    \"    </h4>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"  <div id=\\\"{{::panelId}}\\\" aria-labelledby=\\\"{{::headingId}}\\\" aria-hidden=\\\"{{!isOpen}}\\\" role=\\\"tabpanel\\\" class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n\t    \"    <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/accordion/accordion.html\",\n\t    \"<div role=\\\"tablist\\\" class=\\\"panel-group\\\" ng-transclude></div>\");\n\t}]);\n\t\n\tangular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/alert/alert.html\",\n\t    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n\t    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n\t    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n\t    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n\t    \"    </button>\\n\" +\n\t    \"    <div ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/carousel/carousel.html\",\n\t    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n\t    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n\t    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"  </ol>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"uib/template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/carousel/slide.html\",\n\t    \"<div ng-class=\\\"{\\n\" +\n\t    \"    'active': active\\n\" +\n\t    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/datepicker.html\",\n\t    \"<div class=\\\"uib-datepicker\\\" ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n\t    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n\t    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n\t    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/day.html\",\n\t    \"<table class=\\\"uib-daypicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n\t    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"uib-weeks\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-day text-center\\\" role=\\\"gridcell\\\"\\n\" +\n\t    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n\t    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\"\\n\" +\n\t    \"          uib-is-class=\\\"\\n\" +\n\t    \"            'btn-info' for selectedDt,\\n\" +\n\t    \"            'active' for activeDt\\n\" +\n\t    \"            on dt\\\"\\n\" +\n\t    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n\t    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n\t    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/month.html\",\n\t    \"<table class=\\\"uib-monthpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"uib-months\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-month text-center\\\" role=\\\"gridcell\\\"\\n\" +\n\t    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n\t    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n\t    \"          uib-is-class=\\\"\\n\" +\n\t    \"            'btn-info' for selectedDt,\\n\" +\n\t    \"            'active' for activeDt\\n\" +\n\t    \"            on dt\\\"\\n\" +\n\t    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n\t    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n\t    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/popup.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"uib-datepicker-popup dropdown-menu\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n\t    \"    <li ng-transclude></li>\\n\" +\n\t    \"    <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n\t    \"    <span class=\\\"btn-group pull-left\\\">\\n\" +\n\t    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today')\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n\t    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n\t    \"    </span>\\n\" +\n\t    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"  </ul>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/year.html\",\n\t    \"<table class=\\\"uib-yearpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{::columns - 2}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"uib-years\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-year text-center\\\" role=\\\"gridcell\\\"\\n\" +\n\t    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n\t    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n\t    \"          uib-is-class=\\\"\\n\" +\n\t    \"            'btn-info' for selectedDt,\\n\" +\n\t    \"            'active' for activeDt\\n\" +\n\t    \"            on dt\\\"\\n\" +\n\t    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n\t    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n\t    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/modal/backdrop.html\",\n\t    \"<div class=\\\"modal-backdrop\\\"\\n\" +\n\t    \"     uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"     modal-in-class=\\\"in\\\"\\n\" +\n\t    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n\t    \"></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/modal/window.html\",\n\t    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n\t    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"    modal-in-class=\\\"in\\\"\\n\" +\n\t    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n\t    \"    <div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/pager/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/pager/pager.html\",\n\t    \"<ul class=\\\"pager\\\">\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/pagination/pagination.html\",\n\t    \"<ul class=\\\"pagination\\\">\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tooltip/tooltip-html-popup.html\",\n\t    \"<div class=\\\"tooltip\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tooltip/tooltip-popup.html\",\n\t    \"<div class=\\\"tooltip\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tooltip/tooltip-template-popup.html\",\n\t    \"<div class=\\\"tooltip\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n\t    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/popover/popover-html.html\",\n\t    \"<div class=\\\"popover\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/popover/popover-template.html\",\n\t    \"<div class=\\\"popover\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\"\\n\" +\n\t    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/popover/popover.html\",\n\t    \"<div class=\\\"popover\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/progressbar/bar.html\",\n\t    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/progressbar/progress.html\",\n\t    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n\t}]);\n\t\n\tangular.module(\"uib/template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/progressbar/progressbar.html\",\n\t    \"<div class=\\\"progress\\\">\\n\" +\n\t    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/rating/rating.html\",\n\t    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n\t    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n\t    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n\t    \"</span>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tabs/tab.html\",\n\t    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\" class=\\\"uib-tab\\\">\\n\" +\n\t    \"  <a href ng-click=\\\"select()\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n\t    \"</li>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tabs/tabset.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n\t    \"  <div class=\\\"tab-content\\\">\\n\" +\n\t    \"    <div class=\\\"tab-pane\\\" \\n\" +\n\t    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n\t    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n\t    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n\t    \"    </div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/timepicker/timepicker.html\",\n\t    \"<table class=\\\"uib-timepicker\\\">\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td class=\\\"uib-increment hours\\\"><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td class=\\\"uib-increment minutes\\\"><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-increment seconds\\\"><a ng-click=\\\"incrementSeconds()\\\" ng-class=\\\"{disabled: noIncrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <td class=\\\"form-group uib-time hours\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"HH\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementHours()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td class=\\\"uib-separator\\\">:</td>\\n\" +\n\t    \"      <td class=\\\"form-group uib-time minutes\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"MM\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementMinutes()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-separator\\\">:</td>\\n\" +\n\t    \"      <td class=\\\"form-group uib-time seconds\\\" ng-class=\\\"{'has-error': invalidSeconds}\\\" ng-show=\\\"showSeconds\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"SS\\\" ng-model=\\\"seconds\\\" ng-change=\\\"updateSeconds()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementSeconds()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\" class=\\\"uib-time am-pm\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td class=\\\"uib-decrement hours\\\"><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td class=\\\"uib-decrement minutes\\\"><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-decrement seconds\\\"><a ng-click=\\\"decrementSeconds()\\\" ng-class=\\\"{disabled: noDecrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/typeahead/typeahead-match.html\",\n\t    \"<a href\\n\" +\n\t    \"   tabindex=\\\"-1\\\"\\n\" +\n\t    \"   ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"\\n\" +\n\t    \"   ng-attr-title=\\\"{{match.label}}\\\"></a>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/typeahead/typeahead-popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index, $event)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n\t    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\tangular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); });\n\tangular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;}.uib-button-bar{padding:10px 9px 2px;}</style>'); });\n\tangular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'); });\n\tangular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); });\n\n/***/ },\n\n/***/ 131:\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }\n\n/******/ })));\n\n\n/** WEBPACK FOOTER **\n ** vendors.e1204953154a91789291.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tvar _m = moreModules[moduleId];\n\n \t\t\t// Check if module is deduplicated\n \t\t\tswitch(typeof _m) {\n \t\t\tcase \"object\":\n \t\t\t\t// Module can be created from a template\n \t\t\t\tmodules[moduleId] = (function(_m) {\n \t\t\t\t\tvar args = _m.slice(1), templateId = _m[0];\n \t\t\t\t\treturn function (a,b,c) {\n \t\t\t\t\t\tmodules[templateId].apply(this, [a,b,c].concat(args));\n \t\t\t\t\t};\n \t\t\t\t}(_m));\n \t\t\t\tbreak;\n \t\t\tcase \"function\":\n \t\t\t\t// Normal module\n \t\t\t\tmodules[moduleId] = _m;\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\t// Module is a copy of another module\n \t\t\t\tmodules[moduleId] = modules[_m];\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t1:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"chunk.\" + {\"0\":\"bea689d366ba2240570d\",\"2\":\"44e5298b476cca0e3b35\",\"3\":\"8ac7b8fbb39273951380\"}[chunkId] + \".js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e1204953154a91789291\n **/","module.exports = angular;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 2\n ** module chunks = 1\n **/","//! api-check version 7.5.5 built with  by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) ( _)==(_ )\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"apiCheck\"] = factory();\n\telse\n\t\troot[\"apiCheck\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _apiCheck = __webpack_require__(1);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = _apiCheck2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\tvar apiCheckUtil = __webpack_require__(3);\n\tvar each = apiCheckUtil.each;\n\tvar isError = apiCheckUtil.isError;\n\tvar t = apiCheckUtil.t;\n\tvar arrayify = apiCheckUtil.arrayify;\n\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\tvar typeOf = apiCheckUtil.typeOf;\n\tvar getError = apiCheckUtil.getError;\n\n\tvar checkers = __webpack_require__(4);\n\tvar apiCheckApis = getApiCheckApis();\n\n\tmodule.exports = getApiCheckInstance;\n\tmodule.exports.VERSION = (\"7.5.5\");\n\tmodule.exports.utils = apiCheckUtil;\n\tmodule.exports.globalConfig = {\n\t  verbose: false,\n\t  disabled: false\n\t};\n\n\tvar apiCheckApiCheck = getApiCheckInstance({\n\t  output: { prefix: 'apiCheck' }\n\t});\n\tmodule.exports.internalChecker = apiCheckApiCheck;\n\n\teach(checkers, function (checker, name) {\n\t  return module.exports[name] = checker;\n\t});\n\n\tfunction getApiCheckInstance() {\n\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t  /* eslint complexity:[2, 6] */\n\t  if (apiCheckApiCheck && arguments.length) {\n\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t      prefix: 'creating an apiCheck instance'\n\t    });\n\t  }\n\n\t  var additionalProperties = {\n\t    'throw': getApiCheck(true),\n\t    warn: getApiCheck(false),\n\t    getErrorMessage: getErrorMessage,\n\t    handleErrorMessage: handleErrorMessage,\n\t    config: {\n\t      output: config.output || {\n\t        prefix: '',\n\t        suffix: '',\n\t        docsBaseUrl: ''\n\t      },\n\t      verbose: config.verbose || false,\n\t      disabled: config.disabled || false\n\t    },\n\t    utils: apiCheckUtil\n\t  };\n\n\t  each(additionalProperties, function (wrapper, name) {\n\t    return apiCheck[name] = wrapper;\n\t  });\n\n\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\t  each(extraCheckers, function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\n\t  return apiCheck;\n\n\t  /**\n\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t   * @param {Array} api - the checkers to check with\n\t   * @param {Array} args - the args to check\n\t   * @param {Object} output - output options\n\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t   */\n\t  function apiCheck(api, args, output) {\n\t    /* eslint complexity:[2, 8] */\n\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t      return {\n\t        apiTypes: {}, argTypes: {},\n\t        passed: true, message: '',\n\t        failed: false\n\t      }; // empty version of what is normally returned\n\t    }\n\t    checkApiCheckApi(arguments);\n\t    if (!Array.isArray(api)) {\n\t      api = [api];\n\t      args = [args];\n\t    } else {\n\t      // turn arguments into an array\n\t      args = Array.prototype.slice.call(args);\n\t    }\n\t    var messages = checkEnoughArgs(api, args);\n\t    if (!messages.length) {\n\t      // this is where we actually go perform the checks.\n\t      messages = checkApiWithArgs(api, args);\n\t    }\n\n\t    var returnObject = getTypes(api, args);\n\t    returnObject.args = args;\n\t    if (messages.length) {\n\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t      returnObject.failed = true;\n\t      returnObject.passed = false;\n\t    } else {\n\t      returnObject.message = '';\n\t      returnObject.failed = false;\n\t      returnObject.passed = true;\n\t    }\n\t    return returnObject;\n\t  }\n\n\t  /**\n\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t   */\n\t  function checkApiCheckApi(checkApiArgs) {\n\t    var api = checkApiArgs[0];\n\t    var args = checkApiArgs[1];\n\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\n\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t    }\n\t    // dog fooding here\n\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t    if (errors.length) {\n\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t        prefix: 'apiCheck'\n\t      });\n\t      apiCheck.handleErrorMessage(message, true);\n\t    }\n\t  }\n\n\t  function getApiCheck(shouldThrow) {\n\t    return function apiCheckWrapper(api, args, output) {\n\t      var result = apiCheck(api, args, output);\n\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t      return result; // wont get here if an error is thrown\n\t    };\n\t  }\n\n\t  function handleErrorMessage(message, shouldThrow) {\n\t    if (shouldThrow && message) {\n\t      throw new Error(message);\n\t    } else if (message) {\n\t      /* eslint no-console:0 */\n\t      console.warn(message);\n\t    }\n\t  }\n\n\t  function getErrorMessage(api, args) {\n\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n\t    var gOut = apiCheck.config.output || {};\n\t    var prefix = getPrefix();\n\t    var suffix = getSuffix();\n\t    var url = getUrl();\n\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\n\t    function getPrefix() {\n\t      var p = output.onlyPrefix;\n\t      if (!p) {\n\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t      }\n\t      return p;\n\t    }\n\n\t    function getSuffix() {\n\t      var s = output.onlySuffix;\n\t      if (!s) {\n\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t      }\n\t      return s;\n\t    }\n\n\t    function getUrl() {\n\t      var u = output.url;\n\t      if (!u) {\n\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t      }\n\t      return u;\n\t    }\n\t  }\n\n\t  function buildMessageFromApiAndArgs(api, args) {\n\t    var _getTypes = getTypes(api, args);\n\n\t    var apiTypes = _getTypes.apiTypes;\n\t    var argTypes = _getTypes.argTypes;\n\n\t    var copy = Array.prototype.slice.call(args || []);\n\t    var replacedItems = [];\n\t    replaceFunctionWithName(copy);\n\t    var passedArgs = getObjectString(copy);\n\t    argTypes = getObjectString(argTypes);\n\t    apiTypes = getObjectString(apiTypes);\n\n\t    return generateMessage();\n\n\t    // functions\n\n\t    function replaceFunctionWithName(obj) {\n\t      each(obj, function (val, name) {\n\t        /* eslint complexity:[2, 6] */\n\t        if (replacedItems.indexOf(val) === -1) {\n\t          // avoid recursive problems\n\t          replacedItems.push(val);\n\t          if (typeof val === 'object') {\n\t            replaceFunctionWithName(obj);\n\t          } else if (typeof val === 'function') {\n\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t          }\n\t        }\n\t      });\n\t    }\n\n\t    function getObjectString(types) {\n\t      if (!types || !types.length) {\n\t        return 'nothing';\n\t      } else if (types && types.length === 1) {\n\t        types = types[0];\n\t      }\n\t      return stringify(types, null, 2);\n\t    }\n\n\t    function generateMessage() {\n\t      var n = '\\n';\n\t      var useS = true;\n\t      if (args && args.length === 1) {\n\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t          useS = !!Object.keys(args[0]).length;\n\t        } else {\n\t          useS = false;\n\t        }\n\t      }\n\t      var types = 'type' + (useS ? 's' : '');\n\t      var newLine = n + n;\n\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t    }\n\t  }\n\n\t  function getTypes(api, args) {\n\t    api = arrayify(api);\n\t    args = arrayify(args);\n\t    var apiTypes = api.map(function (checker, index) {\n\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t      return getCheckerDisplay(checker, {\n\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t        obj: args[index],\n\t        addHelpers: true\n\t      });\n\t    });\n\t    var argTypes = args.map(function (arg) {\n\t      return getArgDisplay(arg, []);\n\t    });\n\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t  }\n\t}\n\n\t// STATELESS FUNCTIONS\n\n\t/**\n\t * This is where the magic happens for actually checking the arguments with the api.\n\t * @param {Array} api - checkers\n\t * @param  {Array} args - and arguments object\n\t * @returns {Array} - the error messages\n\t */\n\tfunction checkApiWithArgs(api, args) {\n\t  /* eslint complexity:[2, 7] */\n\t  var messages = [];\n\t  var failed = false;\n\t  var checkerIndex = 0;\n\t  var argIndex = 0;\n\t  var arg = undefined,\n\t      checker = undefined,\n\t      res = undefined,\n\t      lastChecker = undefined,\n\t      argName = undefined,\n\t      argFailed = undefined,\n\t      skipPreviousChecker = undefined;\n\t  /* jshint -W084 */\n\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t    arg = args[argIndex++];\n\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t    res = checker(arg, 'value', argName);\n\t    argFailed = isError(res);\n\t    lastChecker = checkerIndex >= api.length;\n\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t      failed = true;\n\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t    } else if (argFailed && checker.isOptional) {\n\t      argIndex--;\n\t    } else {\n\t      messages.push(t(argName) + ' passed');\n\t    }\n\t  }\n\t  return failed ? messages : [];\n\t}\n\n\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\tfunction checkerTypeType(checkerType, name, location) {\n\t  var apiCheckDataChecker = checkers.shape({\n\t    type: checkers.string,\n\t    optional: checkers.bool\n\t  });\n\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t  if (isError(wrongShape)) {\n\t    return wrongShape;\n\t  }\n\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t    return getError(name, location, checkerTypeType.type);\n\t  }\n\t}\n\n\tfunction getCheckerErrorMessage(res, checker, val) {\n\t  var checkerHelp = getCheckerHelp(checker, val);\n\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t  return res.message + checkerHelp;\n\t}\n\n\tfunction getCheckerHelp(_ref, val) {\n\t  var help = _ref.help;\n\n\t  if (!help) {\n\t    return '';\n\t  }\n\t  if (typeof help === 'function') {\n\t    help = help(val);\n\t  }\n\t  return help;\n\t}\n\n\tfunction checkEnoughArgs(api, args) {\n\t  var requiredArgs = api.filter(function (a) {\n\t    return !a.isOptional;\n\t  });\n\t  if (args.length < requiredArgs.length) {\n\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t  } else {\n\t    return [];\n\t  }\n\t}\n\n\tfunction getArgDisplay(arg, gottenArgs) {\n\t  /* eslint complexity:[2, 7] */\n\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t  var type = typeOf(arg);\n\t  if (type === 'function') {\n\t    if (hasKeys()) {\n\t      var properties = stringify(getDisplayIfNotGotten());\n\t      return cName + ' (with properties: ' + properties + ')';\n\t    }\n\t    return cName;\n\t  }\n\n\t  if (arg === null) {\n\t    return 'null';\n\t  }\n\n\t  if (type !== 'array' && type !== 'object') {\n\t    return type;\n\t  }\n\n\t  if (hasKeys()) {\n\t    return getDisplayIfNotGotten();\n\t  }\n\n\t  return cName;\n\n\t  // utility functions\n\t  function hasKeys() {\n\t    return arg && Object.keys(arg).length;\n\t  }\n\n\t  function getDisplayIfNotGotten() {\n\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t      return '[Circular]';\n\t    }\n\t    gottenArgs.push(arg);\n\t    return getDisplay(arg, gottenArgs);\n\t  }\n\t}\n\n\tfunction getDisplay(obj, gottenArgs) {\n\t  var argDisplay = {};\n\t  each(obj, function (v, k) {\n\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t  });\n\t  return argDisplay;\n\t}\n\n\tfunction getApiCheckApis() {\n\t  var os = checkers.string.optional;\n\n\t  var checkerFnChecker = checkers.func.withProperties({\n\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t    displayName: checkers.string.optional,\n\t    shortType: checkers.string.optional,\n\t    notOptional: checkers.bool.optional,\n\t    notRequired: checkers.bool.optional\n\t  });\n\n\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t    output: checkers.shape({\n\t      prefix: checkers.string.optional,\n\t      suffix: checkers.string.optional,\n\t      docsBaseUrl: checkers.string.optional\n\t    }).strict.optional,\n\t    verbose: checkers.bool.optional,\n\t    disabled: checkers.bool.optional\n\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\n\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t  }).strict.optional];\n\n\t  return {\n\t    checkerFnChecker: checkerFnChecker,\n\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t    checkApiCheckApi: checkApiCheckApi\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = stringify;\n\n\tfunction getSerialize (fn, decycle) {\n\t  var seen = [], keys = [];\n\t  decycle = decycle || function(key, value) {\n\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t  };\n\t  return function(key, value) {\n\t    var ret = value;\n\t    if (typeof value === 'object' && value) {\n\t      if (seen.indexOf(value) !== -1)\n\t        ret = decycle(key, value);\n\t      else {\n\t        seen.push(value);\n\t        keys.push(key);\n\t      }\n\t    }\n\t    if (fn) ret = fn(key, ret);\n\t    return ret;\n\t  }\n\t}\n\n\tfunction getPath (value, seen, keys) {\n\t  var index = seen.indexOf(value);\n\t  var path = [ keys[index] ];\n\t  for (index--; index >= 0; index--) {\n\t    if (seen[index][ path[0] ] === value) {\n\t      value = seen[index];\n\t      path.unshift(keys[index]);\n\t    }\n\t  }\n\t  return '~' + path.join('.');\n\t}\n\n\tfunction stringify(obj, fn, spaces, decycle) {\n\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t}\n\n\tstringify.getSerialize = getSerialize;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\tvar stringify = __webpack_require__(2);\n\tvar checkerHelpers = {\n\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t};\n\n\tmodule.exports = {\n\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t  noop: noop\n\t};\n\n\tfunction copy(obj) {\n\t  var type = typeOf(obj);\n\t  var daCopy = undefined;\n\t  if (type === 'array') {\n\t    daCopy = [];\n\t  } else if (type === 'object') {\n\t    daCopy = {};\n\t  } else {\n\t    return obj;\n\t  }\n\t  each(obj, function (val, key) {\n\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t  });\n\t  return daCopy;\n\t}\n\n\tfunction typeOf(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return 'array';\n\t  } else if (obj instanceof RegExp) {\n\t    return 'object';\n\t  } else {\n\t    return typeof obj;\n\t  }\n\t}\n\n\tfunction getCheckerDisplay(checker, options) {\n\t  /* eslint complexity:[2, 7] */\n\t  var display = undefined;\n\t  var short = options && options.short;\n\t  if (short && checker.shortType) {\n\t    display = checker.shortType;\n\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t    display = getCheckerType(checker, options);\n\t  } else {\n\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t  }\n\t  return display;\n\t}\n\n\tfunction getCheckerType(_ref, options) {\n\t  var type = _ref.type;\n\n\t  if (typeof type === 'function') {\n\t    var __apiCheckData = type.__apiCheckData;\n\t    var typeTypes = type(options);\n\t    type = _defineProperty({\n\t      __apiCheckData: __apiCheckData\n\t    }, __apiCheckData.type, typeTypes);\n\t  }\n\t  return type;\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (!obj) {\n\t    return [];\n\t  } else if (Array.isArray(obj)) {\n\t    return obj;\n\t  } else {\n\t    return [obj];\n\t  }\n\t}\n\n\tfunction each(obj, iterator, context) {\n\t  if (Array.isArray(obj)) {\n\t    return eachArry(obj, iterator, context);\n\t  } else {\n\t    return eachObj(obj, iterator, context);\n\t  }\n\t}\n\n\tfunction eachObj(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t  for (var key in obj) {\n\t    if (hasOwn.call(obj, key)) {\n\t      ret = iterator.call(context, obj[key], key, obj);\n\t      if (ret === false) {\n\t        return ret;\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction eachArry(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var length = obj.length;\n\t  for (var i = 0; i < length; i++) {\n\t    ret = iterator.call(context, obj[i], i, obj);\n\t    if (ret === false) {\n\t      return ret;\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction isError(obj) {\n\t  return obj instanceof Error;\n\t}\n\n\tfunction list(arry, join, finalJoin) {\n\t  arry = arrayify(arry);\n\t  var copy = arry.slice();\n\t  var last = copy.pop();\n\t  if (copy.length === 1) {\n\t    join = ' ';\n\t  }\n\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t}\n\n\tfunction getError(name, location, checkerType) {\n\t  if (typeof checkerType === 'function') {\n\t    checkerType = checkerType({ short: true });\n\t  }\n\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t}\n\n\tfunction nAtL(name, location) {\n\t  var tName = t(name || 'value');\n\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t  return '' + tName + tLocation;\n\t}\n\n\tfunction t(thing) {\n\t  return '`' + thing + '`';\n\t}\n\n\tfunction undef(thing) {\n\t  return typeof thing === 'undefined';\n\t}\n\n\t/**\n\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t * optional version\n\t *\n\t * @param {Function} checker - the checker to setup with properties\n\t * @param {Object} properties - properties to add to the checker\n\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t * @returns {Function} checker - the setup checker\n\t */\n\tfunction setupChecker(checker, properties, disabled) {\n\t  /* eslint complexity:[2, 9] */\n\t  if (disabled) {\n\t    // swap out the checker for its own copy of noop\n\t    checker = getNoop();\n\t    checker.isNoop = true;\n\t  }\n\n\t  if (typeof checker.type === 'string') {\n\t    checker.shortType = checker.type;\n\t  }\n\n\t  // assign all properties given\n\t  each(properties, function (prop, name) {\n\t    return checker[name] = prop;\n\t  });\n\n\t  if (!checker.displayName) {\n\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t  }\n\n\t  if (!checker.notRequired) {\n\t    checker = getRequiredVersion(checker, disabled);\n\t  }\n\n\t  if (!checker.notNullable) {\n\t    addNullable(checker, disabled);\n\t  }\n\n\t  if (!checker.notOptional) {\n\t    addOptional(checker, disabled);\n\t  }\n\n\t  return checker;\n\t}\n\n\tfunction getRequiredVersion(checker, disabled) {\n\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t    if (undef(val) && !checker.isOptional) {\n\t      var tLocation = location ? ' in ' + t(location) : '';\n\t      var type = getCheckerDisplay(checker, { short: true });\n\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t    } else {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  copyProps(checker, requiredChecker);\n\t  requiredChecker.originalChecker = checker;\n\t  return requiredChecker;\n\t}\n\n\tfunction addOptional(checker, disabled) {\n\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t    if (!undef(val)) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, optionalCheck);\n\n\t  optionalCheck.isOptional = true;\n\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t  optionalCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .optional to the end of the checkers\n\t  checker.optional = optionalCheck;\n\n\t  fixType(checker, checker.optional);\n\t}\n\n\tfunction addNullable(checker, disabled) {\n\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t    if (val !== null) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, nullableCheck);\n\n\t  nullableCheck.isNullable = true;\n\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t  nullableCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t  checker.nullable = nullableCheck;\n\n\t  fixType(checker, checker.nullable);\n\t  if (!checker.notOptional) {\n\t    addOptional(checker.nullable, disabled);\n\t  }\n\t}\n\n\tfunction fixType(checker, checkerCopy) {\n\t  // fix type, because it's not a straight copy...\n\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t  // we also want to add \"(optional)\" to the types with a string\n\t  if (typeof checkerCopy.type === 'object') {\n\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t  } else if (typeof checkerCopy.type === 'function') {\n\t      checkerCopy.type = function () {\n\t        return checker.type.apply(checker, arguments);\n\t      };\n\t    } else {\n\t      checkerCopy.type += ' (optional)';\n\t      return;\n\t    }\n\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t  checkerCopy.type.__apiCheckData.optional = true;\n\t}\n\n\t// UTILS\n\n\tfunction copyProps(src, dest) {\n\t  each(Object.keys(src), function (key) {\n\t    return dest[key] = src[key];\n\t  });\n\t}\n\n\tfunction noop() {}\n\n\tfunction getNoop() {\n\t  /* eslint no-shadow:0 */\n\t  /* istanbul ignore next */\n\t  return function noop() {};\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\n\tvar _require = __webpack_require__(3);\n\n\tvar typeOf = _require.typeOf;\n\tvar each = _require.each;\n\tvar copy = _require.copy;\n\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\tvar isError = _require.isError;\n\tvar arrayify = _require.arrayify;\n\tvar list = _require.list;\n\tvar getError = _require.getError;\n\tvar nAtL = _require.nAtL;\n\tvar t = _require.t;\n\tvar checkerHelpers = _require.checkerHelpers;\n\tvar undef = _require.undef;\n\tvar setupChecker = checkerHelpers.setupChecker;\n\n\tvar checkers = module.exports = getCheckers();\n\tmodule.exports.getCheckers = getCheckers;\n\n\tfunction getCheckers(disabled) {\n\t  return {\n\t    array: typeOfCheckGetter('Array'),\n\t    bool: typeOfCheckGetter('Boolean'),\n\t    number: typeOfCheckGetter('Number'),\n\t    string: typeOfCheckGetter('String'),\n\t    func: funcCheckGetter(),\n\t    object: objectCheckGetter(),\n\n\t    emptyObject: emptyObjectCheckGetter(),\n\n\t    instanceOf: instanceCheckGetter,\n\t    oneOf: oneOfCheckGetter,\n\t    oneOfType: oneOfTypeCheckGetter,\n\n\t    arrayOf: arrayOfCheckGetter,\n\t    objectOf: objectOfCheckGetter,\n\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\n\t    range: rangeCheckGetter,\n\t    lessThan: lessThanCheckGetter,\n\t    greaterThan: greaterThanCheckGetter,\n\n\t    shape: getShapeCheckGetter(),\n\t    args: argumentsCheckerGetter(),\n\n\t    any: anyCheckGetter(),\n\t    'null': nullCheckGetter()\n\n\t  };\n\n\t  function typeOfCheckGetter(type) {\n\t    var lType = type.toLowerCase();\n\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== lType) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function funcCheckGetter() {\n\t    var type = 'Function';\n\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'function') {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\n\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t      if (isError(apiError)) {\n\t        throw apiError;\n\t      }\n\t      var shapeChecker = checkers.shape(properties, true);\n\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\n\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t        var notFunction = checkers.func(val, name, location);\n\t        if (isError(notFunction)) {\n\t          return notFunction;\n\t        }\n\t        return shapeChecker(val, name, location);\n\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t    };\n\t    return functionChecker;\n\t  }\n\n\t  function objectCheckGetter() {\n\t    var type = 'Object';\n\t    var nullType = 'Object (null ok)';\n\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'object') {\n\t        return getError(name, location, nullType);\n\t      }\n\t    }, { type: nullType }, disabled);\n\n\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t        return getError(name, location, objectChecker.type);\n\t      }\n\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\n\t    return objectChecker;\n\t  }\n\n\t  function instanceCheckGetter(classToCheck) {\n\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t      if (!(val instanceof classToCheck)) {\n\t        return getError(name, location, classToCheck.name);\n\t      }\n\t    }, { type: classToCheck.name }, disabled);\n\t  }\n\n\t  function oneOfCheckGetter(enums) {\n\t    var type = {\n\t      __apiCheckData: { optional: false, type: 'enum' },\n\t      'enum': enums\n\t    };\n\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t      return stringify(enm);\n\t    }).join(', ') + ']';\n\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t      if (!enums.some(function (enm) {\n\t        return enm === val;\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t      return getCheckerDisplay(checker, { short: true });\n\t    });\n\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return typeCheckers.map(function (checker) {\n\t        return getCheckerDisplay(checker, options);\n\t      });\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t      if (!typeCheckers.some(function (checker) {\n\t        return !isError(checker(val, name, location));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function arrayOfCheckGetter(checker) {\n\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\n\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t        return !isError(checker(item));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function objectOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\n\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t      var notObject = checkers.object(val, name, location);\n\t      if (isError(notObject)) {\n\t        return notObject;\n\t      }\n\t      var allTypesSuccess = each(val, function (item, key) {\n\t        if (isError(checker(item, key, name))) {\n\t          return false;\n\t        }\n\t      });\n\t      if (!allTypesSuccess) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function typeOrArrayOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\n\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function getShapeCheckGetter() {\n\t    function shapeCheckGetter(shape, nonObject) {\n\t      var shapeTypes = {};\n\t      each(shape, function (checker, prop) {\n\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t      });\n\t      function type() {\n\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t        var ret = {};\n\t        var terse = options.terse;\n\t        var obj = options.obj;\n\t        var addHelpers = options.addHelpers;\n\n\t        var parentRequired = options.required;\n\t        each(shape, function (checker, prop) {\n\t          /* eslint complexity:[2, 6] */\n\t          var specified = obj && obj.hasOwnProperty(prop);\n\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t          if (!terse || (specified || !checker.isOptional)) {\n\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t          }\n\t          if (addHelpers) {\n\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t          }\n\t        });\n\t        return ret;\n\n\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t          if (!specified && required && !checker.isOptional) {\n\t            var item = 'ITEM';\n\t            if (checker.type && checker.type.__apiCheckData) {\n\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t            }\n\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t          } else if (specified) {\n\t            var error = checker(obj[prop], prop, null, obj);\n\t            if (isError(error)) {\n\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t            }\n\t          }\n\n\t          function addHelper(property, objectMessage, stringMessage) {\n\t            if (typeof theRet[prop] === 'string') {\n\t              theRet[prop] += stringMessage;\n\t            } else {\n\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t        /* eslint complexity:[2, 6] */\n\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t        if (isError(isObject)) {\n\t          return isObject;\n\t        }\n\t        var shapePropError = undefined;\n\t        location = location ? location + (name ? '/' : '') : '';\n\t        name = name || '';\n\t        each(shape, function (checker, prop) {\n\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t            return !isError(shapePropError);\n\t          }\n\t        });\n\t        if (isError(shapePropError)) {\n\t          return shapePropError;\n\t        }\n\t      }, { type: type, shortType: 'shape' }, disabled);\n\n\t      function strictType() {\n\t        return type.apply(undefined, arguments);\n\t      }\n\n\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t      strictType.__apiCheckData.strict = true;\n\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t        var shapeError = shapeChecker(val, name, location);\n\t        if (isError(shapeError)) {\n\t          return shapeError;\n\t        }\n\t        var allowedProperties = Object.keys(shape);\n\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t          return allowedProperties.indexOf(prop) === -1;\n\t        });\n\t        if (extraProps.length) {\n\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t        }\n\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\n\t      return shapeChecker;\n\t    }\n\n\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t      } else {\n\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (propExists === otherPropsExist) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t      otherProps = arrayify(otherProps);\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t      } else {\n\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t        var othersPresent = otherProps.every(function (property) {\n\t          return obj.hasOwnProperty(property);\n\t        });\n\t        if (!othersPresent) {\n\t          return getError(propName, location, type);\n\t        } else {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        throw new Error('requiredIfNot.all must be passed an array');\n\t      }\n\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t    };\n\n\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t      var props = t(otherProps.join(', '));\n\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var iteration = all ? 'every' : 'some';\n\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (!otherPropsExist && !propExists) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, notRequired: true }, disabled);\n\t    }\n\n\t    return shapeCheckGetter;\n\n\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t      function type(options) {\n\t        if (options && options.short) {\n\t          return shortType;\n\t        }\n\t        return getCheckerDisplay(propChecker);\n\t      }\n\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t      return type;\n\t    }\n\t  }\n\n\t  function argumentsCheckerGetter() {\n\t    var type = 'function arguments';\n\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function anyCheckGetter() {\n\t    return setupChecker(function anyCheckerDefinition() {\n\t      // don't do anything\n\t    }, { type: 'any' }, disabled);\n\t  }\n\n\t  function nullCheckGetter() {\n\t    var type = 'null';\n\t    return setupChecker(function nullChecker(val, name, location) {\n\t      if (val !== null) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function rangeCheckGetter(min, max) {\n\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t    return setupChecker(function rangeChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < min || val > max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function lessThanCheckGetter(min) {\n\t    var type = 'lessThan[' + min + ']';\n\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val > min) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function greaterThanCheckGetter(max) {\n\t    var type = 'greaterThan[' + max + ']';\n\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function emptyObjectCheckGetter() {\n\t    var type = 'empty object';\n\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/api-check/dist/api-check.js\n ** module id = 3\n ** module chunks = 1\n **/","/*!\n* angular-formly JavaScript Library v7.5.0\n*\n* @license MIT (http://license.angular-formly.com)\n*\n* built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n* ( _)==(_ )\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _indexCommon = __webpack_require__(1);\n\n\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\n\texports['default'] = _indexCommon2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\n\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\n\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\n\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\n\tvar _providersFormlyUsability = __webpack_require__(7);\n\n\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\n\tvar _providersFormlyConfig = __webpack_require__(8);\n\n\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\n\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\n\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\n\tvar _servicesFormlyUtil = __webpack_require__(11);\n\n\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\n\tvar _servicesFormlyWarn = __webpack_require__(12);\n\n\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\n\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\n\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\n\tvar _directivesFormlyField = __webpack_require__(14);\n\n\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\n\tvar _directivesFormlyFocus = __webpack_require__(15);\n\n\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\n\tvar _directivesFormlyForm = __webpack_require__(16);\n\n\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\n\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\n\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\n\tvar _runFormlyCustomTags = __webpack_require__(18);\n\n\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\n\tvar ngModuleName = 'formly';\n\n\texports['default'] = ngModuleName;\n\n\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\n\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\tngModule.constant('formlyVersion', (\"7.5.0\")); // <-- webpack variable\n\n\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\n\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\n\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\n\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\tngModule.run(_runFormlyCustomTags2['default']);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar angular = __webpack_require__(3);\n\n\t/* istanbul ignore next */\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\texports['default'] = angular;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\tvar apiCheck = (0, _apiCheck2['default'])({\n\t  output: {\n\t    prefix: 'angular-formly:',\n\t    docsBaseUrl: __webpack_require__(6)\n\t  }\n\t});\n\n\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t    otherProps = [otherProps];\n\t  }\n\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\n\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t      return obj && obj.hasOwnProperty(otherProp);\n\t    });\n\t    if (!otherPropsExist && !propExists) {\n\t      return apiCheck.utils.getError(propName, location, type);\n\t    } else if (propExists) {\n\t      return propChecker(prop, propName, location, obj);\n\t    }\n\t  }\n\n\t  shapeRequiredIfNotDefinition.type = type;\n\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t}\n\n\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\n\tvar apiCheckProperty = apiCheck.func;\n\n\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t  warn: apiCheck.func,\n\t  'throw': apiCheck.func,\n\t  shape: apiCheck.func\n\t}));\n\n\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\n\tvar formlyWrapperType = apiCheck.shape({\n\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  overwriteOk: apiCheck.bool.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional\n\t}).strict;\n\n\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\n\tvar templateManipulators = apiCheck.shape({\n\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t}).strict.nullable;\n\n\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar fieldOptionsApiShape = {\n\t  $$hashKey: apiCheck.any.optional,\n\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  model: modelChecker.optional,\n\t  originalModel: modelChecker.optional,\n\t  className: apiCheck.string.optional,\n\t  id: apiCheck.string.optional,\n\t  name: apiCheck.string.optional,\n\t  expressionProperties: expressionProperties.optional,\n\t  extras: apiCheck.shape({\n\t    validateOnModelChange: apiCheck.bool.optional,\n\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t  }).strict.optional,\n\t  data: apiCheck.object.optional,\n\t  templateOptions: apiCheck.object.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  modelOptions: apiCheck.shape({\n\t    updateOn: apiCheck.string.optional,\n\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t    allowInvalid: apiCheck.bool.optional,\n\t    getterSetter: apiCheck.bool.optional,\n\t    timezone: apiCheck.string.optional\n\t  }).optional,\n\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t    expression: formlyExpression.optional,\n\t    listener: formlyExpression.optional,\n\t    runFieldExpressions: apiCheck.bool.optional\n\t  })).optional,\n\t  validators: validatorChecker.optional,\n\t  asyncValidators: validatorChecker.optional,\n\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t  noFormControl: apiCheck.bool.optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t  }).strict).optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  link: apiCheck.func.optional,\n\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t  validation: apiCheck.shape({\n\t    show: apiCheck.bool.nullable.optional,\n\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t  }).optional,\n\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t  value: apiCheck.func.optional,\n\t  runExpressions: apiCheck.func.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  initialValue: apiCheck.any.optional,\n\t  defaultValue: apiCheck.any.optional\n\t};\n\n\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\n\tvar formOptionsApi = apiCheck.shape({\n\t  formState: apiCheck.object.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  manualModelWatcher: apiCheck.oneOfType([apiCheck.bool, apiCheck.func]).optional,\n\t  watchAllExpressions: apiCheck.bool.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t  data: apiCheck.object.optional\n\t}).strict;\n\n\tvar fieldGroup = apiCheck.shape({\n\t  $$hashKey: apiCheck.any.optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  // danger. Nested field groups wont get api-checked...\n\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t  className: apiCheck.string.optional,\n\t  options: formOptionsApi.optional,\n\t  templateOptions: apiCheck.object.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t    expression: formlyExpression.optional,\n\t    listener: formlyExpression\n\t  })).optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  data: apiCheck.object.optional,\n\t  model: modelChecker.optional,\n\t  form: apiCheck.object.optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t}).strict;\n\n\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\n\tvar formlyTypeOptions = apiCheck.shape({\n\t  name: apiCheck.string,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t  link: apiCheck.func.optional,\n\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t  'extends': apiCheck.string.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  data: apiCheck.object.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional,\n\t  overwriteOk: apiCheck.bool.optional\n\t}).strict;\n\n\t_angularFix2['default'].extend(apiCheck, {\n\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t});\n\n\texports['default'] = apiCheck;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.5.0\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyUsability;\n\n\t// @ngInject\n\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t  var _this = this;\n\n\t  _angularFix2['default'].extend(this, {\n\t    getFormlyError: getFormlyError,\n\t    getFieldError: getFieldError,\n\t    checkWrapper: checkWrapper,\n\t    checkWrapperTemplate: checkWrapperTemplate,\n\t    getErrorMessage: getErrorMessage,\n\t    $get: function $get() {\n\t      return _this;\n\t    }\n\t  });\n\n\t  function getFieldError(errorInfoSlug, message, field) {\n\t    if (arguments.length < 3) {\n\t      field = message;\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t  }\n\n\t  function getFormlyError(errorInfoSlug, message) {\n\t    if (!message) {\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t  }\n\n\t  function getErrorMessage(errorInfoSlug, message) {\n\t    var url = '';\n\t    if (errorInfoSlug !== null) {\n\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t    }\n\t    return 'Formly Error: ' + message + '. ' + url;\n\t  }\n\n\t  function checkWrapper(wrapper) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t      prefix: 'formlyConfig.setWrapper',\n\t      urlSuffix: 'setwrapper-validation-failed'\n\t    });\n\t  }\n\n\t  function checkWrapperTemplate(template, additionalInfo) {\n\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t    if (template.indexOf(formlyTransclude) === -1) {\n\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t    }\n\t  }\n\t}\n\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyConfig;\n\n\t// @ngInject\n\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t  var _this2 = this;\n\n\t  var typeMap = {};\n\t  var templateWrappersMap = {};\n\t  var defaultWrapperName = 'default';\n\t  var _this = this;\n\t  var getError = formlyUsabilityProvider.getFormlyError;\n\n\t  _angularFix2['default'].extend(this, {\n\t    setType: setType,\n\t    getType: getType,\n\t    getTypeHeritage: getTypeHeritage,\n\t    setWrapper: setWrapper,\n\t    getWrapper: getWrapper,\n\t    getWrapperByType: getWrapperByType,\n\t    removeWrapperByName: removeWrapperByName,\n\t    removeWrappersForType: removeWrappersForType,\n\t    disableWarnings: false,\n\t    extras: {\n\t      disableNgModelAttrsManipulator: false,\n\t      fieldTransform: [],\n\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t      removeChromeAutoComplete: false,\n\t      defaultHideDirective: 'ng-if',\n\t      getFieldId: null\n\t    },\n\t    templateManipulators: {\n\t      preWrapper: [],\n\t      postWrapper: []\n\t    },\n\t    $get: function $get() {\n\t      return _this2;\n\t    }\n\t  });\n\n\t  function setType(options) {\n\t    if (_angularFix2['default'].isArray(options)) {\n\t      var _ret = (function () {\n\t        var allTypes = [];\n\t        _angularFix2['default'].forEach(options, function (item) {\n\t          allTypes.push(setType(item));\n\t        });\n\t        return {\n\t          v: allTypes\n\t        };\n\t      })();\n\n\t      if (typeof _ret === 'object') return _ret.v;\n\t    } else if (_angularFix2['default'].isObject(options)) {\n\t      checkType(options);\n\t      if (options['extends']) {\n\t        extendTypeOptions(options);\n\t      }\n\t      typeMap[options.name] = options;\n\t      return typeMap[options.name];\n\t    } else {\n\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t    }\n\t  }\n\n\t  function checkType(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t      prefix: 'formlyConfig.setType',\n\t      url: 'settype-validation-failed'\n\t    });\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t    } else {\n\t      options.overwriteOk = undefined;\n\t    }\n\t  }\n\n\t  function extendTypeOptions(options) {\n\t    var extendsType = getType(options['extends'], true, options);\n\t    extendTypeControllerFunction(options, extendsType);\n\t    extendTypeLinkFunction(options, extendsType);\n\t    extendTypeDefaultOptions(options, extendsType);\n\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t    extendTemplate(options, extendsType);\n\t  }\n\n\t  function extendTemplate(options, extendsType) {\n\t    if (options.template && extendsType.templateUrl) {\n\t      delete options.templateUrl;\n\t    } else if (options.templateUrl && extendsType.template) {\n\t      delete options.template;\n\t    }\n\t  }\n\n\t  function extendTypeControllerFunction(options, extendsType) {\n\t    var extendsCtrl = extendsType.controller;\n\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t      return;\n\t    }\n\t    var optionsCtrl = options.controller;\n\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t      options.controller = function ($scope, $controller) {\n\t        $controller(extendsCtrl, { $scope: $scope });\n\t        $controller(optionsCtrl, { $scope: $scope });\n\t      };\n\t      options.controller.$inject = ['$scope', '$controller'];\n\t    } else {\n\t      options.controller = extendsCtrl;\n\t    }\n\t  }\n\n\t  function extendTypeLinkFunction(options, extendsType) {\n\t    var extendsFn = extendsType.link;\n\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t      return;\n\t    }\n\t    var optionsFn = options.link;\n\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t      options.link = function () {\n\t        extendsFn.apply(undefined, arguments);\n\t        optionsFn.apply(undefined, arguments);\n\t      };\n\t    } else {\n\t      options.link = extendsFn;\n\t    }\n\t  }\n\n\t  function extendTypeDefaultOptions(options, extendsType) {\n\t    var extendsDO = extendsType.defaultOptions;\n\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t      return;\n\t    }\n\t    var optionsDO = options.defaultOptions;\n\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t    if (extendsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t        var mergedDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t        var extenderOptionsDefaultOptions = optionsDO;\n\t        if (optionsDOIsFn) {\n\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t        }\n\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t        return extendsDefaultOptions;\n\t      };\n\t    } else if (optionsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var newDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t        return optionsDO(newDefaultOptions, scope);\n\t      };\n\t    }\n\t  }\n\n\t  function getType(name, throwError, errorContext) {\n\t    if (!name) {\n\t      return undefined;\n\t    }\n\t    var type = typeMap[name];\n\t    if (!type && throwError === true) {\n\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t    } else {\n\t      return type;\n\t    }\n\t  }\n\n\t  function getTypeHeritage(parent) {\n\t    var heritage = [];\n\t    var type = parent;\n\t    if (_angularFix2['default'].isString(type)) {\n\t      type = getType(parent);\n\t    }\n\t    parent = type['extends'];\n\t    while (parent) {\n\t      type = getType(parent);\n\t      heritage.push(type);\n\t      parent = type['extends'];\n\t    }\n\t    return heritage;\n\t  }\n\n\t  function setWrapper(_x, _x2) {\n\t    var _again = true;\n\n\t    _function: while (_again) {\n\t      var options = _x,\n\t          name = _x2;\n\t      _again = false;\n\n\t      if (_angularFix2['default'].isArray(options)) {\n\t        return options.map(function (wrapperOptions) {\n\t          return setWrapper(wrapperOptions);\n\t        });\n\t      } else if (_angularFix2['default'].isObject(options)) {\n\t        options.types = getOptionsTypes(options);\n\t        options.name = getOptionsName(options, name);\n\t        checkWrapperAPI(options);\n\t        templateWrappersMap[options.name] = options;\n\t        return options;\n\t      } else if (_angularFix2['default'].isString(options)) {\n\t        _x = {\n\t          template: options,\n\t          name: name\n\t        };\n\t        _x2 = undefined;\n\t        _again = true;\n\t        continue _function;\n\t      }\n\t    }\n\t  }\n\n\t  function getOptionsTypes(options) {\n\t    if (_angularFix2['default'].isString(options.types)) {\n\t      return [options.types];\n\t    }\n\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t      return [];\n\t    } else {\n\t      return options.types;\n\t    }\n\t  }\n\n\t  function getOptionsName(options, name) {\n\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t  }\n\n\t  function checkWrapperAPI(options) {\n\t    formlyUsabilityProvider.checkWrapper(options);\n\t    if (options.template) {\n\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t    }\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t    } else {\n\t      delete options.overwriteOk;\n\t    }\n\t    checkWrapperTypes(options);\n\t  }\n\n\t  function checkWrapperTypes(options) {\n\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t    if (shouldThrow) {\n\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t    }\n\t  }\n\n\t  function checkOverwrite(property, object, newValue, objectName) {\n\t    if (object.hasOwnProperty(property)) {\n\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t    }\n\t  }\n\n\t  function getWrapper(name) {\n\t    return templateWrappersMap[name || defaultWrapperName];\n\t  }\n\n\t  function getWrapperByType(type) {\n\t    /* eslint prefer-const:0 */\n\t    var wrappers = [];\n\t    for (var _name in templateWrappersMap) {\n\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t          wrappers.push(templateWrappersMap[_name]);\n\t        }\n\t      }\n\t    }\n\t    return wrappers;\n\t  }\n\n\t  function removeWrapperByName(name) {\n\t    var wrapper = templateWrappersMap[name];\n\t    delete templateWrappersMap[name];\n\t    return wrapper;\n\t  }\n\n\t  function removeWrappersForType(type) {\n\t    var wrappers = getWrapperByType(type);\n\t    if (!wrappers) {\n\t      return undefined;\n\t    }\n\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t      return removeWrapperByName(wrappers.name);\n\t    } else {\n\t      wrappers.forEach(function (wrapper) {\n\t        return removeWrapperByName(wrapper.name);\n\t      });\n\t      return wrappers;\n\t    }\n\t  }\n\n\t  function warn() {\n\t    if (!_this.disableWarnings && console.warn) {\n\t      /* eslint no-console:0 */\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      console.warn.apply(console, _toConsumableArray(args));\n\t    }\n\t  }\n\t}\n\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = {\n\t  containsSelector: containsSelector, containsSpecialChar: containsSpecialChar, formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName,\n\t  arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t};\n\n\tfunction containsSelector(string) {\n\t  return containsSpecialChar(string, '.') || containsSpecialChar(string, '[') && containsSpecialChar(string, ']');\n\t}\n\n\tfunction containsSpecialChar(a, b) {\n\t  if (!a || !a.indexOf) {\n\t    return false;\n\t  }\n\t  return a.indexOf(b) !== -1;\n\t}\n\n\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t  if (_angularFix2['default'].isFunction(expression)) {\n\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t  } else {\n\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t  }\n\t}\n\n\tfunction getFieldId(formId, options, index) {\n\t  if (options.id) {\n\t    return options.id;\n\t  }\n\t  var type = options.type;\n\t  if (!type && options.template) {\n\t    type = 'template';\n\t  } else if (!type && options.templateUrl) {\n\t    type = 'templateUrl';\n\t  }\n\n\t  return [formId, type, options.key, index].join('_');\n\t}\n\n\tfunction reverseDeepMerge(dest) {\n\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t    if (!index) {\n\t      return;\n\t    }\n\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t        dest[prop] = _angularFix2['default'].copy(val);\n\t      } else if (objAndSameType(dest[prop], val)) {\n\t        reverseDeepMerge(dest[prop], val);\n\t      }\n\t    });\n\t  });\n\t  return dest;\n\t}\n\n\tfunction objAndSameType(obj1, obj2) {\n\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t}\n\n\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\tfunction findByNodeName(el, nodeName) {\n\t  if (!el.prop) {\n\t    // not a jQuery or jqLite object -> wrap it\n\t    el = _angularFix2['default'].element(el);\n\t  }\n\n\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t    return el;\n\t  }\n\n\t  var c = el.children();\n\t  for (var i = 0; c && i < c.length; i++) {\n\t    var node = findByNodeName(c[i], nodeName);\n\t    if (node) {\n\t      return node;\n\t    }\n\t  }\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t    obj = [obj];\n\t  } else if (!obj) {\n\t    obj = [];\n\t  }\n\t  return obj;\n\t}\n\n\tfunction extendFunction() {\n\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t    fns[_key] = arguments[_key];\n\t  }\n\n\t  return function extendedFunction() {\n\t    var args = arguments;\n\t    fns.forEach(function (fn) {\n\t      return fn.apply(null, args);\n\t    });\n\t  };\n\t}\n\n\tfunction extendArray(primary, secondary, property) {\n\t  if (property) {\n\t    primary = primary[property];\n\t    secondary = secondary[property];\n\t  }\n\t  if (secondary && primary) {\n\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t      if (primary.indexOf(item) === -1) {\n\t        primary.push(item);\n\t      }\n\t    });\n\t    return primary;\n\t  } else if (secondary) {\n\t    return secondary;\n\t  } else {\n\t    return primary;\n\t  }\n\t}\n\n\tfunction startsWith(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n\tfunction contains(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = formlyValidationMessages;\n\n\t// @ngInject\n\tfunction formlyValidationMessages() {\n\n\t  var validationMessages = {\n\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t    addStringMessage: addStringMessage,\n\t    messages: {}\n\t  };\n\n\t  return validationMessages;\n\n\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t  }\n\n\t  function addStringMessage(name, string) {\n\t    validationMessages.messages[name] = function () {\n\t      return string;\n\t    };\n\t  }\n\n\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t      if (typeof scope.options.templateOptions[prop] !== 'undefined') {\n\t        return prefix + ' ' + scope.options.templateOptions[prop] + ' ' + suffix;\n\t      } else {\n\t        return alternate;\n\t      }\n\t    };\n\t  }\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyUtil;\n\n\t// @ngInject\n\tfunction formlyUtil() {\n\t  return _otherUtils2['default'];\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\texports['default'] = formlyWarn;\n\n\t// @ngInject\n\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t  return function warn() {\n\t    if (!formlyConfig.disableWarnings) {\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      $log.warn.apply($log, _toConsumableArray(args));\n\t    }\n\t  };\n\t}\n\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyCustomValidation;\n\n\t// @ngInject\n\tfunction formlyCustomValidation(formlyUtil) {\n\t  return {\n\t    restrict: 'A',\n\t    require: 'ngModel',\n\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t      var opts = scope.options;\n\t      opts.validation.messages = opts.validation.messages || {};\n\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t        opts.validation.messages[key] = function () {\n\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t        };\n\t      });\n\n\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\n\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t        setupMessage(validator, name);\n\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t        if (useNewValidatorsApi) {\n\t          setupWithValidators(validator, name, isAsync);\n\t        } else {\n\t          setupWithParsers(validator, name, isAsync);\n\t        }\n\t      }\n\n\t      function setupMessage(validator, name) {\n\t        var message = validator.message;\n\t        if (message) {\n\t          opts.validation.messages[name] = function () {\n\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t          };\n\t        }\n\t      }\n\n\t      function setupWithValidators(validator, name, isAsync) {\n\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\n\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t        };\n\t      }\n\n\t      function setupWithParsers(validator, name, isAsync) {\n\t        var inFlightValidator = undefined;\n\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t          if (isAsync) {\n\t            ctrl.$pending = ctrl.$pending || {};\n\t            ctrl.$pending[name] = true;\n\t            inFlightValidator = isValid;\n\t            isValid.then(function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, true);\n\t              }\n\t            })['catch'](function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, false);\n\t              }\n\t            })['finally'](function () {\n\t              var $pending = ctrl.$pending || {};\n\t              if (Object.keys($pending).length === 1) {\n\t                delete ctrl.$pending;\n\t              } else {\n\t                delete ctrl.$pending[name];\n\t              }\n\t            });\n\t          } else {\n\t            ctrl.$setValidity(name, isValid);\n\t          }\n\t          return viewValue;\n\t        });\n\t      }\n\t    }\n\t  };\n\t}\n\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = formlyField;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyField\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t  var arrayify = formlyUtil.arrayify;\n\n\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t  return {\n\t    restrict: 'AE',\n\t    transclude: true,\n\t    require: '?^formlyForm',\n\t    scope: {\n\t      options: '=',\n\t      model: '=',\n\t      originalModel: '=?',\n\t      formId: '@', // TODO remove formId in a breaking release\n\t      index: '=?',\n\t      fields: '=?',\n\t      formState: '=?',\n\t      formOptions: '=?',\n\t      form: '=?' },\n\t    // TODO require form in a breaking release\n\t    controller: FormlyFieldController,\n\t    link: fieldLink\n\t  };\n\n\t  // @ngInject\n\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t    /* eslint max-statements:[2, 34] */\n\t    if ($scope.options.fieldGroup) {\n\t      setupFieldGroup();\n\t      return;\n\t    }\n\n\t    var fieldType = getFieldType($scope.options);\n\t    simplifyLife($scope.options);\n\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t    checkApi($scope.options);\n\t    // set field id to link labels and fields\n\n\t    // initalization\n\t    setFieldIdAndName();\n\t    setDefaultValue();\n\t    setInitialValue();\n\t    runExpressions();\n\t    watchExpressions();\n\t    addValidationMessages($scope.options);\n\t    invokeControllers($scope, $scope.options, fieldType);\n\n\t    // function definitions\n\t    function runExpressions() {\n\t      // must run on next tick to make sure that the current value is correct.\n\t      return $timeout(function runExpressionsOnNextTick() {\n\t        var field = $scope.options;\n\t        var currentValue = valueGetterSetter();\n\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t          var setter = $parse(prop).assign;\n\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t          promise.then(function setFieldValue(value) {\n\t            setter(field, value);\n\t          });\n\t        });\n\t      }, 0, false);\n\t    }\n\n\t    function watchExpressions() {\n\t      if ($scope.formOptions.watchAllExpressions) {\n\t        (function () {\n\t          var field = $scope.options;\n\t          var currentValue = valueGetterSetter();\n\t          _angularFix2['default'].forEach(field.expressionProperties, function watchExpression(expression, prop) {\n\t            var setter = $parse(prop).assign;\n\t            $scope.$watch(function expressionPropertyWatcher() {\n\t              return formlyUtil.formlyEval($scope, expression, currentValue, currentValue);\n\t            }, function expressionPropertyListener(value) {\n\t              setter(field, value);\n\t            }, true);\n\t          });\n\t        })();\n\t      }\n\t    }\n\n\t    function valueGetterSetter(newVal) {\n\t      if (!$scope.model || !$scope.options.key) {\n\t        return undefined;\n\t      }\n\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t        parseSet($scope.options.key, $scope.model, newVal);\n\t      }\n\t      return parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function shouldNotUseParseKey(key) {\n\t      return _angularFix2['default'].isNumber(key) || !formlyUtil.containsSelector(key);\n\t    }\n\n\t    function parseSet(key, model, newVal) {\n\t      // If either of these are null/undefined then just return undefined\n\t      if (!key || !model) {\n\t        return;\n\t      }\n\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t      if (shouldNotUseParseKey(key)) {\n\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t        model[key] = newVal;\n\t      } else {\n\t        var setter = $parse($scope.options.key).assign;\n\t        if (setter) {\n\t          setter($scope.model, newVal);\n\t        }\n\t      }\n\t    }\n\n\t    function parseGet(key, model) {\n\t      // If either of these are null/undefined then just return undefined\n\t      if (!key || !model) {\n\t        return undefined;\n\t      }\n\n\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t      if (shouldNotUseParseKey(key)) {\n\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t        return model[key];\n\t      } else {\n\t        return $parse(key)(model);\n\t      }\n\t    }\n\n\t    function simplifyLife(options) {\n\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t      formlyUtil.reverseDeepMerge(options, {\n\t        originalModel: options.model,\n\t        extras: {},\n\t        data: {},\n\t        templateOptions: {},\n\t        validation: {}\n\t      });\n\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t      $scope.to = $scope.options.templateOptions;\n\t      $scope.formOptions = $scope.formOptions || {};\n\t    }\n\n\t    function setFieldIdAndName() {\n\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t      } else {\n\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t      }\n\t      $scope.options.id = $scope.id;\n\t      $scope.name = $scope.options.name || $scope.options.id;\n\t      $scope.options.name = $scope.name;\n\t    }\n\n\t    function setDefaultValue() {\n\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined(parseGet($scope.options.key, $scope.model))) {\n\t        parseSet($scope.options.key, $scope.model, $scope.options.defaultValue);\n\t      }\n\t    }\n\n\t    function setInitialValue() {\n\t      $scope.options.initialValue = $scope.model && parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t      if (type) {\n\t        mergeOptions(options, type.defaultOptions);\n\t      }\n\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t      });\n\t    }\n\n\t    function mergeOptions(options, extraOptions) {\n\t      if (extraOptions) {\n\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t          extraOptions = extraOptions(options, $scope);\n\t        }\n\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t      }\n\t    }\n\n\t    function extendOptionsWithDefaults(options, index) {\n\t      var key = options.key || index || 0;\n\t      _angularFix2['default'].extend(options, {\n\t        // attach the key in case the formly-field directive is used directly\n\t        key: key,\n\t        value: options.value || valueGetterSetter,\n\t        runExpressions: runExpressions,\n\t        resetModel: resetModel,\n\t        updateInitialValue: updateInitialValue\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      parseSet($scope.options.key, $scope.model, $scope.options.initialValue);\n\t      if ($scope.options.formControl) {\n\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t            resetFormControl(formControl, true);\n\t          });\n\t        } else {\n\t          resetFormControl($scope.options.formControl);\n\t        }\n\t      }\n\t      if ($scope.form) {\n\t        $scope.form.$setUntouched && $scope.form.$setUntouched();\n\t        $scope.form.$setPristine();\n\t      }\n\t    }\n\n\t    function resetFormControl(formControl, isMultiNgModel) {\n\t      if (!isMultiNgModel) {\n\t        formControl.$setViewValue(parseGet($scope.options.key, $scope.model));\n\t      }\n\n\t      formControl.$render();\n\t      formControl.$setUntouched && formControl.$setUntouched();\n\t      formControl.$setPristine();\n\n\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t      if (!$scope.$root.$$phase) {\n\t        $scope.$digest();\n\t      }\n\t    }\n\n\t    function updateInitialValue() {\n\t      $scope.options.initialValue = parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function addValidationMessages(options) {\n\t      options.validation.messages = options.validation.messages || {};\n\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t        if (!options.validation.messages[name]) {\n\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t          };\n\t        }\n\t      });\n\t    }\n\n\t    function invokeControllers(scope) {\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t        if (controller) {\n\t          $controller(controller, { $scope: scope });\n\t        }\n\t      });\n\t    }\n\n\t    function setupFieldGroup() {\n\t      $scope.options.options = $scope.options.options || {};\n\t      $scope.options.options.formState = $scope.formState;\n\t      $scope.to = $scope.options.templateOptions;\n\t    }\n\t  }\n\n\t  // link function\n\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t    if (scope.options.fieldGroup) {\n\t      setFieldGroupTemplate();\n\t      return;\n\t    }\n\n\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t    if (!formlyFormCtrl && scope.options.model) {\n\t      scope.$watch('options.model', function () {\n\t        return scope.options.runExpressions();\n\t      }, true);\n\t    }\n\n\t    addAttributes();\n\t    addClasses();\n\n\t    var type = getFieldType(scope.options);\n\t    var args = arguments;\n\t    var thusly = this;\n\t    var fieldCount = 0;\n\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t    });\n\n\t    function setFieldGroupTemplate() {\n\t      checkFieldGroupApi(scope.options);\n\t      el.addClass('formly-field-group');\n\t      var extraAttributes = '';\n\t      if (scope.options.elementAttributes) {\n\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t        }).join(' ');\n\t      }\n\t      var modelValue = 'model';\n\t      scope.options.form = scope.form;\n\t      if (scope.options.key) {\n\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t      }\n\t      getTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ').then(transcludeInWrappers(scope.options, scope.formOptions)).then(setElementTemplate);\n\t    }\n\n\t    function addAttributes() {\n\t      if (scope.options.elementAttributes) {\n\t        el.attr(scope.options.elementAttributes);\n\t      }\n\t    }\n\n\t    function addClasses() {\n\t      if (scope.options.className) {\n\t        el.addClass(scope.options.className);\n\t      }\n\t      if (scope.options.type) {\n\t        el.addClass('formly-field-' + scope.options.type);\n\t      }\n\t    }\n\n\t    function setElementTemplate(templateString) {\n\t      el.html(asHtml(templateString));\n\t      $compile(el.contents())(scope);\n\t      return templateString;\n\t    }\n\n\t    function watchFormControl(templateString) {\n\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t      if (scope.options.noFormControl) {\n\t        return;\n\t      }\n\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\n\t      if (ngModelNodes.length) {\n\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t          fieldCount++;\n\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t        });\n\t      }\n\n\t      function watchFieldNameOrExistence(name) {\n\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t        var nameExpression = nameExpressionRegex.exec(name);\n\t        if (nameExpression) {\n\t          name = $interpolate(name)(scope);\n\t        }\n\t        watchFieldExistence(name);\n\t      }\n\n\t      function watchFieldExistence(name) {\n\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t          if (formControl) {\n\t            if (fieldCount > 1) {\n\t              if (!scope.options.formControl) {\n\t                scope.options.formControl = [];\n\t              }\n\t              scope.options.formControl.push(formControl);\n\t            } else {\n\t              scope.options.formControl = formControl;\n\t            }\n\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t            stopWatchingShowError();\n\t            addShowMessagesWatcher();\n\t            addParsers();\n\t            addFormatters();\n\t          }\n\t        });\n\t      }\n\n\t      function addShowMessagesWatcher() {\n\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t          var options = scope.options;\n\t          var formControls = arrayify(scope.fc);\n\t          if (!formControls.some(function (fc) {\n\t            return fc.$invalid;\n\t          })) {\n\t            return false;\n\t          } else if (typeof options.validation.show === 'boolean') {\n\t            return options.validation.show;\n\t          } else if (customExpression) {\n\t            return formControls.some(function (fc) {\n\t              return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t            });\n\t          } else {\n\t            return formControls.some(function (fc) {\n\t              var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t              return fc.$touched || noTouchedButDirty;\n\t            });\n\t          }\n\t        }, function onShowValidationChange(show) {\n\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t          scope.showError = show; // shortcut for template authors\n\t        });\n\t      }\n\n\t      function addParsers() {\n\t        setParsersOrFormatters('parsers');\n\t      }\n\n\t      function addFormatters() {\n\t        setParsersOrFormatters('formatters');\n\t        var ctrl = scope.fc;\n\t        var formWasPristine = scope.form.$pristine;\n\t        if (scope.options.formatters) {\n\t          (function () {\n\t            var value = ctrl.$modelValue;\n\t            ctrl.$formatters.forEach(function (formatter) {\n\t              value = formatter(value);\n\t            });\n\n\t            ctrl.$setViewValue(value);\n\t            ctrl.$render();\n\t            ctrl.$setPristine();\n\t            if (formWasPristine) {\n\t              scope.form.$setPristine();\n\t            }\n\t          })();\n\t        }\n\t      }\n\n\t      function setParsersOrFormatters(which) {\n\t        var originalThingProp = 'originalParser';\n\t        if (which === 'formatters') {\n\t          originalThingProp = 'originalFormatter';\n\t        }\n\n\t        // init with type's parsers\n\t        var things = getThingsFromType(type);\n\n\t        // get optionsTypes things\n\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\n\t        // get field's things\n\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\n\t        // convert things into formlyExpression things\n\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t          things[index] = getFormlyExpressionThing(thing);\n\t        });\n\n\t        var ngModelCtrls = scope.fc;\n\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t          ngModelCtrls = [ngModelCtrls];\n\t        }\n\n\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t          var _ngModelCtrl;\n\n\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t        });\n\n\t        function getThingsFromType(theType) {\n\t          if (!theType) {\n\t            return [];\n\t          }\n\t          if (_angularFix2['default'].isString(theType)) {\n\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t          }\n\t          var typeThings = [];\n\n\t          // get things from parent\n\t          if (theType['extends']) {\n\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t          }\n\n\t          // get own type's things\n\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\n\t          // get things from optionsTypes\n\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\n\t          return typeThings;\n\t        }\n\n\t        function getThingsFromOptionsTypes() {\n\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n\t          var optionsTypesThings = [];\n\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t          });\n\t          return optionsTypesThings;\n\t        }\n\n\t        function getFormlyExpressionThing(thing) {\n\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t          return formlyExpressionParserOrFormatterFunction;\n\n\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t            var $modelValue = scope.options.value();\n\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    function callLinkFunctions() {\n\t      if (type && type.link) {\n\t        type.link.apply(thusly, args);\n\t      }\n\t      if (scope.options.link) {\n\t        scope.options.link.apply(thusly, args);\n\t      }\n\t    }\n\n\t    function runManipulators(manipulators) {\n\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t        var chain = $q.when(templateToManipulate);\n\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t          chain = chain.then(function (template) {\n\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t            });\n\t          });\n\t        });\n\t        return chain;\n\t      };\n\t    }\n\t  }\n\n\t  // sort-of stateless util functions\n\t  function asHtml(el) {\n\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t    return wrapper.append(el).html();\n\t  }\n\n\t  function getFieldType(options) {\n\t    return options.type && formlyConfig.getType(options.type);\n\t  }\n\n\t  function getManipulators(options, formOptions) {\n\t    var preWrapper = [];\n\t    var postWrapper = [];\n\t    addManipulators(options.templateManipulators);\n\t    addManipulators(formOptions.templateManipulators);\n\t    addManipulators(formlyConfig.templateManipulators);\n\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\n\t    function addManipulators(manipulators) {\n\t      /* eslint-disable */ // it doesn't understand this :-(\n\n\t      var _ref = manipulators || {};\n\n\t      var _ref$preWrapper = _ref.preWrapper;\n\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t      var _ref$postWrapper = _ref.postWrapper;\n\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\n\t      preWrapper = preWrapper.concat(pre);\n\t      postWrapper = postWrapper.concat(post);\n\t      /* eslint-enable */\n\t    }\n\t  }\n\n\t  function getFieldTemplate(options) {\n\t    function fromOptionsOrType(key, fieldType) {\n\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t        return options[key];\n\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t        return fieldType[key];\n\t      }\n\t    }\n\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    var template = fromOptionsOrType('template', type);\n\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t    }\n\n\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t  }\n\n\t  function getTemplate(template, isUrl, options) {\n\t    var templatePromise = undefined;\n\t    if (_angularFix2['default'].isFunction(template)) {\n\t      templatePromise = $q.when(template(options));\n\t    } else {\n\t      templatePromise = $q.when(template);\n\t    }\n\n\t    if (!isUrl) {\n\t      return templatePromise;\n\t    } else {\n\t      var _ret3 = (function () {\n\t        var httpOptions = { cache: $templateCache };\n\t        return {\n\t          v: templatePromise.then(function (url) {\n\t            return $http.get(url, httpOptions);\n\t          }).then(function (response) {\n\t            return response.data;\n\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t          })\n\t        };\n\t      })();\n\n\t      if (typeof _ret3 === 'object') return _ret3.v;\n\t    }\n\t  }\n\n\t  function transcludeInWrappers(options, formOptions) {\n\t    var wrapper = getWrapperOption(options, formOptions);\n\n\t    return function transcludeTemplate(template) {\n\t      if (!wrapper.length) {\n\t        return $q.when(template);\n\t      }\n\n\t      wrapper.forEach(function (aWrapper) {\n\t        formlyUsability.checkWrapper(aWrapper, options);\n\t        runApiCheck(aWrapper, options);\n\t      });\n\t      var promises = wrapper.map(function (w) {\n\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t      });\n\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t        });\n\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t        var totalWrapper = wrappersTemplates.shift();\n\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t        });\n\t        return doTransclusion(totalWrapper, template);\n\t      });\n\t    };\n\t  }\n\n\t  function doTransclusion(wrapper, template) {\n\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t    superWrapper.append(wrapper);\n\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t    if (!transcludeEl.length) {\n\t      // try it using our custom find function\n\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t    }\n\t    transcludeEl.replaceWith(template);\n\t    return superWrapper.html();\n\t  }\n\n\t  function getWrapperOption(options, formOptions) {\n\t    /* eslint complexity:[2, 6] */\n\t    var wrapper = options.wrapper;\n\t    // explicit null means no wrapper\n\t    if (wrapper === null) {\n\t      return [];\n\t    }\n\n\t    // nothing specified means use the default wrapper for the type\n\t    if (!wrapper) {\n\t      // get all wrappers that specify they apply to this type\n\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t    } else {\n\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t    }\n\n\t    // get all wrappers for that the type specified that it uses.\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    if (type && type.wrapper) {\n\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(typeWrappers);\n\t    }\n\n\t    // add form wrappers\n\t    if (formOptions.wrapper) {\n\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(formWrappers);\n\t    }\n\n\t    // add the default wrapper last\n\t    var defaultWrapper = formlyConfig.getWrapper();\n\t    if (defaultWrapper) {\n\t      wrapper.push(defaultWrapper);\n\t    }\n\t    return wrapper;\n\t  }\n\n\t  function checkApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t    // validate with the type\n\t    var type = options.type && formlyConfig.getType(options.type);\n\t    if (type) {\n\t      runApiCheck(type, options, true);\n\t    }\n\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t    }\n\t  }\n\n\t  function checkFieldGroupApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t  }\n\n\t  function runApiCheck(_ref2, options, forType) {\n\t    var apiCheck = _ref2.apiCheck;\n\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\n\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t    if (forType && options.type) {\n\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t      });\n\t    }\n\t  }\n\n\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t    /* eslint complexity:[2, 9] */\n\t    if (!apiCheck) {\n\t      return;\n\t    }\n\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t      return;\n\t    }\n\t    var fn = apiCheckFunction || 'warn';\n\t    // this is the new API\n\t    var checkerObjects = apiCheck(instance);\n\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t      var checker = instance.shape(shape);\n\t      var checkOptions = _angularFix2['default'].extend({\n\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t      }, apiCheckOptions);\n\t      instance[fn](checker, options[name], checkOptions);\n\t    });\n\t  }\n\t}\n\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\n\t// Stateless util functions\n\tfunction getDefaultOptionsOptionsTypes(type) {\n\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t}\n\n\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = formlyFocus;\n\n\t// @ngInject\n\tfunction formlyFocus($timeout, $document) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function formlyFocusLink(scope, element, attrs) {\n\t      var previousEl = null;\n\t      var el = element[0];\n\t      var doc = $document[0];\n\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t        if (value === 'true') {\n\t          $timeout(function setElementFocus() {\n\t            previousEl = doc.activeElement;\n\t            el.focus();\n\t          }, ~ ~attrs.focusWait);\n\t        } else if (value === 'false') {\n\t          if (doc.activeElement === el) {\n\t            el.blur();\n\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t              previousEl.focus();\n\t            }\n\t          }\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar _slice = Array.prototype.slice;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyForm;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyForm\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t  var currentFormId = 1;\n\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t  return {\n\t    restrict: 'AE',\n\t    template: formlyFormGetTemplate,\n\t    replace: true,\n\t    transclude: true,\n\t    scope: {\n\t      fields: '=',\n\t      model: '=',\n\t      form: '=?',\n\t      options: '=?'\n\t    },\n\t    controller: FormlyFormController,\n\t    link: formlyFormLink\n\t  };\n\n\t  function formlyFormGetTemplate(el, attrs) {\n\t    var rootEl = getRootEl();\n\t    var fieldRootEl = getFieldRootEl();\n\t    var formId = 'formly_' + currentFormId++;\n\t    var parentFormAttributes = '';\n\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t    }\n\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\n\t    function getRootEl() {\n\t      return attrs.rootEl || 'ng-form';\n\t    }\n\n\t    function getFieldRootEl() {\n\t      return attrs.fieldRootEl || 'div';\n\t    }\n\n\t    function getHideDirective() {\n\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t    }\n\n\t    function getTrackBy() {\n\t      if (!attrs.trackBy) {\n\t        return '';\n\t      } else {\n\t        return 'track by ' + attrs.trackBy;\n\t      }\n\t    }\n\n\t    function getFormName() {\n\t      var formName = formId;\n\t      var bindName = attrs.bindName;\n\t      if (bindName) {\n\t        if (_angularFix2['default'].version.minor < 3) {\n\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t        }\n\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t      }\n\t      return formName;\n\t    }\n\n\t    function getTranscludeClass() {\n\t      return attrs.transcludeClass || '';\n\t    }\n\n\t    function copyAttributes(attributes) {\n\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t      var arrayAttrs = [];\n\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t        var nodeName = _ref.nodeName;\n\t        var value = _ref.value;\n\n\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t        }\n\t      });\n\t      return arrayAttrs.join(' ');\n\t    }\n\t  }\n\n\t  // @ngInject\n\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t    setupOptions();\n\t    $scope.model = $scope.model || {};\n\t    setupFields();\n\n\t    // watch the model and evaluate watch expressions that depend on it.\n\t    if (!$scope.options.manualModelWatcher) {\n\t      $scope.$watch('model', onModelOrFormStateChange, true);\n\t    } else if (_angularFix2['default'].isFunction($scope.options.manualModelWatcher)) {\n\t      $scope.$watch($scope.options.manualModelWatcher, onModelOrFormStateChange, true);\n\t    }\n\n\t    if ($scope.options.formState) {\n\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t    }\n\n\t    function onModelOrFormStateChange() {\n\t      _angularFix2['default'].forEach($scope.fields, runFieldExpressionProperties);\n\t    }\n\n\t    function runFieldExpressionProperties(field, index) {\n\t      var model = field.model || $scope.model;\n\t      var promise = field.runExpressions && field.runExpressions();\n\t      if (field.hideExpression) {\n\t        // can't use hide with expressionProperties reliably\n\t        var val = model[field.key];\n\t        field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t      }\n\t      if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t        var validate = field.formControl.$validate;\n\t        if (promise) {\n\t          promise.then(validate);\n\t        } else {\n\t          validate();\n\t        }\n\t      }\n\t    }\n\n\t    function setupFields() {\n\t      $scope.fields = $scope.fields || [];\n\n\t      checkDeprecatedOptions($scope.options);\n\n\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\n\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t        fieldTransforms = [fieldTransforms];\n\t      }\n\n\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t        if (fieldTransform) {\n\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t          if (!$scope.fields) {\n\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t          }\n\t        }\n\t      });\n\n\t      setupModels();\n\n\t      if ($scope.options.watchAllExpressions) {\n\t        _angularFix2['default'].forEach($scope.fields, setupHideExpressionWatcher);\n\t      }\n\n\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t    }\n\n\t    function checkDeprecatedOptions(options) {\n\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t      }\n\t    }\n\n\t    function setupOptions() {\n\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t      $scope.options = $scope.options || {};\n\t      $scope.options.formState = $scope.options.formState || {};\n\n\t      _angularFix2['default'].extend($scope.options, {\n\t        updateInitialValue: updateInitialValue,\n\t        resetModel: resetModel\n\t      });\n\t    }\n\n\t    function updateInitialValue() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.updateInitialValue();\n\t        } else {\n\t          field.updateInitialValue();\n\t        }\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.resetModel();\n\t        } else if (field.resetModel) {\n\t          field.resetModel();\n\t        }\n\t      });\n\t    }\n\n\t    function setupModels() {\n\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t      var watchedModels = [$scope.model];\n\t      // we will not set up automatic model watchers if manual mode is set\n\t      var manualModelWatcher = $scope.options.manualModelWatcher;\n\n\t      if ($scope.options.formState) {\n\t        // $scope.options.formState will have its own watcher\n\t        watchedModels.push($scope.options.formState);\n\t      }\n\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        var isNewModel = initModel(field);\n\n\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1 && !manualModelWatcher) {\n\t          $scope.$watch(function () {\n\t            return field.model;\n\t          }, onModelOrFormStateChange, true);\n\t          watchedModels.push(field.model);\n\t        }\n\t      });\n\t    }\n\n\t    function setupHideExpressionWatcher(field, index) {\n\t      if (field.hideExpression) {\n\t        (function () {\n\t          // can't use hide with expressionProperties reliably\n\t          var model = field.model || $scope.model;\n\t          $scope.$watch(function hideExpressionWatcher() {\n\t            var val = model[field.key];\n\t            return evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t          }, function (hide) {\n\t            return field.hide = hide;\n\t          }, true);\n\t        })();\n\t      }\n\t    }\n\n\t    function initModel(field) {\n\t      var isNewModel = true;\n\n\t      if (_angularFix2['default'].isString(field.model)) {\n\t        var expression = field.model;\n\t        var index = $scope.fields.indexOf(field);\n\n\t        isNewModel = !referencesCurrentlyWatchedModel(expression);\n\n\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t        if (!field.model) {\n\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t        }\n\t      }\n\t      return isNewModel;\n\t    }\n\n\t    function referencesCurrentlyWatchedModel(expression) {\n\t      return ['model', 'formState'].some(function (item) {\n\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t      });\n\t    }\n\n\t    function attachKey(field, index) {\n\t      if (!isFieldGroup(field)) {\n\t        field.key = field.key || index || 0;\n\t      }\n\t    }\n\n\t    function setupWatchers(field, index) {\n\t      if (!_angularFix2['default'].isDefined(field.watcher)) {\n\t        return;\n\t      }\n\t      var watchers = field.watcher;\n\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t        watchers = [watchers];\n\t      }\n\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t        if (!_angularFix2['default'].isDefined(watcher.listener) && !watcher.runFieldExpressions) {\n\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t        }\n\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t        var watchListener = getWatchListener(watcher, field, index);\n\n\t        var type = watcher.type || '$watch';\n\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t      });\n\t    }\n\n\t    function getWatchExpression(watcher, field, index) {\n\t      var watchExpression = undefined;\n\t      if (!_angularFix2['default'].isUndefined(watcher.expression)) {\n\t        watchExpression = watcher.expression;\n\t      } else if (field.key) {\n\t        watchExpression = 'model[\\'' + field.key.toString().split('.').join('\\'][\\'') + '\\']';\n\t      }\n\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t        (function () {\n\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalExpression = watchExpression;\n\t          watchExpression = function formlyWatchExpression() {\n\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t          };\n\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchExpression;\n\t    }\n\n\t    function getWatchListener(watcher, field, index) {\n\t      var watchListener = watcher.listener;\n\t      if (_angularFix2['default'].isFunction(watchListener) || watcher.runFieldExpressions) {\n\t        (function () {\n\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalListener = watchListener;\n\t          watchListener = function formlyWatchListener() {\n\t            var value = undefined;\n\t            if (originalListener) {\n\t              var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t              value = originalListener.apply(undefined, _toConsumableArray(args));\n\t            }\n\t            if (watcher.runFieldExpressions) {\n\t              runFieldExpressionProperties(field, index);\n\t            }\n\t            return value;\n\t          };\n\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchListener;\n\t    }\n\n\t    function modifyArgs(watcher, index) {\n\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t        originalArgs[_key - 2] = arguments[_key];\n\t      }\n\n\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t    }\n\n\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t    }\n\n\t    function getFormlyFieldLikeLocals(field, index) {\n\t      // this makes it closer to what a regular formlyExpression would be\n\t      return {\n\t        options: field,\n\t        index: index,\n\t        formState: $scope.options.formState,\n\t        formId: $scope.formId\n\t      };\n\t    }\n\t  }\n\n\t  function formlyFormLink(scope, el, attrs) {\n\t    setFormController();\n\t    fixChromeAutocomplete();\n\n\t    function setFormController() {\n\t      var formId = attrs.name;\n\t      scope.formId = formId;\n\t      scope.theFormlyForm = scope[formId];\n\t      if (attrs.form) {\n\t        var getter = $parse(attrs.form);\n\t        var setter = getter.assign;\n\t        var parentForm = getter(scope.$parent);\n\t        if (parentForm) {\n\t          scope.theFormlyForm = parentForm;\n\t          if (scope[formId]) {\n\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t          }\n\n\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t          // to children forms :-( This line was added to solve this issue:\n\t          // https://github.com/formly-js/angular-formly/issues/287\n\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t          // so I expect it will remain this way for the life of angular 1.x\n\t          el.removeData('$formController');\n\t        } else {\n\t          setter(scope.$parent, scope[formId]);\n\t        }\n\t      }\n\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t        /* eslint no-console:0 */\n\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t      }\n\t    }\n\n\t    /*\n\t     * chrome autocomplete lameness\n\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t     * ()   ()     ()\n\t     */\n\t    function fixChromeAutocomplete() {\n\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t      if (global && !offInstance || onInstance) {\n\t        var input = document.createElement('input');\n\t        input.setAttribute('autocomplete', 'address-level4');\n\t        input.setAttribute('hidden', 'true');\n\t        el[0].appendChild(input);\n\t      }\n\t    }\n\t  }\n\n\t  // stateless util functions\n\t  function toKebabCase(string) {\n\t    if (string) {\n\t      return string.replace(/([A-Z])/g, function ($1) {\n\t        return '-' + $1.toLowerCase();\n\t      });\n\t    } else {\n\t      return '';\n\t    }\n\t  }\n\n\t  function isFieldGroup(field) {\n\t    return field && !!field.fieldGroup;\n\t  }\n\t}\n\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\texports['default'] = addFormlyNgModelAttrsManipulator;\n\n\t// @ngInject\n\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t    return;\n\t  }\n\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\n\t  function ngModelAttrsManipulator(template, options, scope) {\n\t    var node = document.createElement('div');\n\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t    if (skip === true) {\n\t      return template;\n\t    }\n\t    node.innerHTML = template;\n\n\t    var modelNodes = getNgModelNodes(node, skip);\n\t    if (!modelNodes || !modelNodes.length) {\n\t      return template;\n\t    }\n\n\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\n\t    addValidation();\n\t    alterNgModelAttr();\n\t    addModelOptions();\n\t    addTemplateOptionsAttrs();\n\t    addNgModelElAttrs();\n\n\t    return node.innerHTML;\n\n\t    function addValidation() {\n\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t      }\n\t    }\n\n\t    function alterNgModelAttr() {\n\t      if (isPropertyAccessor(options.key)) {\n\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t      }\n\t    }\n\n\t    function addModelOptions() {\n\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t        if (options.modelOptions.getterSetter) {\n\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t        }\n\t      }\n\t    }\n\n\t    function addTemplateOptionsAttrs() {\n\t      if (!options.templateOptions && !options.expressionProperties) {\n\t        // no need to run these if there are no templateOptions or expressionProperties\n\t        return;\n\t      }\n\t      var to = options.templateOptions || {};\n\t      var ep = options.expressionProperties || {};\n\n\t      var ngModelAttributes = getBuiltInAttributes();\n\n\t      // extend with the user's specifications winning\n\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\n\t      // Feel free to make this more simple :-)\n\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t        /* eslint complexity:[2, 14] */\n\t        var attrVal = undefined,\n\t            attrName = undefined;\n\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t        var toVal = to[name];\n\t        var epVal = getEpValue(ep, name);\n\n\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t        if (val.value) {\n\t          // I realize this looks backwards, but it's right, trust me...\n\t          attrName = val.value;\n\t          attrVal = name;\n\t        } else if (val.statement && inTo) {\n\t          attrName = val.statement;\n\t          if (_angularFix2['default'].isString(to[name])) {\n\t            attrVal = '$eval(' + ref + ')';\n\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t          } else {\n\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t          }\n\t        } else if (val.bound && inEp) {\n\t          attrName = val.bound;\n\t          attrVal = ref;\n\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t          attrName = val.attribute || val.boolean;\n\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t        } else if (val.attribute && inTo) {\n\t          attrName = val.attribute;\n\t          attrVal = toVal;\n\t        } else if (val.boolean) {\n\t          if (inTo && !inEp && toVal) {\n\t            attrName = val.boolean;\n\t            attrVal = true;\n\t          } else {\n\t            /* eslint no-empty:0 */\n\t            // empty to illustrate that a boolean will not be added via val.bound\n\t            // if you want it added via val.bound, then put it in expressionProperties\n\t          }\n\t        } else if (val.bound && inTo) {\n\t            attrName = val.bound;\n\t            attrVal = ref;\n\t          }\n\n\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t        }\n\t      });\n\t    }\n\n\t    function addNgModelElAttrs() {\n\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t        addRegardlessOfPresence(modelNodes, name, val);\n\t      });\n\t    }\n\t  }\n\n\t  // Utility functions\n\t  function getNgModelNodes(node, skip) {\n\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t    try {\n\t      return node.querySelectorAll(query);\n\t    } catch (e) {\n\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t      //it should be removed when IE8 support is dropped\n\t      return getNgModelNodesFallback(node, skip);\n\t    }\n\t  }\n\n\t  function getNgModelNodesFallback(node, skip) {\n\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t    var matchingNgModelNodes = [];\n\n\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t    matchingNgModelNodes.item = function (i) {\n\t      return this[i];\n\t    };\n\n\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t      var ngModelNode = allNgModelNodes[i];\n\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t        matchingNgModelNodes.push(ngModelNode);\n\t      }\n\t    }\n\n\t    return matchingNgModelNodes;\n\t  }\n\n\t  function nodeMatches(node, selector) {\n\t    var div = document.createElement('div');\n\t    div.innerHTML = node.outerHTML;\n\t    return div.querySelector(selector);\n\t  }\n\n\t  function getBuiltInAttributes() {\n\t    var ngModelAttributes = {\n\t      focus: {\n\t        attribute: 'formly-focus'\n\t      }\n\t    };\n\t    var boundOnly = [];\n\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t    var attributeOnly = ['placeholder', 'min', 'max', 'tabindex', 'type'];\n\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t      bothAttributeAndBound.push('maxlength');\n\t    } else {\n\t      boundOnly.push('maxlength');\n\t    }\n\n\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t      ngModelAttributes[item] = { attribute: item };\n\t    });\n\t    return ngModelAttributes;\n\t  }\n\n\t  function getEpValue(ep, name) {\n\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t  }\n\n\t  function addIfNotPresent(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      if (!node.getAttribute(attr)) {\n\t        node.setAttribute(attr, val);\n\t      }\n\t    });\n\t  }\n\n\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      node.setAttribute(attr, val);\n\t    });\n\t  }\n\n\t  function isPropertyAccessor(key) {\n\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t  }\n\t}\n\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = addCustomTags;\n\n\t// @ngInject\n\tfunction addCustomTags($document) {\n\t  // IE8 check ->\n\t  // https://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx\n\t  if ($document && $document.documentMode < 9) {\n\t    (function () {\n\t      var document = $document.get(0);\n\t      // add the custom elements that we need for formly\n\t      var customElements = ['formly-field', 'formly-form'];\n\t      _angularFix2['default'].forEach(customElements, function (el) {\n\t        document.createElement(el);\n\t      });\n\t    })();\n\t  }\n\t}\n\taddCustomTags.$inject = [\"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly/dist/formly.js\n ** module id = 5\n ** module chunks = 1\n **/","//! angular-formly-templates-bootstrap version 6.3.0 built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> ( _)==(_ )\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tmodule.exports = __webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar ngModuleName = 'formlyBootstrap';\n\tvar angular = __webpack_require__(2);\n\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t  output: {\n\t    prefix: 'angular-formly-bootstrap'\n\t  }\n\t}));\n\tngModule.constant('formlyBootstrapVersion', (\"6.3.0\"));\n\n\t__webpack_require__(6)(ngModule);\n\t__webpack_require__(9)(ngModule);\n\t__webpack_require__(19)(ngModule);\n\n\texports['default'] = ngModuleName;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tvar angular = __webpack_require__(3);\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\tmodule.exports = angular;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addWrappers);\n\n\t  function addWrappers(formlyConfigProvider) {\n\t    formlyConfigProvider.setWrapper([{\n\t      name: 'bootstrapLabel',\n\t      template: __webpack_require__(7),\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string.optional,\n\t            required: check.bool.optional,\n\t            labelSrOnly: check.bool.optional\n\t          }\n\t        };\n\t      }\n\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t  }\n\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  __webpack_require__(10)(ngModule);\n\t  __webpack_require__(12)(ngModule);\n\t  __webpack_require__(14)(ngModule);\n\t  __webpack_require__(15)(ngModule);\n\t  __webpack_require__(17)(ngModule);\n\t  __webpack_require__(18)(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'checkbox',\n\t      template: __webpack_require__(11),\n\t      wrapper: ['bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'multiCheckbox',\n\t      template: __webpack_require__(13),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      },\n\t      defaultOptions: {\n\t        noFormControl: false,\n\t        ngModelAttrs: {\n\t          required: {\n\t            attribute: '',\n\t            bound: ''\n\t          }\n\t        }\n\t      },\n\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t        var to = $scope.to;\n\t        var opts = $scope.options;\n\t        $scope.multiCheckbox = {\n\t          checked: [],\n\t          change: setModel\n\t        };\n\n\t        // initialize the checkboxes check property\n\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t          var modelValue, valueProp;\n\n\t          if (Object.keys(newModelValue).length) {\n\t            modelValue = newModelValue[opts.key];\n\n\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t                valueProp = to.valueProp || 'value';\n\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t                }\n\t              }\n\t            });\n\t          }\n\t        }, true);\n\n\t        function checkValidity(expressionValue) {\n\t          var valid;\n\n\t          if ($scope.to.required) {\n\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\n\t            $scope.fc.$setValidity('required', valid);\n\t          }\n\t        }\n\n\t        function setModel() {\n\t          $scope.model[opts.key] = [];\n\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t            if (checkbox) {\n\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t            }\n\t          });\n\n\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t          $scope.fc.$setTouched();\n\t          checkValidity(true);\n\t        }\n\n\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t          $scope.$watch(function () {\n\t            return $scope.to.required;\n\t          }, function (newValue) {\n\t            checkValidity(newValue);\n\t          });\n\t        }\n\n\t        if ($scope.to.required) {\n\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t            if (!newValue) {\n\t              return;\n\t            }\n\t            checkValidity(true);\n\t            unwatchFormControl();\n\t          });\n\t        }\n\t      }]\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addInputType);\n\n\t  function addInputType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'input',\n\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t    });\n\t  }\n\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addRadioType);\n\n\t  function addRadioType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'radio',\n\t      template: __webpack_require__(16),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        noFormControl: false\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addSelectType);\n\n\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\n\t  function addSelectType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'select',\n\t      template: template,\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: function defaultOptions(options) {\n\t        /* jshint maxlen:195 */\n\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t        return {\n\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t          })\n\t        };\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            optionsAttr: check.string.optional,\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional,\n\t            groupProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addTextareaType);\n\n\t  function addTextareaType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'textarea',\n\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        ngModelAttrs: {\n\t          rows: { attribute: 'rows' },\n\t          cols: { attribute: 'cols' }\n\t        }\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            rows: check.number.optional,\n\t            cols: check.number.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _addons = __webpack_require__(20);\n\n\tvar _addons2 = _interopRequireDefault(_addons);\n\n\tvar _description = __webpack_require__(22);\n\n\tvar _description2 = _interopRequireDefault(_description);\n\n\texports['default'] = function (ngModule) {\n\t  (0, _addons2['default'])(ngModule);\n\t  (0, _description2['default'])(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addAddonsManipulator);\n\n\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t    var addonTemplate = __webpack_require__(21);\n\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t      'class': formlyBootstrapApiCheck.string.optional,\n\t      text: formlyBootstrapApiCheck.string.optional,\n\t      onClick: formlyBootstrapApiCheck.func.optional\n\t    }).strict.optional;\n\t    var api = formlyBootstrapApiCheck.shape({\n\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t        addonLeft: addonChecker,\n\t        addonRight: addonChecker\n\t      })\n\t    });\n\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t        return template;\n\t      }\n\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t    });\n\t  }\n\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this, $event)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this, $event)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addDescriptionManipulator);\n\n\t  function addDescriptionManipulator(formlyConfig) {\n\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t      if (angular.isDefined(options.templateOptions.description)) {\n\t        var el = document.createElement('div');\n\t        el.appendChild(angular.element(template)[0]);\n\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t        if (modelEls) {\n\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t        }\n\t        return el.innerHTML;\n\t      } else {\n\t        return template;\n\t      }\n\t    });\n\t  }\n\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js\n ** module id = 7\n ** module chunks = 1\n **/","/**\n * angular-permission\n * Route permission and access control as simple as it can get\n * @version v2.0.2 - 2016-02-03\n * @link http://www.rafaelvidaurre.com\n * @author Rafael Vidaurre <narzerus@gmail.com>\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n(function () {\n  'use strict';\n\n  var permission = angular.module('permission', ['ui.router']);\n\n  /**\n   * This decorator is required to access full state object instead of it's configuration\n   * when trying to obtain full toState state object not it's configuration\n   * Can be removed when implemented https://github.com/angular-ui/ui-router/issues/13.\n   */\n  permission.config(['$stateProvider', function ($stateProvider) {\n    $stateProvider.decorator('parent', function (state, parentFn) {\n      state.self.getState = function () {\n        return state;\n      };\n      return parentFn(state);\n    });\n  }]);\n\n  permission.run(['$rootScope', '$state', '$q', 'Authorization', 'PermissionMap', function ($rootScope, $state, $q, Authorization, PermissionMap) {\n    $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams, options) {\n\n      if (toState.$$isAuthorizationFinished) {\n        return;\n      }\n\n      if (areSetStatePermissions(toState)) {\n        event.preventDefault();\n        setStateAuthorizationStatus(true);\n\n\n        if (!areStateEventsDefaultPrevented()) {\n          var compensatedPermissionMap = compensatePermissionMap(toState.data.permissions);\n          authorizeForState(compensatedPermissionMap);\n        }\n      }\n\n      /**\n       * Checks if state is qualified to be permission based verified\n       *\n       * @returns {boolean}\n       */\n      function areSetStatePermissions(state) {\n        return angular.isDefined(state.data) && angular.isDefined(state.data.permissions);\n      }\n\n      /**\n       * Sets internal state `$$finishedAuthorization` variable to prevent looping\n       *\n       * @param status {boolean} When true authorization has been already preceded\n       */\n      function setStateAuthorizationStatus(status) {\n        angular.extend(toState, {'$$isAuthorizationFinished': status});\n      }\n\n      /**\n       * Checks if state events are not prevented by default\n       *\n       * @returns {boolean}\n       */\n      function areStateEventsDefaultPrevented() {\n        return isStateChangePermissionStartDefaultPrevented() || isStateChangeStartDefaultPrevented();\n      }\n\n      /**\n       * Builds map of permissions resolving passed values to data.permissions and combine them with all its parents\n       * keeping the order of permissions from the newest (children) to the oldest (parent)\n       *\n       * @param statePermissionMap {Object} Current state permission map\n       * @returns {{only: Array, except: Array}} Permission map\n       */\n      function compensatePermissionMap(statePermissionMap) {\n        var permissionMap = new PermissionMap({redirectTo: statePermissionMap.redirectTo});\n\n        var toStatePath = $state\n          .get(toState.name)\n          .getState().path\n          .slice()\n          .reverse();\n\n        angular.forEach(toStatePath, function (state) {\n          if (areSetStatePermissions(state)) {\n            permissionMap.extendPermissionMap(new PermissionMap(state.data.permissions));\n          }\n        });\n\n        return permissionMap;\n      }\n\n      /**\n       * Handles state authorization\n       *\n       * @param permissions {Object} Map of \"only\" or \"except\" permission names\n       */\n      function authorizeForState(permissions) {\n        Authorization\n          .authorize(permissions, toParams)\n          .then(function () {\n            $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams, options);\n            goToState(toState.name);\n          })\n          .catch(function (rejectedPermission) {\n            $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams, options);\n            permissions.redirectToState(rejectedPermission);\n          });\n      }\n\n      /**\n       * Redirects to states when permissions are met\n       *\n       * If authorized, use call state.go without triggering the event.\n       * Then trigger $stateChangeSuccess manually to resume the rest of the process\n       * Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n       */\n      function goToState(name) {\n        $state\n          .go(name, toParams, angular.extend({}, options, {notify: false}))\n          .then(function () {\n            $rootScope.$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams, options);\n          });\n      }\n\n      /**\n       * Checks if event $stateChangeStart hasn't been disabled by default\n       *\n       * @returns {boolean}\n       */\n      function isStateChangeStartDefaultPrevented() {\n        return $rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams, options).defaultPrevented;\n      }\n\n      /**\n       * Checks if event $stateChangePermissionStart hasn't been disabled by default\n       *\n       * @returns {boolean}\n       */\n      function isStateChangePermissionStartDefaultPrevented() {\n        return $rootScope.$broadcast('$stateChangePermissionStart', toState, toParams, options).defaultPrevented;\n      }\n    });\n  }]);\n}());\n\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .factory('PermissionMap', ['$q', '$state', function ($q, $state) {\n\n      /**\n       * Constructs map object instructing authorization service how to handle authorizing\n       *\n       * @param permissionMap {Object} Map of permissions provided to authorization service\n       * @param permissionMap.only {Array} List of exclusive permission/role names allowed for authorization\n       * @param permissionMap.except {Array} List of exclusive permission/role names denied for authorization\n       * @param permissionMap.redirectTo {String|Function|Object|promise} Handling redirection when rejected\n       *   authorization\n       * @param [toState] {Object} UI-Router transition state object\n       * @param [toParams] {Object} UI-Router transition state params\n       * @param [options] {Object} UI-Router transition state options\n       * @constructor\n       */\n      function PermissionMap(permissionMap, toState, toParams, options) {\n        this.only = resolvePermissionMapProperty(permissionMap.only, toState, toParams, options);\n        this.except = resolvePermissionMapProperty(permissionMap.except, toState, toParams, options);\n        this.redirectTo = permissionMap.redirectTo;\n      }\n\n      /**\n       * Extends permission map by pushing to it state's permissions\n       *\n       * @param permissionMap {PermissionMap} Compensated permission map\n       */\n      PermissionMap.prototype.extendPermissionMap = function (permissionMap) {\n        this.only = this.only.concat(permissionMap.only);\n        this.except = this.except.concat(permissionMap.except);\n      };\n\n\n      /**\n       * Redirects to fallback states when permissions fail\n       *\n       * @param rejectedPermissionName {String} Permission name\n       */\n      PermissionMap.prototype.redirectToState = function (rejectedPermissionName) {\n        if (angular.isFunction(this.redirectTo)) {\n          handleFunctionRedirect(this.redirectTo, rejectedPermissionName);\n        }\n\n        if (angular.isObject(this.redirectTo)) {\n          handleObjectRedirect(this.redirectTo, rejectedPermissionName);\n        }\n\n        if (angular.isString(this.redirectTo)) {\n          handleStringRedirect(this.redirectTo, this.toParams, this.options);\n        }\n      };\n\n      /**\n       * Handles function based redirection for rejected permissions\n       *\n       * @param redirectFunction {Function} Redirection function\n       * @param permission {String} Rejected permission\n       */\n      function handleFunctionRedirect(redirectFunction, permission) {\n        $q.when(redirectFunction.call(null, permission))\n          .then(function (redirectState) {\n            if (!angular.isString(redirectState)) {\n              throw new TypeError('When used \"redirectTo\" as function, returned value must be string with state name');\n            }\n            handleStringRedirect(redirectState);\n          });\n      }\n\n      /**\n       * Handles object based redirection for rejected permissions\n       *\n       * @param redirectObject {Object} Redirection function\n       * @param permission {String} Rejected permission\n       */\n      function handleObjectRedirect(redirectObject, permission) {\n        if (!angular.isDefined(redirectObject['default'])) {\n          throw new ReferenceError('When used \"redirectTo\" as object, property \"default\" must be defined');\n        }\n\n        var redirectState = redirectObject[permission];\n\n        if (!angular.isDefined(redirectState)) {\n          redirectState = redirectObject['default'];\n        }\n\n        if (angular.isFunction(redirectState)) {\n          handleFunctionRedirect(redirectState, permission);\n        }\n\n        if (angular.isString(redirectState)) {\n          handleStringRedirect(redirectState);\n        }\n      }\n\n      /**\n       * Handles string based redirection for rejected permissions\n       */\n      function handleStringRedirect(state, toParams, options) {\n        $state.go(state, toParams, options);\n      }\n\n      /**\n       * Handles extraction of permission map \"only\" and \"except\" properties\n       * @private\n       *\n       * @param property {Array|Function|promise} Permission map property \"only\" or \"except\"\n       * @param [toState] {Object} UI-Router transition state object\n       * @param [toParams] {Object} UI-Router transition state params\n       * @param [options] {Object} UI-Router transition state options\n       * @returns {Array} Array of permission \"only\" or \"except\" names\n       */\n      function resolvePermissionMapProperty(property, toState, toParams, options) {\n        if (angular.isString(property)) {\n          return [property];\n        }\n\n        if (angular.isArray(property)) {\n          return property;\n        }\n\n        if (angular.isFunction(property)) {\n          return property.call(null, toState, toParams, options);\n        }\n\n        return [];\n      }\n\n      return PermissionMap;\n    }]);\n}());\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .factory('Permission', ['$q', function ($q) {\n\n      /**\n       * Permission definition object constructor\n       *\n       * @param permissionName {String} Name repressing permission\n       * @param validationFunction {Function} Function used to check if permission is valid\n       * @constructor\n       */\n      function Permission(permissionName, validationFunction) {\n        validateConstructor(permissionName, validationFunction);\n\n        this.permissionName = permissionName;\n        this.validationFunction = validationFunction;\n      }\n\n      /**\n       * Checks if permission is still valid\n       *\n       * @param toParams {Object} UI-Router params object\n       * @returns {Promise}\n       */\n      Permission.prototype.validatePermission = function (toParams) {\n        var validationResult = this.validationFunction.call(null, toParams, this.permissionName);\n\n        if (!angular.isFunction(validationResult.then)) {\n          validationResult = wrapInPromise(validationResult, this.permissionName);\n        }\n\n        return validationResult;\n      };\n\n      /**\n       * Converts a value into a promise, if the value is truthy it resolves it, otherwise it rejects it\n       * @private\n       *\n       * @param result {Boolean} Function to be wrapped into promise\n       * @param permissionName {String} Returned value in promise\n       * @return {Promise}\n       */\n      function wrapInPromise(result, permissionName) {\n        var dfd = $q.defer();\n\n        if (result) {\n          dfd.resolve(permissionName);\n        } else {\n          dfd.reject(permissionName);\n        }\n\n        return dfd.promise;\n      }\n\n      /**\n       * Checks if provided permission has accepted parameter types\n       * @private\n       */\n      function validateConstructor(permissionName, validationFunction) {\n        if (!angular.isString(permissionName)) {\n          throw new TypeError('Parameter \"permissionName\" name must be String');\n        }\n        if (!angular.isFunction(validationFunction)) {\n          throw new TypeError('Parameter \"validationFunction\" must be Function');\n        }\n      }\n\n      return Permission;\n    }]);\n}());\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .factory('Role', ['$q', 'PermissionStore', function ($q, PermissionStore) {\n\n      /**\n       * Role definition constructor\n       *\n       * @param roleName {String} Name representing role\n       * @param permissionNames {Array} List of permission names representing role\n       * @param [validationFunction] {Function} Optional function used to validate if permissions are still valid\n       * @constructor\n       */\n      function Role(roleName, permissionNames, validationFunction) {\n        validateConstructor(roleName, permissionNames, validationFunction);\n        this.roleName = roleName;\n        this.permissionNames = permissionNames || [];\n\n        if (validationFunction) {\n          PermissionStore.defineManyPermissions(permissionNames, validationFunction);\n        }\n      }\n\n      /**\n       * Checks if role is still valid\n       *\n       * @param toParams {Object} UI-Router params object\n       * @returns {Promise} $q.promise object\n       */\n      Role.prototype.validateRole = function (toParams) {\n\n        // When set permissions is provided check each of them\n        if (this.permissionNames.length) {\n          var promises = this.permissionNames.map(function (permissionName) {\n            if (PermissionStore.hasPermissionDefinition(permissionName)) {\n              var permission = PermissionStore.getPermissionDefinition(permissionName);\n              var validationResult = permission.validationFunction.call(null, toParams, permission.permissionName);\n\n              if (!angular.isFunction(validationResult.then)) {\n                validationResult = wrapInPromise(validationResult);\n              }\n\n              return validationResult;\n            }\n\n            return $q.reject(null);\n          });\n\n          return $q.all(promises);\n        }\n\n        // If not call validation function manually\n        var validationResult = this.validationFunction.call(null, toParams, this.roleName);\n        if (!angular.isFunction(validationResult.then)) {\n          validationResult = wrapInPromise(validationResult, this.roleName);\n        }\n\n        return $q.resolve(validationResult);\n\n      };\n\n      /**\n       * Converts a value into a promise, if the value is truthy it resolves it, otherwise it rejects it\n       * @private\n       *\n       * @param result {Boolean} Function to be wrapped into promise\n       * @param roleName {String} Returned value in promise\n       * @return {Promise}\n       */\n      function wrapInPromise(result, roleName) {\n        var dfd = $q.defer();\n\n        if (result) {\n          dfd.resolve(roleName);\n        } else {\n          dfd.reject(roleName);\n        }\n\n        return dfd.promise;\n      }\n\n      /**\n       * Checks if provided permission has accepted parameter types\n       * @private\n       */\n      function validateConstructor(roleName, permissionNames, validationFunction) {\n        if (!angular.isString(roleName)) {\n          throw new TypeError('Parameter \"roleName\" name must be String');\n        }\n\n        if (!angular.isArray(permissionNames)) {\n          throw new TypeError('Parameter \"permissionNames\" must be Array');\n        }\n\n        if (!permissionNames.length && !angular.isFunction(validationFunction)) {\n          throw new TypeError('Parameter \"validationFunction\" must be provided for empty \"permissionNames\" array');\n        }\n      }\n\n      return Role;\n    }]);\n}());\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .service('PermissionStore', ['Permission', function (Permission) {\n      var permissionStore = {};\n\n      this.definePermission = definePermission;\n      this.defineManyPermissions = defineManyPermissions;\n      this.removePermissionDefinition = removePermissionDefinition;\n      this.hasPermissionDefinition = hasPermissionDefinition;\n      this.getPermissionDefinition = getPermissionDefinition;\n      this.getStore = getStore;\n      this.clearStore = clearStore;\n\n      /**\n       * Allows to define permission on application configuration\n       *\n       * @param permissionName {String} Name of defined permission\n       * @param validationFunction {Function} Function used to validate if permission is valid\n       */\n      function definePermission(permissionName, validationFunction) {\n        permissionStore[permissionName] = new Permission(permissionName, validationFunction);\n      }\n\n      /**\n       * Allows to define set of permissionNames with shared validation function on application configuration\n       *\n       * @param permissionNames {Array} Set of permission names\n       * @param validationFunction {Function} Function used to validate if permission is valid\n       */\n      function defineManyPermissions(permissionNames, validationFunction) {\n        if (!angular.isArray(permissionNames)) {\n          throw new TypeError('Parameter \"permissionNames\" name must be Array');\n        }\n\n        angular.forEach(permissionNames, function (permissionName) {\n          definePermission(permissionName, validationFunction);\n        });\n      }\n\n      /**\n       * Deletes permission\n       *\n       * @param permissionName {String} Name of defined permission\n       */\n      function removePermissionDefinition(permissionName) {\n        delete permissionStore[permissionName];\n      }\n\n      /**\n       * Checks if permission exists\n       *\n       * @param permissionName {String} Name of defined permission\n       * @returns {Boolean}\n       */\n      function hasPermissionDefinition(permissionName) {\n        return angular.isDefined(permissionStore[permissionName]);\n      }\n\n      /**\n       * Returns permission by it's name\n       *\n       * @returns {Object} Permissions collection\n       */\n      function getPermissionDefinition(permissionName) {\n        return permissionStore[permissionName];\n      }\n\n      /**\n       * Returns all permissions\n       *\n       * @returns {Object} Permissions collection\n       */\n      function getStore() {\n        return permissionStore;\n      }\n\n      /**\n       * Removes all permissions\n       */\n      function clearStore() {\n        permissionStore = {};\n      }\n    }]);\n}());\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .service('RoleStore', ['Role', function (Role) {\n      var roleStore = {};\n\n      this.defineRole = defineRole;\n      this.getRoleDefinition = getRoleDefinition;\n      this.hasRoleDefinition = hasRoleDefinition;\n      this.removeRoleDefinition = removeRoleDefinition;\n      this.getStore = getStore;\n      this.clearStore = clearStore;\n\n      /**\n       * Allows to define role\n       *\n       * @param roleName {String} Name of defined role\n       * @param permissions {Array} Set of permission names\n       * @param [validationFunction] {Function} Function used to validate if permissions in role are valid\n       */\n      function defineRole(roleName, permissions, validationFunction) {\n        roleStore[roleName] = new Role(roleName, permissions, validationFunction);\n      }\n\n      /**\n       * Deletes role from store\n       *\n       * @param roleName {String} Name of defined permission\n       */\n      function removeRoleDefinition(roleName) {\n        delete roleStore[roleName];\n      }\n\n      /**\n       * Checks if role is defined in store\n       *\n       * @param roleName {String} Name of role\n       * @returns {Boolean}\n       */\n      function hasRoleDefinition(roleName) {\n        return angular.isDefined(roleStore[roleName]);\n      }\n\n      /**\n       * Returns role definition object by it's name\n       *\n       * @returns {Object} Role definition object\n       */\n      function getRoleDefinition(roleName) {\n        return roleStore[roleName];\n      }\n\n      /**\n       * Returns all role definitions\n       *\n       * @returns {Object} Defined roles collection\n       */\n      function getStore() {\n        return roleStore;\n      }\n\n      /**\n       * Removes all role definitions\n       */\n      function clearStore() {\n        roleStore = {};\n      }\n    }]);\n}());\n(function () {\n  'use strict';\n\n  /**\n   * Show/hide elements based on provided permissions\n   *\n   * @example\n   * <div permission only=\"'USER'\"></div>\n   * <div permission only=\"['USER','ADMIN']\" except=\"'MANAGER'\"></div>\n   * <div permission except=\"'MANAGER'\"></div>\n   */\n  angular\n    .module('permission')\n    .directive('permission', ['$log', 'Authorization', 'PermissionMap', function ($log, Authorization, PermissionMap) {\n      return {\n        restrict: 'A',\n        link: function (scope, element, attrs) {\n          try {\n            Authorization\n              .authorize(new PermissionMap({\n                only: scope.$eval(attrs.only),\n                except: scope.$eval(attrs.except)\n              }), null)\n              .then(function () {\n                element.removeClass('ng-hide');\n              })\n              .catch(function () {\n                element.addClass('ng-hide');\n              });\n          } catch (e) {\n            element.addClass('ng-hide');\n            $log.error(e.message);\n          }\n        }\n      };\n    }]);\n}());\n\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .service('Authorization', ['$q', 'PermissionMap', 'PermissionStore', 'RoleStore', function ($q, PermissionMap, PermissionStore, RoleStore) {\n      this.authorize = authorize;\n\n      /**\n       * Checks if provided permissions are acceptable\n       *\n       * @param permissionsMap {PermissionMap} Map of permission names\n       * @param [toParams] {Object} UI-Router params object\n       * @returns {promise} $q.promise object\n       */\n      function authorize(permissionsMap, toParams) {\n        return handleAuthorization(permissionsMap, toParams);\n      }\n\n      /**\n       * Handles authorization based on provided permissions map\n       * @private\n       *\n       * @param permissionsMap {Object} Map of permission names\n       * @param toParams {Object} UI-Router params object\n       * @returns {promise} $q.promise object\n       */\n      function handleAuthorization(permissionsMap, toParams) {\n        var deferred = $q.defer();\n\n        var exceptPromises = findMatchingPermissions(permissionsMap.except, toParams);\n\n        $q.all(exceptPromises)\n          .then(function (rejectedPermissions) {\n            // If any \"except\" permissions are found reject authorization\n            if (rejectedPermissions.length) {\n              deferred.reject(rejectedPermissions);\n            } else {\n              // If none go to checking \"only\" permissions\n              return $q.reject(null);\n            }\n          })\n          .catch(function () {\n            var onlyPromises = findMatchingPermissions(permissionsMap.only, toParams);\n            $q.all(onlyPromises)\n              .then(function (resolvedPermissions) {\n                deferred.resolve(resolvedPermissions);\n              })\n              .catch(function (rejectedPermission) {\n                deferred.reject(rejectedPermission);\n              });\n          });\n\n        return deferred.promise;\n      }\n\n      /**\n       * Performs iteration over list of defined permissions looking for matching roles\n       * @private\n       *\n       * @param permissionNames {Array} Set of permission names\n       * @param toParams {Object} UI-Router params object\n       * @returns {Array} Promise collection\n       */\n      function findMatchingPermissions(permissionNames, toParams) {\n        return permissionNames.map(function (permissionName) {\n          if (RoleStore.hasRoleDefinition(permissionName)) {\n            return handleRoleValidation(permissionName, toParams);\n          }\n\n          if (PermissionStore.hasPermissionDefinition(permissionName)) {\n            return handlePermissionValidation(permissionName, toParams);\n          }\n\n          if (permissionName) {\n            return $q.reject(permissionName);\n          }\n        });\n      }\n\n      /**\n       * Executes role validation checking\n       * @private\n       *\n       * @param roleName {String} Store permission key\n       * @param toParams {Object} UI-Router params object\n       * @returns {Promise}\n       */\n      function handleRoleValidation(roleName, toParams) {\n        var role = RoleStore.getRoleDefinition(roleName);\n        return role.validateRole(toParams);\n      }\n\n      /**\n       * Executes permission validation checking\n       * @private\n       *\n       * @param permissionName {String} Store permission key\n       * @param toParams {Object} UI-Router params object\n       * @returns {Promise}\n       */\n      function handlePermissionValidation(permissionName, toParams) {\n        var permission = PermissionStore.getPermissionDefinition(permissionName);\n        return permission.validatePermission(toParams);\n      }\n    }]);\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-permission/dist/angular-permission.js\n ** module id = 8\n ** module chunks = 1\n **/","require('./dist/ui-bootstrap-tpls');\n\nmodule.exports = 'ui.bootstrap';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/index.js\n ** module id = 9\n ** module chunks = 1\n **/","/**\r\n * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n * @author Mark Lagendijk <mark@lagendijk.info>\r\n * @license MIT\r\n */\r\nangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n        var self = this;\r\n\r\n        /**\r\n         * Recursively sets the states using $stateProvider.state.\r\n         * Child states are defined via a `children` property.\r\n         *\r\n         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n         * 3. Sets `parent` property of the descendant states.\r\n         *\r\n         * @param {Object} state - A regular ui.router state object.\r\n         * @param {Array} [state.children] - An optional array of child states.\r\n         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n         * @param {Object} [options] - An optional options object.\r\n         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n         *     prevents conversion of names to dot notation if true.\r\n         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n         */\r\n        this.state = function(state){\r\n            var args = Array.prototype.slice.apply(arguments);\r\n            var options = {\r\n                keepOriginalNames: false,\r\n                siblingTraversal: false\r\n            };  \r\n\r\n            if (typeof args[1] === 'boolean') {\r\n                options.keepOriginalNames = args[1];\r\n            } \r\n            else if (typeof args[1] === 'object') {\r\n                angular.extend(options, args[1]);\r\n            }\r\n\r\n            if (!options.keepOriginalNames) {\r\n                fixStateName(state);\r\n            }\r\n\r\n            $stateProvider.state(state);\r\n\r\n            if(state.children && state.children.length){\r\n                state.children.forEach(function(childState){\r\n                    childState.parent = state;\r\n                    self.state(childState, options);\r\n                });\r\n\r\n                if (options.siblingTraversal) {\r\n                    addSiblings(state);\r\n                }\r\n            }\r\n\r\n            return self;\r\n        };\r\n\r\n        this.setNestedState = this.state;\r\n\r\n        self.$get = angular.noop;\r\n\r\n        /**\r\n         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n         * @param state\r\n         */\r\n        function fixStateName(state){\r\n            if(state.parent){\r\n                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n            }\r\n        }\r\n\r\n        function addSiblings(state) {\r\n            state.children.forEach(function (childState, idx, array) {\r\n                if (array[idx + 1]) {\r\n                    childState.nextSibling = array[idx + 1].name;\r\n                }\r\n                if (array[idx - 1]) {\r\n                    childState.previousSibling = array[idx - 1].name;\r\n                }\r\n            });\r\n        }\r\n    }]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router.statehelper/statehelper.js\n ** module id = 10\n ** module chunks = 1\n **/","/**\n * State-based routing for AngularJS\n * @version v0.2.18\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\nvar ngMajorVer = angular.version.major;\nvar ngMinorVer = angular.version.minor;\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n * will be applied to the ui-view)\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = {\n      enter: function (element, target, cb) { target.after(element); cb(); },\n      leave: function (element, cb) { element.remove(); cb(); }\n    };\n\n    if (!!attrs.noanimation) return statics;\n\n    function animEnabled(element) {\n      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n      return (!!$animator);\n    }\n\n    // ng 1.2+\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (!animEnabled(element)) {\n            statics.enter(element, target, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (!animEnabled(element)) {\n            statics.leave(element, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    // ng 1.1.5\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics;\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          var _previousEl = previousEl;\n          var _currentScope = currentScope;\n\n          if (_currentScope) {\n            _currentScope._willBeDestroyed = true;\n          }\n\n          function cleanOld() {\n            if (_previousEl) {\n              _previousEl.remove();\n            }\n\n            if (_currentScope) {\n              _currentScope.$destroy();\n            }\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              cleanOld();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n          } else {\n            cleanOld();\n            previousEl = null;\n          }\n\n          currentEl = null;\n          currentScope = null;\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        addState(newState, newParams, uiSrefActive);\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        states.push({\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        });\n\n        activeClasses[stateHash] = activeClass;\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router/release/angular-ui-router.js\n ** module id = 11\n ** module chunks = 1\n **/","(function (root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(['angular'], factory);\n  } else if (root.hasOwnProperty('angular')) {\n    // Browser globals (root is window), we don't register it.\n    factory(root.angular);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('angular'));\n  }\n}(this , function (angular) {\n    'use strict';\n\n    // In cases where Angular does not get passed or angular is a truthy value\n    // but misses .module we can fall back to using window.\n    angular = (angular && angular.module ) ? angular : window.angular;\n\n    /**\n     * @ngdoc overview\n     * @name ngStorage\n     */\n\n    return angular.module('ngStorage', [])\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$localStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$localStorage', _storageProvider('localStorage'))\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$sessionStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\n    function _storageProvider(storageType) {\n        return function () {\n          var storageKeyPrefix = 'ngStorage-';\n\n          this.setKeyPrefix = function (prefix) {\n            if (typeof prefix !== 'string') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n            }\n            storageKeyPrefix = prefix;\n          };\n\n          var serializer = angular.toJson;\n          var deserializer = angular.fromJson;\n\n          this.setSerializer = function (s) {\n            if (typeof s !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n            }\n\n            serializer = s;\n          };\n\n          this.setDeserializer = function (d) {\n            if (typeof d !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n            }\n\n            deserializer = d;\n          };\n\n          // Note: This is not very elegant at all.\n          this.get = function (key) {\n            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n          };\n\n          // Note: This is not very elegant at all.\n          this.set = function (key, value) {\n            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n          };\n\n          this.$get = [\n              '$rootScope',\n              '$window',\n              '$log',\n              '$timeout',\n              '$document',\n\n              function(\n                  $rootScope,\n                  $window,\n                  $log,\n                  $timeout,\n                  $document\n              ){\n                function isStorageSupported(storageType) {\n\n                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n                    // that error and allow execution to continue.\n\n                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n                    // when \"Block cookies\": \"Always block\" is turned on\n                    var supported;\n                    try {\n                        supported = $window[storageType];\n                    }\n                    catch (err) {\n                        supported = false;\n                    }\n\n                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n                    // is available, but trying to call .setItem throws an exception below:\n                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n                    if (supported && storageType === 'localStorage') {\n                        var key = '__' + Math.round(Math.random() * 1e7);\n\n                        try {\n                            localStorage.setItem(key, key);\n                            localStorage.removeItem(key);\n                        }\n                        catch (err) {\n                            supported = false;\n                        }\n                    }\n\n                    return supported;\n                }\n\n                // The magic number 10 is used which only works for some keyPrefixes...\n                // See https://github.com/gsklee/ngStorage/issues/137\n                var prefixLength = storageKeyPrefix.length;\n\n                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n                    $storage = {\n                        $default: function(items) {\n                            for (var k in items) {\n                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n                            }\n\n                            $storage.$sync();\n                            return $storage;\n                        },\n                        $reset: function(items) {\n                            for (var k in $storage) {\n                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n                            }\n\n                            return $storage.$default(items);\n                        },\n                        $sync: function () {\n                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n                            }\n                        },\n                        $apply: function() {\n                            var temp$storage;\n\n                            _debounce = null;\n\n                            if (!angular.equals($storage, _last$storage)) {\n                                temp$storage = angular.copy(_last$storage);\n                                angular.forEach($storage, function(v, k) {\n                                    if (angular.isDefined(v) && '$' !== k[0]) {\n                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n                                        delete temp$storage[k];\n                                    }\n                                });\n\n                                for (var k in temp$storage) {\n                                    webStorage.removeItem(storageKeyPrefix + k);\n                                }\n\n                                _last$storage = angular.copy($storage);\n                            }\n                        }\n                    },\n                    _last$storage,\n                    _debounce;\n\n                $storage.$sync();\n\n                _last$storage = angular.copy($storage);\n\n                $rootScope.$watch(function() {\n                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n                });\n\n                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n                $window.addEventListener && $window.addEventListener('storage', function(event) {\n                    if (!event.key) {\n                      return;\n                    }\n\n                    // Reference doc.\n                    var doc = $document[0];\n\n                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\n                        _last$storage = angular.copy($storage);\n\n                        $rootScope.$apply();\n                    }\n                });\n\n                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n                    $storage.$apply();\n                });\n\n                return $storage;\n              }\n          ];\n      };\n    }\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngstorage/ngStorage.js\n ** module id = 12\n ** module chunks = 1\n **/","/**\n * oclazyload - Load modules on demand (lazy load) with angularJS\n * @version v1.0.9\n * @link https://github.com/ocombe/ocLazyLoad\n * @license MIT\n * @author Olivier Combe <olivier.combe@gmail.com>\n */\n(function (angular, window) {\n    'use strict';\n\n    var regModules = ['ng', 'oc.lazyLoad'],\n        regInvokes = {},\n        regConfigs = [],\n        modulesToLoad = [],\n        // modules to load from angular.module or other sources\n    realModules = [],\n        // real modules called from angular.module\n    recordDeclarations = [],\n        broadcast = angular.noop,\n        runBlocks = {},\n        justLoaded = [];\n\n    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\n    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n        var modules = {},\n            providers = {\n            $controllerProvider: $controllerProvider,\n            $compileProvider: $compileProvider,\n            $filterProvider: $filterProvider,\n            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n            $injector: $injector,\n            $animateProvider: $animateProvider\n        },\n            debug = false,\n            events = false,\n            moduleCache = [],\n            modulePromises = {};\n\n        moduleCache.push = function (value) {\n            if (this.indexOf(value) === -1) {\n                Array.prototype.push.apply(this, arguments);\n            }\n        };\n\n        this.config = function (config) {\n            // If we want to define modules configs\n            if (angular.isDefined(config.modules)) {\n                if (angular.isArray(config.modules)) {\n                    angular.forEach(config.modules, function (moduleConfig) {\n                        modules[moduleConfig.name] = moduleConfig;\n                    });\n                } else {\n                    modules[config.modules.name] = config.modules;\n                }\n            }\n\n            if (angular.isDefined(config.debug)) {\n                debug = config.debug;\n            }\n\n            if (angular.isDefined(config.events)) {\n                events = config.events;\n            }\n        };\n\n        /**\n         * Get the list of existing registered modules\n         * @param element\n         */\n        this._init = function _init(element) {\n            // this is probably useless now because we override angular.bootstrap\n            if (modulesToLoad.length === 0) {\n                var elements = [element],\n                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n                    append = function append(elm) {\n                    return elm && elements.push(elm);\n                };\n\n                angular.forEach(names, function (name) {\n                    names[name] = true;\n                    append(document.getElementById(name));\n                    name = name.replace(':', '\\\\:');\n                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n                    }\n                });\n\n                angular.forEach(elements, function (elm) {\n                    if (modulesToLoad.length === 0) {\n                        var className = ' ' + element.className + ' ';\n                        var match = NG_APP_CLASS_REGEXP.exec(className);\n                        if (match) {\n                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n                        } else {\n                            angular.forEach(elm.attributes, function (attr) {\n                                if (modulesToLoad.length === 0 && names[attr.name]) {\n                                    modulesToLoad.push(attr.value);\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n\n            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n            }\n\n            var addReg = function addReg(moduleName) {\n                if (regModules.indexOf(moduleName) === -1) {\n                    // register existing modules\n                    regModules.push(moduleName);\n                    var mainModule = angular.module(moduleName);\n\n                    // register existing components (directives, services, ...)\n                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\n                    angular.forEach(mainModule.requires, addReg);\n                }\n            };\n\n            angular.forEach(modulesToLoad, function (moduleName) {\n                addReg(moduleName);\n            });\n\n            modulesToLoad = []; // reset for next bootstrap\n            recordDeclarations.pop(); // wait for the next lazy load\n        };\n\n        /**\n         * Like JSON.stringify but that doesn't throw on circular references\n         * @param obj\n         */\n        var stringify = function stringify(obj) {\n            try {\n                return JSON.stringify(obj);\n            } catch (e) {\n                var cache = [];\n                return JSON.stringify(obj, function (key, value) {\n                    if (angular.isObject(value) && value !== null) {\n                        if (cache.indexOf(value) !== -1) {\n                            // Circular reference found, discard key\n                            return;\n                        }\n                        // Store value in our collection\n                        cache.push(value);\n                    }\n                    return value;\n                });\n            }\n        };\n\n        var hashCode = function hashCode(str) {\n            var hash = 0,\n                i,\n                chr,\n                len;\n            if (str.length == 0) {\n                return hash;\n            }\n            for (i = 0, len = str.length; i < len; i++) {\n                chr = str.charCodeAt(i);\n                hash = (hash << 5) - hash + chr;\n                hash |= 0; // Convert to 32bit integer\n            }\n            return hash;\n        };\n\n        function _register(providers, registerModules, params) {\n            if (registerModules) {\n                var k,\n                    moduleName,\n                    moduleFn,\n                    tempRunBlocks = [];\n                for (k = registerModules.length - 1; k >= 0; k--) {\n                    moduleName = registerModules[k];\n                    if (!angular.isString(moduleName)) {\n                        moduleName = getModuleName(moduleName);\n                    }\n                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n                        continue;\n                    }\n                    // new if not registered\n                    var newModule = regModules.indexOf(moduleName) === -1;\n                    moduleFn = ngModuleFct(moduleName);\n                    if (newModule) {\n                        regModules.push(moduleName);\n                        _register(providers, moduleFn.requires, params);\n                    }\n                    if (moduleFn._runBlocks.length > 0) {\n                        // new run blocks detected! Replace the old ones (if existing)\n                        runBlocks[moduleName] = [];\n                        while (moduleFn._runBlocks.length > 0) {\n                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n                        }\n                    }\n                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n                    }\n                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n                    registerModules.pop();\n                    justLoaded.push(moduleName);\n                }\n                // execute the run blocks at the end\n                var instanceInjector = providers.getInstanceInjector();\n                angular.forEach(tempRunBlocks, function (fn) {\n                    instanceInjector.invoke(fn);\n                });\n            }\n        }\n\n        function _registerInvokeList(args, moduleName) {\n            var invokeList = args[2][0],\n                type = args[1],\n                newInvoke = false;\n            if (angular.isUndefined(regInvokes[moduleName])) {\n                regInvokes[moduleName] = {};\n            }\n            if (angular.isUndefined(regInvokes[moduleName][type])) {\n                regInvokes[moduleName][type] = {};\n            }\n            var onInvoke = function onInvoke(invokeName, invoke) {\n                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n                    regInvokes[moduleName][type][invokeName] = [];\n                }\n                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n                    newInvoke = true;\n                    regInvokes[moduleName][type][invokeName].push(invoke);\n                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n                }\n            };\n\n            function checkHashes(potentialNew, invokes) {\n                var isNew = true,\n                    newHash;\n                if (invokes.length) {\n                    newHash = signature(potentialNew);\n                    angular.forEach(invokes, function (invoke) {\n                        isNew = isNew && signature(invoke) !== newHash;\n                    });\n                }\n                return isNew;\n            }\n\n            function signature(data) {\n                if (angular.isArray(data)) {\n                    // arrays are objects, we need to test for it first\n                    return hashCode(data.toString());\n                } else if (angular.isObject(data)) {\n                    // constants & values for example\n                    return hashCode(stringify(data));\n                } else {\n                    if (angular.isDefined(data) && data !== null) {\n                        return hashCode(data.toString());\n                    } else {\n                        // null & undefined constants\n                        return data;\n                    }\n                }\n            }\n\n            if (angular.isString(invokeList)) {\n                onInvoke(invokeList, args[2][1]);\n            } else if (angular.isObject(invokeList)) {\n                angular.forEach(invokeList, function (invoke, key) {\n                    if (angular.isString(invoke)) {\n                        // decorators for example\n                        onInvoke(invoke, invokeList[1]);\n                    } else {\n                        // components registered as object lists {\"componentName\": function() {}}\n                        onInvoke(key, invoke);\n                    }\n                });\n            } else {\n                return false;\n            }\n            return newInvoke;\n        }\n\n        function _invokeQueue(providers, queue, moduleName, reconfig) {\n            if (!queue) {\n                return;\n            }\n\n            var i, len, args, provider;\n            for (i = 0, len = queue.length; i < len; i++) {\n                args = queue[i];\n                if (angular.isArray(args)) {\n                    if (providers !== null) {\n                        if (providers.hasOwnProperty(args[0])) {\n                            provider = providers[args[0]];\n                        } else {\n                            throw new Error('unsupported provider ' + args[0]);\n                        }\n                    }\n                    var isNew = _registerInvokeList(args, moduleName);\n                    if (args[1] !== 'invoke') {\n                        if (isNew && angular.isDefined(provider)) {\n                            provider[args[1]].apply(provider, args[2]);\n                        }\n                    } else {\n                        // config block\n                        var callInvoke = function callInvoke(fct) {\n                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n                            if (invoked === -1 || reconfig) {\n                                if (invoked === -1) {\n                                    regConfigs.push(moduleName + '-' + fct);\n                                }\n                                if (angular.isDefined(provider)) {\n                                    provider[args[1]].apply(provider, args[2]);\n                                }\n                            }\n                        };\n                        if (angular.isFunction(args[2][0])) {\n                            callInvoke(args[2][0]);\n                        } else if (angular.isArray(args[2][0])) {\n                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n                                if (angular.isFunction(args[2][0][j])) {\n                                    callInvoke(args[2][0][j]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function getModuleName(module) {\n            var moduleName = null;\n            if (angular.isString(module)) {\n                moduleName = module;\n            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n                moduleName = module.name;\n            }\n            return moduleName;\n        }\n\n        function moduleExists(moduleName) {\n            if (!angular.isString(moduleName)) {\n                return false;\n            }\n            try {\n                return ngModuleFct(moduleName);\n            } catch (e) {\n                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                    return false;\n                }\n            }\n        }\n\n        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n            var instanceInjector,\n                filesCache = $cacheFactory('ocLazyLoad');\n\n            if (!debug) {\n                $log = {};\n                $log['error'] = angular.noop;\n                $log['warn'] = angular.noop;\n                $log['info'] = angular.noop;\n            }\n\n            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n            providers.getInstanceInjector = function () {\n                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n            };\n\n            broadcast = function broadcast(eventName, params) {\n                if (events) {\n                    $rootScope.$broadcast(eventName, params);\n                }\n                if (debug) {\n                    $log.info(eventName, params);\n                }\n            };\n\n            function reject(e) {\n                var deferred = $q.defer();\n                $log.error(e.message);\n                deferred.reject(e);\n                return deferred.promise;\n            }\n\n            return {\n                _broadcast: broadcast,\n\n                _$log: $log,\n\n                /**\n                 * Returns the files cache used by the loaders to store the files currently loading\n                 * @returns {*}\n                 */\n                _getFilesCache: function getFilesCache() {\n                    return filesCache;\n                },\n\n                /**\n                 * Let the service know that it should monitor angular.module because files are loading\n                 * @param watch boolean\n                 */\n                toggleWatch: function toggleWatch(watch) {\n                    if (watch) {\n                        recordDeclarations.push(true);\n                    } else {\n                        recordDeclarations.pop();\n                    }\n                },\n\n                /**\n                 * Let you get a module config object\n                 * @param moduleName String the name of the module\n                 * @returns {*}\n                 */\n                getModuleConfig: function getModuleConfig(moduleName) {\n                    if (!angular.isString(moduleName)) {\n                        throw new Error('You need to give the name of the module to get');\n                    }\n                    if (!modules[moduleName]) {\n                        return null;\n                    }\n                    return angular.copy(modules[moduleName]);\n                },\n\n                /**\n                 * Let you define a module config object\n                 * @param moduleConfig Object the module config object\n                 * @returns {*}\n                 */\n                setModuleConfig: function setModuleConfig(moduleConfig) {\n                    if (!angular.isObject(moduleConfig)) {\n                        throw new Error('You need to give the module config object to set');\n                    }\n                    modules[moduleConfig.name] = moduleConfig;\n                    return moduleConfig;\n                },\n\n                /**\n                 * Returns the list of loaded modules\n                 * @returns {string[]}\n                 */\n                getModules: function getModules() {\n                    return regModules;\n                },\n\n                /**\n                 * Let you check if a module has been loaded into Angular or not\n                 * @param modulesNames String/Object a module name, or a list of module names\n                 * @returns {boolean}\n                 */\n                isLoaded: function isLoaded(modulesNames) {\n                    var moduleLoaded = function moduleLoaded(module) {\n                        var isLoaded = regModules.indexOf(module) > -1;\n                        if (!isLoaded) {\n                            isLoaded = !!moduleExists(module);\n                        }\n                        return isLoaded;\n                    };\n                    if (angular.isString(modulesNames)) {\n                        modulesNames = [modulesNames];\n                    }\n                    if (angular.isArray(modulesNames)) {\n                        var i, len;\n                        for (i = 0, len = modulesNames.length; i < len; i++) {\n                            if (!moduleLoaded(modulesNames[i])) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    } else {\n                        throw new Error('You need to define the module(s) name(s)');\n                    }\n                },\n\n                /**\n                 * Given a module, return its name\n                 * @param module\n                 * @returns {String}\n                 */\n                _getModuleName: getModuleName,\n\n                /**\n                 * Returns a module if it exists\n                 * @param moduleName\n                 * @returns {module}\n                 */\n                _getModule: function getModule(moduleName) {\n                    try {\n                        return ngModuleFct(moduleName);\n                    } catch (e) {\n                        // this error message really suxx\n                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n                        }\n                        throw e;\n                    }\n                },\n\n                /**\n                 * Check if a module exists and returns it if it does\n                 * @param moduleName\n                 * @returns {boolean}\n                 */\n                moduleExists: moduleExists,\n\n                /**\n                 * Load the dependencies, and might try to load new files depending on the config\n                 * @param moduleName (String or Array of Strings)\n                 * @param localParams\n                 * @returns {*}\n                 * @private\n                 */\n                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n                    var loadedModule,\n                        requires,\n                        diff,\n                        promisesList = [],\n                        self = this;\n\n                    moduleName = self._getModuleName(moduleName);\n\n                    if (moduleName === null) {\n                        return $q.when();\n                    } else {\n                        try {\n                            loadedModule = self._getModule(moduleName);\n                        } catch (e) {\n                            return reject(e);\n                        }\n                        // get unloaded requires\n                        requires = self.getRequires(loadedModule);\n                    }\n\n                    angular.forEach(requires, function (requireEntry) {\n                        // If no configuration is provided, try and find one from a previous load.\n                        // If there isn't one, bail and let the normal flow run\n                        if (angular.isString(requireEntry)) {\n                            var config = self.getModuleConfig(requireEntry);\n                            if (config === null) {\n                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n                                return;\n                            }\n                            requireEntry = config;\n                            // ignore the name because it's probably not a real module name\n                            config.name = undefined;\n                        }\n\n                        // Check if this dependency has been loaded previously\n                        if (self.moduleExists(requireEntry.name)) {\n                            // compare against the already loaded module to see if the new definition adds any new files\n                            diff = requireEntry.files.filter(function (n) {\n                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n                            });\n\n                            // If the module was redefined, advise via the console\n                            if (diff.length !== 0) {\n                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n                            }\n\n                            // Push everything to the file loader, it will weed out the duplicates.\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                            return;\n                        } else if (angular.isArray(requireEntry)) {\n                            var files = [];\n                            angular.forEach(requireEntry, function (entry) {\n                                // let's check if the entry is a file name or a config name\n                                var config = self.getModuleConfig(entry);\n                                if (config === null) {\n                                    files.push(entry);\n                                } else if (config.files) {\n                                    files = files.concat(config.files);\n                                }\n                            });\n                            if (files.length > 0) {\n                                requireEntry = {\n                                    files: files\n                                };\n                            }\n                        } else if (angular.isObject(requireEntry)) {\n                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n                                self.setModuleConfig(requireEntry);\n                                moduleCache.push(requireEntry['name']);\n                            }\n                        }\n\n                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                        }\n                    });\n\n                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n                    return $q.all(promisesList);\n                },\n\n                /**\n                 * Inject new modules into Angular\n                 * @param moduleName\n                 * @param localParams\n                 * @param real\n                 */\n                inject: function inject(moduleName) {\n                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n                    var self = this,\n                        deferred = $q.defer();\n                    if (angular.isDefined(moduleName) && moduleName !== null) {\n                        if (angular.isArray(moduleName)) {\n                            var promisesList = [];\n                            angular.forEach(moduleName, function (module) {\n                                promisesList.push(self.inject(module, localParams, real));\n                            });\n                            return $q.all(promisesList);\n                        } else {\n                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n                        }\n                    }\n                    if (modulesToLoad.length > 0) {\n                        var res = modulesToLoad.slice(); // clean copy\n                        var loadNext = function loadNext(moduleName) {\n                            moduleCache.push(moduleName);\n                            modulePromises[moduleName] = deferred.promise;\n                            self._loadDependencies(moduleName, localParams).then(function success() {\n                                try {\n                                    justLoaded = [];\n                                    _register(providers, moduleCache, localParams);\n                                } catch (e) {\n                                    self._$log.error(e.message);\n                                    deferred.reject(e);\n                                    return;\n                                }\n\n                                if (modulesToLoad.length > 0) {\n                                    loadNext(modulesToLoad.shift()); // load the next in list\n                                } else {\n                                        deferred.resolve(res); // everything has been loaded, resolve\n                                    }\n                            }, function error(err) {\n                                deferred.reject(err);\n                            });\n                        };\n\n                        // load the first in list\n                        loadNext(modulesToLoad.shift());\n                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n                        return modulePromises[localParams.name];\n                    } else {\n                        deferred.resolve();\n                    }\n                    return deferred.promise;\n                },\n\n                /**\n                 * Get the list of required modules/services/... for this module\n                 * @param module\n                 * @returns {Array}\n                 */\n                getRequires: function getRequires(module) {\n                    var requires = [];\n                    angular.forEach(module.requires, function (requireModule) {\n                        if (regModules.indexOf(requireModule) === -1) {\n                            requires.push(requireModule);\n                        }\n                    });\n                    return requires;\n                },\n\n                /**\n                 * Invoke the new modules & component by their providers\n                 * @param providers\n                 * @param queue\n                 * @param moduleName\n                 * @param reconfig\n                 * @private\n                 */\n                _invokeQueue: _invokeQueue,\n\n                /**\n                 * Check if a module has been invoked and registers it if not\n                 * @param args\n                 * @param moduleName\n                 * @returns {boolean} is new\n                 */\n                _registerInvokeList: _registerInvokeList,\n\n                /**\n                 * Register a new module and loads it, executing the run/config blocks if needed\n                 * @param providers\n                 * @param registerModules\n                 * @param params\n                 * @private\n                 */\n                _register: _register,\n\n                /**\n                 * Add a module name to the list of modules that will be loaded in the next inject\n                 * @param name\n                 * @param force\n                 * @private\n                 */\n                _addToLoadList: _addToLoadList,\n\n                /**\n                 * Unregister modules (you shouldn't have to use this)\n                 * @param modules\n                 */\n                _unregister: function _unregister(modules) {\n                    if (angular.isDefined(modules)) {\n                        if (angular.isArray(modules)) {\n                            angular.forEach(modules, function (module) {\n                                regInvokes[module] = undefined;\n                            });\n                        }\n                    }\n                }\n            };\n        }];\n\n        // Let's get the list of loaded modules & components\n        this._init(angular.element(window.document));\n    }]);\n\n    var bootstrapFct = angular.bootstrap;\n    angular.bootstrap = function (element, modules, config) {\n        // we use slice to make a clean copy\n        angular.forEach(modules.slice(), function (module) {\n            _addToLoadList(module, true, true);\n        });\n        return bootstrapFct(element, modules, config);\n    };\n\n    var _addToLoadList = function _addToLoadList(name, force, real) {\n        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n            modulesToLoad.push(name);\n            if (real) {\n                realModules.push(name);\n            }\n        }\n    };\n\n    var ngModuleFct = angular.module;\n    angular.module = function (name, requires, configFn) {\n        _addToLoadList(name, false, true);\n        return ngModuleFct(name, requires, configFn);\n    };\n\n    // CommonJS package manager support:\n    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n        module.exports = 'oc.lazyLoad';\n    }\n})(angular, window);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\n        return {\n            restrict: 'A',\n            terminal: true,\n            priority: 1000,\n            compile: function compile(element, attrs) {\n                // we store the content and remove it before compilation\n                var content = element[0].innerHTML;\n                element.html('');\n\n                return function ($scope, $element, $attr) {\n                    var model = $parse($attr.ocLazyLoad);\n                    $scope.$watch(function () {\n                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n                    }, function (moduleName) {\n                        if (angular.isDefined(moduleName)) {\n                            $ocLazyLoad.load(moduleName).then(function () {\n                                // Attach element contents to DOM and then compile them.\n                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\n                                // of the compiled contents when attaching to the parent DOM.\n                                $animate.enter(content, $element);\n                                // get the new content & compile it\n                                $compile($element.contents())($scope);\n                            });\n                        }\n                    }, true);\n                };\n            }\n        };\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n            var uaCssChecked = false,\n                useCssLoadPatch = false,\n                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\n            /**\r\n             * Load a js/css file\r\n             * @param type\r\n             * @param path\r\n             * @param params\r\n             * @returns promise\r\n             */\n            $delegate.buildElement = function buildElement(type, path, params) {\n                var deferred = $q.defer(),\n                    el,\n                    loaded,\n                    filesCache = $delegate._getFilesCache(),\n                    cacheBuster = function cacheBuster(url) {\n                    var dc = new Date().getTime();\n                    if (url.indexOf('?') >= 0) {\n                        if (url.substring(0, url.length - 1) === '&') {\n                            return url + '_dc=' + dc;\n                        }\n                        return url + '&_dc=' + dc;\n                    } else {\n                        return url + '?_dc=' + dc;\n                    }\n                };\n\n                // Store the promise early so the file load can be detected by other parallel lazy loads\n                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n                // as it causes false positive load results.\n                if (angular.isUndefined(filesCache.get(path))) {\n                    filesCache.put(path, deferred.promise);\n                }\n\n                // Switch in case more content types are added later\n                switch (type) {\n                    case 'css':\n                        el = $window.document.createElement('link');\n                        el.type = 'text/css';\n                        el.rel = 'stylesheet';\n                        el.href = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    case 'js':\n                        el = $window.document.createElement('script');\n                        el.src = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    default:\n                        filesCache.remove(path);\n                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n                        break;\n                }\n                el.onload = el['onreadystatechange'] = function (e) {\n                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n                    el.onload = el['onreadystatechange'] = null;\n                    loaded = 1;\n                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n                    deferred.resolve();\n                };\n                el.onerror = function () {\n                    filesCache.remove(path);\n                    deferred.reject(new Error('Unable to load ' + path));\n                };\n                el.async = params.serie ? 0 : 1;\n\n                var insertBeforeElem = anchor.lastChild;\n                if (params.insertBefore) {\n                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n                    if (element && element.length > 0) {\n                        insertBeforeElem = element[0];\n                    }\n                }\n                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\n                /*\r\n                 The event load or readystatechange doesn't fire in:\r\n                 - iOS < 6       (default mobile browser)\r\n                 - Android < 4.4 (default mobile browser)\r\n                 - Safari < 6    (desktop browser)\r\n                 */\n                if (type == 'css') {\n                    if (!uaCssChecked) {\n                        var ua = $window.navigator.userAgent.toLowerCase();\n\n                        // iOS < 6\n                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n                            useCssLoadPatch = iOSVersion < 6;\n                        } else if (ua.indexOf(\"android\") > -1) {\n                            // Android < 4.4\n                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n                            useCssLoadPatch = androidVersion < 4.4;\n                        } else if (ua.indexOf('safari') > -1) {\n                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n                        }\n                    }\n\n                    if (useCssLoadPatch) {\n                        var tries = 1000; // * 20 = 20000 miliseconds\n                        var interval = $interval(function () {\n                            try {\n                                el.sheet.cssRules;\n                                $interval.cancel(interval);\n                                el.onload();\n                            } catch (e) {\n                                if (--tries <= 0) {\n                                    el.onerror();\n                                }\n                            }\n                        }, 20);\n                    }\n                }\n\n                return deferred.promise;\n            };\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\r\n             * The function that loads new files\r\n             * @param config\r\n             * @param params\r\n             * @returns {*}\r\n             */\n            $delegate.filesLoader = function filesLoader(config) {\n                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var cssFiles = [],\n                    templatesFiles = [],\n                    jsFiles = [],\n                    promises = [],\n                    cachePromise = null,\n                    filesCache = $delegate._getFilesCache();\n\n                $delegate.toggleWatch(true); // start watching angular.module calls\n\n                angular.extend(params, config);\n\n                var pushFile = function pushFile(path) {\n                    var file_type = null,\n                        m;\n                    if (angular.isObject(path)) {\n                        file_type = path.type;\n                        path = path.path;\n                    }\n                    cachePromise = filesCache.get(path);\n                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\n                        // always check for requirejs syntax just in case\n                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n                            // Detect file type using preceding type declaration (ala requireJS)\n                            file_type = m[1];\n                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n                        }\n\n                        if (!file_type) {\n                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n                                // Detect file type via file extension\n                                file_type = m[1];\n                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\n                                // requirejs\n                                file_type = 'js';\n                            } else {\n                                $delegate._$log.error('File type could not be determined. ' + path);\n                                return;\n                            }\n                        }\n\n                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n                            cssFiles.push(path);\n                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n                            templatesFiles.push(path);\n                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n                            jsFiles.push(path);\n                        } else {\n                            $delegate._$log.error('File type is not valid. ' + path);\n                        }\n                    } else if (cachePromise) {\n                        promises.push(cachePromise);\n                    }\n                };\n\n                if (params.serie) {\n                    pushFile(params.files.shift());\n                } else {\n                    angular.forEach(params.files, function (path) {\n                        pushFile(path);\n                    });\n                }\n\n                if (cssFiles.length > 0) {\n                    var cssDeferred = $q.defer();\n                    $delegate.cssLoader(cssFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            cssDeferred.reject(err);\n                        } else {\n                            cssDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(cssDeferred.promise);\n                }\n\n                if (templatesFiles.length > 0) {\n                    var templatesDeferred = $q.defer();\n                    $delegate.templatesLoader(templatesFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            templatesDeferred.reject(err);\n                        } else {\n                            templatesDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(templatesDeferred.promise);\n                }\n\n                if (jsFiles.length > 0) {\n                    var jsDeferred = $q.defer();\n                    $delegate.jsLoader(jsFiles, function (err) {\n                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\n                            $delegate._$log.error(err);\n                            jsDeferred.reject(err);\n                        } else {\n                            jsDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(jsDeferred.promise);\n                }\n\n                if (promises.length === 0) {\n                    var deferred = $q.defer(),\n                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n                    $delegate._$log.error(err);\n                    deferred.reject(err);\n                    return deferred.promise;\n                } else if (params.serie && params.files.length > 0) {\n                    return $q.all(promises).then(function () {\n                        return $delegate.filesLoader(config, params);\n                    });\n                } else {\n                    return $q.all(promises)['finally'](function (res) {\n                        $delegate.toggleWatch(false); // stop watching angular.module calls\n                        return res;\n                    });\n                }\n            };\n\n            /**\r\n             * Load a module or a list of modules into Angular\r\n             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n             * @param params Object optional parameters\r\n             * @returns promise\r\n             */\n            $delegate.load = function (originalModule) {\n                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var self = this,\n                    config = null,\n                    deferredList = [],\n                    deferred = $q.defer(),\n                    errText;\n\n                // clean copy\n                var module = angular.copy(originalModule);\n                var params = angular.copy(originalParams);\n\n                // If module is an array, break it down\n                if (angular.isArray(module)) {\n                    // Resubmit each entry as a single module\n                    angular.forEach(module, function (m) {\n                        deferredList.push(self.load(m, params));\n                    });\n\n                    // Resolve the promise once everything has loaded\n                    $q.all(deferredList).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n\n                    return deferred.promise;\n                }\n\n                // Get or Set a configuration depending on what was passed in\n                if (angular.isString(module)) {\n                    config = self.getModuleConfig(module);\n                    if (!config) {\n                        config = {\n                            files: [module]\n                        };\n                    }\n                } else if (angular.isObject(module)) {\n                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n                        config = {\n                            files: [module]\n                        };\n                    } else {\n                        config = self.setModuleConfig(module);\n                    }\n                }\n\n                if (config === null) {\n                    var moduleName = self._getModuleName(module);\n                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n                    $delegate._$log.error(errText);\n                    deferred.reject(new Error(errText));\n                    return deferred.promise;\n                } else {\n                    // deprecated\n                    if (angular.isDefined(config.template)) {\n                        if (angular.isUndefined(config.files)) {\n                            config.files = [];\n                        }\n                        if (angular.isString(config.template)) {\n                            config.files.push(config.template);\n                        } else if (angular.isArray(config.template)) {\n                            config.files.concat(config.template);\n                        }\n                    }\n                }\n\n                var localParams = angular.extend({}, params, config);\n\n                // if someone used an external loader and called the load function with just the module name\n                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n                    return $delegate.inject(config.name, localParams, true);\n                }\n\n                $delegate.filesLoader(config, localParams).then(function () {\n                    $delegate.inject(null, localParams).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n                }, function (err) {\n                    deferred.reject(err);\n                });\n\n                return deferred.promise;\n            };\n\n            // return the patched service\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * cssLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite cssLoader and it will probably not use promises :(\n             */\n            $delegate.cssLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('css', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.cssLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * jsLoader function\n             * @type Function\n             * @param paths array list of js files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite jsLoader and it will probably not use promises :(\n             */\n            $delegate.jsLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('js', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.jsLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n            /**\n             * templatesLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters for $http\n             * because the user can overwrite templatesLoader and it will probably not use promises :(\n             */\n            $delegate.templatesLoader = function (paths, callback, params) {\n                var promises = [],\n                    filesCache = $delegate._getFilesCache();\n\n                angular.forEach(paths, function (url) {\n                    var deferred = $q.defer();\n                    promises.push(deferred.promise);\n                    $http.get(url, params).success(function (data) {\n                        if (angular.isString(data) && data.length > 0) {\n                            angular.forEach(angular.element(data), function (node) {\n                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n                                    $templateCache.put(node.id, node.innerHTML);\n                                }\n                            });\n                        }\n                        if (angular.isUndefined(filesCache.get(url))) {\n                            filesCache.put(url, true);\n                        }\n                        deferred.resolve();\n                    }).error(function (err) {\n                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n                    });\n                });\n                return $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n// Array.indexOf polyfill for IE8\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement, fromIndex) {\n        var k;\n\n        // 1. Let O be the result of calling ToObject passing\n        //    the this value as the argument.\n        if (this == null) {\n            throw new TypeError('\"this\" is null or not defined');\n        }\n\n        var O = Object(this);\n\n        // 2. Let lenValue be the result of calling the Get\n        //    internal method of O with the argument \"length\".\n        // 3. Let len be ToUint32(lenValue).\n        var len = O.length >>> 0;\n\n        // 4. If len is 0, return -1.\n        if (len === 0) {\n            return -1;\n        }\n\n        // 5. If argument fromIndex was passed let n be\n        //    ToInteger(fromIndex); else let n be 0.\n        var n = +fromIndex || 0;\n\n        if (Math.abs(n) === Infinity) {\n            n = 0;\n        }\n\n        // 6. If n >= len, return -1.\n        if (n >= len) {\n            return -1;\n        }\n\n        // 7. If n >= 0, then Let k be n.\n        // 8. Else, n<0, Let k be len - abs(n).\n        //    If k is less than 0, then let k be 0.\n        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n        // 9. Repeat, while k < len\n        while (k < len) {\n            // a. Let Pk be ToString(k).\n            //   This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the\n            //    HasProperty internal method of O with argument Pk.\n            //   This step can be combined with c\n            // c. If kPresent is true, then\n            //    i.  Let elementK be the result of calling the Get\n            //        internal method of O with the argument ToString(k).\n            //   ii.  Let same be the result of applying the\n            //        Strict Equality Comparison Algorithm to\n            //        searchElement and elementK.\n            //  iii.  If same is true, return k.\n            if (k in O && O[k] === searchElement) {\n                return k;\n            }\n            k++;\n        }\n        return -1;\n    };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/oclazyload/dist/ocLazyLoad.js\n ** module id = 13\n ** module chunks = 1\n **/","/*! https://mths.be/utf8js v2.0.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tcheckScalarValue(codePoint);\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, its not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tvar byte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar utf8 = {\n\t\t'version': '2.0.0',\n\t\t'encode': utf8encode,\n\t\t'decode': utf8decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn utf8;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = utf8;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tvar object = {};\n\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\tfor (var key in utf8) {\n\t\t\t\thasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.utf8 = utf8;\n\t}\n\n}(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/utf8/utf8.js\n ** module id = 14\n ** module chunks = 1\n **/","'use strict';\nangular.module(\"ngLocale\", [], [\"$provide\", function($provide) {\nvar PLURAL_CATEGORY = {ZERO: \"zero\", ONE: \"one\", TWO: \"two\", FEW: \"few\", MANY: \"many\", OTHER: \"other\"};\nfunction getDecimals(n) {\n  n = n + '';\n  var i = n.indexOf('.');\n  return (i == -1) ? 0 : n.length - i - 1;\n}\n\nfunction getVF(n, opt_precision) {\n  var v = opt_precision;\n\n  if (undefined === v) {\n    v = Math.min(getDecimals(n), 3);\n  }\n\n  var base = Math.pow(10, v);\n  var f = ((n * base) | 0) % base;\n  return {v: v, f: f};\n}\n\n$provide.value(\"$locale\", {\n  \"DATETIME_FORMATS\": {\n    \"AMPMS\": [\n      \"vorm.\",\n      \"nachm.\"\n    ],\n    \"DAY\": [\n      \"Sonntag\",\n      \"Montag\",\n      \"Dienstag\",\n      \"Mittwoch\",\n      \"Donnerstag\",\n      \"Freitag\",\n      \"Samstag\"\n    ],\n    \"ERANAMES\": [\n      \"v. Chr.\",\n      \"n. Chr.\"\n    ],\n    \"ERAS\": [\n      \"v. Chr.\",\n      \"n. Chr.\"\n    ],\n    \"FIRSTDAYOFWEEK\": 0,\n    \"MONTH\": [\n      \"Januar\",\n      \"Februar\",\n      \"M\\u00e4rz\",\n      \"April\",\n      \"Mai\",\n      \"Juni\",\n      \"Juli\",\n      \"August\",\n      \"September\",\n      \"Oktober\",\n      \"November\",\n      \"Dezember\"\n    ],\n    \"SHORTDAY\": [\n      \"So.\",\n      \"Mo.\",\n      \"Di.\",\n      \"Mi.\",\n      \"Do.\",\n      \"Fr.\",\n      \"Sa.\"\n    ],\n    \"SHORTMONTH\": [\n      \"Jan.\",\n      \"Feb.\",\n      \"M\\u00e4rz\",\n      \"Apr.\",\n      \"Mai\",\n      \"Juni\",\n      \"Juli\",\n      \"Aug.\",\n      \"Sep.\",\n      \"Okt.\",\n      \"Nov.\",\n      \"Dez.\"\n    ],\n    \"STANDALONEMONTH\": [\n      \"Januar\",\n      \"Februar\",\n      \"M\\u00e4rz\",\n      \"April\",\n      \"Mai\",\n      \"Juni\",\n      \"Juli\",\n      \"August\",\n      \"September\",\n      \"Oktober\",\n      \"November\",\n      \"Dezember\"\n    ],\n    \"WEEKENDRANGE\": [\n      5,\n      6\n    ],\n    \"fullDate\": \"EEEE, d. MMMM y\",\n    \"longDate\": \"d. MMMM y\",\n    \"medium\": \"dd.MM.y HH:mm:ss\",\n    \"mediumDate\": \"dd.MM.y\",\n    \"mediumTime\": \"HH:mm:ss\",\n    \"short\": \"dd.MM.yy HH:mm\",\n    \"shortDate\": \"dd.MM.yy\",\n    \"shortTime\": \"HH:mm\"\n  },\n  \"NUMBER_FORMATS\": {\n    \"CURRENCY_SYM\": \"\\u20ac\",\n    \"DECIMAL_SEP\": \",\",\n    \"GROUP_SEP\": \".\",\n    \"PATTERNS\": [\n      {\n        \"gSize\": 3,\n        \"lgSize\": 3,\n        \"maxFrac\": 3,\n        \"minFrac\": 0,\n        \"minInt\": 1,\n        \"negPre\": \"-\",\n        \"negSuf\": \"\",\n        \"posPre\": \"\",\n        \"posSuf\": \"\"\n      },\n      {\n        \"gSize\": 3,\n        \"lgSize\": 3,\n        \"maxFrac\": 2,\n        \"minFrac\": 2,\n        \"minInt\": 1,\n        \"negPre\": \"-\",\n        \"negSuf\": \"\\u00a0\\u00a4\",\n        \"posPre\": \"\",\n        \"posSuf\": \"\\u00a0\\u00a4\"\n      }\n    ]\n  },\n  \"id\": \"de-de\",\n  \"pluralCat\": function(n, opt_precision) {  var i = n | 0;  var vf = getVF(n, opt_precision);  if (i == 1 && vf.v == 0) {    return PLURAL_CATEGORY.ONE;  }  return PLURAL_CATEGORY.OTHER;}\n});\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/angular-locale_de-de.js\n ** module id = 15\n ** module chunks = 1\n **/","/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 1.1.2 - 2016-02-01\n * License: MIT\n */angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.debounce\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module(\"ui.bootstrap.tpls\", [\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/popup.html\",\"uib/template/datepicker/year.html\",\"uib/template/modal/backdrop.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]);\nangular.module('ui.bootstrap.collapse', [])\n\n  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        var expandingExpr = $parse(attrs.expanding),\n            expandedExpr = $parse(attrs.expanded),\n            collapsingExpr = $parse(attrs.collapsing),\n            collapsedExpr = $parse(attrs.collapsed);\n\n        if (!scope.$eval(attrs.uibCollapse)) {\n          element.addClass('in')\n            .addClass('collapse')\n            .attr('aria-expanded', true)\n            .attr('aria-hidden', false)\n            .css({height: 'auto'});\n        }\n\n        function expand() {\n          if (element.hasClass('collapse') && element.hasClass('in')) {\n            return;\n          }\n\n          $q.resolve(expandingExpr(scope))\n            .then(function() {\n              element.removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', true)\n                .attr('aria-hidden', false);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  addClass: 'in',\n                  easing: 'ease',\n                  to: { height: element[0].scrollHeight + 'px' }\n                }).start()['finally'](expandDone);\n              } else {\n                $animate.addClass(element, 'in', {\n                  to: { height: element[0].scrollHeight + 'px' }\n                }).then(expandDone);\n              }\n            });\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse')\n            .css({height: 'auto'});\n          expandedExpr(scope);\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          $q.resolve(collapsingExpr(scope))\n            .then(function() {\n              element\n                // IMPORTANT: The height must be set before adding \"collapsing\" class.\n                // Otherwise, the browser attempts to animate from height 0 (in\n                // collapsing class) to the given height here.\n                .css({height: element[0].scrollHeight + 'px'})\n                // initially all panel collapse have the collapse class, this removal\n                // prevents the animation from jumping to collapsed state\n                .removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', false)\n                .attr('aria-hidden', true);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: 'in',\n                  to: {height: '0'}\n                }).start()['finally'](collapseDone);\n              } else {\n                $animate.removeClass(element, 'in', {\n                  to: {height: '0'}\n                }).then(collapseDone);\n              }\n            });\n        }\n\n        function collapseDone() {\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n          collapsedExpr(scope);\n        }\n\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\n.constant('uibAccordionConfig', {\n  closeOthers: true\n})\n\n.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if (closeOthers) {\n      angular.forEach(this.groups, function(group) {\n        if (group !== openGroup) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function(event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if (index !== -1) {\n      this.groups.splice(index, 1);\n    }\n  };\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('uibAccordion', function() {\n  return {\n    controller: 'UibAccordionController',\n    controllerAs: 'accordion',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion.html';\n    }\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('uibAccordionGroup', function() {\n  return {\n    require: '^uibAccordion',         // We need this directive to be inside an accordion\n    transclude: true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';\n    },\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      accordionCtrl.addGroup(scope);\n\n      scope.openClass = attrs.openClass || 'panel-open';\n      scope.panelClass = attrs.panelClass || 'panel-default';\n      scope.$watch('isOpen', function(value) {\n        element.toggleClass(scope.openClass, !!value);\n        if (value) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function($event) {\n        if (!scope.isDisabled) {\n          if (!$event || $event.which === 32) {\n            scope.isOpen = !scope.isOpen;\n          }\n        }\n      };\n\n      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n      scope.headingId = id + '-tab';\n      scope.panelId = id + '-panel';\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n.directive('uibAccordionHeading', function() {\n  return {\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n.directive('uibAccordionTransclude', function() {\n  return {\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, controller) {\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n        if (heading) {\n          element.find('span').html('');\n          element.find('span').append(heading);\n        }\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n  $scope.closeable = !!$attrs.close;\n\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\n  if (dismissOnTimeout) {\n    $timeout(function() {\n      $scope.close();\n    }, parseInt(dismissOnTimeout, 10));\n  }\n}])\n\n.directive('uibAlert', function() {\n  return {\n    controller: 'UibAlertController',\n    controllerAs: 'alert',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/alert/alert.html';\n    },\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@',\n      close: '&'\n    }\n  };\n});\n\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('uibButtonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('uibBtnRadio', ['$parse', function($parse) {\n  return {\n    require: ['uibBtnRadio', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'buttons',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      var uncheckableExpr = $parse(attrs.uibUncheckable);\n\n      element.find('input').css({display: 'none'});\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n\n      if (attrs.uibUncheckable) {\n        scope.$watch(uncheckableExpr, function(uncheckable) {\n          attrs.$set('uncheckable', uncheckable ? '' : null);\n        });\n      }\n    }\n  };\n}])\n\n.directive('uibBtnCheckbox', function() {\n  return {\n    require: ['uibBtnCheckbox', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'button',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attribute, defaultValue) {\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        scope.$apply(function() {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.carousel', [])\n\n.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    currentIndex = -1,\n    currentInterval, isPlaying, bufferedTransitions = [];\n  self.currentSlide = null;\n\n  var destroyed = false;\n\n  self.addSlide = function(slide, element) {\n    slide.$element = element;\n    slides.push(slide);\n    //if this is the first slide or the slide is set to active, select it\n    if (slides.length === 1 || slide.active) {\n      if ($scope.$currentTransition) {\n        $scope.$currentTransition = null;\n      }\n\n      self.select(slides[slides.length - 1]);\n      if (slides.length === 1) {\n        $scope.play();\n      }\n    } else {\n      slide.active = false;\n    }\n  };\n\n  self.getCurrentIndex = function() {\n    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {\n      return +self.currentSlide.index;\n    }\n    return currentIndex;\n  };\n\n  self.next = $scope.next = function() {\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\n    if (newIndex === 0 && $scope.noWrap()) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), 'next');\n  };\n\n  self.prev = $scope.prev = function() {\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), 'prev');\n  };\n\n  self.removeSlide = function(slide) {\n    if (angular.isDefined(slide.index)) {\n      slides.sort(function(a, b) {\n        return +a.index > +b.index;\n      });\n    }\n\n    var bufferedIndex = bufferedTransitions.indexOf(slide);\n    if (bufferedIndex !== -1) {\n      bufferedTransitions.splice(bufferedIndex, 1);\n    }\n    //get the index of the slide inside the carousel\n    var index = slides.indexOf(slide);\n    slides.splice(index, 1);\n    $timeout(function() {\n      if (slides.length > 0 && slide.active) {\n        if (index >= slides.length) {\n          self.select(slides[index - 1]);\n        } else {\n          self.select(slides[index]);\n        }\n      } else if (currentIndex > index) {\n        currentIndex--;\n      }\n    });\n\n    //clean the currentSlide when no more slide\n    if (slides.length === 0) {\n      self.currentSlide = null;\n      clearBufferedTransitions();\n    }\n  };\n\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = $scope.indexOfSlide(nextSlide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n    }\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {\n      goNext(nextSlide, nextIndex, direction);\n    } else if (nextSlide && nextSlide !== self.currentSlide && $scope.$currentTransition) {\n      bufferedTransitions.push(nextSlide);\n      nextSlide.active = false;\n    }\n  };\n\n  /* Allow outside people to call indexOf on slides array */\n  $scope.indexOfSlide = function(slide) {\n    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);\n  };\n\n  $scope.isActive = function(slide) {\n    return self.currentSlide === slide;\n  };\n\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n    resetTimer();\n  });\n\n  $scope.$watch('noTransition', function(noTransition) {\n    $animate.enabled($element, !noTransition);\n  });\n\n  $scope.$watch('interval', restartTimer);\n\n  $scope.$watchCollection('slides', resetTransition);\n\n  function clearBufferedTransitions() {\n    while (bufferedTransitions.length) {\n      bufferedTransitions.shift();\n    }\n  }\n\n  function getSlideByIndex(index) {\n    if (angular.isUndefined(slides[index].index)) {\n      return slides[index];\n    }\n    for (var i = 0, l = slides.length; i < l; ++i) {\n      if (slides[i].index === index) {\n        return slides[i];\n      }\n    }\n  }\n\n  function goNext(slide, index, direction) {\n    if (destroyed) { return; }\n\n    angular.extend(slide, {direction: direction, active: true});\n    angular.extend(self.currentSlide || {}, {direction: direction, active: false});\n    if ($animate.enabled($element) && !$scope.$currentTransition &&\n      slide.$element && self.slides.length > 1) {\n      slide.$element.data(SLIDE_DIRECTION, slide.direction);\n      if (self.currentSlide && self.currentSlide.$element) {\n        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);\n      }\n\n      $scope.$currentTransition = true;\n      $animate.on('addClass', slide.$element, function(element, phase) {\n        if (phase === 'close') {\n          $scope.$currentTransition = null;\n          $animate.off('addClass', element);\n          if (bufferedTransitions.length) {\n            var nextSlide = bufferedTransitions.pop();\n            var nextIndex = $scope.indexOfSlide(nextSlide);\n            var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n            clearBufferedTransitions();\n\n            goNext(nextSlide, nextIndex, nextDirection);\n          }\n        }\n      });\n    }\n\n    self.currentSlide = slide;\n    currentIndex = index;\n\n    //every time you change slides, reset the timer\n    restartTimer();\n  }\n\n  function resetTimer() {\n    if (currentInterval) {\n      $interval.cancel(currentInterval);\n      currentInterval = null;\n    }\n  }\n\n  function resetTransition(slides) {\n    if (!slides.length) {\n      $scope.$currentTransition = null;\n      clearBufferedTransitions();\n    }\n  }\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval > 0) {\n      currentInterval = $interval(timerFn, interval);\n    }\n  }\n\n  function timerFn() {\n    var interval = +$scope.interval;\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n      $scope.next();\n    } else {\n      $scope.pause();\n    }\n  }\n}])\n\n.directive('uibCarousel', function() {\n  return {\n    transclude: true,\n    replace: true,\n    controller: 'UibCarouselController',\n    controllerAs: 'carousel',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/carousel.html';\n    },\n    scope: {\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    }\n  };\n})\n\n.directive('uibSlide', function() {\n  return {\n    require: '^uibCarousel',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/slide.html';\n    },\n    scope: {\n      active: '=?',\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n})\n\n.animation('.item', ['$animateCss',\nfunction($animateCss) {\n  var SLIDE_DIRECTION = 'uib-slideDirection';\n\n  function removeClass(element, className, callback) {\n    element.removeClass(className);\n    if (callback) {\n      callback();\n    }\n  }\n\n  return {\n    beforeAddClass: function(element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element,\n          directionClass + ' ' + direction, done);\n        element.addClass(direction);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    },\n    beforeRemoveClass: function (element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  var localeId;\n  var formatCodeToRegex;\n\n  this.init = function() {\n    localeId = $locale.id;\n\n    this.parsers = {};\n    this.formatters = {};\n\n    formatCodeToRegex = [\n      {\n        key: 'yyyy',\n        regex: '\\\\d{4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yyyy');\n        }\n      },\n      {\n        key: 'yy',\n        regex: '\\\\d{2}',\n        apply: function(value) { this.year = +value + 2000; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yy');\n        }\n      },\n      {\n        key: 'y',\n        regex: '\\\\d{1,4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'y');\n        }\n      },\n      {\n        key: 'M!',\n        regex: '0?[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) {\n          var value = date.getMonth();\n          if (/^[0-9]$/.test(value)) {\n            return dateFilter(date, 'MM');\n          }\n\n          return dateFilter(date, 'M');\n        }\n      },\n      {\n        key: 'MMMM',\n        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMMM'); }\n      },\n      {\n        key: 'MMM',\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMM'); }\n      },\n      {\n        key: 'MM',\n        regex: '0[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'MM'); }\n      },\n      {\n        key: 'M',\n        regex: '[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'M'); }\n      },\n      {\n        key: 'd!',\n        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) {\n          var value = date.getDate();\n          if (/^[1-9]$/.test(value)) {\n            return dateFilter(date, 'dd');\n          }\n\n          return dateFilter(date, 'd');\n        }\n      },\n      {\n        key: 'dd',\n        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'dd'); }\n      },\n      {\n        key: 'd',\n        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'd'); }\n      },\n      {\n        key: 'EEEE',\n        regex: $locale.DATETIME_FORMATS.DAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEEE'); }\n      },\n      {\n        key: 'EEE',\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEE'); }\n      },\n      {\n        key: 'HH',\n        regex: '(?:0|1)[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'HH'); }\n      },\n      {\n        key: 'hh',\n        regex: '0[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'hh'); }\n      },\n      {\n        key: 'H',\n        regex: '1?[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'H'); }\n      },\n      {\n        key: 'h',\n        regex: '[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'h'); }\n      },\n      {\n        key: 'mm',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'mm'); }\n      },\n      {\n        key: 'm',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'm'); }\n      },\n      {\n        key: 'sss',\n        regex: '[0-9][0-9][0-9]',\n        apply: function(value) { this.milliseconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'sss'); }\n      },\n      {\n        key: 'ss',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'ss'); }\n      },\n      {\n        key: 's',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 's'); }\n      },\n      {\n        key: 'a',\n        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n        apply: function(value) {\n          if (this.hours === 12) {\n            this.hours = 0;\n          }\n\n          if (value === 'PM') {\n            this.hours += 12;\n          }\n        },\n        formatter: function(date) { return dateFilter(date, 'a'); }\n      },\n      {\n        key: 'Z',\n        regex: '[+-]\\\\d{4}',\n        apply: function(value) {\n          var matches = value.match(/([+-])(\\d{2})(\\d{2})/),\n            sign = matches[1],\n            hours = matches[2],\n            minutes = matches[3];\n          this.hours += toInt(sign + hours);\n          this.minutes += toInt(sign + minutes);\n        },\n        formatter: function(date) {\n          return dateFilter(date, 'Z');\n        }\n      },\n      {\n        key: 'ww',\n        regex: '[0-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'ww'); }\n      },\n      {\n        key: 'w',\n        regex: '[0-9]|[1-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'w'); }\n      },\n      {\n        key: 'GGGG',\n        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\\s/g, '\\\\s'),\n        formatter: function(date) { return dateFilter(date, 'GGGG'); }\n      },\n      {\n        key: 'GGG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GGG'); }\n      },\n      {\n        key: 'GG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GG'); }\n      },\n      {\n        key: 'G',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'G'); }\n      }\n    ];\n  };\n\n  this.init();\n\n  function createParser(format, func) {\n    var map = [], regex = format.split('');\n\n    // check for literal values\n    var quoteIndex = format.indexOf('\\'');\n    if (quoteIndex > -1) {\n      var inLiteral = false;\n      format = format.split('');\n      for (var i = quoteIndex; i < format.length; i++) {\n        if (inLiteral) {\n          if (format[i] === '\\'') {\n            if (i + 1 < format.length && format[i+1] === '\\'') { // escaped single quote\n              format[i+1] = '$';\n              regex[i+1] = '';\n            } else { // end of literal\n              regex[i] = '';\n              inLiteral = false;\n            }\n          }\n          format[i] = '$';\n        } else {\n          if (format[i] === '\\'') { // start of literal\n            format[i] = '$';\n            regex[i] = '';\n            inLiteral = true;\n          }\n        }\n      }\n\n      format = format.join('');\n    }\n\n    angular.forEach(formatCodeToRegex, function(data) {\n      var index = format.indexOf(data.key);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + data.key.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({\n          index: index,\n          key: data.key,\n          apply: data[func],\n          matcher: data.regex\n        });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  this.filter = function(date, format) {\n    if (!angular.isDate(date) || isNaN(date) || !format) {\n      return '';\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.formatters[format]) {\n      this.formatters[format] = createParser(format, 'formatter');\n    }\n\n    var parser = this.formatters[format],\n      map = parser.map;\n\n    var _format = format;\n\n    return map.reduce(function(str, mapper, i) {\n      var match = _format.match(new RegExp('(.*)' + mapper.key));\n      if (match && angular.isString(match[1])) {\n        str += match[1];\n        _format = _format.replace(match[1] + mapper.key, '');\n      }\n\n      if (mapper.apply) {\n        return str + mapper.apply.call(null, date);\n      }\n\n      return str;\n    }, '');\n  };\n\n  this.parse = function(input, format, baseDate) {\n    if (!angular.isString(input) || !format) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.parsers[format]) {\n      this.parsers[format] = createParser(format, 'apply');\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex),\n        tzOffset = false;\n    if (results && results.length) {\n      var fields, dt;\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n        fields = {\n          year: baseDate.getFullYear(),\n          month: baseDate.getMonth(),\n          date: baseDate.getDate(),\n          hours: baseDate.getHours(),\n          minutes: baseDate.getMinutes(),\n          seconds: baseDate.getSeconds(),\n          milliseconds: baseDate.getMilliseconds()\n        };\n      } else {\n        if (baseDate) {\n          $log.warn('dateparser:', 'baseDate is not a valid date');\n        }\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n      }\n\n      for (var i = 1, n = results.length; i < n; i++) {\n        var mapper = map[i - 1];\n        if (mapper.matcher === 'Z') {\n          tzOffset = true;\n        }\n\n        if (mapper.apply) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :\n        Date.prototype.setFullYear;\n      var timesetter = tzOffset ? Date.prototype.setUTCHours :\n        Date.prototype.setHours;\n\n      if (isValid(fields.year, fields.month, fields.date)) {\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {\n          dt = new Date(baseDate);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours, fields.minutes,\n            fields.seconds, fields.milliseconds);\n        } else {\n          dt = new Date(0);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,\n            fields.seconds || 0, fields.milliseconds || 0);\n        }\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if (date < 1) {\n      return false;\n    }\n\n    if (month === 1 && date > 28) {\n      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);\n    }\n\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\n      return date < 31;\n    }\n\n    return true;\n  }\n\n  function toInt(str) {\n    return parseInt(str, 10);\n  }\n\n  this.toTimezone = toTimezone;\n  this.fromTimezone = fromTimezone;\n  this.timezoneToOffset = timezoneToOffset;\n  this.addDateMinutes = addDateMinutes;\n  this.convertTimezoneToLocal = convertTimezoneToLocal;\n\n  function toTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;\n  }\n\n  function fromTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;\n  }\n\n  //https://github.com/angular/angular.js/blob/4daafd3dbe6a80d578f5a31df1bb99c77559543e/src/Angular.js#L1207\n  function timezoneToOffset(timezone, fallback) {\n    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\n    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n  }\n\n  function addDateMinutes(date, minutes) {\n    date = new Date(date.getTime());\n    date.setMinutes(date.getMinutes() + minutes);\n    return date;\n  }\n\n  function convertTimezoneToLocal(date, timezone, reverse) {\n    reverse = reverse ? -1 : 1;\n    var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());\n    return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));\n  }\n}]);\n\n// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to\n// at most one element.\nangular.module('ui.bootstrap.isClass', [])\n.directive('uibIsClass', [\n         '$animate',\nfunction ($animate) {\n  //                    11111111          22222222\n  var ON_REGEXP = /^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/;\n  //                    11111111           22222222\n  var IS_REGEXP = /^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;\n\n  var dataPerTracked = {};\n\n  return {\n    restrict: 'A',\n    compile: function (tElement, tAttrs) {\n      var linkedScopes = [];\n      var instances = [];\n      var expToData = {};\n      var lastActivated = null;\n      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);\n      var onExp = onExpMatches[2];\n      var expsStr = onExpMatches[1];\n      var exps = expsStr.split(',');\n\n      return linkFn;\n\n      function linkFn(scope, element, attrs) {\n        linkedScopes.push(scope);\n        instances.push({\n          scope: scope,\n          element: element\n        });\n\n        exps.forEach(function (exp, k) {\n          addForExp(exp, scope);\n        });\n\n        scope.$on('$destroy', removeScope);\n      }\n\n      function addForExp(exp, scope) {\n        var matches = exp.match(IS_REGEXP);\n        var clazz = scope.$eval(matches[1]);\n        var compareWithExp = matches[2];\n        var data = expToData[exp];\n        if (!data) {\n          var watchFn = function (compareWithVal) {\n            var newActivated = null;\n            instances.some(function (instance) {\n              var thisVal = instance.scope.$eval(onExp);\n              if (thisVal === compareWithVal) {\n                newActivated = instance;\n                return true;\n              }\n            });\n            if (data.lastActivated !== newActivated) {\n              if (data.lastActivated) {\n                $animate.removeClass(data.lastActivated.element, clazz);\n              }\n              if (newActivated) {\n                $animate.addClass(newActivated.element, clazz);\n              }\n              data.lastActivated = newActivated;\n            }\n          };\n          expToData[exp] = data = {\n            lastActivated: null,\n            scope: scope,\n            watchFn: watchFn,\n            compareWithExp: compareWithExp,\n            watcher: scope.$watch(compareWithExp, watchFn)\n          };\n        }\n        data.watchFn(scope.$eval(compareWithExp));\n      }\n\n      function removeScope(e) {\n        var removedScope = e.targetScope;\n        var index = linkedScopes.indexOf(removedScope);\n        linkedScopes.splice(index, 1);\n        instances.splice(index, 1);\n        if (linkedScopes.length) {\n          var newWatchScope = linkedScopes[0];\n          angular.forEach(expToData, function (data) {\n            if (data.scope === removedScope) {\n              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);\n              data.scope = newWatchScope;\n            }\n          });\n        }\n        else {\n          expToData = {};\n        }\n      }\n    }\n  };\n}]);\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods for working with the DOM.\n * It is meant to be used where we need to absolute-position elements in\n * relation to another element (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n    /**\n     * Used by scrollbarWidth() function to cache scrollbar's width.\n     * Do not access this variable directly, use scrollbarWidth() instead.\n     */\n    var SCROLLBAR_WIDTH;\n    var OVERFLOW_REGEX = {\n      normal: /(auto|scroll)/,\n      hidden: /(auto|scroll|hidden)/\n    };\n    var PLACEMENT_REGEX = {\n      auto: /\\s?auto?\\s?/i,\n      primary: /^(top|bottom|left|right)$/,\n      secondary: /^(top|bottom|left|right|center)$/,\n      vertical: /^(top|bottom)$/\n    };\n\n    return {\n\n      /**\n       * Provides a raw DOM element from a jQuery/jQLite element.\n       *\n       * @param {element} elem - The element to convert.\n       *\n       * @returns {element} A HTML element.\n       */\n      getRawNode: function(elem) {\n        return elem[0] || elem;\n      },\n\n      /**\n       * Provides a parsed number for a style property.  Strips\n       * units and casts invalid numbers to 0.\n       *\n       * @param {string} value - The style value to parse.\n       *\n       * @returns {number} A valid number.\n       */\n      parseStyle: function(value) {\n        value = parseFloat(value);\n        return isFinite(value) ? value : 0;\n      },\n\n      /**\n       * Provides the closest positioned ancestor.\n       *\n       * @param {element} element - The element to get the offest parent for.\n       *\n       * @returns {element} The closest positioned ancestor.\n       */\n      offsetParent: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var offsetParent = elem.offsetParent || $document[0].documentElement;\n\n        function isStaticPositioned(el) {\n          return ($window.getComputedStyle(el).position || 'static') === 'static';\n        }\n\n        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || $document[0].documentElement;\n      },\n\n      /**\n       * Provides the scrollbar width, concept from TWBS measureScrollbar()\n       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js\n       *\n       * @returns {number} The width of the browser scollbar.\n       */\n      scrollbarWidth: function() {\n        if (angular.isUndefined(SCROLLBAR_WIDTH)) {\n          var scrollElem = angular.element('<div style=\"position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;\"></div>');\n          $document.find('body').append(scrollElem);\n          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;\n          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;\n          scrollElem.remove();\n        }\n\n        return SCROLLBAR_WIDTH;\n      },\n\n      /**\n       * Provides the closest scrollable ancestor.\n       * A port of the jQuery UI scrollParent method:\n       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js\n       *\n       * @param {element} elem - The element to find the scroll parent of.\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n       *   default is false.\n       *\n       * @returns {element} A HTML element.\n       */\n      scrollParent: function(elem, includeHidden) {\n        elem = this.getRawNode(elem);\n\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n        var documentEl = $document[0].documentElement;\n        var elemStyle = $window.getComputedStyle(elem);\n        var excludeStatic = elemStyle.position === 'absolute';\n        var scrollParent = elem.parentElement || documentEl;\n\n        if (scrollParent === documentEl || elemStyle.position === 'fixed') {\n          return documentEl;\n        }\n\n        while (scrollParent.parentElement && scrollParent !== documentEl) {\n          var spStyle = $window.getComputedStyle(scrollParent);\n          if (excludeStatic && spStyle.position !== 'static') {\n            excludeStatic = false;\n          }\n\n          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {\n            break;\n          }\n          scrollParent = scrollParent.parentElement;\n        }\n\n        return scrollParent;\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/ - distance to closest positioned\n       * ancestor.  Does not account for margins by default like jQuery position.\n       *\n       * @param {element} elem - The element to caclulate the position on.\n       * @param {boolean=} [includeMargins=false] - Should margins be accounted\n       * for, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of offset parent</li>\n       *     <li>**left**: distance to left edge of offset parent</li>\n       *   </ul>\n       */\n      position: function(elem, includeMagins) {\n        elem = this.getRawNode(elem);\n\n        var elemOffset = this.offset(elem);\n        if (includeMagins) {\n          var elemStyle = $window.getComputedStyle(elem);\n          elemOffset.top -= this.parseStyle(elemStyle.marginTop);\n          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);\n        }\n        var parent = this.offsetParent(elem);\n        var parentOffset = {top: 0, left: 0};\n\n        if (parent !== $document[0].documentElement) {\n          parentOffset = this.offset(parent);\n          parentOffset.top += parent.clientTop - parent.scrollTop;\n          parentOffset.left += parent.clientLeft - parent.scrollLeft;\n        }\n\n        return {\n          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),\n          top: Math.round(elemOffset.top - parentOffset.top),\n          left: Math.round(elemOffset.left - parentOffset.left)\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/ - distance to viewport.  Does\n       * not account for borders, margins, or padding on the body\n       * element.\n       *\n       * @param {element} elem - The element to calculate the offset on.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of viewport</li>\n       *     <li>**right**: distance to bottom edge of viewport</li>\n       *   </ul>\n       */\n      offset: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var elemBCR = elem.getBoundingClientRect();\n        return {\n          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),\n          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),\n          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))\n        };\n      },\n\n      /**\n       * Provides offset distance to the closest scrollable ancestor\n       * or viewport.  Accounts for border and scrollbar width.\n       *\n       * Right and bottom dimensions represent the distance to the\n       * respective edge of the viewport element.  If the element\n       * edge extends beyond the viewport, a negative value will be\n       * reported.\n       *\n       * @param {element} elem - The element to get the viewport offset for.\n       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead\n       * of the first scrollable element, default is false.\n       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element\n       * be accounted for, default is true.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: distance to the top content edge of viewport element</li>\n       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>\n       *     <li>**left**: distance to the left content edge of viewport element</li>\n       *     <li>**right**: distance to the right content edge of viewport element</li>\n       *   </ul>\n       */\n      viewportOffset: function(elem, useDocument, includePadding) {\n        elem = this.getRawNode(elem);\n        includePadding = includePadding !== false ? true : false;\n\n        var elemBCR = elem.getBoundingClientRect();\n        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};\n\n        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);\n        var offsetParentBCR = offsetParent.getBoundingClientRect();\n\n        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;\n        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;\n        if (offsetParent === $document[0].documentElement) {\n          offsetBCR.top += $window.pageYOffset;\n          offsetBCR.left += $window.pageXOffset;\n        }\n        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;\n        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;\n\n        if (includePadding) {\n          var offsetParentStyle = $window.getComputedStyle(offsetParent);\n          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);\n          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);\n          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);\n          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);\n        }\n\n        return {\n          top: Math.round(elemBCR.top - offsetBCR.top),\n          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),\n          left: Math.round(elemBCR.left - offsetBCR.left),\n          right: Math.round(offsetBCR.right - elemBCR.right)\n        };\n      },\n\n      /**\n       * Provides an array of placement values parsed from a placement string.\n       * Along with the 'auto' indicator, supported placement strings are:\n       *   <ul>\n       *     <li>top: element on top, horizontally centered on host element.</li>\n       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>\n       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>\n       *     <li>bottom: element on bottom, horizontally centered on host element.</li>\n       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>\n       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>\n       *     <li>left: element on left, vertically centered on host element.</li>\n       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>\n       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>\n       *     <li>right: element on right, vertically centered on host element.</li>\n       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>\n       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>\n       *   </ul>\n       * A placement string with an 'auto' indicator is expected to be\n       * space separated from the placement, i.e: 'auto bottom-left'  If\n       * the primary and secondary placement values do not match 'top,\n       * bottom, left, right' then 'top' will be the primary placement and\n       * 'center' will be the secondary placement.  If 'auto' is passed, true\n       * will be returned as the 3rd value of the array.\n       *\n       * @param {string} placement - The placement string to parse.\n       *\n       * @returns {array} An array with the following values\n       * <ul>\n       *   <li>**[0]**: The primary placement.</li>\n       *   <li>**[1]**: The secondary placement.</li>\n       *   <li>**[2]**: If auto is passed: true, else undefined.</li>\n       * </ul>\n       */\n      parsePlacement: function(placement) {\n        var autoPlace = PLACEMENT_REGEX.auto.test(placement);\n        if (autoPlace) {\n          placement = placement.replace(PLACEMENT_REGEX.auto, '');\n        }\n\n        placement = placement.split('-');\n\n        placement[0] = placement[0] || 'top';\n        if (!PLACEMENT_REGEX.primary.test(placement[0])) {\n          placement[0] = 'top';\n        }\n\n        placement[1] = placement[1] || 'center';\n        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {\n          placement[1] = 'center';\n        }\n\n        if (autoPlace) {\n          placement[2] = true;\n        } else {\n          placement[2] = false;\n        }\n\n        return placement;\n      },\n\n      /**\n       * Provides coordinates for an element to be positioned relative to\n       * another element.  Passing 'auto' as part of the placement parameter\n       * will enable smart placement - where the element fits. i.e:\n       * 'auto left-top' will check to see if there is enough space to the left\n       * of the hostElem to fit the targetElem, if not place right (same for secondary\n       * top placement).  Available space is calculated using the viewportOffset\n       * function.\n       *\n       * @param {element} hostElem - The element to position against.\n       * @param {element} targetElem - The element to position.\n       * @param {string=} [placement=top] - The placement for the targetElem,\n       *   default is 'top'. 'center' is assumed as secondary placement for\n       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:\n       *   <ul>\n       *     <li>top</li>\n       *     <li>top-right</li>\n       *     <li>top-left</li>\n       *     <li>bottom</li>\n       *     <li>bottom-left</li>\n       *     <li>bottom-right</li>\n       *     <li>left</li>\n       *     <li>left-top</li>\n       *     <li>left-bottom</li>\n       *     <li>right</li>\n       *     <li>right-top</li>\n       *     <li>right-bottom</li>\n       *   </ul>\n       * @param {boolean=} [appendToBody=false] - Should the top and left values returned\n       *   be calculated from the body element, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: Value for targetElem top.</li>\n       *     <li>**left**: Value for targetElem left.</li>\n       *     <li>**placement**: The resolved placement.</li>\n       *   </ul>\n       */\n      positionElements: function(hostElem, targetElem, placement, appendToBody) {\n        hostElem = this.getRawNode(hostElem);\n        targetElem = this.getRawNode(targetElem);\n\n        // need to read from prop to support tests.\n        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');\n        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');\n\n        placement = this.parsePlacement(placement);\n\n        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);\n        var targetElemPos = {top: 0, left: 0, placement: ''};\n\n        if (placement[2]) {\n          var viewportOffset = this.viewportOffset(hostElem);\n\n          var targetElemStyle = $window.getComputedStyle(targetElem);\n          var adjustedSize = {\n            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),\n            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))\n          };\n\n          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :\n                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :\n                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :\n                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :\n                         placement[0];\n\n          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :\n                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :\n                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :\n                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :\n                         placement[1];\n\n          if (placement[1] === 'center') {\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;\n              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {\n                placement[1] = 'left';\n              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {\n                placement[1] = 'right';\n              }\n            } else {\n              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;\n              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {\n                placement[1] = 'top';\n              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {\n                placement[1] = 'bottom';\n              }\n            }\n          }\n        }\n\n        switch (placement[0]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top - targetHeight;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left - targetWidth;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width;\n            break;\n        }\n\n        switch (placement[1]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;\n            break;\n          case 'center':\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;\n            } else {\n              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;\n            }\n            break;\n        }\n\n        targetElemPos.top = Math.round(targetElemPos.top);\n        targetElemPos.left = Math.round(targetElemPos.left);\n        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];\n\n        return targetElemPos;\n      },\n\n      /**\n      * Provides a way for positioning tooltip & dropdown\n      * arrows when using placement options beyond the standard\n      * left, right, top, or bottom.\n      *\n      * @param {element} elem - The tooltip/dropdown element.\n      * @param {string} placement - The placement for the elem.\n      */\n      positionArrow: function(elem, placement) {\n        elem = this.getRawNode(elem);\n\n        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');\n        if (!innerElem) {\n          return;\n        }\n\n        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');\n\n        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');\n        if (!arrowElem) {\n          return;\n        }\n\n        placement = this.parsePlacement(placement);\n        if (placement[1] === 'center') {\n          // no adjustment necessary - just reset styles\n          angular.element(arrowElem).css({top: '', bottom: '', right: '', left: '', margin: ''});\n          return;\n        }\n\n        var borderProp = 'border-' + placement[0] + '-width';\n        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];\n\n        var borderRadiusProp = 'border-';\n        if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n          borderRadiusProp += placement[0] + '-' + placement[1];\n        } else {\n          borderRadiusProp += placement[1] + '-' + placement[0];\n        }\n        borderRadiusProp += '-radius';\n        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];\n\n        var arrowCss = {\n          top: 'auto',\n          bottom: 'auto',\n          left: 'auto',\n          right: 'auto',\n          margin: 0\n        };\n\n        switch (placement[0]) {\n          case 'top':\n            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'bottom':\n            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'left':\n            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'right':\n            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;\n            break;\n        }\n\n        arrowCss[placement[1]] = borderRadius;\n\n        angular.element(arrowElem).css(arrowCss);\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position'])\n\n.value('$datepickerSuppressError', false)\n\n.constant('uibDatepickerConfig', {\n  datepickerMode: 'day',\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  maxDate: null,\n  maxMode: 'year',\n  minDate: null,\n  minMode: 'day',\n  ngModelOptions: {},\n  shortcutPropagation: false,\n  showWeeks: true,\n  yearColumns: 5,\n  yearRows: 4\n})\n\n.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', 'uibDateParser',\n  function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerSuppressError, dateParser) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;\n      ngModelOptions = {},\n      watchListeners = [];\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  if ($attrs.datepickerOptions) {\n    angular.forEach([\n      'formatDay',\n      'formatDayHeader',\n      'formatDayTitle',\n      'formatMonth',\n      'formatMonthTitle',\n      'formatYear',\n      'initDate',\n      'maxDate',\n      'maxMode',\n      'minDate',\n      'minMode',\n      'showWeeks',\n      'shortcutPropagation',\n      'startingDay',\n      'yearColumns',\n      'yearRows'\n    ], function(key) {\n      switch (key) {\n        case 'formatDay':\n        case 'formatDayHeader':\n        case 'formatDayTitle':\n        case 'formatMonth':\n        case 'formatMonthTitle':\n        case 'formatYear':\n          self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];\n          break;\n        case 'showWeeks':\n        case 'shortcutPropagation':\n        case 'yearColumns':\n        case 'yearRows':\n          self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n            $scope.datepickerOptions[key] : datepickerConfig[key];\n          break;\n        case 'startingDay':\n          if (angular.isDefined($scope.datepickerOptions.startingDay)) {\n            self.startingDay = $scope.datepickerOptions.startingDay;\n          } else if (angular.isNumber(datepickerConfig.startingDay)) {\n            self.startingDay = datepickerConfig.startingDay;\n          } else {\n            self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n          }\n\n          break;\n        case 'maxDate':\n        case 'minDate':\n          if ($scope.datepickerOptions[key]) {\n            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n              if (value) {\n                if (angular.isDate(value)) {\n                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n                } else {\n                  self[key] = new Date(dateFilter(value, 'medium'));\n                }\n              } else {\n                self[key] = null;\n              }\n\n              self.refreshView();\n            });\n          } else {\n            self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;\n          }\n\n          break;\n        case 'maxMode':\n        case 'minMode':\n          if ($scope.datepickerOptions[key]) {\n            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n              self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];\n              if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||\n                key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {\n                $scope.datepickerMode = self[key];\n              }\n            });\n          } else {\n            self[key] = $scope[key] = datepickerConfig[key] || null;\n          }\n\n          break;\n        case 'initDate':\n          if ($scope.datepickerOptions.initDate) {\n            this.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();\n            $scope.$watch(function() { return $scope.datepickerOptions.initDate; }, function(initDate) {\n              if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n                self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n                self.refreshView();\n              }\n            });\n          } else {\n            this.activeDate = new Date();\n          }\n      }\n    });\n  } else {\n    // Interpolated configuration attributes\n    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle'], function(key) {\n      self[key] = angular.isDefined($attrs[key]) ? $interpolate($attrs[key])($scope.$parent) : datepickerConfig[key];\n    });\n\n    // Evaled configuration attributes\n    angular.forEach(['showWeeks', 'yearRows', 'yearColumns', 'shortcutPropagation'], function(key) {\n      self[key] = angular.isDefined($attrs[key]) ?\n        $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];\n    });\n\n    if (angular.isDefined($attrs.startingDay)) {\n      self.startingDay = $scope.$parent.$eval($attrs.startingDay);\n    } else if (angular.isNumber(datepickerConfig.startingDay)) {\n      self.startingDay = datepickerConfig.startingDay;\n    } else {\n      self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n    }\n\n    // Watchable date attributes\n    angular.forEach(['minDate', 'maxDate'], function(key) {\n      if ($attrs[key]) {\n        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {\n          if (value) {\n            if (angular.isDate(value)) {\n              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n            } else {\n              self[key] = new Date(dateFilter(value, 'medium'));\n            }\n          } else {\n            self[key] = null;\n          }\n\n          self.refreshView();\n        }));\n      } else {\n        self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;\n      }\n    });\n\n    angular.forEach(['minMode', 'maxMode'], function(key) {\n      if ($attrs[key]) {\n        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {\n          self[key] = $scope[key] = angular.isDefined(value) ? value : $attrs[key];\n          if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||\n            key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {\n            $scope.datepickerMode = self[key];\n          }\n        }));\n      } else {\n        self[key] = $scope[key] = datepickerConfig[key] || null;\n      }\n    });\n\n    if (angular.isDefined($attrs.initDate)) {\n      this.activeDate = dateParser.fromTimezone($scope.$parent.$eval($attrs.initDate), ngModelOptions.timezone) || new Date();\n      watchListeners.push($scope.$parent.$watch($attrs.initDate, function(initDate) {\n        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n          self.refreshView();\n        }\n      }));\n    } else {\n      this.activeDate = new Date();\n    }\n  }\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n  if (angular.isDefined($attrs.ngDisabled)) {\n    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {\n      $scope.disabled = disabled;\n      self.refreshView();\n    }));\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;\n\n    if (ngModelCtrl.$modelValue) {\n      this.activeDate = ngModelCtrl.$modelValue;\n    }\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n          isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      $scope.selectedDt = null;\n      this._refreshView();\n      if ($scope.activeDt) {\n        $scope.activeDateId = $scope.activeDt.uid;\n      }\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      date = dateParser.fromTimezone(date, ngModelOptions.timezone);\n      ngModelCtrl.$setValidity('dateDisabled', !date ||\n        this.element && !this.isDisabled(date));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    model = dateParser.fromTimezone(model, ngModelOptions.timezone);\n    var dt = {\n      date: date,\n      label: dateParser.filter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date) || null\n    };\n\n    if (model && this.compare(date, model) === 0) {\n      $scope.selectedDt = dt;\n    }\n\n    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {\n      $scope.activeDt = dt;\n    }\n\n    return dt;\n  };\n\n  this.isDisabled = function(date) {\n    return $scope.disabled ||\n      this.minDate && this.compare(date, this.minDate) < 0 ||\n      this.maxDate && this.compare(date, this.maxDate) > 0 ||\n      $attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      dt = dateParser.toTimezone(dt, ngModelOptions.timezone);\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if ($scope.datepickerMode === self.maxMode && direction === 1 ||\n      $scope.datepickerMode === self.minMode && direction === -1) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n\n  $scope.$on(\"$destroy\", function() {\n    //Clear all watch listeners on destroy\n    while (watchListeners.length) {\n      watchListeners.shift()();\n    }\n  });\n}])\n\n.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  this.step = { months: 1 };\n  this.element = $element;\n  function getDaysInMonth(year, month) {\n    return month === 1 && year % 4 === 0 &&\n      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];\n  }\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    scope.showWeeks = ctrl.showWeeks;\n    ctrl.refreshView();\n  };\n\n  this.getDates = function(startDate, n) {\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n    while (i < n) {\n      date = new Date(current);\n      dates[i++] = date;\n      current.setDate(current.getDate() + 1);\n    }\n    return dates;\n  };\n\n  this._refreshView = function() {\n    var year = this.activeDate.getFullYear(),\n      month = this.activeDate.getMonth(),\n      firstDayOfMonth = new Date(this.activeDate);\n\n    firstDayOfMonth.setFullYear(year, month, 1);\n\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\n      numDisplayedFromPreviousMonth = difference > 0 ?\n        7 - difference : - difference,\n      firstDate = new Date(firstDayOfMonth);\n\n    if (numDisplayedFromPreviousMonth > 0) {\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n    }\n\n    // 42 is the number of days on a six-week calendar\n    var days = this.getDates(firstDate, 42);\n    for (var i = 0; i < 42; i ++) {\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n        secondary: days[i].getMonth() !== month,\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.labels = new Array(7);\n    for (var j = 0; j < 7; j++) {\n      scope.labels[j] = {\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\n        full: dateFilter(days[j].date, 'EEEE')\n      };\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n    scope.rows = this.split(days, 7);\n\n    if (scope.showWeeks) {\n      scope.weekNumbers = [];\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n          numWeeks = scope.rows.length;\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n        scope.weekNumbers.push(\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n      }\n    }\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  function getISO8601WeekNumber(date) {\n    var checkDate = new Date(date);\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  }\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getDate();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - 7;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + 7;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setMonth(month, 1);\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n    } else if (key === 'home') {\n      date = 1;\n    } else if (key === 'end') {\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n    }\n    this.activeDate.setDate(date);\n  };\n}])\n\n.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  this.step = { years: 1 };\n  this.element = $element;\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    ctrl.refreshView();\n  };\n\n  this._refreshView = function() {\n    var months = new Array(12),\n        year = this.activeDate.getFullYear(),\n        date;\n\n    for (var i = 0; i < 12; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(year, i, 1);\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n    scope.rows = this.split(months, 3);\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getMonth();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - 3;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + 3;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setFullYear(year);\n    } else if (key === 'home') {\n      date = 0;\n    } else if (key === 'end') {\n      date = 11;\n    }\n    this.activeDate.setMonth(date);\n  };\n}])\n\n.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var columns, range;\n  this.element = $element;\n\n  function getStartingYear(year) {\n    return parseInt((year - 1) / range, 10) * range + 1;\n  }\n\n  this.yearpickerInit = function() {\n    columns = this.yearColumns;\n    range = this.yearRows * columns;\n    this.step = { years: range };\n  };\n\n  this._refreshView = function() {\n    var years = new Array(range), date;\n\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(start + i, 0, 1);\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n    scope.rows = this.split(years, columns);\n    scope.columns = columns;\n  };\n\n  this.compare = function(date1, date2) {\n    return date1.getFullYear() - date2.getFullYear();\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getFullYear();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - columns;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + columns;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      date += (key === 'pageup' ? - 1 : 1) * range;\n    } else if (key === 'home') {\n      date = getStartingYear(this.activeDate.getFullYear());\n    } else if (key === 'end') {\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n    }\n    this.activeDate.setFullYear(date);\n  };\n}])\n\n.directive('uibDatepicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerMode: '=?',\n      datepickerOptions: '=?',\n      dateDisabled: '&',\n      customClass: '&',\n      shortcutPropagation: '&?'\n    },\n    require: ['uibDatepicker', '^ngModel'],\n    controller: 'UibDatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n})\n\n.directive('uibDaypicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/day.html';\n    },\n    require: ['^uibDatepicker', 'uibDaypicker'],\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibMonthpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/month.html';\n    },\n    require: ['^uibDatepicker', 'uibMonthpicker'],\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibYearpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/year.html';\n    },\n    require: ['^uibDatepicker', 'uibYearpicker'],\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var ctrl = ctrls[0];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n})\n\n.constant('uibDatepickerPopupConfig', {\n  altInputFormats: [],\n  appendToBody: false,\n  clearText: 'Clear',\n  closeOnDateSelection: true,\n  closeText: 'Done',\n  currentText: 'Today',\n  datepickerPopup: 'yyyy-MM-dd',\n  datepickerPopupTemplateUrl: 'uib/template/datepicker/popup.html',\n  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',\n  html5Types: {\n    date: 'yyyy-MM-dd',\n    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n    'month': 'yyyy-MM'\n  },\n  onOpenFocus: true,\n  showButtonBar: true\n})\n\n.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig',\nfunction(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig) {\n  var cache = {},\n    isHtml5DateInput = false;\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,\n    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];\n\n  scope.watchData = {};\n\n  this.init = function(_ngModel_) {\n    ngModel = _ngModel_;\n    ngModelOptions = _ngModel_.$options || datepickerConfig.ngModelOptions;\n    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;\n    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n    altInputFormats = angular.isDefined(attrs.altInputFormats) ? scope.$parent.$eval(attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;\n\n    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\n    if (datepickerPopupConfig.html5Types[attrs.type]) {\n      dateFormat = datepickerPopupConfig.html5Types[attrs.type];\n      isHtml5DateInput = true;\n    } else {\n      dateFormat = attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n        // Invalidate the $modelValue to ensure that formatters re-run\n        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n        if (newDateFormat !== dateFormat) {\n          dateFormat = newDateFormat;\n          ngModel.$modelValue = null;\n\n          if (!dateFormat) {\n            throw new Error('uibDatepickerPopup must have a date format specified.');\n          }\n        }\n      });\n    }\n\n    if (!dateFormat) {\n      throw new Error('uibDatepickerPopup must have a date format specified.');\n    }\n\n    if (isHtml5DateInput && attrs.uibDatepickerPopup) {\n      throw new Error('HTML5 date input types do not support custom formats.');\n    }\n\n    // popup element used to display calendar\n    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n    scope.ngModelOptions = angular.copy(ngModelOptions);\n    scope.ngModelOptions.timezone = null;\n    popupEl.attr({\n      'ng-model': 'date',\n      'ng-model-options': 'ngModelOptions',\n      'ng-change': 'dateSelection(date)',\n      'template-url': datepickerPopupTemplateUrl\n    });\n\n    // datepicker element\n    datepickerEl = angular.element(popupEl.children()[0]);\n    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\n    if (isHtml5DateInput) {\n      if (attrs.type === 'month') {\n        datepickerEl.attr('datepicker-mode', '\"month\"');\n        datepickerEl.attr('min-mode', 'month');\n      }\n    }\n\n    if (scope.datepickerOptions) {\n      angular.forEach(scope.datepickerOptions, function(value, option) {\n        // Ignore this options, will be managed later\n        if (['minDate', 'maxDate', 'minMode', 'maxMode', 'initDate', 'datepickerMode'].indexOf(option) === -1) {\n          datepickerEl.attr(cameltoDash(option), value);\n        } else {\n          datepickerEl.attr(cameltoDash(option), 'datepickerOptions.' + option);\n        }\n      });\n    }\n\n    angular.forEach(['minMode', 'maxMode', 'datepickerMode', 'shortcutPropagation'], function(key) {\n      if (attrs[key]) {\n        var getAttribute = $parse(attrs[key]);\n        var propConfig = {\n          get: function() {\n            return getAttribute(scope.$parent);\n          }\n        };\n\n        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\n        // Propagate changes from datepicker to outside\n        if (key === 'datepickerMode') {\n          var setAttribute = getAttribute.assign;\n          propConfig.set = function(v) {\n            setAttribute(scope.$parent, v);\n          };\n        }\n\n        Object.defineProperty(scope.watchData, key, propConfig);\n      }\n    });\n\n    angular.forEach(['minDate', 'maxDate', 'initDate'], function(key) {\n      if (attrs[key]) {\n        var getAttribute = $parse(attrs[key]);\n\n        watchListeners.push(scope.$parent.$watch(getAttribute, function(value) {\n          if (key === 'minDate' || key === 'maxDate') {\n            if (value === null) {\n              cache[key] = null;\n            } else if (angular.isDate(value)) {\n              cache[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n            } else {\n              cache[key] = new Date(dateFilter(value, 'medium'));\n            }\n\n            scope.watchData[key] = value === null ? null : cache[key];\n          } else {\n            scope.watchData[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n          }\n        }));\n\n        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n      }\n    });\n\n    if (attrs.dateDisabled) {\n      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n    }\n\n    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRows', 'yearColumns'], function(key) {\n      if (angular.isDefined(attrs[key])) {\n        datepickerEl.attr(cameltoDash(key), attrs[key]);\n      }\n    });\n\n    if (attrs.customClass) {\n      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n    }\n\n    if (!isHtml5DateInput) {\n      // Internal API to maintain the correct ng-invalid-[key] class\n      ngModel.$$parserName = 'date';\n      ngModel.$validators.date = validator;\n      ngModel.$parsers.unshift(parseDate);\n      ngModel.$formatters.push(function(value) {\n        if (ngModel.$isEmpty(value)) {\n          scope.date = value;\n          return value;\n        }\n\n        scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);\n\n        if (angular.isNumber(scope.date)) {\n          scope.date = new Date(scope.date);\n        }\n\n        return dateParser.filter(scope.date, dateFormat);\n      });\n    } else {\n      ngModel.$formatters.push(function(value) {\n        scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);\n        return value;\n      });\n    }\n\n    // Detect changes in the view from the text box\n    ngModel.$viewChangeListeners.push(function() {\n      scope.date = parseDateString(ngModel.$viewValue);\n    });\n\n    element.on('keydown', inputKeydownBind);\n\n    $popup = $compile(popupEl)(scope);\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\n    popupEl.remove();\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    scope.$on('$destroy', function() {\n      if (scope.isOpen === true) {\n        if (!$rootScope.$$phase) {\n          scope.$apply(function() {\n            scope.isOpen = false;\n          });\n        }\n      }\n\n      $popup.remove();\n      element.off('keydown', inputKeydownBind);\n      $document.off('click', documentClickBind);\n\n      //Clear all watch listeners on destroy\n      while (watchListeners.length) {\n        watchListeners.shift()();\n      }\n    });\n  };\n\n  scope.getText = function(key) {\n    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n  };\n\n  scope.isDisabled = function(date) {\n    if (date === 'today') {\n      date = new Date();\n    }\n\n    return scope.watchData.minDate && scope.compare(date, cache.minDate) < 0 ||\n        scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0;\n  };\n\n  scope.compare = function(date1, date2) {\n    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n  };\n\n  // Inner change\n  scope.dateSelection = function(dt) {\n    if (angular.isDefined(dt)) {\n      scope.date = dt;\n    }\n    var date = scope.date ? dateParser.filter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n    element.val(date);\n    ngModel.$setViewValue(date);\n\n    if (closeOnDateSelection) {\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.keydown = function(evt) {\n    if (evt.which === 27) {\n      evt.stopPropagation();\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.select = function(date) {\n    if (date === 'today') {\n      var today = new Date();\n      if (angular.isDate(scope.date)) {\n        date = new Date(scope.date);\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n      } else {\n        date = new Date(today.setHours(0, 0, 0, 0));\n      }\n    }\n    scope.dateSelection(date);\n  };\n\n  scope.close = function() {\n    scope.isOpen = false;\n    element[0].focus();\n  };\n\n  scope.disabled = angular.isDefined(attrs.disabled) || false;\n  if (attrs.ngDisabled) {\n    watchListeners.push(scope.$parent.$watch($parse(attrs.ngDisabled), function(disabled) {\n      scope.disabled = disabled;\n    }));\n  }\n\n  scope.$watch('isOpen', function(value) {\n    if (value) {\n      if (!scope.disabled) {\n        scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n        scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n        $timeout(function() {\n          if (onOpenFocus) {\n            scope.$broadcast('uib:datepicker.focus');\n          }\n          $document.on('click', documentClickBind);\n        }, 0, false);\n      } else {\n        scope.isOpen = false;\n      }\n    } else {\n      $document.off('click', documentClickBind);\n    }\n  });\n\n  function cameltoDash(string) {\n    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n  }\n\n  function parseDateString(viewValue) {\n    var date = dateParser.parse(viewValue, dateFormat, scope.date);\n    if (isNaN(date)) {\n      for (var i = 0; i < altInputFormats.length; i++) {\n        date = dateParser.parse(viewValue, altInputFormats[i], scope.date);\n        if (!isNaN(date)) {\n          return date;\n        }\n      }\n    }\n    return date;\n  }\n\n  function parseDate(viewValue) {\n    if (angular.isNumber(viewValue)) {\n      // presumably timestamp to date object\n      viewValue = new Date(viewValue);\n    }\n\n    if (!viewValue) {\n      return null;\n    }\n\n    if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n      return viewValue;\n    }\n\n    if (angular.isString(viewValue)) {\n      var date = parseDateString(viewValue);\n      if (!isNaN(date)) {\n        return dateParser.toTimezone(date, ngModelOptions.timezone);\n      }\n    }\n\n    return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;\n  }\n\n  function validator(modelValue, viewValue) {\n    var value = modelValue || viewValue;\n\n    if (!attrs.ngRequired && !value) {\n      return true;\n    }\n\n    if (angular.isNumber(value)) {\n      value = new Date(value);\n    }\n\n    if (!value) {\n      return true;\n    }\n\n    if (angular.isDate(value) && !isNaN(value)) {\n      return true;\n    }\n\n    if (angular.isString(value)) {\n      return !isNaN(parseDateString(viewValue));\n    }\n\n    return false;\n  }\n\n  function documentClickBind(event) {\n    if (!scope.isOpen && scope.disabled) {\n      return;\n    }\n\n    var popup = $popup[0];\n    var dpContainsTarget = element[0].contains(event.target);\n    // The popup node may not be an element node\n    // In some browsers (IE) only element nodes have the 'contains' function\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n    }\n  }\n\n  function inputKeydownBind(evt) {\n    if (evt.which === 27 && scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n      element[0].focus();\n    } else if (evt.which === 40 && !scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = true;\n      });\n    }\n  }\n}])\n\n.directive('uibDatepickerPopup', function() {\n  return {\n    require: ['ngModel', 'uibDatepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      datepickerOptions: '=?',\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&',\n      customClass: '&'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n})\n\n.directive('uibDatepickerPopupWrap', function() {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/popup.html';\n    }\n  };\n});\n\nangular.module('ui.bootstrap.debounce', [])\n/**\n * A helper, internal service that debounces a function\n */\n  .factory('$$debounce', ['$timeout', function($timeout) {\n    return function(callback, debounceTime) {\n      var timeoutPromise;\n\n      return function() {\n        var self = this;\n        var args = Array.prototype.slice.call(arguments);\n        if (timeoutPromise) {\n          $timeout.cancel(timeoutPromise);\n        }\n\n        timeoutPromise = $timeout(function() {\n          callback.apply(self, args);\n        }, debounceTime);\n      };\n    };\n  }]);\n\nangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\n.constant('uibDropdownConfig', {\n  appendToOpenClass: 'uib-dropdown-open',\n  openClass: 'open'\n})\n\n.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n  var openScope = null;\n\n  this.open = function(dropdownScope) {\n    if (!openScope) {\n      $document.on('click', closeDropdown);\n      $document.on('keydown', keybindFilter);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function(dropdownScope) {\n    if (openScope === dropdownScope) {\n      openScope = null;\n      $document.off('click', closeDropdown);\n      $document.off('keydown', keybindFilter);\n    }\n  };\n\n  var closeDropdown = function(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope) { return; }\n\n    if (evt && openScope.getAutoClose() === 'disabled') { return; }\n\n    if (evt && evt.which === 3) { return; }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  var keybindFilter = function(evt) {\n    if (evt.which === 27) {\n      openScope.focusToggleElement();\n      closeDropdown();\n    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      openScope.focusDropdownEntry(evt.which);\n    }\n  };\n}])\n\n.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    appendToOpenClass = dropdownConfig.appendToOpenClass,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    appendTo = null,\n    keynavEnabled = false,\n    selectedOption = null,\n    body = $document.find('body');\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    if (angular.isDefined($attrs.dropdownAppendTo)) {\n      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);\n      if (appendToEl) {\n        appendTo = angular.element(appendToEl);\n      }\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.keyboardNav);\n\n    if (appendToBody && !appendTo) {\n      appendTo = body;\n    }\n\n    if (appendTo && self.dropdownMenu) {\n      appendTo.append(self.dropdownMenu);\n      $element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      angular.element(self.dropdownMenu).find('a') :\n      $element.find('ul').eq(0).find('a');\n\n    switch (keyCode) {\n      case 40: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = self.selectedOption === elems.length - 1 ?\n            self.selectedOption :\n            self.selectedOption + 1;\n        }\n        break;\n      }\n      case 38: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    if (appendTo && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),\n        css,\n        rightalign;\n\n      css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        css.right = window.innerWidth -\n          (pos.left + $element.prop('offsetWidth')) + 'px';\n      }\n\n      // Need to adjust our positioning to be relative to the appendTo container\n      // if it's not the body element\n      if (!appendToBody) {\n        var appendOffset = $position.offset(appendTo);\n\n        css.top = pos.top - appendOffset.top + 'px';\n\n        if (!rightalign) {\n          css.left = pos.left - appendOffset.left + 'px';\n        } else {\n          css.right = window.innerWidth -\n            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';\n        }\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    var openContainer = appendTo ? appendTo : $element;\n\n    $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {\n      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n        toggleInvoker($scope, { open: !!isOpen });\n      }\n    });\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    if (scope.getAutoClose() !== 'disabled') {\n      scope.isOpen = false;\n    }\n  });\n}])\n\n.directive('uibDropdown', function() {\n  return {\n    controller: 'UibDropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init();\n    }\n  };\n})\n\n.directive('uibDropdownMenu', function() {\n  return {\n    restrict: 'A',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n})\n\n.directive('uibDropdownToggle', function() {\n  return {\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.stackedMap', [])\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function() {\n    return {\n      createNew: function() {\n        var stack = [];\n\n        return {\n          add: function(key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function(key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function() {\n            return stack[stack.length - 1];\n          },\n          remove: function(key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function() {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function() {\n            return stack.length;\n          }\n        };\n      }\n    };\n  });\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n/**\n * A helper, internal data structure that stores all references attached to key\n */\n  .factory('$$multiMap', function() {\n    return {\n      createNew: function() {\n        var map = {};\n\n        return {\n          entries: function() {\n            return Object.keys(map).map(function(key) {\n              return {\n                key: key,\n                value: map[key]\n              };\n            });\n          },\n          get: function(key) {\n            return map[key];\n          },\n          hasKey: function(key) {\n            return !!map[key];\n          },\n          keys: function() {\n            return Object.keys(map);\n          },\n          put: function(key, value) {\n            if (!map[key]) {\n              map[key] = [];\n            }\n\n            map[key].push(value);\n          },\n          remove: function(key, value) {\n            var values = map[key];\n\n            if (!values) {\n              return;\n            }\n\n            var idx = values.indexOf(value);\n\n            if (idx !== -1) {\n              values.splice(idx, 1);\n            }\n\n            if (!values.length) {\n              delete map[key];\n            }\n          }\n        };\n      }\n    };\n  })\n\n/**\n * Pluggable resolve mechanism for the modal resolve resolution\n * Supports UI Router's $resolve service\n */\n  .provider('$uibResolve', function() {\n    var resolve = this;\n    this.resolver = null;\n\n    this.setResolver = function(resolver) {\n      this.resolver = resolver;\n    };\n\n    this.$get = ['$injector', '$q', function($injector, $q) {\n      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;\n      return {\n        resolve: function(invocables, locals, parent, self) {\n          if (resolver) {\n            return resolver.resolve(invocables, locals, parent, self);\n          }\n\n          var promises = [];\n\n          angular.forEach(invocables, function(value) {\n            if (angular.isFunction(value) || angular.isArray(value)) {\n              promises.push($q.resolve($injector.invoke(value)));\n            } else if (angular.isString(value)) {\n              promises.push($q.resolve($injector.get(value)));\n            } else {\n              promises.push($q.resolve(value));\n            }\n          });\n\n          return $q.all(promises).then(function(resolves) {\n            var resolveObj = {};\n            var resolveIter = 0;\n            angular.forEach(invocables, function(value, key) {\n              resolveObj[key] = resolves[resolveIter++];\n            });\n\n            return resolveObj;\n          });\n        }\n      };\n    }];\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('uibModalBackdrop', ['$animateCss', '$injector', '$uibModalStack',\n  function($animateCss, $injector, $modalStack) {\n    return {\n      replace: true,\n      templateUrl: 'uib/template/modal/backdrop.html',\n      compile: function(tElement, tAttrs) {\n        tElement.addClass(tAttrs.backdropClass);\n        return linkFn;\n      }\n    };\n\n    function linkFn(scope, element, attrs) {\n      if (attrs.modalInClass) {\n        $animateCss(element, {\n          addClass: attrs.modalInClass\n        }).start();\n\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n          var done = setIsAsync();\n          if (scope.modalOptions.animation) {\n            $animateCss(element, {\n              removeClass: attrs.modalInClass\n            }).start().then(done);\n          } else {\n            done();\n          }\n        });\n      }\n    }\n  }])\n\n  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animate', '$animateCss', '$document',\n  function($modalStack, $q, $animate, $animateCss, $document) {\n    return {\n      scope: {\n        index: '@'\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'uib/template/modal/window.html';\n      },\n      link: function(scope, element, attrs) {\n        element.addClass(attrs.windowClass || '');\n        element.addClass(attrs.windowTopClass || '');\n        scope.size = attrs.size;\n\n        scope.close = function(evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop &&\n            modal.value.backdrop !== 'static' &&\n            evt.target === evt.currentTarget) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n\n        // moved from template to fix issue #2280\n        element.on('click', scope.close);\n\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n        // We can detect that by using this property in the template associated with this directive and then use\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n        scope.$isRendered = true;\n\n        // Deferred object that will be resolved when this modal is render.\n        var modalRenderDeferObj = $q.defer();\n        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n        attrs.$observe('modalRender', function(value) {\n          if (value === 'true') {\n            modalRenderDeferObj.resolve();\n          }\n        });\n\n        modalRenderDeferObj.promise.then(function() {\n          var animationPromise = null;\n\n          if (attrs.modalInClass) {\n            animationPromise = $animateCss(element, {\n              addClass: attrs.modalInClass\n            }).start();\n\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n              var done = setIsAsync();\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: attrs.modalInClass\n                }).start().then(done);\n              } else {\n                $animate.removeClass(element, attrs.modalInClass).then(done);\n              }\n            });\n          }\n\n\n          $q.when(animationPromise).then(function() {\n            /**\n             * If something within the freshly-opened modal already has focus (perhaps via a\n             * directive that causes focus). then no need to try and focus anything.\n             */\n            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {\n              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n              /**\n               * Auto-focusing of a freshly-opened modal element causes any child elements\n               * with the autofocus attribute to lose focus. This is an issue on touch\n               * based devices which will show and then hide the onscreen keyboard.\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n               * the modal element if the modal does not contain an autofocus element.\n               */\n              if (inputWithAutofocus) {\n                inputWithAutofocus.focus();\n              } else {\n                element[0].focus();\n              }\n            }\n          });\n\n          // Notify {@link $modalStack} that modal is rendered.\n          var modal = $modalStack.getTop();\n          if (modal) {\n            $modalStack.modalRendered(modal.key);\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('uibModalAnimationClass', function() {\n    return {\n      compile: function(tElement, tAttrs) {\n        if (tAttrs.modalAnimation) {\n          tElement.addClass(tAttrs.uibModalAnimationClass);\n        }\n      }\n    };\n  })\n\n  .directive('uibModalTransclude', function() {\n    return {\n      link: function(scope, element, attrs, controller, transclude) {\n        transclude(scope.$parent, function(clone) {\n          element.empty();\n          element.append(clone);\n        });\n      }\n    };\n  })\n\n  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',\n    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap',\n    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap) {\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var openedClasses = $$multiMap.createNew();\n      var $modalStack = {\n        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n      };\n\n      //Modal focus behavior\n      var focusableElementList;\n      var focusIndex = 0;\n      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n        var modalWindow = openedWindows.get(modalInstance).value;\n        var appendToElement = modalWindow.appendTo;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n          openedClasses.remove(modalBodyClass, modalInstance);\n          appendToElement.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n          toggleTopWindowClass(true);\n        }, modalWindow.closedDeferred);\n        checkRemoveBackdrop();\n\n        //move focus to specified element if available, or else to body\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n          elementToReceiveFocus.focus();\n        } else if (appendToElement.focus) {\n          appendToElement.focus();\n        }\n      }\n\n      // Add or remove \"windowTopClass\" from the top window in the stack\n      function toggleTopWindowClass(toggleSwitch) {\n        var modalWindow;\n\n        if (openedWindows.length() > 0) {\n          modalWindow = openedWindows.top().value;\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n        }\n      }\n\n      function checkRemoveBackdrop() {\n        //remove backdrop if no longer needed\n        if (backdropDomEl && backdropIndex() === -1) {\n          var backdropScopeRef = backdropScope;\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n            backdropScopeRef = null;\n          });\n          backdropDomEl = undefined;\n          backdropScope = undefined;\n        }\n      }\n\n      function removeAfterAnimate(domEl, scope, done, closedDeferred) {\n        var asyncDeferred;\n        var asyncPromise = null;\n        var setIsAsync = function() {\n          if (!asyncDeferred) {\n            asyncDeferred = $q.defer();\n            asyncPromise = asyncDeferred.promise;\n          }\n\n          return function asyncDone() {\n            asyncDeferred.resolve();\n          };\n        };\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\n        // Note that it's intentional that asyncPromise might be null.\n        // That's when setIsAsync has not been called during the\n        // NOW_CLOSING_EVENT broadcast.\n        return $q.when(asyncPromise).then(afterAnimating);\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          $animateCss(domEl, {\n            event: 'leave'\n          }).start().then(function() {\n            domEl.remove();\n            if (closedDeferred) {\n              closedDeferred.resolve();\n            }\n          });\n\n          scope.$destroy();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.on('keydown', keydownListener);\n\n      $rootScope.$on('$destroy', function() {\n        $document.off('keydown', keydownListener);\n      });\n\n      function keydownListener(evt) {\n        if (evt.isDefaultPrevented()) {\n          return evt;\n        }\n\n        var modal = openedWindows.top();\n        if (modal) {\n          switch (evt.which) {\n            case 27: {\n              if (modal.value.keyboard) {\n                evt.preventDefault();\n                $rootScope.$apply(function() {\n                  $modalStack.dismiss(modal.key, 'escape key press');\n                });\n              }\n              break;\n            }\n            case 9: {\n              $modalStack.loadFocusElementList(modal);\n              var focusChanged = false;\n              if (evt.shiftKey) {\n                if ($modalStack.isFocusInFirstItem(evt) || $modalStack.isModalFocused(evt, modal)) {\n                  focusChanged = $modalStack.focusLastFocusableElement();\n                }\n              } else {\n                if ($modalStack.isFocusInLastItem(evt)) {\n                  focusChanged = $modalStack.focusFirstFocusableElement();\n                }\n              }\n\n              if (focusChanged) {\n                evt.preventDefault();\n                evt.stopPropagation();\n              }\n              break;\n            }\n          }\n        }\n      }\n\n      $modalStack.open = function(modalInstance, modal) {\n        var modalOpener = $document[0].activeElement,\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\n        toggleTopWindowClass(false);\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          renderDeferred: modal.renderDeferred,\n          closedDeferred: modal.closedDeferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard,\n          openedClass: modal.openedClass,\n          windowTopClass: modal.windowTopClass,\n          animation: modal.animation,\n          appendTo: modal.appendTo\n        });\n\n        openedClasses.put(modalBodyClass, modalInstance);\n\n        var appendToElement = modal.appendTo,\n            currBackdropIndex = backdropIndex();\n\n        if (!appendToElement.length) {\n          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');\n        }\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.modalOptions = modal;\n          backdropScope.index = currBackdropIndex;\n          backdropDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n          backdropDomEl.attr('backdrop-class', modal.backdropClass);\n          if (modal.animation) {\n            backdropDomEl.attr('modal-animation', 'true');\n          }\n          $compile(backdropDomEl)(backdropScope);\n          $animate.enter(backdropDomEl, appendToElement);\n        }\n\n        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n        angularDomEl.attr({\n          'template-url': modal.windowTemplateUrl,\n          'window-class': modal.windowClass,\n          'window-top-class': modal.windowTopClass,\n          'size': modal.size,\n          'index': openedWindows.length() - 1,\n          'animate': 'animate'\n        }).html(modal.content);\n        if (modal.animation) {\n          angularDomEl.attr('modal-animation', 'true');\n        }\n\n        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement)\n          .then(function() {\n            $animate.addClass(appendToElement, modalBodyClass);\n          });\n\n        openedWindows.top().value.modalDomEl = angularDomEl;\n        openedWindows.top().value.modalOpener = modalOpener;\n\n        $modalStack.clearFocusListCache();\n      };\n\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\n        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n      }\n\n      $modalStack.close = function(modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismiss = function(modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismissAll = function(reason) {\n        var topModal = this.getTop();\n        while (topModal && this.dismiss(topModal.key, reason)) {\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function() {\n        return openedWindows.top();\n      };\n\n      $modalStack.modalRendered = function(modalInstance) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.renderDeferred.resolve();\n        }\n      };\n\n      $modalStack.focusFirstFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[0].focus();\n          return true;\n        }\n        return false;\n      };\n      $modalStack.focusLastFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[focusableElementList.length - 1].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.isModalFocused = function(evt, modalWindow) {\n        if (evt && modalWindow) {\n          var modalDomEl = modalWindow.value.modalDomEl;\n          if (modalDomEl && modalDomEl.length) {\n            return (evt.target || evt.srcElement) === modalDomEl[0];\n          }\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInFirstItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) === focusableElementList[0];\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInLastItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) === focusableElementList[focusableElementList.length - 1];\n        }\n        return false;\n      };\n\n      $modalStack.clearFocusListCache = function() {\n        focusableElementList = [];\n        focusIndex = 0;\n      };\n\n      $modalStack.loadFocusElementList = function(modalWindow) {\n        if (focusableElementList === undefined || !focusableElementList.length) {\n          if (modalWindow) {\n            var modalDomE1 = modalWindow.value.modalDomEl;\n            if (modalDomE1 && modalDomE1.length) {\n              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n            }\n          }\n        }\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$uibModal', function() {\n    var $modalProvider = {\n      options: {\n        animation: true,\n        backdrop: true, //can also be false or 'static'\n        keyboard: true\n      },\n      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',\n        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $templateRequest(angular.isFunction(options.templateUrl) ?\n                options.templateUrl() : options.templateUrl);\n          }\n\n          var promiseChain = null;\n          $modal.getPromiseChain = function() {\n            return promiseChain;\n          };\n\n          $modal.open = function(modalOptions) {\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n            var modalClosedDeferred = $q.defer();\n            var modalRenderDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              closed: modalClosedDeferred.promise,\n              rendered: modalRenderDeferred.promise,\n              close: function (result) {\n                return $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                return $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);\n\n            function resolveWithTemplate() {\n              return templateAndResolvePromise;\n            }\n\n            // Wait for the resolution of the existing promise chain.\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n            // Then add to $modalStack and resolve opened.\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n            var samePromise;\n            samePromise = promiseChain = $q.all([promiseChain])\n              .then(resolveWithTemplate, resolveWithTemplate)\n              .then(function resolveSuccess(tplAndVars) {\n                var providedScope = modalOptions.scope || $rootScope;\n\n                var modalScope = providedScope.$new();\n                modalScope.$close = modalInstance.close;\n                modalScope.$dismiss = modalInstance.dismiss;\n\n                modalScope.$on('$destroy', function() {\n                  if (!modalScope.$$uibDestructionScheduled) {\n                    modalScope.$dismiss('$uibUnscheduledDestruction');\n                  }\n                });\n\n                var ctrlInstance, ctrlLocals = {};\n\n                //controllers\n                if (modalOptions.controller) {\n                  ctrlLocals.$scope = modalScope;\n                  ctrlLocals.$uibModalInstance = modalInstance;\n                  angular.forEach(tplAndVars[1], function(value, key) {\n                    ctrlLocals[key] = value;\n                  });\n\n                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n                  if (modalOptions.controllerAs) {\n                    if (modalOptions.bindToController) {\n                      ctrlInstance.$close = modalScope.$close;\n                      ctrlInstance.$dismiss = modalScope.$dismiss;\n                      angular.extend(ctrlInstance, providedScope);\n                    }\n\n                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n                  }\n                }\n\n                $modalStack.open(modalInstance, {\n                  scope: modalScope,\n                  deferred: modalResultDeferred,\n                  renderDeferred: modalRenderDeferred,\n                  closedDeferred: modalClosedDeferred,\n                  content: tplAndVars[0],\n                  animation: modalOptions.animation,\n                  backdrop: modalOptions.backdrop,\n                  keyboard: modalOptions.keyboard,\n                  backdropClass: modalOptions.backdropClass,\n                  windowTopClass: modalOptions.windowTopClass,\n                  windowClass: modalOptions.windowClass,\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n                  size: modalOptions.size,\n                  openedClass: modalOptions.openedClass,\n                  appendTo: modalOptions.appendTo\n                });\n                modalOpenedDeferred.resolve(true);\n\n            }, function resolveError(reason) {\n              modalOpenedDeferred.reject(reason);\n              modalResultDeferred.reject(reason);\n            })['finally'](function() {\n              if (promiseChain === samePromise) {\n                promiseChain = null;\n              }\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }\n      ]\n    };\n\n    return $modalProvider;\n  });\n\nangular.module('ui.bootstrap.paging', [])\n/**\n * Helper internal service for generating common controller code between the\n * pager and pagination components\n */\n.factory('uibPaging', ['$parse', function($parse) {\n  return {\n    create: function(ctrl, $scope, $attrs) {\n      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl\n      ctrl._watchers = [];\n\n      ctrl.init = function(ngModelCtrl, config) {\n        ctrl.ngModelCtrl = ngModelCtrl;\n        ctrl.config = config;\n\n        ngModelCtrl.$render = function() {\n          ctrl.render();\n        };\n\n        if ($attrs.itemsPerPage) {\n          ctrl._watchers.push($scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n            ctrl.itemsPerPage = parseInt(value, 10);\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }));\n        } else {\n          ctrl.itemsPerPage = config.itemsPerPage;\n        }\n\n        $scope.$watch('totalItems', function(newTotal, oldTotal) {\n          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }\n        });\n      };\n\n      ctrl.calculateTotalPages = function() {\n        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);\n        return Math.max(totalPages || 0, 1);\n      };\n\n      ctrl.render = function() {\n        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;\n      };\n\n      $scope.selectPage = function(page, evt) {\n        if (evt) {\n          evt.preventDefault();\n        }\n\n        var clickAllowed = !$scope.ngDisabled || !evt;\n        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n          if (evt && evt.target) {\n            evt.target.blur();\n          }\n          ctrl.ngModelCtrl.$setViewValue(page);\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.getText = function(key) {\n        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];\n      };\n\n      $scope.noPrevious = function() {\n        return $scope.page === 1;\n      };\n\n      $scope.noNext = function() {\n        return $scope.page === $scope.totalPages;\n      };\n\n      ctrl.updatePage = function() {\n        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable\n\n        if ($scope.page > $scope.totalPages) {\n          $scope.selectPage($scope.totalPages);\n        } else {\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.$on('$destroy', function() {\n        while (ctrl._watchers.length) {\n          ctrl._watchers.shift()();\n        }\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])\n\n.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {\n  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;\n\n  uibPaging.create(this, $scope, $attrs);\n}])\n\n.constant('uibPagerConfig', {\n  itemsPerPage: 10,\n  previousText: ' Previous',\n  nextText: 'Next ',\n  align: true\n})\n\n.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['uibPager', '?ngModel'],\n    controller: 'UibPagerController',\n    controllerAs: 'pager',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pager/pager.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n        return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPagerConfig);\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])\n.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {\n  var ctrl = this;\n  // Setup configuration parameters\n  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,\n    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,\n    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,\n    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers;\n  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;\n  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;\n\n  uibPaging.create(this, $scope, $attrs);\n\n  if ($attrs.maxSize) {\n    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {\n      maxSize = parseInt(value, 10);\n      ctrl.render();\n    }));\n  }\n\n  // Create page object used in template\n  function makePage(number, text, isActive) {\n    return {\n      number: number,\n      text: text,\n      active: isActive\n    };\n  }\n\n  function getPages(currentPage, totalPages) {\n    var pages = [];\n\n    // Default page limits\n    var startPage = 1, endPage = totalPages;\n    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n    // recompute if maxSize\n    if (isMaxSized) {\n      if (rotate) {\n        // Current page is displayed in the middle of the visible ones\n        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\n        endPage = startPage + maxSize - 1;\n\n        // Adjust if limit is exceeded\n        if (endPage > totalPages) {\n          endPage = totalPages;\n          startPage = endPage - maxSize + 1;\n        }\n      } else {\n        // Visible pages are paginated with maxSize\n        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;\n\n        // Adjust last page if limit is exceeded\n        endPage = Math.min(startPage + maxSize - 1, totalPages);\n      }\n    }\n\n    // Add page number links\n    for (var number = startPage; number <= endPage; number++) {\n      var page = makePage(number, number, number === currentPage);\n      pages.push(page);\n    }\n\n    // Add links to move between page sets\n    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {\n      if (startPage > 1) {\n        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning\n        var previousPageSet = makePage(startPage - 1, '...', false);\n        pages.unshift(previousPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential\n            var secondPageLink = makePage(2, '2', false);\n            pages.unshift(secondPageLink);\n          }\n          //add the first page\n          var firstPageLink = makePage(1, '1', false);\n          pages.unshift(firstPageLink);\n        }\n      }\n\n      if (endPage < totalPages) {\n        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end\n        var nextPageSet = makePage(endPage + 1, '...', false);\n        pages.push(nextPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential\n            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);\n            pages.push(secondToLastPageLink);\n          }\n          //add the last page\n          var lastPageLink = makePage(totalPages, totalPages, false);\n          pages.push(lastPageLink);\n        }\n      }\n    }\n    return pages;\n  }\n\n  var originalRender = this.render;\n  this.render = function() {\n    originalRender();\n    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {\n      $scope.pages = getPages($scope.page, $scope.totalPages);\n    }\n  };\n}])\n\n.constant('uibPaginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  boundaryLinkNumbers: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true,\n  forceEllipses: false\n})\n\n.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['uibPagination', '?ngModel'],\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pagination/pagination.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider('$uibTooltip', function() {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    placementClassPrefix: '',\n    animation: true,\n    popupDelay: 0,\n    popupCloseDelay: 0,\n    useContentExp: false\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'outsideClick': 'outsideClick',\n    'focus': 'blur',\n    'none': ''\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function(value) {\n\t\tangular.extend(globalOptions, value);\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n   */\n  this.setTriggers = function setTriggers(triggers) {\n    angular.extend(triggerMap, triggers);\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake_case.\n   */\n  function snake_case(name) {\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n    var openedTooltips = $$stackedMap.createNew();\n    $document.on('keypress', keypressListener);\n\n    $rootScope.$on('$destroy', function() {\n      $document.off('keypress', keypressListener);\n    });\n\n    function keypressListener(e) {\n      if (e.which === 27) {\n        var last = openedTooltips.top();\n        if (last) {\n          last.value.close();\n          openedTooltips.removeTop();\n          last = null;\n        }\n      }\n    }\n\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n      options = angular.extend({}, defaultOptions, globalOptions, options);\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers(trigger) {\n        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n        var hide = show.map(function(trigger) {\n          return triggerMap[trigger] || trigger;\n        });\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case(ttType);\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName + '-popup '+\n          'title=\"' + startSym + 'title' + endSym + '\" '+\n          (options.useContentExp ?\n            'content-exp=\"contentExp()\" ' :\n            'content=\"' + startSym + 'content' + endSym + '\" ') +\n          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n          'animation=\"animation\" ' +\n          'is-open=\"isOpen\"' +\n          'origin-scope=\"origScope\" ' +\n          'style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"' +\n          '>' +\n        '</div>';\n\n      return {\n        compile: function(tElem, tAttrs) {\n          var tooltipLinker = $compile(template);\n\n          return function link(scope, element, attrs, tooltipCtrl) {\n            var tooltip;\n            var tooltipLinkedScope;\n            var transitionTimeout;\n            var showTimeout;\n            var hideTimeout;\n            var positionTimeout;\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n            var triggers = getTriggers(undefined);\n            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n            var ttScope = scope.$new(true);\n            var repositionScheduled = false;\n            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n            var observers = [];\n\n            var positionTooltip = function() {\n              // check if tooltip exists and is not empty\n              if (!tooltip || !tooltip.html()) { return; }\n\n              if (!positionTimeout) {\n                positionTimeout = $timeout(function() {\n                  // Reset the positioning.\n                  tooltip.css({ top: 0, left: 0 });\n\n                  // Now set the calculated positioning.\n                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px', visibility: 'visible' });\n\n                  // If the placement class is prefixed, still need\n                  // to remove the TWBS standard class.\n                  if (options.placementClassPrefix) {\n                    tooltip.removeClass('top bottom left right');\n                  }\n\n                  tooltip.removeClass(\n                    options.placementClassPrefix + 'top ' +\n                    options.placementClassPrefix + 'top-left ' +\n                    options.placementClassPrefix + 'top-right ' +\n                    options.placementClassPrefix + 'bottom ' +\n                    options.placementClassPrefix + 'bottom-left ' +\n                    options.placementClassPrefix + 'bottom-right ' +\n                    options.placementClassPrefix + 'left ' +\n                    options.placementClassPrefix + 'left-top ' +\n                    options.placementClassPrefix + 'left-bottom ' +\n                    options.placementClassPrefix + 'right ' +\n                    options.placementClassPrefix + 'right-top ' +\n                    options.placementClassPrefix + 'right-bottom');\n\n                  var placement = ttPosition.placement.split('-');\n                  tooltip.addClass(placement[0] + ' ' + options.placementClassPrefix + ttPosition.placement);\n                  $position.positionArrow(tooltip, ttPosition.placement);\n\n                  positionTimeout = null;\n                }, 0, false);\n              }\n            };\n\n            // Set up the correct scope to allow transclusion later\n            ttScope.origScope = scope;\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            ttScope.isOpen = false;\n            openedTooltips.add(ttScope, {\n              close: hide\n            });\n\n            function toggleTooltipBind() {\n              if (!ttScope.isOpen) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n                return;\n              }\n\n              cancelHide();\n              prepareTooltip();\n\n              if (ttScope.popupDelay) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!showTimeout) {\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n                }\n              } else {\n                show();\n              }\n            }\n\n            function hideTooltipBind() {\n              cancelShow();\n\n              if (ttScope.popupCloseDelay) {\n                if (!hideTimeout) {\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n                }\n              } else {\n                hide();\n              }\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n              cancelShow();\n              cancelHide();\n\n              // Don't show empty tooltips.\n              if (!ttScope.content) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // And show the tooltip.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = true;\n                assignIsOpen(true);\n                positionTooltip();\n              });\n            }\n\n            function cancelShow() {\n              if (showTimeout) {\n                $timeout.cancel(showTimeout);\n                showTimeout = null;\n              }\n\n              if (positionTimeout) {\n                $timeout.cancel(positionTimeout);\n                positionTimeout = null;\n              }\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              if (!ttScope) {\n                return;\n              }\n\n              // First things first: we don't show it anymore.\n              ttScope.$evalAsync(function() {\n                if (ttScope) {\n                  ttScope.isOpen = false;\n                  assignIsOpen(false);\n                  // And now we remove it from the DOM. However, if we have animation, we\n                  // need to wait for it to expire beforehand.\n                  // FIXME: this is a placeholder for a port of the transitions library.\n                  // The fade transition in TWBS is 150ms.\n                  if (ttScope.animation) {\n                    if (!transitionTimeout) {\n                      transitionTimeout = $timeout(removeTooltip, 150, false);\n                    }\n                  } else {\n                    removeTooltip();\n                  }\n                }\n              });\n            }\n\n            function cancelHide() {\n              if (hideTimeout) {\n                $timeout.cancel(hideTimeout);\n                hideTimeout = null;\n              }\n\n              if (transitionTimeout) {\n                $timeout.cancel(transitionTimeout);\n                transitionTimeout = null;\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                return;\n              }\n\n              tooltipLinkedScope = ttScope.$new();\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n                if (appendToBody) {\n                  $document.find('body').append(tooltip);\n                } else {\n                  element.after(tooltip);\n                }\n              });\n\n              prepObservers();\n            }\n\n            function removeTooltip() {\n              cancelShow();\n              cancelHide();\n              unregisterObservers();\n\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n              if (tooltipLinkedScope) {\n                tooltipLinkedScope.$destroy();\n                tooltipLinkedScope = null;\n              }\n            }\n\n            /**\n             * Set the initial scope values. Once\n             * the tooltip is created, the observers\n             * will be added to keep things in sync.\n             */\n            function prepareTooltip() {\n              ttScope.title = attrs[prefix + 'Title'];\n              if (contentParse) {\n                ttScope.content = contentParse(scope);\n              } else {\n                ttScope.content = attrs[ttType];\n              }\n\n              ttScope.popupClass = attrs[prefix + 'Class'];\n              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\n              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n            }\n\n            function assignIsOpen(isOpen) {\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n                isOpenParse.assign(scope, isOpen);\n              }\n            }\n\n            ttScope.contentExp = function() {\n              return ttScope.content;\n            };\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe('disabled', function(val) {\n              if (val) {\n                cancelShow();\n              }\n\n              if (val && ttScope.isOpen) {\n                hide();\n              }\n            });\n\n            if (isOpenParse) {\n              scope.$watch(isOpenParse, function(val) {\n                if (ttScope && !val === ttScope.isOpen) {\n                  toggleTooltipBind();\n                }\n              });\n            }\n\n            function prepObservers() {\n              observers.length = 0;\n\n              if (contentParse) {\n                observers.push(\n                  scope.$watch(contentParse, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    }\n                  })\n                );\n\n                observers.push(\n                  tooltipLinkedScope.$watch(function() {\n                    if (!repositionScheduled) {\n                      repositionScheduled = true;\n                      tooltipLinkedScope.$$postDigest(function() {\n                        repositionScheduled = false;\n                        if (ttScope && ttScope.isOpen) {\n                          positionTooltip();\n                        }\n                      });\n                    }\n                  })\n                );\n              } else {\n                observers.push(\n                  attrs.$observe(ttType, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    } else {\n                      positionTooltip();\n                    }\n                  })\n                );\n              }\n\n              observers.push(\n                attrs.$observe(prefix + 'Title', function(val) {\n                  ttScope.title = val;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n\n              observers.push(\n                attrs.$observe(prefix + 'Placement', function(val) {\n                  ttScope.placement = val ? val : options.placement;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n            }\n\n            function unregisterObservers() {\n              if (observers.length) {\n                angular.forEach(observers, function(observer) {\n                  observer();\n                });\n                observers.length = 0;\n              }\n            }\n\n            // hide tooltips/popovers for outsideClick trigger\n            function bodyHideTooltipBind(e) {\n              if (!ttScope || !ttScope.isOpen || !tooltip) {\n                return;\n              }\n              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked\n              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {\n                hideTooltipBind();\n              }\n            }\n\n            var unregisterTriggers = function() {\n              triggers.show.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  element.off('click', toggleTooltipBind);\n                } else {\n                  element.off(trigger, showTooltipBind);\n                  element.off(trigger, toggleTooltipBind);\n                }\n              });\n              triggers.hide.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  $document.off('click', bodyHideTooltipBind);\n                } else {\n                  element.off(trigger, hideTooltipBind);\n                }\n              });\n            };\n\n            function prepTriggers() {\n              var val = attrs[prefix + 'Trigger'];\n              unregisterTriggers();\n\n              triggers = getTriggers(val);\n\n              if (triggers.show !== 'none') {\n                triggers.show.forEach(function(trigger, idx) {\n                  if (trigger === 'outsideClick') {\n                    element.on('click', toggleTooltipBind);\n                    $document.on('click', bodyHideTooltipBind);\n                  } else if (trigger === triggers.hide[idx]) {\n                    element.on(trigger, toggleTooltipBind);\n                  } else if (trigger) {\n                    element.on(trigger, showTooltipBind);\n                    element.on(triggers.hide[idx], hideTooltipBind);\n                  }\n\n                  element.on('keypress', function(e) {\n                    if (e.which === 27) {\n                      hideTooltipBind();\n                    }\n                  });\n                });\n              }\n            }\n\n            prepTriggers();\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            var appendToBodyVal;\n            var appendKey = prefix + 'AppendToBody';\n            if (appendKey in attrs && attrs[appendKey] === undefined) {\n              appendToBodyVal = true;\n            } else {\n              appendToBodyVal = scope.$eval(attrs[appendKey]);\n            }\n\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n            \n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              unregisterTriggers();\n              removeTooltip();\n              openedTooltips.remove(ttScope);\n              ttScope = null;\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n// This is mostly ngInclude code but with a custom scope\n.directive('uibTooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest',\nfunction ($animate, $sce, $compile, $templateRequest) {\n  return {\n    link: function(scope, elem, attrs) {\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n/**\n * Note that it's intentional that these classes are *not* applied through $animate.\n * They must not be animated as they're expected to be present on the tooltip on\n * initialization.\n */\n.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      // need to set the primary position so the\n      // arrow has space during position measure.\n      // tooltip.positionTooltip()\n      if (scope.placement) {\n        // // There are no top-left etc... classes\n        // // in TWBS, so we need the primary position.\n        var position = $uibPosition.parsePlacement(scope.placement);\n        element.addClass(position[0]);\n      } else {\n        element.addClass('top');\n      }\n\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n}])\n\n.directive('uibTooltipPopup', function() {\n  return {\n    replace: true,\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-popup.html'\n  };\n})\n\n.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('uibTooltipTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'\n  };\n})\n\n.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibTooltipHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'\n  };\n})\n\n.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, and selector delegatation.\n */\nangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\n.directive('uibPopoverTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'uib/template/popover/popover-template.html'\n  };\n})\n\n.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/popover/popover-html.html'\n  };\n})\n\n.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverPopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/popover/popover.html'\n  };\n})\n\n.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopover', 'popover', 'click');\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('uibProgressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n  var self = this,\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = $scope.max;\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n    this.bars.forEach(function (bar) {\n      bar.recalculatePercentage();\n    });\n  };\n\n  $scope.$watch('max', function(max) {\n    self.bars.forEach(function(bar) {\n      bar.max = $scope.max;\n      bar.recalculatePercentage();\n    });\n  });\n}])\n\n.directive('uibProgress', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    require: 'uibProgress',\n    scope: {\n      max: '=?'\n    },\n    templateUrl: 'uib/template/progressbar/progress.html'\n  };\n})\n\n.directive('uibBar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^uibProgress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, element, attrs);\n    }\n  };\n})\n\n.directive('uibProgressbar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    scope: {\n      value: '=',\n      max: '=?',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n});\n\nangular.module('ui.bootstrap.rating', [])\n\n.constant('uibRatingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null,\n  titles : ['one', 'two', 'three', 'four', 'five']\n})\n\n.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl = { $setViewValue: angular.noop };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.push(function(value) {\n      if (angular.isNumber(value) && value << 0 !== value) {\n        value = Math.round(value);\n      }\n\n      return value;\n    });\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n      tmpTitles : ratingConfig.titles;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n      $scope.$parent.$eval($attrs.ratingStates) :\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n    }\n    return states;\n  };\n\n  this.getTitle = function(index) {\n    if (index >= this.titles.length) {\n      return index + 1;\n    }\n\n    return this.titles[index];\n  };\n\n  $scope.rate = function(value) {\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if (!$scope.readonly) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n  };\n}])\n\n.directive('uibRating', function() {\n  return {\n    require: ['uibRating', 'ngModel'],\n    scope: {\n      readonly: '=?',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'UibRatingController',\n    templateUrl: 'uib/template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n});\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('UibTabsetController', ['$scope', function ($scope) {\n  var ctrl = this,\n      tabs = ctrl.tabs = $scope.tabs = [];\n\n  ctrl.select = function(selectedTab) {\n    angular.forEach(tabs, function(tab) {\n      if (tab.active && tab !== selectedTab) {\n        tab.active = false;\n        tab.onDeselect();\n        selectedTab.selectCalled = false;\n      }\n    });\n    selectedTab.active = true;\n    // only call select if it has not already been called\n    if (!selectedTab.selectCalled) {\n      selectedTab.onSelect();\n      selectedTab.selectCalled = true;\n    }\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    tabs.push(tab);\n    // we can't run the select function on the first tab\n    // since that would select it twice\n    if (tabs.length === 1 && tab.active !== false) {\n      tab.active = true;\n    } else if (tab.active) {\n      ctrl.select(tab);\n    } else {\n      tab.active = false;\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index = tabs.indexOf(tab);\n    //Select a new tab if the tab to be removed is selected and not destroyed\n    if (tab.active && tabs.length > 1 && !destroyed) {\n      //If this is the last tab, select the previous tab. else, the next tab.\n      var newActiveIndex = index === tabs.length - 1 ? index - 1 : index + 1;\n      ctrl.select(tabs[newActiveIndex]);\n    }\n    tabs.splice(index, 1);\n  };\n\n  var destroyed;\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n}])\n\n.directive('uibTabset', function() {\n  return {\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@'\n    },\n    controller: 'UibTabsetController',\n    templateUrl: 'uib/template/tabs/tabset.html',\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n.directive('uibTab', ['$parse', function($parse) {\n  return {\n    require: '^uibTabset',\n    replace: true,\n    templateUrl: 'uib/template/tabs/tab.html',\n    transclude: true,\n    scope: {\n      active: '=?',\n      heading: '@',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    controllerAs: 'tab',\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n      scope.$watch('active', function(active) {\n        if (active) {\n          tabsetCtrl.select(scope);\n        }\n      });\n\n      scope.disabled = false;\n      if (attrs.disable) {\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\n          scope.disabled = !! value;\n        });\n      }\n\n      scope.select = function() {\n        if (!scope.disabled) {\n          scope.active = true;\n        }\n      };\n\n      tabsetCtrl.addTab(scope);\n      scope.$on('$destroy', function() {\n        tabsetCtrl.removeTab(scope);\n      });\n\n      //We need to transclude later, once the content container is ready.\n      //when this link happens, we're inside a tab heading.\n      scope.$transcludeFn = transclude;\n    }\n  };\n}])\n\n.directive('uibTabHeadingTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTab',\n    link: function(scope, elm) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n})\n\n.directive('uibTabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTabset',\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.uibTabContentTransclude);\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n\n  function isTabHeading(node) {\n    return node.tagName && (\n      node.hasAttribute('uib-tab-heading') ||\n      node.hasAttribute('data-uib-tab-heading') ||\n      node.hasAttribute('x-uib-tab-heading') ||\n      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n    );\n  }\n});\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('uibTimepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  secondStep: 1,\n  showMeridian: true,\n  showSeconds: false,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true,\n  arrowkeys: true,\n  showSpinners: true,\n  templateUrl: 'uib/template/timepicker/timepicker.html'\n})\n\n.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var selected = new Date(),\n    watchers = [],\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n  $element.removeAttr('tabindex');\n\n  this.init = function(ngModelCtrl_, inputs) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\n      return modelValue ? new Date(modelValue) : null;\n    });\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1),\n        secondsInputEl = inputs.eq(2);\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\n    if (mousewheel) {\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n    if (arrowkeys) {\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = +value;\n    }));\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = +value;\n    }));\n  }\n\n  var min;\n  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {\n    var dt = new Date(value);\n    min = isNaN(dt) ? undefined : dt;\n  }));\n\n  var max;\n  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {\n    var dt = new Date(value);\n    max = isNaN(dt) ? undefined : dt;\n  }));\n\n  var disabled = false;\n  if ($attrs.ngDisabled) {\n    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {\n      disabled = value;\n    }));\n  }\n\n  $scope.noIncrementHours = function() {\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementHours = function() {\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementMinutes = function() {\n    var incrementedSelected = addMinutes(selected, minuteStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementMinutes = function() {\n    var decrementedSelected = addMinutes(selected, -minuteStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementSeconds = function() {\n    var incrementedSelected = addSeconds(selected, secondStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementSeconds = function() {\n    var decrementedSelected = addSeconds(selected, -secondStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noToggleMeridian = function() {\n    if (selected.getHours() < 12) {\n      return disabled || addMinutes(selected, 12 * 60) > max;\n    }\n\n    return disabled || addMinutes(selected, -12 * 60) < min;\n  };\n\n  var secondStep = timepickerConfig.secondStep;\n  if ($attrs.secondStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {\n      secondStep = +value;\n    }));\n  }\n\n  $scope.showSeconds = timepickerConfig.showSeconds;\n  if ($attrs.showSeconds) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {\n      $scope.showSeconds = !!value;\n    }));\n  }\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if (ngModelCtrl.$error.time) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n          selected.setHours(hours);\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    }));\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate() {\n    var hours = +$scope.hours;\n    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :\n      hours >= 0 && hours < 24;\n    if (!valid) {\n      return undefined;\n    }\n\n    if ($scope.showMeridian) {\n      if (hours === 12) {\n        hours = 0;\n      }\n      if ($scope.meridian === meridians[1]) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = +$scope.minutes;\n    return minutes >= 0 && minutes < 60 ? minutes : undefined;\n  }\n\n  function getSecondsFromTemplate() {\n    var seconds = +$scope.seconds;\n    return seconds >= 0 && seconds < 60 ? seconds : undefined;\n  }\n\n  function pad(value) {\n    if (value === null) {\n      return '';\n    }\n\n    return angular.isDefined(value) && value.toString().length < 2 ?\n      '0' + value : value.toString();\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;\n      return e.detail || delta > 0;\n    };\n\n    hoursInputEl.bind('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n      }\n      e.preventDefault();\n    });\n\n    minutesInputEl.bind('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n      }\n      e.preventDefault();\n    });\n\n     secondsInputEl.bind('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());\n      }\n      e.preventDefault();\n    });\n  };\n\n  // Respond on up/down arrowkeys\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    hoursInputEl.bind('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementHours();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementHours();\n          $scope.$apply();\n        }\n      }\n    });\n\n    minutesInputEl.bind('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementMinutes();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementMinutes();\n          $scope.$apply();\n        }\n      }\n    });\n\n    secondsInputEl.bind('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementSeconds();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementSeconds();\n          $scope.$apply();\n        }\n      }\n    });\n  };\n\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    if ($scope.readonlyInput) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      $scope.updateSeconds = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {\n      ngModelCtrl.$setViewValue(null);\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n      }\n\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n      }\n\n      if (angular.isDefined(invalidSeconds)) {\n        $scope.invalidSeconds = invalidSeconds;\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate(),\n        minutes = getMinutesFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(true);\n        } else {\n          refresh('h');\n        }\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.bind('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if ($scope.hours === null || $scope.hours === '') {\n        invalidate(true);\n      } else if (!$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply(function() {\n          $scope.hours = pad($scope.hours);\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(undefined, true);\n        } else {\n          refresh('m');\n        }\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.bind('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if ($scope.minutes === null) {\n        invalidate(undefined, true);\n      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {\n        $scope.$apply(function() {\n          $scope.minutes = pad($scope.minutes);\n        });\n      }\n    });\n\n    $scope.updateSeconds = function() {\n      var seconds = getSecondsFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(seconds)) {\n        selected.setSeconds(seconds);\n        refresh('s');\n      } else {\n        invalidate(undefined, undefined, true);\n      }\n    };\n\n    secondsInputEl.bind('blur', function(e) {\n      if (!$scope.invalidSeconds && $scope.seconds < 10) {\n        $scope.$apply( function() {\n          $scope.seconds = pad($scope.seconds);\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$viewValue;\n\n    if (isNaN(date)) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if (date) {\n        selected = date;\n      }\n\n      if (selected < min || selected > max) {\n        ngModelCtrl.$setValidity('time', false);\n        $scope.invalidHours = true;\n        $scope.invalidMinutes = true;\n      } else {\n        makeValid();\n      }\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh(keyboardChange) {\n    makeValid();\n    ngModelCtrl.$setViewValue(new Date(selected));\n    updateTemplate(keyboardChange);\n  }\n\n  function makeValid() {\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n    $scope.invalidSeconds = false;\n  }\n\n  function updateTemplate(keyboardChange) {\n    if (!ngModelCtrl.$modelValue) {\n      $scope.hours = null;\n      $scope.minutes = null;\n      $scope.seconds = null;\n      $scope.meridian = meridians[0];\n    } else {\n      var hours = selected.getHours(),\n        minutes = selected.getMinutes(),\n        seconds = selected.getSeconds();\n\n      if ($scope.showMeridian) {\n        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system\n      }\n\n      $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n      if (keyboardChange !== 'm') {\n        $scope.minutes = pad(minutes);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\n      if (keyboardChange !== 's') {\n        $scope.seconds = pad(seconds);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n    }\n  }\n\n  function addSecondsToSelected(seconds) {\n    selected = addSeconds(selected, seconds);\n    refresh();\n  }\n\n  function addMinutes(selected, minutes) {\n    return addSeconds(selected, minutes*60);\n  }\n\n  function addSeconds(date, seconds) {\n    var dt = new Date(date.getTime() + seconds * 1000);\n    var newDate = new Date(date);\n    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());\n    return newDate;\n  }\n\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\n  $scope.incrementHours = function() {\n    if (!$scope.noIncrementHours()) {\n      addSecondsToSelected(hourStep * 60 * 60);\n    }\n  };\n\n  $scope.decrementHours = function() {\n    if (!$scope.noDecrementHours()) {\n      addSecondsToSelected(-hourStep * 60 * 60);\n    }\n  };\n\n  $scope.incrementMinutes = function() {\n    if (!$scope.noIncrementMinutes()) {\n      addSecondsToSelected(minuteStep * 60);\n    }\n  };\n\n  $scope.decrementMinutes = function() {\n    if (!$scope.noDecrementMinutes()) {\n      addSecondsToSelected(-minuteStep * 60);\n    }\n  };\n\n  $scope.incrementSeconds = function() {\n    if (!$scope.noIncrementSeconds()) {\n      addSecondsToSelected(secondStep);\n    }\n  };\n\n  $scope.decrementSeconds = function() {\n    if (!$scope.noDecrementSeconds()) {\n      addSecondsToSelected(-secondStep);\n    }\n  };\n\n  $scope.toggleMeridian = function() {\n    var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n    if (!$scope.noToggleMeridian()) {\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));\n      } else {\n        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];\n      }\n    }\n  };\n\n  $scope.blur = function() {\n    ngModelCtrl.$setTouched();\n  };\n\n  $scope.$on('$destroy', function() {\n    while (watchers.length) {\n      watchers.shift()();\n    }\n  });\n}])\n\n.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {\n  return {\n    require: ['uibTimepicker', '?^ngModel'],\n    controller: 'UibTimepickerController',\n    controllerAs: 'timepicker',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || uibTimepickerConfig.templateUrl;\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n    return {\n      parse: function(input) {\n        var match = input.match(TYPEAHEAD_REGEXP);\n        if (!match) {\n          throw new Error(\n            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n              ' but got \"' + input + '\".');\n        }\n\n        return {\n          itemName: match[3],\n          source: $parse(match[4]),\n          viewMapper: $parse(match[2] || match[1]),\n          modelMapper: $parse(match[1])\n        };\n      }\n    };\n  }])\n\n  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    var modelCtrl, ngModelOptions;\n    //SUPPORTED ATTRIBUTES (OPTIONS)\n\n    //minimal no of characters that needs to be entered before typeahead kicks-in\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n    if (!minLength && minLength !== 0) {\n      minLength = 1;\n    }\n\n    //minimal wait time after last character typed before typeahead kicks-in\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n    //should it restrict model values to the ones selected from the popup only?\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {\n      isEditable = newVal !== false;\n    });\n\n    //binding to a variable that indicates if matches are being retrieved asynchronously\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n    //a callback executed when a match is selected\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n    //should it select highlighted popup value when losing focus?\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n    //binding to a variable that indicates if there were no results after the query is completed\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n    var appendTo = attrs.typeaheadAppendTo ?\n      originalScope.$eval(attrs.typeaheadAppendTo) : null;\n\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n    //If input matches an item of the list exactly, select it automatically\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n    //binding to a variable that indicates if dropdown is open\n    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;\n\n    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;\n\n    //INTERNAL VARIABLES\n\n    //model setter executed upon match selection\n    var parsedModel = $parse(attrs.ngModel);\n    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n    var $setModelValue = function(scope, newValue) {\n      if (angular.isFunction(parsedModel(originalScope)) &&\n        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n        return invokeModelSetter(scope, {$$$p: newValue});\n      }\n\n      return parsedModel.assign(scope, newValue);\n    };\n\n    //expressions used by typeahead\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\n    var hasFocus;\n\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n    //mousedown & mouseup events\n    //Issue #3699\n    var selected;\n\n    //create a child scope for the typeahead directive so we are not polluting original scope\n    //with typeahead-specific data (matches, query etc.)\n    var scope = originalScope.$new();\n    var offDestroy = originalScope.$on('$destroy', function() {\n      scope.$destroy();\n    });\n    scope.$on('$destroy', offDestroy);\n\n    // WAI-ARIA\n    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n    element.attr({\n      'aria-autocomplete': 'list',\n      'aria-expanded': false,\n      'aria-owns': popupId\n    });\n\n    var inputsContainer, hintInputElem;\n    //add read-only input to show hint\n    if (showHint) {\n      inputsContainer = angular.element('<div></div>');\n      inputsContainer.css('position', 'relative');\n      element.after(inputsContainer);\n      hintInputElem = element.clone();\n      hintInputElem.attr('placeholder', '');\n      hintInputElem.val('');\n      hintInputElem.css({\n        'position': 'absolute',\n        'top': '0px',\n        'left': '0px',\n        'border-color': 'transparent',\n        'box-shadow': 'none',\n        'opacity': 1,\n        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',\n        'color': '#999'\n      });\n      element.css({\n        'position': 'relative',\n        'vertical-align': 'top',\n        'background-color': 'transparent'\n      });\n      inputsContainer.append(hintInputElem);\n      hintInputElem.after(element);\n    }\n\n    //pop-up element used to display matches\n    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n    popUpEl.attr({\n      id: popupId,\n      matches: 'matches',\n      active: 'activeIdx',\n      select: 'select(activeIdx, evt)',\n      'move-in-progress': 'moveInProgress',\n      query: 'query',\n      position: 'position',\n      'assign-is-open': 'assignIsOpen(isOpen)',\n      debounce: 'debounceUpdate'\n    });\n    //custom item template\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n    }\n\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n    }\n\n    var resetHint = function() {\n      if (showHint) {\n        hintInputElem.val('');\n      }\n    };\n\n    var resetMatches = function() {\n      scope.matches = [];\n      scope.activeIdx = -1;\n      element.attr('aria-expanded', false);\n      resetHint();\n    };\n\n    var getMatchId = function(index) {\n      return popupId + '-option-' + index;\n    };\n\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n    // This attribute is added or removed automatically when the `activeIdx` changes.\n    scope.$watch('activeIdx', function(index) {\n      if (index < 0) {\n        element.removeAttr('aria-activedescendant');\n      } else {\n        element.attr('aria-activedescendant', getMatchId(index));\n      }\n    });\n\n    var inputIsExactMatch = function(inputValue, index) {\n      if (scope.matches.length > index && inputValue) {\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n      }\n\n      return false;\n    };\n\n    var getMatchesAsync = function(inputValue, evt) {\n      var locals = {$viewValue: inputValue};\n      isLoadingSetter(originalScope, true);\n      isNoResultsSetter(originalScope, false);\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n        //it might happen that several async queries were in progress if a user were typing fast\n        //but we are interested only in responses that correspond to the current view value\n        var onCurrentRequest = inputValue === modelCtrl.$viewValue;\n        if (onCurrentRequest && hasFocus) {\n          if (matches && matches.length > 0) {\n            scope.activeIdx = focusFirst ? 0 : -1;\n            isNoResultsSetter(originalScope, false);\n            scope.matches.length = 0;\n\n            //transform labels\n            for (var i = 0; i < matches.length; i++) {\n              locals[parserResult.itemName] = matches[i];\n              scope.matches.push({\n                id: getMatchId(i),\n                label: parserResult.viewMapper(scope, locals),\n                model: matches[i]\n              });\n            }\n\n            scope.query = inputValue;\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n            //due to other elements being rendered\n            recalculatePosition();\n\n            element.attr('aria-expanded', true);\n\n            //Select the single remaining option if user input matches\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n                $$debounce(function() {\n                  scope.select(0, evt);\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n              } else {\n                scope.select(0, evt);\n              }\n            }\n\n            if (showHint) {\n              var firstLabel = scope.matches[0].label;\n              if (angular.isString(inputValue) &&\n                inputValue.length > 0 &&\n                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {\n                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));\n              } else {\n                hintInputElem.val('');\n              }\n            }\n          } else {\n            resetMatches();\n            isNoResultsSetter(originalScope, true);\n          }\n        }\n        if (onCurrentRequest) {\n          isLoadingSetter(originalScope, false);\n        }\n      }, function() {\n        resetMatches();\n        isLoadingSetter(originalScope, false);\n        isNoResultsSetter(originalScope, true);\n      });\n    };\n\n    // bind events only if appendToBody params exist - performance feature\n    if (appendToBody) {\n      angular.element($window).on('resize', fireRecalculating);\n      $document.find('body').on('scroll', fireRecalculating);\n    }\n\n    // Declare the debounced function outside recalculating for\n    // proper debouncing\n    var debouncedRecalculate = $$debounce(function() {\n      // if popup is visible\n      if (scope.matches.length) {\n        recalculatePosition();\n      }\n\n      scope.moveInProgress = false;\n    }, eventDebounceTime);\n\n    // Default progress type\n    scope.moveInProgress = false;\n\n    function fireRecalculating() {\n      if (!scope.moveInProgress) {\n        scope.moveInProgress = true;\n        scope.$digest();\n      }\n\n      debouncedRecalculate();\n    }\n\n    // recalculate actual position and set new values to scope\n    // after digest loop is popup in right position\n    function recalculatePosition() {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top += element.prop('offsetHeight');\n    }\n\n    //we need to propagate user's query so we can higlight matches\n    scope.query = undefined;\n\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutPromise;\n\n    var scheduleSearchWithTimeout = function(inputValue) {\n      timeoutPromise = $timeout(function() {\n        getMatchesAsync(inputValue);\n      }, waitTime);\n    };\n\n    var cancelPreviousTimeout = function() {\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n    };\n\n    resetMatches();\n\n    scope.assignIsOpen = function (isOpen) {\n      isOpenSetter(originalScope, isOpen);\n    };\n\n    scope.select = function(activeIdx, evt) {\n      //called from within the $digest() cycle\n      var locals = {};\n      var model, item;\n\n      selected = true;\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n      model = parserResult.modelMapper(originalScope, locals);\n      $setModelValue(originalScope, model);\n      modelCtrl.$setValidity('editable', true);\n      modelCtrl.$setValidity('parse', true);\n\n      onSelectCallback(originalScope, {\n        $item: item,\n        $model: model,\n        $label: parserResult.viewMapper(originalScope, locals),\n        $event: evt\n      });\n\n      resetMatches();\n\n      //return focus to the input element if a match was selected via a mouse click event\n      // use timeout to avoid $rootScope:inprog error\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n        $timeout(function() { element[0].focus(); }, 0, false);\n      }\n    };\n\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n    element.on('keydown', function(evt) {\n      //typeahead is open and an \"interesting\" key was pressed\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n        return;\n      }\n\n      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n        resetMatches();\n        scope.$digest();\n        return;\n      }\n\n      evt.preventDefault();\n      var target;\n      switch (evt.which) {\n        case 9:\n        case 13:\n          scope.$apply(function () {\n            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n              $$debounce(function() {\n                scope.select(scope.activeIdx, evt);\n              }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n            } else {\n              scope.select(scope.activeIdx, evt);\n            }\n          });\n          break;\n        case 27:\n          evt.stopPropagation();\n\n          resetMatches();\n          scope.$digest();\n          break;\n        case 38:\n          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n          scope.$digest();\n          target = popUpEl.find('li')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n        case 40:\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n          scope.$digest();\n          target = popUpEl.find('li')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n      }\n    });\n\n    element.bind('focus', function (evt) {\n      hasFocus = true;\n      if (minLength === 0 && !modelCtrl.$viewValue) {\n        $timeout(function() {\n          getMatchesAsync(modelCtrl.$viewValue, evt);\n        }, 0);\n      }\n    });\n\n    element.bind('blur', function(evt) {\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n        selected = true;\n        scope.$apply(function() {\n          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {\n            $$debounce(function() {\n              scope.select(scope.activeIdx, evt);\n            }, scope.debounceUpdate.blur);\n          } else {\n            scope.select(scope.activeIdx, evt);\n          }\n        });\n      }\n      if (!isEditable && modelCtrl.$error.editable) {\n        modelCtrl.$viewValue = '';\n        element.val('');\n      }\n      hasFocus = false;\n      selected = false;\n    });\n\n    // Keep reference to click handler to unbind it.\n    var dismissClickHandler = function(evt) {\n      // Issue #3973\n      // Firefox treats right click as a click on document\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n        resetMatches();\n        if (!$rootScope.$$phase) {\n          scope.$digest();\n        }\n      }\n    };\n\n    $document.on('click', dismissClickHandler);\n\n    originalScope.$on('$destroy', function() {\n      $document.off('click', dismissClickHandler);\n      if (appendToBody || appendTo) {\n        $popup.remove();\n      }\n\n      if (appendToBody) {\n        angular.element($window).off('resize', fireRecalculating);\n        $document.find('body').off('scroll', fireRecalculating);\n      }\n      // Prevent jQuery cache memory leak\n      popUpEl.remove();\n\n      if (showHint) {\n          inputsContainer.remove();\n      }\n    });\n\n    var $popup = $compile(popUpEl)(scope);\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else if (appendTo) {\n      angular.element(appendTo).eq(0).append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    this.init = function(_modelCtrl, _ngModelOptions) {\n      modelCtrl = _modelCtrl;\n      ngModelOptions = _ngModelOptions;\n\n      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function(inputValue) {\n        hasFocus = true;\n\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        }\n\n        if (!inputValue) {\n          // Reset in case user had typed something previously.\n          modelCtrl.$setValidity('editable', true);\n          return null;\n        }\n\n        modelCtrl.$setValidity('editable', false);\n        return undefined;\n      });\n\n      modelCtrl.$formatters.push(function(modelValue) {\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        // The validity may be set to false via $parsers (see above) if\n        // the model is restricted to selected values. If the model\n        // is set manually it is considered to be valid.\n        if (!isEditable) {\n          modelCtrl.$setValidity('editable', true);\n        }\n\n        if (inputFormatter) {\n          locals.$model = modelValue;\n          return inputFormatter(originalScope, locals);\n        }\n\n        //it might happen that we don't have enough info to properly render input value\n        //we need to check for this situation and simply return model value if we can't apply custom formatting\n        locals[parserResult.itemName] = modelValue;\n        candidateViewValue = parserResult.viewMapper(originalScope, locals);\n        locals[parserResult.itemName] = undefined;\n        emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n      });\n    };\n  }])\n\n  .directive('uibTypeahead', function() {\n    return {\n      controller: 'UibTypeaheadController',\n      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n      link: function(originalScope, element, attrs, ctrls) {\n        ctrls[2].init(ctrls[0], ctrls[1]);\n      }\n    };\n  })\n\n  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&',\n        assignIsOpen: '&',\n        debounce: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          var isDropdownOpen = scope.matches.length > 0;\n          scope.assignIsOpen({ isOpen: isDropdownOpen });\n          return isDropdownOpen;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active === matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx, evt) {\n          var debounce = scope.debounce();\n          if (angular.isNumber(debounce) || angular.isObject(debounce)) {\n            $$debounce(function() {\n              scope.select({activeIdx: activeIdx, evt: evt});\n            }, angular.isNumber(debounce) ? debounce : debounce['default']);\n          } else {\n            scope.select({activeIdx: activeIdx, evt: evt});\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n    return {\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link: function(scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          var tplEl = angular.element(tplContent.trim());\n          element.replaceWith(tplEl);\n          $compile(tplEl)(scope);\n        });\n      }\n    };\n  }])\n\n  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n      return matchItem;\n    };\n  }]);\n\nangular.module(\"uib/template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion-group.html\",\n    \"<div class=\\\"panel\\\" ng-class=\\\"panelClass || 'panel-default'\\\">\\n\" +\n    \"  <div role=\\\"tab\\\" id=\\\"{{::headingId}}\\\" aria-selected=\\\"{{isOpen}}\\\" class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n    \"      <a role=\\\"button\\\" data-toggle=\\\"collapse\\\" href aria-expanded=\\\"{{isOpen}}\\\" aria-controls=\\\"{{::panelId}}\\\" tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n    \"    </h4>\\n\" +\n    \"  </div>\\n\" +\n    \"  <div id=\\\"{{::panelId}}\\\" aria-labelledby=\\\"{{::headingId}}\\\" aria-hidden=\\\"{{!isOpen}}\\\" role=\\\"tabpanel\\\" class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n    \"    <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion.html\",\n    \"<div role=\\\"tablist\\\" class=\\\"panel-group\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/alert/alert.html\",\n    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n    \"    </button>\\n\" +\n    \"    <div ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/carousel/carousel.html\",\n    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ol>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"uib/template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/carousel/slide.html\",\n    \"<div ng-class=\\\"{\\n\" +\n    \"    'active': active\\n\" +\n    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/datepicker.html\",\n    \"<div class=\\\"uib-datepicker\\\" ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"uib/template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/day.html\",\n    \"<table class=\\\"uib-daypicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-weeks\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-day text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/month.html\",\n    \"<table class=\\\"uib-monthpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-months\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-month text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/popup.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"uib-datepicker-popup dropdown-menu\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"    <li ng-transclude></li>\\n\" +\n    \"    <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n    \"    <span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today')\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"    </span>\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ul>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/year.html\",\n    \"<table class=\\\"uib-yearpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::columns - 2}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-years\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-year text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/modal/backdrop.html\",\n    \"<div class=\\\"modal-backdrop\\\"\\n\" +\n    \"     uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"     modal-in-class=\\\"in\\\"\\n\" +\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n    \"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/modal/window.html\",\n    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"    modal-in-class=\\\"in\\\"\\n\" +\n    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n    \"    <div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pager/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/pager/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/pagination/pagination.html\",\n    \"<ul class=\\\"pagination\\\">\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-html-popup.html\",\n    \"<div class=\\\"tooltip\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-popup.html\",\n    \"<div class=\\\"tooltip\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-template-popup.html\",\n    \"<div class=\\\"tooltip\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-html.html\",\n    \"<div class=\\\"popover\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-template.html\",\n    \"<div class=\\\"popover\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\"\\n\" +\n    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover.html\",\n    \"<div class=\\\"popover\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/bar.html\",\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n}]);\n\nangular.module(\"uib/template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\">\\n\" +\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tab.html\",\n    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\" class=\\\"uib-tab\\\">\\n\" +\n    \"  <a href ng-click=\\\"select()\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tabset.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n    \"  <div class=\\\"tab-content\\\">\\n\" +\n    \"    <div class=\\\"tab-pane\\\" \\n\" +\n    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/timepicker/timepicker.html\",\n    \"<table class=\\\"uib-timepicker\\\">\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-increment hours\\\"><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-increment minutes\\\"><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-increment seconds\\\"><a ng-click=\\\"incrementSeconds()\\\" ng-class=\\\"{disabled: noIncrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <td class=\\\"form-group uib-time hours\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"HH\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementHours()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time minutes\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"MM\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementMinutes()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time seconds\\\" ng-class=\\\"{'has-error': invalidSeconds}\\\" ng-show=\\\"showSeconds\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"SS\\\" ng-model=\\\"seconds\\\" ng-change=\\\"updateSeconds()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementSeconds()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\" class=\\\"uib-time am-pm\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-decrement hours\\\"><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-decrement minutes\\\"><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-decrement seconds\\\"><a ng-click=\\\"decrementSeconds()\\\" ng-class=\\\"{disabled: noDecrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-match.html\",\n    \"<a href\\n\" +\n    \"   tabindex=\\\"-1\\\"\\n\" +\n    \"   ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"\\n\" +\n    \"   ng-attr-title=\\\"{{match.label}}\\\"></a>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index, $event)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\nangular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); });\nangular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;}.uib-button-bar{padding:10px 9px 2px;}</style>'); });\nangular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'); });\nangular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); });\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/dist/ui-bootstrap-tpls.js\n ** module id = 16\n ** module chunks = 1\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 131\n ** module chunks = 1\n **/"],"sourceRoot":""}