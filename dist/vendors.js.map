{"version":3,"sources":["webpack:///vendors.js","webpack:///webpack/bootstrap c16d6e7161dc5f4d53c1","webpack:///external \"angular\"","webpack:///./~/api-check/dist/api-check.js","webpack:///./~/angular-formly/dist/formly.js","webpack:///./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js","webpack:///./~/angular-permission/dist/angular-permission.js","webpack:///./~/angular-ui-bootstrap/index.js","webpack:///./~/angular-ui-router.statehelper/statehelper.js","webpack:///./~/angular-ui-router/release/angular-ui-router.js","webpack:///./~/ngstorage/ngStorage.js","webpack:///./~/oclazyload/dist/ocLazyLoad.js","webpack:///./~/angular-ui-bootstrap/ui-bootstrap-tpls.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift",2,"e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","angular","root","factory","this","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_apiCheck","_apiCheck2","getApiCheckInstance","apiCheck","api","args","output","config","disabled","globalConfig","apiTypes","argTypes","passed","message","failed","checkApiCheckApi","arguments","Array","isArray","prototype","slice","messages","checkEnoughArgs","checkApiWithArgs","returnObject","getTypes","getErrorMessage","checkApiArgs","isArrayOrArgs","Error","prefix","errors","apiCheckApis","handleErrorMessage","getApiCheck","shouldThrow","result","console","warn","getPrefix","onlyPrefix","gOut","trim","getSuffix","s","onlySuffix","suffix","getUrl","u","url","docsBaseUrl","urlSuffix","join","passedAndShouldHavePassed","buildMessageFromApiAndArgs","replaceFunctionWithName","each","val","name","replacedItems","indexOf","displayName","getObjectString","types","stringify","generateMessage","n","useS","keys","newLine","passedArgs","_getTypes","copy","arrayify","map","checker","index","specified","hasOwnProperty","getCheckerDisplay","terse","verbose","addHelpers","arg","getArgDisplay","extraCheckers","apiCheckApiCheck","getApiCheckInstanceCheckers","additionalProperties","throw","utils","apiCheckUtil","wrapper","checkers","getCheckers","checkerIndex","argIndex","res","lastChecker","argName","argFailed","skipPreviousChecker","isOptional","isError","getCheckerErrorMessage","t","checkerTypeType","checkerType","location","apiCheckDataChecker","shape","string","optional","bool","asFunc","func","withProperties","__apiCheckData","asShape","wrongShape","oneOfType","getError","checkerHelp","getCheckerHelp","_ref","help","requiredArgs","filter","a","gottenArgs","hasKeys","getDisplayIfNotGotten","getDisplay","cName","constructor","typeOf","properties","argDisplay","v","k","getApiCheckApis","os","checkerFnChecker","shortType","notOptional","notRequired","strict","objectOf","typeOrArrayOf","any","VERSION","internalChecker","getSerialize","fn","decycle","seen","key","getPath","ret","path","unshift","spaces","JSON","_defineProperty","enumerable","configurable","writable","daCopy","RegExp","options","display","short","getCheckerType","typeTypes","iterator","context","eachArry","eachObj","hasOwn","list","arry","finalJoin","last","pop","stringType","nAtL","tName","tLocation","thing","undef","setupChecker","getNoop","isNoop","prop","getRequiredVersion","notNullable","addNullable","addOptional","requiredChecker","copyProps","originalChecker","optionalCheck","fixType","nullableCheck","isNullable","nullable","checkerCopy","dest","noop","checkerHelpers","typeOfCheckGetter","lType","toLowerCase","funcCheckGetter","functionChecker","apiError","shapeChecker","notFunction","objectCheckGetter","nullType","objectNullOkChecker","objectChecker","nullOk","instanceCheckGetter","classToCheck","oneOfCheckGetter","enums","enum","enm","some","oneOfTypeCheckGetter","typeCheckers","checkersDisplay","arrayOfCheckGetter","shortCheckerDisplay","array","every","item","objectOfCheckGetter","checkerDisplay","notObject","object","allTypesSuccess","typeOrArrayOfCheckGetter","arrayOf","getShapeCheckGetter","shapeCheckGetter","nonObject","modifyTypeDisplayToHelpOut","theRet","required","addHelper","property","objectMessage","stringMessage","error","toUpperCase","parentRequired","strictType","shapeTypes","isObject","shapePropError","shapeError","allowedProperties","extraProps","getRequiredIfNotChecker","all","otherProps","propChecker","props","ifProps","description","getTypeForShapeChild","propName","propExists","iteration","otherPropsExist","otherProp","ifNot","onlyIf","othersPresent","requiredIfNot","argumentsCheckerGetter","number","anyCheckGetter","nullCheckGetter","rangeCheckGetter","min","max","lessThanCheckGetter","greaterThanCheckGetter","emptyObjectCheckGetter","emptyObject","instanceOf","oneOf","range","lessThan","greaterThan","null","_require","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_5__","_indexCommon","_indexCommon2","_angularFix","_angularFix2","_providersFormlyApiCheck","_providersFormlyApiCheck2","_otherDocsBaseUrl","_otherDocsBaseUrl2","_providersFormlyUsability","_providersFormlyUsability2","_providersFormlyConfig","_providersFormlyConfig2","_providersFormlyValidationMessages","_providersFormlyValidationMessages2","_servicesFormlyUtil","_servicesFormlyUtil2","_servicesFormlyWarn","_servicesFormlyWarn2","_directivesFormlyCustomValidation","_directivesFormlyCustomValidation2","_directivesFormlyField","_directivesFormlyField2","_directivesFormlyFocus","_directivesFormlyFocus2","_directivesFormlyForm","_directivesFormlyForm2","_runFormlyNgModelAttrsManipulator","_runFormlyNgModelAttrsManipulator2","_runFormlyCustomTags","_runFormlyCustomTags2","ngModuleName","ngModule","constant","provider","directive","run","version","shapeRequiredIfNot","shapeRequiredIfNotDefinition","formlyExpression","specifyWrapperType","apiCheckProperty","apiCheckInstanceProperty","apiCheckFunctionProperty","formlyWrapperType","template","templateUrl","overwriteOk","apiCheckInstance","apiCheckFunction","apiCheckOptions","expressionProperties","expression","modelChecker","templateManipulators","preWrapper","postWrapper","validatorChecker","fieldOptionsApiShape","$$hashKey","model","originalModel","className","extras","validateOnModelChange","skipNgModelAttrsManipulator","data","templateOptions","modelOptions","updateOn","debounce","allowInvalid","getterSetter","timezone","watcher","listener","validators","asyncValidators","parsers","formatters","noFormControl","hide","hideExpression","ngModelElAttrs","ngModelAttrs","statement","attribute","bound","boolean","elementAttributes","optionsTypes","link","controller","validation","show","errorExistsAndShouldBeVisible","formControl","runExpressions","resetModel","updateInitialValue","initialValue","defaultValue","formlyFieldOptions","formOptionsApi","formState","removeChromeAutoComplete","fieldTransform","fieldGroup","form","typeOptionsDefaultOptions","formlyTypeOptions","defaultOptions","extends","extend","formlyUsability","formlyApiCheck","formlyErrorAndWarningsUrlPrefix","getFieldError","errorInfoSlug","field","toJson","getFormlyError","checkWrapper","checkWrapperTemplate","additionalInfo","formlyTransclude","_this","$get","$inject","_toConsumableArray","arr","arr2","from","formlyConfig","formlyUsabilityProvider","setType","checkType","extendTypeOptions","typeMap","_ret","allTypes","forEach","checkOverwrite","extendsType","getType","extendTypeControllerFunction","extendTypeLinkFunction","extendTypeDefaultOptions","_otherUtils2","reverseDeepMerge","extendTemplate","extendsCtrl","isDefined","optionsCtrl","$scope","$controller","extendsFn","optionsFn","extendsDO","optionsDO","optionsDOIsFn","isFunction","extendsDOIsFn","opts","scope","extendsDefaultOptions","mergedDefaultOptions","extenderOptionsDefaultOptions","newDefaultOptions","throwError","errorContext","getTypeHeritage","parent","heritage","isString","setWrapper","_x","_x2","_again","wrapperOptions","getOptionsTypes","getOptionsName","checkWrapperAPI","templateWrappersMap","defaultWrapperName","checkWrapperTypes","newValue","objectName","getWrapper","getWrapperByType","wrappers","_name","removeWrapperByName","removeWrappersForType","disableWarnings","warnInfoSlug","_this2","disableNgModelAttrsManipulator","ngModelAttrsManipulatorPreferUnbound","defaultHideDirective","getFieldId","_otherUtils","formlyEval","$modelValue","$viewValue","extraLocals","$eval","formId","objAndSameType","obj1","obj2","getPrototypeOf","findByNodeName","el","nodeName","element","children","node","extendFunction","_len","fns","_key","extendArray","primary","secondary","startsWith","str","search","substring","contains","formlyValidationMessages","addTemplateOptionValueMessage","alternate","validationMessages","templateOptionValue","addStringMessage","viewValue","modelValue","formlyUtil","formlyWarn","$log","formlyCustomValidation","restrict","require","attrs","ctrl","addValidatorToPipeline","isAsync","validator","setupMessage","useNewValidatorsApi","setupWithValidators","setupWithParsers","validatorCollection","inFlightValidator","$parsers","isValid","$pending","then","$setValidity","bind","formlyField","$http","$q","$compile","$templateCache","$interpolate","FormlyFieldController","$timeout","$parse","currentValue","valueGetterSetter","setter","assign","promise","when","newVal","parseSet","parseGet","isNumber","simplifyLife","to","formOptions","setFieldIdAndName","formName","$name","setDefaultValue","setInitialValue","mergeFieldOptionsWithTypeDefaults","mergeOptions","properOrder","reverse","typeName","extraOptions","extendOptionsWithDefaults","resetFormControl","isMultiNgModel","$setViewValue","$render","$setUntouched","$setPristine","$root","$$phase","$digest","addValidationMessages","invokeControllers","setupFieldGroup","fieldType","getFieldType","checkApi","fieldLink","formlyFormCtrl","setFieldGroupTemplate","checkFieldGroupApi","addClass","extraAttributes","getTemplate","transcludeInWrappers","setElementTemplate","addAttributes","attr","addClasses","templateString","html","asHtml","contents","watchFormControl","watchFieldNameOrExistence","nameExpressionRegex","nameExpression","exec","watchFieldExistence","$watch","fieldCount","fc","stopWatchingShowError","addShowMessagesWatcher","addParsers","addFormatters","customExpression","errorExistsAndShouldBeVisibleExpression","formControls","$invalid","noTouchedButDirty","isUndefined","$touched","$dirty","showError","setParsersOrFormatters","formWasPristine","$pristine","$formatters","formatter","which","getThingsFromType","theType","typeThings","getDefaultOptionsProperty","getThingsFromOptionsTypes","getDefaultOptionsOptionsTypes","optionsTypesThings","optionsTypeName","getFormlyExpressionThing","formlyExpressionParserOrFormatterFunction","originalThingProp","things","ngModelCtrls","ngModelCtrl","_ngModelCtrl","concat","templateEl","ngModelNodes","querySelectorAll","ngModelNode","getAttribute","callLinkFunctions","thusly","runManipulators","manipulators","templateToManipulate","chain","manipulator","newTemplate","fieldManipulators","getManipulators","getFieldTemplate","append","addManipulators","_ref$preWrapper","pre","_ref$postWrapper","post","fromOptionsOrType","isUrl","templatePromise","_ret2","httpOptions","cache","get","response","getWrapperOption","aWrapper","runApiCheck","promises","w","wrappersTemplates","wrapperTemplate","totalWrapper","doTransclusion","superWrapper","transcludeEl","find","replaceWith","typeWrappers","formWrappers","defaultWrapper","_ref2","forType","runApiCheckForType","instance","checkerObjects","checkOptions","transclude","fields","formlyFocus","$document","previousEl","doc","$observe","activeElement","focus","focusWait","blur","formlyForm","formlyFormGetTemplate","getRootEl","rootEl","getFieldRootEl","fieldRootEl","getHideDirective","hideDirective","getTrackBy","trackBy","getFormName","bindName","minor","startSymbol","endSymbol","getTranscludeClass","transcludeClass","copyAttributes","attributes","excluded","arrayAttrs","toKebabCase","currentFormId","parentFormAttributes","hasClass","FormlyFormController","onModelOrFormStateChange","evalCloseToFormlyExpression","validate","$validate","setupFields","checkDeprecatedOptions","fieldTransforms","setupModels","attachKey","setupWatchers","setupOptions","isFieldGroup","watchedModels","isNewModel","initModel","refrencesCurrentlyWatchedModel","watchers","watchExpression","getWatchExpression","watchListener","getWatchListener","stopWatching","watchDeep","originalExpression","modifyArgs","_slice","originalListener","originalArgs","getFormlyFieldLikeLocals","formlyFormLink","setFormController","theFormlyForm","getter","parentForm","$parent","$removeControl","removeData","fixChromeAutocomplete","global","offInstance","onInstance","input","setAttribute","replace","$1","addFormlyNgModelAttrsManipulator","ngModelAttrsManipulator","addValidation","addIfNotPresent","modelNodes","alterNgModelAttr","isPropertyAccessor","addRegardlessOfPresence","addModelOptions","addTemplateOptionsAttrs","ep","ngModelAttributes","getBuiltInAttributes","attrVal","attrName","ref","toVal","epVal","getEpValue","inTo","inEp","addNgModelElAttrs","skip","innerHTML","getNgModelNodes","selectorNot","skipNot","query","getNgModelNodesFallback","allNgModelNodes","matchingNgModelNodes","hasAttribute","nodeMatches","selector","div","outerHTML","querySelector","boundOnly","bothBooleanAndBound","bothAttributeAndBound","statementOnly","attributeOnly","substr","nodes","addCustomTags","documentMode","customElements","__WEBPACK_EXTERNAL_MODULE_4__","addWrappers","formlyConfigProvider","check","label","labelSrOnly","addCheckboxType","labelProp","valueProp","checkValidity","expressionValue","valid","setModel","multiCheckbox","checked","checkbox","$setTouched","change","newModelValue","newOptionsValues","unwatchFormControl","addInputType","addRadioType","addSelectType","ngOptions","optionsAttr","groupProp","addTextareaType","rows","cols","_addons","_addons2","_description","_description2","addAddonsManipulator","formlyBootstrapApiCheck","addonTemplate","addonChecker","class","text","onClick","addonLeft","addonRight","addDescriptionManipulator","modelEls","$rootScope","Permission","$state","$on","event","toState","toParams","fromState","fromParams","$$finishAuthorize","permissions","log","preventDefault","$broadcast","defaultPrevented","authorize","go","notify","redirectTo","newState","roleValidationConfig","validateRoleDefinitionParams","roleName","validationFunction","validateManyRolesDefinitionParams","roles","defineRole","_promiseify","deferred","defer","resolve","reject","_validateRoleMap","roleMap","only","except","_findMatchingRole","rolesArray","currentRole","roleValidations","validatingRole","defineManyRoles","definedPermissions","resolveIfMatch","rejectIfMatch","authorizing","$stateProvider","fixStateName","state","addSiblings","childState","idx","nextSibling","previousSibling","self","keepOriginalNames","siblingTraversal","setNestedState","inherit","extra","merge","dst","ancestors","first","second","objectKeys","Number","len","Math","ceil","floor","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","j","equalForKeys","b","filterByKeys","values","filtered","pick","omit","collection","$Resolve","$injector","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","$$promises","$$values","study","invocables","visit","visited","cycle","splice","plan","annotate","param","isResolve","invocableKeys","locals","done","wait","merged","$$inheritedValues","resolution","fail","reason","$$failure","invoke","invocable","onfailure","invocation","proceed","waitParams","dep","ii","$TemplateFactory","fromConfig","fromString","fromUrl","templateProvider","fromProvider","headers","Accept","UrlMatcher","pattern","parentMatcher","addParameter","paramNames","test","$$UMFP","Param","quoteRegExp","squash","surroundPattern","matchDetails","isSearch","regexp","segment","cfg","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","lastIndex","sourceSearch","sourcePath","$$paramNames","Type","$UrlMatcherFactory","valToString","toString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","parseInt","date","getFullYear","getMonth","getDate","match","capture","Date","isNaN","valueOf","equals","toISOString","json","fromJson","identity","$$getDefaultValue","strictMode","compile","isMatcher","o","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","ignore","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","handler","$match","$location","$browser","appendBasePath","isHtml5","absolute","baseHref","update","evt","rule","handled","lastPushedUrl","rules","otherwise","listen","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","href","validates","html5Mode","enabled","hashPrefix","slash","port","protocol","host","redirect","handlerIsString","strategies","matcher","regex","sticky","deferIntercept","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","split","pathLength","current","states","queueState","parentName","queue","flushQueuedChildren","queued","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","l","MAX_VALUE","decorator","$view","$resolve","$urlRouter","handleRedirect","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","resolveState","paramsAreFiltered","resolveViews","viewsPromises","views","view","injectables","$template","load","globals","controllerProvider","injectLocals","$$controller","$$state","$$controllerAs","controllerAs","TransitionPrevented","reload","relative","fromPath","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","resolved","entering","exiting","onExit","onEnter","includes","lossy","nav","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","charAt","","abstract","$ViewProvider","$templateFactory","defaults","$ViewScrollProvider","useAnchorScroll","$anchorScroll","$element","scrollIntoView","$ViewDirective","$uiViewScroll","getService","service","has","getRenderer","statics","enter","target","cb","after","leave","remove","$animate","$animator","animate","terminal","priority","tElement","tAttrs","$transclude","cleanupLastView","currentScope","$destroy","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","clone","$emit","autoScrollExp","onloadExp","onload","autoscroll","$ViewDirectiveFill","initial","uiView","inheritedData","parseStateRef","parsed","preparsed","paramExpr","stateContext","stateData","$StateRefDirective","allowedOptions","uiSrefActive","uiSref","hrefKind","newHref","isAnchor","isForm","optionsOverride","uiSrefOpts","option","activeDirective","$$addStateInfo","$set","oldVal","button","ctrlKey","metaKey","shiftKey","ignorePreventDefaultCount","cancel","$StateRefActiveDirective","$attrs","anyMatch","activeClass","removeClass","isMatch","uiSrefActiveEq","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","charCodeAt","isPathParam","isDefaultValue","nextSegment","$subPattern","sub","mode","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_storageProvider","storageType","storageKeyPrefix","setKeyPrefix","TypeError","serializer","deserializer","setSerializer","setDeserializer","d","getItem","set","setItem","$window","isStorageSupported","supported","err","round","random","localStorage","removeItem","_last$storage","_debounce","prefixLength","webStorage","$storage","$default","items","$sync","$reset","$apply","temp$storage","addEventListener","hasFocus","regModules","regInvokes","regConfigs","modulesToLoad","realModules","recordDeclarations","broadcast","runBlocks","justLoaded","ocLazyLoad","$controllerProvider","$provide","$compileProvider","$filterProvider","$animateProvider","_register","providers","registerModules","moduleName","moduleFn","tempRunBlocks","getModuleName","newModule","ngModuleFct","requires","_runBlocks","rerun","_invokeQueue","reconfig","_configBlocks","instanceInjector","getInstanceInjector","_registerInvokeList","checkHashes","potentialNew","invokes","newHash","isNew","signature","hashCode","invokeList","newInvoke","onInvoke","invokeName","callInvoke","fct","invoked","jlen","moduleExists","debug","events","moduleCache","modulePromises","moduleConfig","_init","elements","names","NG_APP_CLASS_REGEXP","elm","getElementById","jasmine","mocha","mock","addReg","mainModule","chr","$rootElement","$cacheFactory","filesCache","eventName","info","_broadcast","_$log","_getFilesCache","toggleWatch","watch","getModuleConfig","setModuleConfig","getModules","isLoaded","modulesNames","moduleLoaded","_getModuleName","_getModule","_loadDependencies","localParams","loadedModule","diff","promisesList","getRequires","requireEntry","files","filesLoader","entry","inject","real","_addToLoadList","loadNext","requireModule","_unregister","bootstrapFct","bootstrap","force","configFn","$ocLazyLoad","content","$attr","$delegate","$interval","uaCssChecked","useCssLoadPatch","anchor","buildElement","cacheBuster","dc","getTime","put","onerror","serie","insertBeforeElem","lastChild","insertBefore","jQuery","parentNode","ua","navigator","userAgent","platform","appVersion","iOSVersion","parseFloat","androidVersion","versionMatch","tries","interval","sheet","cssRules","cssFiles","templatesFiles","jsFiles","cachePromise","pushFile","file_type","jsLoader","cssDeferred","cssLoader","templatesDeferred","templatesLoader","jsDeferred","originalModule","errText","originalParams","deferredList","paths","ocLazyLoadLoader","success","searchElement","fromIndex","O","abs","Infinity","$animateCss","expand","easing","height","scrollHeight","start","expandDone","css","collapse","collapseDone","uibCollapse","shouldCollapse","$collapseSuppressWarning","closeOthers","accordionConfig","groups","openGroup","group","isOpen","addGroup","groupScope","that","removeGroup","heading","isDisabled","setHeading","accordionCtrl","openClass","panelClass","toggleClass","toggleOpen","$event","accordionGroupCtrl","uibAccordionTransclude","$accordionSuppressWarning","accordionTransclude","closeable","close","dismissOnTimeout","$alertSuppressWarning","toggleEvent","buttonConfig","ctrls","buttonsCtrl","uibBtnRadio","on","isActive","uncheckable","getTrueValue","getCheckboxValue","btnCheckboxTrue","getFalseValue","btnCheckboxFalse","$buttonsSuppressWarning","btnRadio","attributeValue","goNext","slide","direction","destroyed","active","currentSlide","noTransition","$currentTransition","slides","SLIDE_DIRECTION","NEW_ANIMATE","phase","off","one","currentIndex","restartTimer","getSlideByIndex","resetTimer","currentInterval","timerFn","isPlaying","next","pause","resetTransition","NO_TRANSITION","select","nextSlide","nextIndex","indexOfSlide","getCurrentIndex","newIndex","noWrap","prev","$watchCollection","play","noPause","addSlide","removeSlide","sort","actual","carouselCtrl","animation","beforeAddClass","stopped","directionClass","removeClassFn","beforeRemoveClass","$carouselSuppressWarning","$locale","orderByFilter","createParser","formatCodeToRegex","code","year","month","localeId","SPECIAL_CHARACTERS_REGEXP","init","yyyy","yy","y","MMMM","DATETIME_FORMATS","MONTH","MMM","SHORTMONTH","MM","M","dd","EEEE","DAY","EEE","SHORTDAY","HH","hours","hh","H","h","mm","minutes","sss","milliseconds","ss","seconds","AMPMS","parse","baseDate","parser","results","dt","isDate","getHours","getMinutes","getSeconds","getMilliseconds","mapper","setFullYear","$dateParserSuppressWarning","uibDateParser","getStyle","cssprop","currentStyle","getComputedStyle","style","isStaticPositioned","parentOffsetEl","docDomEl","offsetParent","position","elBCR","offset","offsetParentBCR","top","offsetParentEl","clientTop","scrollTop","clientLeft","scrollLeft","boundingClientRect","getBoundingClientRect","width","pageYOffset","documentElement","pageXOffset","positionElements","hostEl","targetEl","positionStr","appendToBody","hostElPos","targetElWidth","targetElHeight","targetElPos","positionStrParts","pos0","pos1","shiftWidth","center","shiftHeight","bottom","$positionSuppressWarning","$uibPosition","formatDay","formatMonth","formatYear","formatDayHeader","formatDayTitle","formatMonthTitle","datepickerMode","minMode","maxMode","showWeeks","startingDay","yearRange","minDate","maxDate","shortcutPropagation","dateFilter","datepickerConfig","$datepickerSuppressError","modes","refreshView","uniqueId","$id","initDate","activeDate","$isEmpty","dateObject","compare","activeDateId","uid","ngModelCtrl_","render","_refreshView","createDateObject","selected","customClass","dateDisabled","size","arrays","move","step","years","months","toggleMode",13,32,33,34,35,36,37,38,39,40,"focusElement","keydown","altKey","stopPropagation","handleKeyDown","getDaysInMonth","DAYS_IN_MONTH","getISO8601WeekNumber","checkDate","setDate","getDay","time","setMonth","getDates","startDate","dates","firstDayOfMonth","difference","numDisplayedFromPreviousMonth","firstDate","days","labels","abbr","full","title","weekNumbers","thursdayIndex","numWeeks","curWeek","date1","date2","getStartingYear","yearpickerInit","datepickerCtrl","daypickerCtrl","monthpickerCtrl","datepickerPopup","datepickerPopupTemplateUrl","datepickerTemplateUrl","html5Types","datetime-local","currentText","clearText","closeText","closeOnDateSelection","showButtonBar","onOpenFocus","$position","dateParser","datepickerPopupConfig","cameltoDash","parseDate","dateFormat","ngRequired","documentClickBind","popup","$popup","dpContainsTarget","popupContainsTarget","inputKeydownBind","popupEl","datepickerEl","ngModel","isHtml5DateInput","watchData","_ngModel_","datepickerAppendToBody","uibDatepickerPopup","oldValue","newDateFormat","ng-model","ng-change","template-url","datepickerOptions","oldvalue","$$parserName","$validators","$viewChangeListeners","unbind","getText","dateSelection","today","setHours","$datepickerSuppressWarning","fixTimeZone","openScope","open","dropdownScope","closeDropdown","keybindFilter","getAutoClose","toggleElement","getToggleElement","dropdownElement","getDropdownElement","focusToggleElement","isKeynavEnabled","focusDropdownEntry","dropdownConfig","uibDropdownService","$templateRequest","templateScope","getIsOpen","setIsOpen","toggleInvoker","onToggle","keynavEnabled","dropdownAppendToBody","uibKeyboardNav","dropdownMenu","toggle","autoClose","getElement","keyCode","elems","eq","selectedOption","wasOpen","pos","rightalign","innerWidth","dropdownMenuTemplateUrl","tplContent","newEl","offDestroy","dropdownCtrl","dropdownNested","tplUrl","toggleDropdown","aria-haspopup","aria-expanded","$dropdownSuppressWarning","createNew","stack","add","removeTop","entries","hasKey","$modalStack","linkFn","modalInClass","NOW_CLOSING_EVENT","setIsAsync","backdropClass","windowClass","windowTopClass","modal","getTop","backdrop","currentTarget","dismiss","$isRendered","modalRenderDeferObj","animationPromise","inputWithAutofocus","modalRendered","modalAnimation","uibModalAnimationClass","empty","$$multiMap","$$stackedMap","backdropIndex","topBackdropIndex","opened","openedWindows","removeModalWindow","modalInstance","elementToReceiveFocus","body","modalWindow","removeAfterAnimate","modalDomEl","modalScope","modalBodyClass","openedClass","OPENED_MODAL_CLASS","openedClasses","toggleTopWindowClass","checkRemoveBackdrop","toggleSwitch","backdropDomEl","backdropScopeRef","backdropScope","domEl","afterAnimating","asyncDeferred","asyncPromise","broadcastClosing","resultOrReason","closing","focusableElementList","focusIndex","tababbleSelector","newBackdropIndex","isDefaultPrevented","keyboard","loadFocusElementList","focusChanged","isFocusInFirstItem","focusLastFocusableElement","isFocusInLastItem","focusFirstFocusableElement","modalOpener","renderDeferred","currBackdropIndex","angularBackgroundDomEl","angularDomEl","windowTemplateUrl","window-class","window-top-class","clearFocusListCache","$$uibDestructionScheduled","dismissAll","topModal","srcElement","modalDomE1","$modalProvider","$modalSuppressWarning","getTemplatePromise","getResolvePromises","resolves","promisesArr","$modal","promiseChain","getPromiseChain","modalOptions","resolveWithTemplate","templateAndResolvePromise","modalResultDeferred","modalOpenedDeferred","modalRenderDeferred","rendered","samePromise","tplAndVars","$close","$dismiss","ctrlInstance","ctrlLocals","resolveIter","$uibModalInstance","bindToController","modalAnimationClass","$uibModalStack","$uibModalProvider","setNumPages","numPages","itemsPerPage","totalPages","calculateTotalPages","page","selectPage","totalItems","clickAllowed","ngDisabled","noPrevious","noNext","boundaryLinks","directionLinks","firstText","previousText","nextText","lastText","rotate","paginationConfig","makePage","getPages","currentPage","pages","startPage","endPage","isMaxSized","maxSize","previousPageSet","nextPageSet","paginationCtrl","originalRender","align","pagerConfig","$paginationSuppressWarning","snake_case","separator","letter","placement","popupDelay","popupCloseDelay","useContentExp","triggerMap","mouseenter","click","none","globalOptions","setTriggers","triggers","openedTooltips","ttType","defaultTriggerShow","getTriggers","trigger","directiveName","startSym","endSym","tElem","tooltipLinker","tooltipCtrl","toggleTooltipBind","ttScope","hideTooltipBind","showTooltipBind","hasEnableExp","cancelHide","prepareTooltip","showTimeout","cancelShow","hideTimeout","createTooltip","$evalAsync","assignIsOpen","positionTooltip","positionTimeout","transitionTimeout","removeTooltip","tooltip","tooltipLinkedScope","prepObservers","unregisterObservers","contentParse","popupClass","delay","closeDelay","isOpenParse","observers","repositionScheduled","$$postDigest","observer","prepTriggers","unregisterTriggers","ttCss","visibility","origScope","contentExp","hideTrigger","removeEventListener","appendToBodyVal","$sce","elem","previousElement","currentElement","tooltipTemplateTranscludeScope","changeCounter","cleanupLastIncludeContent","parseAsResourceUrl","uibTooltipTemplateTransclude","thisChangeId","tooltipAnimationClass","$uibTooltip","originScope","$uibTooltipProvider","$tooltipSuppressWarning","tooltipTemplateTransclude","$tooltip","$popoverSuppressWarning","progressConfig","bars","addBar","bar","recalculatePercentage","totalPercentage","reduce","total","percent","toFixed","removeBar","progressCtrl","$progressSuppressWarning","stateOn","stateOff","titles","ratingConfig","tmpTitles","ratingStates","buildTemplateObjects","getTitle","rate","readonly","onHover","reset","onLeave","onKeydown","ratingCtrl","$ratingSuppressWarning","tabs","selectedTab","tab","onDeselect","selectCalled","onSelect","addTab","removeTab","newActiveIndex","vertical","justified","tabsetCtrl","disable","$transcludeFn","isTabHeading","tagName","uibTabContentTransclude","headingElement","$tabsSuppressWarning","tabContentTransclude","hourStep","minuteStep","showMeridian","meridians","readonlyInput","mousewheel","arrowkeys","showSpinners","timepickerConfig","getHoursFromTemplate","meridian","getMinutesFromTemplate","pad","refresh","keyboardChange","makeValid","updateTemplate","invalidHours","invalidMinutes","addMinutes","newDate","addMinutesToSelected","tabindex","removeAttr","inputs","hoursInputEl","minutesInputEl","setupMousewheelEvents","setupArrowkeyEvents","setupInputEvents","noIncrementHours","incrementedSelected","noDecrementHours","decrementedSelected","noIncrementMinutes","noDecrementMinutes","noToggleMeridian","$error","isScrollingUp","originalEvent","delta","wheelDelta","deltaY","detail","incrementHours","decrementHours","incrementMinutes","decrementMinutes","updateHours","updateMinutes","invalidate","setMinutes","toggleMeridian","timepickerCtrl","$timepickerSuppressWarning","TYPEAHEAD_REGEXP","itemName","viewMapper","modelMapper","originalScope","typeaheadParser","fireRecalculating","moveInProgress","timeoutEventPromise","matches","recalculatePosition","eventDebounceTime","modelCtrl","ngModelOptions","HOT_KEYS","minLength","typeaheadMinLength","waitTime","typeaheadWaitMs","isEditable","typeaheadEditable","isLoadingSetter","typeaheadLoading","onSelectCallback","typeaheadOnSelect","isSelectOnBlur","typeaheadSelectOnBlur","isNoResultsSetter","typeaheadNoResults","inputFormatter","typeaheadInputFormatter","typeaheadAppendToBody","appendToElementId","typeaheadAppendToElementId","focusFirst","typeaheadFocusFirst","selectOnExact","typeaheadSelectOnExact","parsedModel","invokeModelSetter","$setModelValue","$options","$$$p","parserResult","uibTypeahead","popupId","aria-autocomplete","aria-owns","popUpEl","move-in-progress","typeaheadTemplateUrl","typeaheadPopupTemplateUrl","resetMatches","activeIdx","getMatchId","inputIsExactMatch","inputValue","getMatchesAsync","onCurrentRequest","timeoutPromise","scheduleSearchWithTimeout","cancelPreviousTimeout","$item","$model","$label","typeaheadFocusOnSelect","dismissClickHandler","_modelCtrl","_ngModelOptions","candidateViewValue","emptyViewValue","popupTemplateUrl","matchIdx","selectActive","selectMatch","clonedElement","escapeRegexp","queryToEscape","containsHtml","matchItem","isSanitizePresent","trustAsHtml","uibTypeaheadParser","$typeaheadSuppressWarning","typeahead","$$csp","prepend"],"mappings":"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","file":"vendors.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t2:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".app.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(17);\n\t__webpack_require__(16);\n\t__webpack_require__(15);\n\t__webpack_require__(25);\n\t__webpack_require__(4);\n\t__webpack_require__(7);\n\t__webpack_require__(13);\n\t__webpack_require__(14);\n\tmodule.exports = __webpack_require__(24);\n\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = angular;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! api-check version 7.5.5 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) (ó ì_í)=óò=(ì_í ò)\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"apiCheck\"] = factory();\n\t\telse\n\t\t\troot[\"apiCheck\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _apiCheck = __webpack_require__(1);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = _apiCheck2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar apiCheckUtil = __webpack_require__(3);\n\t\tvar each = apiCheckUtil.each;\n\t\tvar isError = apiCheckUtil.isError;\n\t\tvar t = apiCheckUtil.t;\n\t\tvar arrayify = apiCheckUtil.arrayify;\n\t\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\t\tvar typeOf = apiCheckUtil.typeOf;\n\t\tvar getError = apiCheckUtil.getError;\n\t\n\t\tvar checkers = __webpack_require__(4);\n\t\tvar apiCheckApis = getApiCheckApis();\n\t\n\t\tmodule.exports = getApiCheckInstance;\n\t\tmodule.exports.VERSION = (\"7.5.5\");\n\t\tmodule.exports.utils = apiCheckUtil;\n\t\tmodule.exports.globalConfig = {\n\t\t  verbose: false,\n\t\t  disabled: false\n\t\t};\n\t\n\t\tvar apiCheckApiCheck = getApiCheckInstance({\n\t\t  output: { prefix: 'apiCheck' }\n\t\t});\n\t\tmodule.exports.internalChecker = apiCheckApiCheck;\n\t\n\t\teach(checkers, function (checker, name) {\n\t\t  return module.exports[name] = checker;\n\t\t});\n\t\n\t\tfunction getApiCheckInstance() {\n\t\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t\t  /* eslint complexity:[2, 6] */\n\t\t  if (apiCheckApiCheck && arguments.length) {\n\t\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t\t      prefix: 'creating an apiCheck instance'\n\t\t    });\n\t\t  }\n\t\n\t\t  var additionalProperties = {\n\t\t    'throw': getApiCheck(true),\n\t\t    warn: getApiCheck(false),\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    handleErrorMessage: handleErrorMessage,\n\t\t    config: {\n\t\t      output: config.output || {\n\t\t        prefix: '',\n\t\t        suffix: '',\n\t\t        docsBaseUrl: ''\n\t\t      },\n\t\t      verbose: config.verbose || false,\n\t\t      disabled: config.disabled || false\n\t\t    },\n\t\t    utils: apiCheckUtil\n\t\t  };\n\t\n\t\t  each(additionalProperties, function (wrapper, name) {\n\t\t    return apiCheck[name] = wrapper;\n\t\t  });\n\t\n\t\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\t  each(extraCheckers, function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\n\t\t  return apiCheck;\n\t\n\t\t  /**\n\t\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t\t   * @param {Array} api - the checkers to check with\n\t\t   * @param {Array} args - the args to check\n\t\t   * @param {Object} output - output options\n\t\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t\t   */\n\t\t  function apiCheck(api, args, output) {\n\t\t    /* eslint complexity:[2, 8] */\n\t\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t\t      return {\n\t\t        apiTypes: {}, argTypes: {},\n\t\t        passed: true, message: '',\n\t\t        failed: false\n\t\t      }; // empty version of what is normally returned\n\t\t    }\n\t\t    checkApiCheckApi(arguments);\n\t\t    if (!Array.isArray(api)) {\n\t\t      api = [api];\n\t\t      args = [args];\n\t\t    } else {\n\t\t      // turn arguments into an array\n\t\t      args = Array.prototype.slice.call(args);\n\t\t    }\n\t\t    var messages = checkEnoughArgs(api, args);\n\t\t    if (!messages.length) {\n\t\t      // this is where we actually go perform the checks.\n\t\t      messages = checkApiWithArgs(api, args);\n\t\t    }\n\t\n\t\t    var returnObject = getTypes(api, args);\n\t\t    returnObject.args = args;\n\t\t    if (messages.length) {\n\t\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t\t      returnObject.failed = true;\n\t\t      returnObject.passed = false;\n\t\t    } else {\n\t\t      returnObject.message = '';\n\t\t      returnObject.failed = false;\n\t\t      returnObject.passed = true;\n\t\t    }\n\t\t    return returnObject;\n\t\t  }\n\t\n\t\t  /**\n\t\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t\t   */\n\t\t  function checkApiCheckApi(checkApiArgs) {\n\t\t    var api = checkApiArgs[0];\n\t\t    var args = checkApiArgs[1];\n\t\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\t\n\t\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t\t    }\n\t\t    // dog fooding here\n\t\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t\t    if (errors.length) {\n\t\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t\t        prefix: 'apiCheck'\n\t\t      });\n\t\t      apiCheck.handleErrorMessage(message, true);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getApiCheck(shouldThrow) {\n\t\t    return function apiCheckWrapper(api, args, output) {\n\t\t      var result = apiCheck(api, args, output);\n\t\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t\t      return result; // wont get here if an error is thrown\n\t\t    };\n\t\t  }\n\t\n\t\t  function handleErrorMessage(message, shouldThrow) {\n\t\t    if (shouldThrow && message) {\n\t\t      throw new Error(message);\n\t\t    } else if (message) {\n\t\t      /* eslint no-console:0 */\n\t\t      console.warn(message);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getErrorMessage(api, args) {\n\t\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t\n\t\t    var gOut = apiCheck.config.output || {};\n\t\t    var prefix = getPrefix();\n\t\t    var suffix = getSuffix();\n\t\t    var url = getUrl();\n\t\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\t\n\t\t    function getPrefix() {\n\t\t      var p = output.onlyPrefix;\n\t\t      if (!p) {\n\t\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t\t      }\n\t\t      return p;\n\t\t    }\n\t\n\t\t    function getSuffix() {\n\t\t      var s = output.onlySuffix;\n\t\t      if (!s) {\n\t\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t\t      }\n\t\t      return s;\n\t\t    }\n\t\n\t\t    function getUrl() {\n\t\t      var u = output.url;\n\t\t      if (!u) {\n\t\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t\t      }\n\t\t      return u;\n\t\t    }\n\t\t  }\n\t\n\t\t  function buildMessageFromApiAndArgs(api, args) {\n\t\t    var _getTypes = getTypes(api, args);\n\t\n\t\t    var apiTypes = _getTypes.apiTypes;\n\t\t    var argTypes = _getTypes.argTypes;\n\t\n\t\t    var copy = Array.prototype.slice.call(args || []);\n\t\t    var replacedItems = [];\n\t\t    replaceFunctionWithName(copy);\n\t\t    var passedArgs = getObjectString(copy);\n\t\t    argTypes = getObjectString(argTypes);\n\t\t    apiTypes = getObjectString(apiTypes);\n\t\n\t\t    return generateMessage();\n\t\n\t\t    // functions\n\t\n\t\t    function replaceFunctionWithName(obj) {\n\t\t      each(obj, function (val, name) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        if (replacedItems.indexOf(val) === -1) {\n\t\t          // avoid recursive problems\n\t\t          replacedItems.push(val);\n\t\t          if (typeof val === 'object') {\n\t\t            replaceFunctionWithName(obj);\n\t\t          } else if (typeof val === 'function') {\n\t\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function getObjectString(types) {\n\t\t      if (!types || !types.length) {\n\t\t        return 'nothing';\n\t\t      } else if (types && types.length === 1) {\n\t\t        types = types[0];\n\t\t      }\n\t\t      return stringify(types, null, 2);\n\t\t    }\n\t\n\t\t    function generateMessage() {\n\t\t      var n = '\\n';\n\t\t      var useS = true;\n\t\t      if (args && args.length === 1) {\n\t\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t\t          useS = !!Object.keys(args[0]).length;\n\t\t        } else {\n\t\t          useS = false;\n\t\t        }\n\t\t      }\n\t\t      var types = 'type' + (useS ? 's' : '');\n\t\t      var newLine = n + n;\n\t\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypes(api, args) {\n\t\t    api = arrayify(api);\n\t\t    args = arrayify(args);\n\t\t    var apiTypes = api.map(function (checker, index) {\n\t\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t\t      return getCheckerDisplay(checker, {\n\t\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t\t        obj: args[index],\n\t\t        addHelpers: true\n\t\t      });\n\t\t    });\n\t\t    var argTypes = args.map(function (arg) {\n\t\t      return getArgDisplay(arg, []);\n\t\t    });\n\t\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t\t  }\n\t\t}\n\t\n\t\t// STATELESS FUNCTIONS\n\t\n\t\t/**\n\t\t * This is where the magic happens for actually checking the arguments with the api.\n\t\t * @param {Array} api - checkers\n\t\t * @param  {Array} args - and arguments object\n\t\t * @returns {Array} - the error messages\n\t\t */\n\t\tfunction checkApiWithArgs(api, args) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var messages = [];\n\t\t  var failed = false;\n\t\t  var checkerIndex = 0;\n\t\t  var argIndex = 0;\n\t\t  var arg = undefined,\n\t\t      checker = undefined,\n\t\t      res = undefined,\n\t\t      lastChecker = undefined,\n\t\t      argName = undefined,\n\t\t      argFailed = undefined,\n\t\t      skipPreviousChecker = undefined;\n\t\t  /* jshint -W084 */\n\t\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t\t    arg = args[argIndex++];\n\t\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t\t    res = checker(arg, 'value', argName);\n\t\t    argFailed = isError(res);\n\t\t    lastChecker = checkerIndex >= api.length;\n\t\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t\t      failed = true;\n\t\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t\t    } else if (argFailed && checker.isOptional) {\n\t\t      argIndex--;\n\t\t    } else {\n\t\t      messages.push(t(argName) + ' passed');\n\t\t    }\n\t\t  }\n\t\t  return failed ? messages : [];\n\t\t}\n\t\n\t\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\t\tfunction checkerTypeType(checkerType, name, location) {\n\t\t  var apiCheckDataChecker = checkers.shape({\n\t\t    type: checkers.string,\n\t\t    optional: checkers.bool\n\t\t  });\n\t\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t\t  if (isError(wrongShape)) {\n\t\t    return wrongShape;\n\t\t  }\n\t\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t\t    return getError(name, location, checkerTypeType.type);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerErrorMessage(res, checker, val) {\n\t\t  var checkerHelp = getCheckerHelp(checker, val);\n\t\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t\t  return res.message + checkerHelp;\n\t\t}\n\t\n\t\tfunction getCheckerHelp(_ref, val) {\n\t\t  var help = _ref.help;\n\t\n\t\t  if (!help) {\n\t\t    return '';\n\t\t  }\n\t\t  if (typeof help === 'function') {\n\t\t    help = help(val);\n\t\t  }\n\t\t  return help;\n\t\t}\n\t\n\t\tfunction checkEnoughArgs(api, args) {\n\t\t  var requiredArgs = api.filter(function (a) {\n\t\t    return !a.isOptional;\n\t\t  });\n\t\t  if (args.length < requiredArgs.length) {\n\t\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t\t  } else {\n\t\t    return [];\n\t\t  }\n\t\t}\n\t\n\t\tfunction getArgDisplay(arg, gottenArgs) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t\t  var type = typeOf(arg);\n\t\t  if (type === 'function') {\n\t\t    if (hasKeys()) {\n\t\t      var properties = stringify(getDisplayIfNotGotten());\n\t\t      return cName + ' (with properties: ' + properties + ')';\n\t\t    }\n\t\t    return cName;\n\t\t  }\n\t\n\t\t  if (arg === null) {\n\t\t    return 'null';\n\t\t  }\n\t\n\t\t  if (type !== 'array' && type !== 'object') {\n\t\t    return type;\n\t\t  }\n\t\n\t\t  if (hasKeys()) {\n\t\t    return getDisplayIfNotGotten();\n\t\t  }\n\t\n\t\t  return cName;\n\t\n\t\t  // utility functions\n\t\t  function hasKeys() {\n\t\t    return arg && Object.keys(arg).length;\n\t\t  }\n\t\n\t\t  function getDisplayIfNotGotten() {\n\t\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t\t      return '[Circular]';\n\t\t    }\n\t\t    gottenArgs.push(arg);\n\t\t    return getDisplay(arg, gottenArgs);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getDisplay(obj, gottenArgs) {\n\t\t  var argDisplay = {};\n\t\t  each(obj, function (v, k) {\n\t\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t\t  });\n\t\t  return argDisplay;\n\t\t}\n\t\n\t\tfunction getApiCheckApis() {\n\t\t  var os = checkers.string.optional;\n\t\n\t\t  var checkerFnChecker = checkers.func.withProperties({\n\t\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t\t    displayName: checkers.string.optional,\n\t\t    shortType: checkers.string.optional,\n\t\t    notOptional: checkers.bool.optional,\n\t\t    notRequired: checkers.bool.optional\n\t\t  });\n\t\n\t\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t\t    output: checkers.shape({\n\t\t      prefix: checkers.string.optional,\n\t\t      suffix: checkers.string.optional,\n\t\t      docsBaseUrl: checkers.string.optional\n\t\t    }).strict.optional,\n\t\t    verbose: checkers.bool.optional,\n\t\t    disabled: checkers.bool.optional\n\t\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\t\n\t\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t\t  }).strict.optional];\n\t\n\t\t  return {\n\t\t    checkerFnChecker: checkerFnChecker,\n\t\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t\t    checkApiCheckApi: checkApiCheckApi\n\t\t  };\n\t\t}\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = stringify;\n\t\n\t\tfunction getSerialize (fn, decycle) {\n\t\t  var seen = [], keys = [];\n\t\t  decycle = decycle || function(key, value) {\n\t\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t\t  };\n\t\t  return function(key, value) {\n\t\t    var ret = value;\n\t\t    if (typeof value === 'object' && value) {\n\t\t      if (seen.indexOf(value) !== -1)\n\t\t        ret = decycle(key, value);\n\t\t      else {\n\t\t        seen.push(value);\n\t\t        keys.push(key);\n\t\t      }\n\t\t    }\n\t\t    if (fn) ret = fn(key, ret);\n\t\t    return ret;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getPath (value, seen, keys) {\n\t\t  var index = seen.indexOf(value);\n\t\t  var path = [ keys[index] ];\n\t\t  for (index--; index >= 0; index--) {\n\t\t    if (seen[index][ path[0] ] === value) {\n\t\t      value = seen[index];\n\t\t      path.unshift(keys[index]);\n\t\t    }\n\t\t  }\n\t\t  return '~' + path.join('.');\n\t\t}\n\t\n\t\tfunction stringify(obj, fn, spaces, decycle) {\n\t\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t\t}\n\t\n\t\tstringify.getSerialize = getSerialize;\n\t\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar checkerHelpers = {\n\t\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t\t};\n\t\n\t\tmodule.exports = {\n\t\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t\t  noop: noop\n\t\t};\n\t\n\t\tfunction copy(obj) {\n\t\t  var type = typeOf(obj);\n\t\t  var daCopy = undefined;\n\t\t  if (type === 'array') {\n\t\t    daCopy = [];\n\t\t  } else if (type === 'object') {\n\t\t    daCopy = {};\n\t\t  } else {\n\t\t    return obj;\n\t\t  }\n\t\t  each(obj, function (val, key) {\n\t\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t\t  });\n\t\t  return daCopy;\n\t\t}\n\t\n\t\tfunction typeOf(obj) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return 'array';\n\t\t  } else if (obj instanceof RegExp) {\n\t\t    return 'object';\n\t\t  } else {\n\t\t    return typeof obj;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerDisplay(checker, options) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var display = undefined;\n\t\t  var short = options && options.short;\n\t\t  if (short && checker.shortType) {\n\t\t    display = checker.shortType;\n\t\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t\t    display = getCheckerType(checker, options);\n\t\t  } else {\n\t\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t\t  }\n\t\t  return display;\n\t\t}\n\t\n\t\tfunction getCheckerType(_ref, options) {\n\t\t  var type = _ref.type;\n\t\n\t\t  if (typeof type === 'function') {\n\t\t    var __apiCheckData = type.__apiCheckData;\n\t\t    var typeTypes = type(options);\n\t\t    type = _defineProperty({\n\t\t      __apiCheckData: __apiCheckData\n\t\t    }, __apiCheckData.type, typeTypes);\n\t\t  }\n\t\t  return type;\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (!obj) {\n\t\t    return [];\n\t\t  } else if (Array.isArray(obj)) {\n\t\t    return obj;\n\t\t  } else {\n\t\t    return [obj];\n\t\t  }\n\t\t}\n\t\n\t\tfunction each(obj, iterator, context) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return eachArry(obj, iterator, context);\n\t\t  } else {\n\t\t    return eachObj(obj, iterator, context);\n\t\t  }\n\t\t}\n\t\n\t\tfunction eachObj(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t\t  for (var key in obj) {\n\t\t    if (hasOwn.call(obj, key)) {\n\t\t      ret = iterator.call(context, obj[key], key, obj);\n\t\t      if (ret === false) {\n\t\t        return ret;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction eachArry(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var length = obj.length;\n\t\t  for (var i = 0; i < length; i++) {\n\t\t    ret = iterator.call(context, obj[i], i, obj);\n\t\t    if (ret === false) {\n\t\t      return ret;\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction isError(obj) {\n\t\t  return obj instanceof Error;\n\t\t}\n\t\n\t\tfunction list(arry, join, finalJoin) {\n\t\t  arry = arrayify(arry);\n\t\t  var copy = arry.slice();\n\t\t  var last = copy.pop();\n\t\t  if (copy.length === 1) {\n\t\t    join = ' ';\n\t\t  }\n\t\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t\t}\n\t\n\t\tfunction getError(name, location, checkerType) {\n\t\t  if (typeof checkerType === 'function') {\n\t\t    checkerType = checkerType({ short: true });\n\t\t  }\n\t\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t\t}\n\t\n\t\tfunction nAtL(name, location) {\n\t\t  var tName = t(name || 'value');\n\t\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t\t  return '' + tName + tLocation;\n\t\t}\n\t\n\t\tfunction t(thing) {\n\t\t  return '`' + thing + '`';\n\t\t}\n\t\n\t\tfunction undef(thing) {\n\t\t  return typeof thing === 'undefined';\n\t\t}\n\t\n\t\t/**\n\t\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t\t * optional version\n\t\t *\n\t\t * @param {Function} checker - the checker to setup with properties\n\t\t * @param {Object} properties - properties to add to the checker\n\t\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t\t * @returns {Function} checker - the setup checker\n\t\t */\n\t\tfunction setupChecker(checker, properties, disabled) {\n\t\t  /* eslint complexity:[2, 9] */\n\t\t  if (disabled) {\n\t\t    // swap out the checker for its own copy of noop\n\t\t    checker = getNoop();\n\t\t    checker.isNoop = true;\n\t\t  }\n\t\n\t\t  if (typeof checker.type === 'string') {\n\t\t    checker.shortType = checker.type;\n\t\t  }\n\t\n\t\t  // assign all properties given\n\t\t  each(properties, function (prop, name) {\n\t\t    return checker[name] = prop;\n\t\t  });\n\t\n\t\t  if (!checker.displayName) {\n\t\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t\t  }\n\t\n\t\t  if (!checker.notRequired) {\n\t\t    checker = getRequiredVersion(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notNullable) {\n\t\t    addNullable(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker, disabled);\n\t\t  }\n\t\n\t\t  return checker;\n\t\t}\n\t\n\t\tfunction getRequiredVersion(checker, disabled) {\n\t\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t\t    if (undef(val) && !checker.isOptional) {\n\t\t      var tLocation = location ? ' in ' + t(location) : '';\n\t\t      var type = getCheckerDisplay(checker, { short: true });\n\t\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t\t    } else {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  copyProps(checker, requiredChecker);\n\t\t  requiredChecker.originalChecker = checker;\n\t\t  return requiredChecker;\n\t\t}\n\t\n\t\tfunction addOptional(checker, disabled) {\n\t\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t\t    if (!undef(val)) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, optionalCheck);\n\t\n\t\t  optionalCheck.isOptional = true;\n\t\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t\t  optionalCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .optional to the end of the checkers\n\t\t  checker.optional = optionalCheck;\n\t\n\t\t  fixType(checker, checker.optional);\n\t\t}\n\t\n\t\tfunction addNullable(checker, disabled) {\n\t\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t\t    if (val !== null) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, nullableCheck);\n\t\n\t\t  nullableCheck.isNullable = true;\n\t\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t\t  nullableCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t\t  checker.nullable = nullableCheck;\n\t\n\t\t  fixType(checker, checker.nullable);\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker.nullable, disabled);\n\t\t  }\n\t\t}\n\t\n\t\tfunction fixType(checker, checkerCopy) {\n\t\t  // fix type, because it's not a straight copy...\n\t\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t\t  // we also want to add \"(optional)\" to the types with a string\n\t\t  if (typeof checkerCopy.type === 'object') {\n\t\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t\t  } else if (typeof checkerCopy.type === 'function') {\n\t\t      checkerCopy.type = function () {\n\t\t        return checker.type.apply(checker, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      checkerCopy.type += ' (optional)';\n\t\t      return;\n\t\t    }\n\t\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t\t  checkerCopy.type.__apiCheckData.optional = true;\n\t\t}\n\t\n\t\t// UTILS\n\t\n\t\tfunction copyProps(src, dest) {\n\t\t  each(Object.keys(src), function (key) {\n\t\t    return dest[key] = src[key];\n\t\t  });\n\t\t}\n\t\n\t\tfunction noop() {}\n\t\n\t\tfunction getNoop() {\n\t\t  /* eslint no-shadow:0 */\n\t\t  /* istanbul ignore next */\n\t\t  return function noop() {};\n\t\t}\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\n\t\tvar _require = __webpack_require__(3);\n\t\n\t\tvar typeOf = _require.typeOf;\n\t\tvar each = _require.each;\n\t\tvar copy = _require.copy;\n\t\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\t\tvar isError = _require.isError;\n\t\tvar arrayify = _require.arrayify;\n\t\tvar list = _require.list;\n\t\tvar getError = _require.getError;\n\t\tvar nAtL = _require.nAtL;\n\t\tvar t = _require.t;\n\t\tvar checkerHelpers = _require.checkerHelpers;\n\t\tvar undef = _require.undef;\n\t\tvar setupChecker = checkerHelpers.setupChecker;\n\t\n\t\tvar checkers = module.exports = getCheckers();\n\t\tmodule.exports.getCheckers = getCheckers;\n\t\n\t\tfunction getCheckers(disabled) {\n\t\t  return {\n\t\t    array: typeOfCheckGetter('Array'),\n\t\t    bool: typeOfCheckGetter('Boolean'),\n\t\t    number: typeOfCheckGetter('Number'),\n\t\t    string: typeOfCheckGetter('String'),\n\t\t    func: funcCheckGetter(),\n\t\t    object: objectCheckGetter(),\n\t\n\t\t    emptyObject: emptyObjectCheckGetter(),\n\t\n\t\t    instanceOf: instanceCheckGetter,\n\t\t    oneOf: oneOfCheckGetter,\n\t\t    oneOfType: oneOfTypeCheckGetter,\n\t\n\t\t    arrayOf: arrayOfCheckGetter,\n\t\t    objectOf: objectOfCheckGetter,\n\t\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\t\n\t\t    range: rangeCheckGetter,\n\t\t    lessThan: lessThanCheckGetter,\n\t\t    greaterThan: greaterThanCheckGetter,\n\t\n\t\t    shape: getShapeCheckGetter(),\n\t\t    args: argumentsCheckerGetter(),\n\t\n\t\t    any: anyCheckGetter(),\n\t\t    'null': nullCheckGetter()\n\t\n\t\t  };\n\t\n\t\t  function typeOfCheckGetter(type) {\n\t\t    var lType = type.toLowerCase();\n\t\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== lType) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function funcCheckGetter() {\n\t\t    var type = 'Function';\n\t\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'function') {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\n\t\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t\t      if (isError(apiError)) {\n\t\t        throw apiError;\n\t\t      }\n\t\t      var shapeChecker = checkers.shape(properties, true);\n\t\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\t\n\t\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t\t        var notFunction = checkers.func(val, name, location);\n\t\t        if (isError(notFunction)) {\n\t\t          return notFunction;\n\t\t        }\n\t\t        return shapeChecker(val, name, location);\n\t\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t\t    };\n\t\t    return functionChecker;\n\t\t  }\n\t\n\t\t  function objectCheckGetter() {\n\t\t    var type = 'Object';\n\t\t    var nullType = 'Object (null ok)';\n\t\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'object') {\n\t\t        return getError(name, location, nullType);\n\t\t      }\n\t\t    }, { type: nullType }, disabled);\n\t\n\t\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t\t        return getError(name, location, objectChecker.type);\n\t\t      }\n\t\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\t\n\t\t    return objectChecker;\n\t\t  }\n\t\n\t\t  function instanceCheckGetter(classToCheck) {\n\t\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t\t      if (!(val instanceof classToCheck)) {\n\t\t        return getError(name, location, classToCheck.name);\n\t\t      }\n\t\t    }, { type: classToCheck.name }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfCheckGetter(enums) {\n\t\t    var type = {\n\t\t      __apiCheckData: { optional: false, type: 'enum' },\n\t\t      'enum': enums\n\t\t    };\n\t\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t\t      return stringify(enm);\n\t\t    }).join(', ') + ']';\n\t\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t\t      if (!enums.some(function (enm) {\n\t\t        return enm === val;\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t\t      return getCheckerDisplay(checker, { short: true });\n\t\t    });\n\t\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return typeCheckers.map(function (checker) {\n\t\t        return getCheckerDisplay(checker, options);\n\t\t      });\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t\t      if (!typeCheckers.some(function (checker) {\n\t\t        return !isError(checker(val, name, location));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function arrayOfCheckGetter(checker) {\n\t\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\t\n\t\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t\t        return !isError(checker(item));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function objectOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\t\n\t\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t\t      var notObject = checkers.object(val, name, location);\n\t\t      if (isError(notObject)) {\n\t\t        return notObject;\n\t\t      }\n\t\t      var allTypesSuccess = each(val, function (item, key) {\n\t\t        if (isError(checker(item, key, name))) {\n\t\t          return false;\n\t\t        }\n\t\t      });\n\t\t      if (!allTypesSuccess) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function typeOrArrayOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\n\t\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function getShapeCheckGetter() {\n\t\t    function shapeCheckGetter(shape, nonObject) {\n\t\t      var shapeTypes = {};\n\t\t      each(shape, function (checker, prop) {\n\t\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t\t      });\n\t\t      function type() {\n\t\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t\t        var ret = {};\n\t\t        var terse = options.terse;\n\t\t        var obj = options.obj;\n\t\t        var addHelpers = options.addHelpers;\n\t\n\t\t        var parentRequired = options.required;\n\t\t        each(shape, function (checker, prop) {\n\t\t          /* eslint complexity:[2, 6] */\n\t\t          var specified = obj && obj.hasOwnProperty(prop);\n\t\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t\t          if (!terse || (specified || !checker.isOptional)) {\n\t\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t\t          }\n\t\t          if (addHelpers) {\n\t\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t\t          }\n\t\t        });\n\t\t        return ret;\n\t\n\t\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t\t          if (!specified && required && !checker.isOptional) {\n\t\t            var item = 'ITEM';\n\t\t            if (checker.type && checker.type.__apiCheckData) {\n\t\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t\t            }\n\t\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t\t          } else if (specified) {\n\t\t            var error = checker(obj[prop], prop, null, obj);\n\t\t            if (isError(error)) {\n\t\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t\t            }\n\t\t          }\n\t\n\t\t          function addHelper(property, objectMessage, stringMessage) {\n\t\t            if (typeof theRet[prop] === 'string') {\n\t\t              theRet[prop] += stringMessage;\n\t\t            } else {\n\t\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\n\t\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t\t        if (isError(isObject)) {\n\t\t          return isObject;\n\t\t        }\n\t\t        var shapePropError = undefined;\n\t\t        location = location ? location + (name ? '/' : '') : '';\n\t\t        name = name || '';\n\t\t        each(shape, function (checker, prop) {\n\t\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t\t            return !isError(shapePropError);\n\t\t          }\n\t\t        });\n\t\t        if (isError(shapePropError)) {\n\t\t          return shapePropError;\n\t\t        }\n\t\t      }, { type: type, shortType: 'shape' }, disabled);\n\t\n\t\t      function strictType() {\n\t\t        return type.apply(undefined, arguments);\n\t\t      }\n\t\n\t\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t\t      strictType.__apiCheckData.strict = true;\n\t\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t\t        var shapeError = shapeChecker(val, name, location);\n\t\t        if (isError(shapeError)) {\n\t\t          return shapeError;\n\t\t        }\n\t\t        var allowedProperties = Object.keys(shape);\n\t\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t\t          return allowedProperties.indexOf(prop) === -1;\n\t\t        });\n\t\t        if (extraProps.length) {\n\t\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t\t        }\n\t\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\t\n\t\t      return shapeChecker;\n\t\t    }\n\t\n\t\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t\t      } else {\n\t\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (propExists === otherPropsExist) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t\t      otherProps = arrayify(otherProps);\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t\t      } else {\n\t\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t\t        var othersPresent = otherProps.every(function (property) {\n\t\t          return obj.hasOwnProperty(property);\n\t\t        });\n\t\t        if (!othersPresent) {\n\t\t          return getError(propName, location, type);\n\t\t        } else {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        throw new Error('requiredIfNot.all must be passed an array');\n\t\t      }\n\t\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t\t      var props = t(otherProps.join(', '));\n\t\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var iteration = all ? 'every' : 'some';\n\t\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (!otherPropsExist && !propExists) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, notRequired: true }, disabled);\n\t\t    }\n\t\n\t\t    return shapeCheckGetter;\n\t\n\t\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t\t      function type(options) {\n\t\t        if (options && options.short) {\n\t\t          return shortType;\n\t\t        }\n\t\t        return getCheckerDisplay(propChecker);\n\t\t      }\n\t\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function argumentsCheckerGetter() {\n\t\t    var type = 'function arguments';\n\t\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function anyCheckGetter() {\n\t\t    return setupChecker(function anyCheckerDefinition() {\n\t\t      // don't do anything\n\t\t    }, { type: 'any' }, disabled);\n\t\t  }\n\t\n\t\t  function nullCheckGetter() {\n\t\t    var type = 'null';\n\t\t    return setupChecker(function nullChecker(val, name, location) {\n\t\t      if (val !== null) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function rangeCheckGetter(min, max) {\n\t\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t\t    return setupChecker(function rangeChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < min || val > max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function lessThanCheckGetter(min) {\n\t\t    var type = 'lessThan[' + min + ']';\n\t\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val > min) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function greaterThanCheckGetter(max) {\n\t\t    var type = 'greaterThan[' + max + ']';\n\t\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function emptyObjectCheckGetter() {\n\t\t    var type = 'empty object';\n\t\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\t}\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 5 */,\n/* 6 */,\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t* angular-formly JavaScript Library v7.3.4\n\t*\n\t* @license MIT (http://license.angular-formly.com)\n\t*\n\t* built with ♥ by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n\t* (ó ì_í)=óò=(ì_í ò)\n\t*/\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(3), __webpack_require__(4));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _indexCommon = __webpack_require__(1);\n\t\n\t\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\t\n\t\texports['default'] = _indexCommon2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\t\n\t\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\t\n\t\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\t\n\t\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\t\n\t\tvar _providersFormlyUsability = __webpack_require__(7);\n\t\n\t\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\t\n\t\tvar _providersFormlyConfig = __webpack_require__(8);\n\t\n\t\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\t\n\t\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\t\n\t\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\t\n\t\tvar _servicesFormlyUtil = __webpack_require__(11);\n\t\n\t\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\t\n\t\tvar _servicesFormlyWarn = __webpack_require__(12);\n\t\n\t\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\t\n\t\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\t\n\t\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\t\n\t\tvar _directivesFormlyField = __webpack_require__(14);\n\t\n\t\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\t\n\t\tvar _directivesFormlyFocus = __webpack_require__(15);\n\t\n\t\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\t\n\t\tvar _directivesFormlyForm = __webpack_require__(16);\n\t\n\t\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\t\n\t\tvar _runFormlyCustomTags = __webpack_require__(18);\n\t\n\t\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\t\n\t\tvar ngModuleName = 'formly';\n\t\n\t\texports['default'] = ngModuleName;\n\t\n\t\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\t\n\t\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\t\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\t\tngModule.constant('formlyVersion', (\"7.3.4\")); // <-- webpack variable\n\t\n\t\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\t\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\t\n\t\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\t\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\t\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\t\n\t\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\t\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\t\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\t\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\t\n\t\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\t\tngModule.run(_runFormlyCustomTags2['default']);\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar angular = __webpack_require__(3);\n\t\n\t\t/* istanbul ignore next */\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\texports['default'] = angular;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\tvar apiCheck = (0, _apiCheck2['default'])({\n\t\t  output: {\n\t\t    prefix: 'angular-formly:',\n\t\t    docsBaseUrl: __webpack_require__(6)\n\t\t  }\n\t\t});\n\t\n\t\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t\t    otherProps = [otherProps];\n\t\t  }\n\t\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\t\n\t\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t      return obj && obj.hasOwnProperty(otherProp);\n\t\t    });\n\t\t    if (!otherPropsExist && !propExists) {\n\t\t      return apiCheck.utils.getError(propName, location, type);\n\t\t    } else if (propExists) {\n\t\t      return propChecker(prop, propName, location, obj);\n\t\t    }\n\t\t  }\n\t\n\t\t  shapeRequiredIfNotDefinition.type = type;\n\t\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t\t}\n\t\n\t\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\t\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\t\n\t\tvar apiCheckProperty = apiCheck.func;\n\t\n\t\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t\t  warn: apiCheck.func,\n\t\t  'throw': apiCheck.func,\n\t\t  shape: apiCheck.func\n\t\t}));\n\t\n\t\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\t\n\t\tvar formlyWrapperType = apiCheck.shape({\n\t\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  overwriteOk: apiCheck.bool.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\t\n\t\tvar templateManipulators = apiCheck.shape({\n\t\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t\t}).strict.nullable;\n\t\n\t\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar fieldOptionsApiShape = {\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  model: modelChecker.optional,\n\t\t  originalModel: modelChecker.optional,\n\t\t  className: apiCheck.string.optional,\n\t\t  id: apiCheck.string.optional,\n\t\t  name: apiCheck.string.optional,\n\t\t  expressionProperties: expressionProperties.optional,\n\t\t  extras: apiCheck.shape({\n\t\t    validateOnModelChange: apiCheck.bool.optional,\n\t\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t\t  }).strict.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  templateOptions: apiCheck.object.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  modelOptions: apiCheck.shape({\n\t\t    updateOn: apiCheck.string.optional,\n\t\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t\t    allowInvalid: apiCheck.bool.optional,\n\t\t    getterSetter: apiCheck.bool.optional,\n\t\t    timezone: apiCheck.string.optional\n\t\t  }).optional,\n\t\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t\t    expression: formlyExpression.optional,\n\t\t    listener: formlyExpression\n\t\t  })).optional,\n\t\t  validators: validatorChecker.optional,\n\t\t  asyncValidators: validatorChecker.optional,\n\t\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  noFormControl: apiCheck.bool.optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t\t  }).strict).optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t\t  validation: apiCheck.shape({\n\t\t    show: apiCheck.bool.nullable.optional,\n\t\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t\t  }).optional,\n\t\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t\t  value: apiCheck.func.optional,\n\t\t  runExpressions: apiCheck.func.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  initialValue: apiCheck.any.optional,\n\t\t  defaultValue: apiCheck.any.optional\n\t\t};\n\t\n\t\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\t\n\t\tvar formOptionsApi = apiCheck.shape({\n\t\t  formState: apiCheck.object.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t\t  data: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar fieldGroup = apiCheck.shape({\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  // danger. Nested field groups wont get api-checked...\n\t\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t\t  className: apiCheck.string.optional,\n\t\t  options: formOptionsApi.optional,\n\t\t  templateOptions: apiCheck.object.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  model: modelChecker.optional,\n\t\t  form: apiCheck.object.optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t\t}).strict;\n\t\n\t\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\t\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\t\n\t\tvar formlyTypeOptions = apiCheck.shape({\n\t\t  name: apiCheck.string,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t\t  'extends': apiCheck.string.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional,\n\t\t  overwriteOk: apiCheck.bool.optional\n\t\t}).strict;\n\t\n\t\t_angularFix2['default'].extend(apiCheck, {\n\t\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t\t});\n\t\n\t\texports['default'] = apiCheck;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.3.4\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\t\tmodule.exports = exports[\"default\"];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyUsability;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t\t  var _this = this;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    getFormlyError: getFormlyError,\n\t\t    getFieldError: getFieldError,\n\t\t    checkWrapper: checkWrapper,\n\t\t    checkWrapperTemplate: checkWrapperTemplate,\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    $get: function $get() {\n\t\t      return _this;\n\t\t    }\n\t\t  });\n\t\n\t\t  function getFieldError(errorInfoSlug, message, field) {\n\t\t    if (arguments.length < 3) {\n\t\t      field = message;\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t\t  }\n\t\n\t\t  function getFormlyError(errorInfoSlug, message) {\n\t\t    if (!message) {\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t\t  }\n\t\n\t\t  function getErrorMessage(errorInfoSlug, message) {\n\t\t    var url = '';\n\t\t    if (errorInfoSlug !== null) {\n\t\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t\t    }\n\t\t    return 'Formly Error: ' + message + '. ' + url;\n\t\t  }\n\t\n\t\t  function checkWrapper(wrapper) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t\t      prefix: 'formlyConfig.setWrapper',\n\t\t      urlSuffix: 'setwrapper-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function checkWrapperTemplate(template, additionalInfo) {\n\t\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t\t    if (template.indexOf(formlyTransclude) === -1) {\n\t\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyConfig;\n\t\n\t\t// @ngInject\n\t\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t\t  var _this2 = this;\n\t\n\t\t  var typeMap = {};\n\t\t  var templateWrappersMap = {};\n\t\t  var defaultWrapperName = 'default';\n\t\t  var _this = this;\n\t\t  var getError = formlyUsabilityProvider.getFormlyError;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    setType: setType,\n\t\t    getType: getType,\n\t\t    getTypeHeritage: getTypeHeritage,\n\t\t    setWrapper: setWrapper,\n\t\t    getWrapper: getWrapper,\n\t\t    getWrapperByType: getWrapperByType,\n\t\t    removeWrapperByName: removeWrapperByName,\n\t\t    removeWrappersForType: removeWrappersForType,\n\t\t    disableWarnings: false,\n\t\t    extras: {\n\t\t      disableNgModelAttrsManipulator: false,\n\t\t      fieldTransform: [],\n\t\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t\t      removeChromeAutoComplete: false,\n\t\t      defaultHideDirective: 'ng-if',\n\t\t      getFieldId: null\n\t\t    },\n\t\t    templateManipulators: {\n\t\t      preWrapper: [],\n\t\t      postWrapper: []\n\t\t    },\n\t\t    $get: function $get() {\n\t\t      return _this2;\n\t\t    }\n\t\t  });\n\t\n\t\t  function setType(options) {\n\t\t    if (_angularFix2['default'].isArray(options)) {\n\t\t      var _ret = (function () {\n\t\t        var allTypes = [];\n\t\t        _angularFix2['default'].forEach(options, function (item) {\n\t\t          allTypes.push(setType(item));\n\t\t        });\n\t\t        return {\n\t\t          v: allTypes\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret === 'object') return _ret.v;\n\t\t    } else if (_angularFix2['default'].isObject(options)) {\n\t\t      checkType(options);\n\t\t      if (options['extends']) {\n\t\t        extendTypeOptions(options);\n\t\t      }\n\t\t      typeMap[options.name] = options;\n\t\t      return typeMap[options.name];\n\t\t    } else {\n\t\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkType(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t\t      prefix: 'formlyConfig.setType',\n\t\t      url: 'settype-validation-failed'\n\t\t    });\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t\t    } else {\n\t\t      options.overwriteOk = undefined;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeOptions(options) {\n\t\t    var extendsType = getType(options['extends'], true, options);\n\t\t    extendTypeControllerFunction(options, extendsType);\n\t\t    extendTypeLinkFunction(options, extendsType);\n\t\t    extendTypeDefaultOptions(options, extendsType);\n\t\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t\t    extendTemplate(options, extendsType);\n\t\t  }\n\t\n\t\t  function extendTemplate(options, extendsType) {\n\t\t    if (options.template && extendsType.templateUrl) {\n\t\t      delete options.templateUrl;\n\t\t    } else if (options.templateUrl && extendsType.template) {\n\t\t      delete options.template;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeControllerFunction(options, extendsType) {\n\t\t    var extendsCtrl = extendsType.controller;\n\t\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsCtrl = options.controller;\n\t\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t\t      options.controller = function ($scope, $controller) {\n\t\t        $controller(extendsCtrl, { $scope: $scope });\n\t\t        $controller(optionsCtrl, { $scope: $scope });\n\t\t      };\n\t\t      options.controller.$inject = ['$scope', '$controller'];\n\t\t    } else {\n\t\t      options.controller = extendsCtrl;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeLinkFunction(options, extendsType) {\n\t\t    var extendsFn = extendsType.link;\n\t\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsFn = options.link;\n\t\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t\t      options.link = function () {\n\t\t        extendsFn.apply(undefined, arguments);\n\t\t        optionsFn.apply(undefined, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      options.link = extendsFn;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeDefaultOptions(options, extendsType) {\n\t\t    var extendsDO = extendsType.defaultOptions;\n\t\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsDO = options.defaultOptions;\n\t\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t\t    if (extendsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t\t        var mergedDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t\t        var extenderOptionsDefaultOptions = optionsDO;\n\t\t        if (optionsDOIsFn) {\n\t\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t\t        }\n\t\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t\t        return extendsDefaultOptions;\n\t\t      };\n\t\t    } else if (optionsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var newDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t\t        return optionsDO(newDefaultOptions, scope);\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function getType(name, throwError, errorContext) {\n\t\t    if (!name) {\n\t\t      return undefined;\n\t\t    }\n\t\t    var type = typeMap[name];\n\t\t    if (!type && throwError === true) {\n\t\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t\t    } else {\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypeHeritage(parent) {\n\t\t    var heritage = [];\n\t\t    var type = parent;\n\t\t    if (_angularFix2['default'].isString(type)) {\n\t\t      type = getType(parent);\n\t\t    }\n\t\t    parent = type['extends'];\n\t\t    while (parent) {\n\t\t      type = getType(parent);\n\t\t      heritage.push(type);\n\t\t      parent = type['extends'];\n\t\t    }\n\t\t    return heritage;\n\t\t  }\n\t\n\t\t  function setWrapper(_x, _x2) {\n\t\t    var _again = true;\n\t\n\t\t    _function: while (_again) {\n\t\t      var options = _x,\n\t\t          name = _x2;\n\t\t      _again = false;\n\t\n\t\t      if (_angularFix2['default'].isArray(options)) {\n\t\t        return options.map(function (wrapperOptions) {\n\t\t          return setWrapper(wrapperOptions);\n\t\t        });\n\t\t      } else if (_angularFix2['default'].isObject(options)) {\n\t\t        options.types = getOptionsTypes(options);\n\t\t        options.name = getOptionsName(options, name);\n\t\t        checkWrapperAPI(options);\n\t\t        templateWrappersMap[options.name] = options;\n\t\t        return options;\n\t\t      } else if (_angularFix2['default'].isString(options)) {\n\t\t        _x = {\n\t\t          template: options,\n\t\t          name: name\n\t\t        };\n\t\t        _x2 = undefined;\n\t\t        _again = true;\n\t\t        continue _function;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsTypes(options) {\n\t\t    if (_angularFix2['default'].isString(options.types)) {\n\t\t      return [options.types];\n\t\t    }\n\t\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t\t      return [];\n\t\t    } else {\n\t\t      return options.types;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsName(options, name) {\n\t\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t\t  }\n\t\n\t\t  function checkWrapperAPI(options) {\n\t\t    formlyUsabilityProvider.checkWrapper(options);\n\t\t    if (options.template) {\n\t\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t\t    }\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t\t    } else {\n\t\t      delete options.overwriteOk;\n\t\t    }\n\t\t    checkWrapperTypes(options);\n\t\t  }\n\t\n\t\t  function checkWrapperTypes(options) {\n\t\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t\t    if (shouldThrow) {\n\t\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkOverwrite(property, object, newValue, objectName) {\n\t\t    if (object.hasOwnProperty(property)) {\n\t\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t\t    }\n\t\t  }\n\t\n\t\t  function getWrapper(name) {\n\t\t    return templateWrappersMap[name || defaultWrapperName];\n\t\t  }\n\t\n\t\t  function getWrapperByType(type) {\n\t\t    /* eslint prefer-const:0 */\n\t\t    var wrappers = [];\n\t\t    for (var _name in templateWrappersMap) {\n\t\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t\t          wrappers.push(templateWrappersMap[_name]);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return wrappers;\n\t\t  }\n\t\n\t\t  function removeWrapperByName(name) {\n\t\t    var wrapper = templateWrappersMap[name];\n\t\t    delete templateWrappersMap[name];\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function removeWrappersForType(type) {\n\t\t    var wrappers = getWrapperByType(type);\n\t\t    if (!wrappers) {\n\t\t      return undefined;\n\t\t    }\n\t\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t\t      return removeWrapperByName(wrappers.name);\n\t\t    } else {\n\t\t      wrappers.forEach(function (wrapper) {\n\t\t        return removeWrapperByName(wrapper.name);\n\t\t      });\n\t\t      return wrappers;\n\t\t    }\n\t\t  }\n\t\n\t\t  function warn() {\n\t\t    if (!_this.disableWarnings && console.warn) {\n\t\t      /* eslint no-console:0 */\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      console.warn.apply(console, _toConsumableArray(args));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = {\n\t\t  formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName, arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t\t};\n\t\n\t\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t\t  if (_angularFix2['default'].isFunction(expression)) {\n\t\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t\t  } else {\n\t\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t\t  }\n\t\t}\n\t\n\t\tfunction getFieldId(formId, options, index) {\n\t\t  if (options.id) {\n\t\t    return options.id;\n\t\t  }\n\t\t  var type = options.type;\n\t\t  if (!type && options.template) {\n\t\t    type = 'template';\n\t\t  } else if (!type && options.templateUrl) {\n\t\t    type = 'templateUrl';\n\t\t  }\n\t\n\t\t  return [formId, type, options.key, index].join('_');\n\t\t}\n\t\n\t\tfunction reverseDeepMerge(dest) {\n\t\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t\t    if (!index) {\n\t\t      return;\n\t\t    }\n\t\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t\t        dest[prop] = _angularFix2['default'].copy(val);\n\t\t      } else if (objAndSameType(dest[prop], val)) {\n\t\t        reverseDeepMerge(dest[prop], val);\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t  return dest;\n\t\t}\n\t\n\t\tfunction objAndSameType(obj1, obj2) {\n\t\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t\t}\n\t\n\t\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\t\tfunction findByNodeName(el, nodeName) {\n\t\t  if (!el.prop) {\n\t\t    // not a jQuery or jqLite object -> wrap it\n\t\t    el = _angularFix2['default'].element(el);\n\t\t  }\n\t\n\t\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t\t    return el;\n\t\t  }\n\t\n\t\t  var c = el.children();\n\t\t  for (var i = 0; c && i < c.length; i++) {\n\t\t    var node = findByNodeName(c[i], nodeName);\n\t\t    if (node) {\n\t\t      return node;\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t\t    obj = [obj];\n\t\t  } else if (!obj) {\n\t\t    obj = [];\n\t\t  }\n\t\t  return obj;\n\t\t}\n\t\n\t\tfunction extendFunction() {\n\t\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t    fns[_key] = arguments[_key];\n\t\t  }\n\t\n\t\t  return function extendedFunction() {\n\t\t    var args = arguments;\n\t\t    fns.forEach(function (fn) {\n\t\t      return fn.apply(null, args);\n\t\t    });\n\t\t  };\n\t\t}\n\t\n\t\tfunction extendArray(primary, secondary, property) {\n\t\t  if (property) {\n\t\t    primary = primary[property];\n\t\t    secondary = secondary[property];\n\t\t  }\n\t\t  if (secondary && primary) {\n\t\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t\t      if (primary.indexOf(item) === -1) {\n\t\t        primary.push(item);\n\t\t      }\n\t\t    });\n\t\t    return primary;\n\t\t  } else if (secondary) {\n\t\t    return secondary;\n\t\t  } else {\n\t\t    return primary;\n\t\t  }\n\t\t}\n\t\n\t\tfunction startsWith(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\n\t\tfunction contains(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\texports['default'] = formlyValidationMessages;\n\t\n\t\t// @ngInject\n\t\tfunction formlyValidationMessages() {\n\t\n\t\t  var validationMessages = {\n\t\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t\t    addStringMessage: addStringMessage,\n\t\t    messages: {}\n\t\t  };\n\t\n\t\t  return validationMessages;\n\t\n\t\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t\t  }\n\t\n\t\t  function addStringMessage(name, string) {\n\t\t    validationMessages.messages[name] = function () {\n\t\t      return string;\n\t\t    };\n\t\t  }\n\t\n\t\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t\t      if (typeof scope.options.templateOptions[prop] !== 'undefined') {\n\t\t        return prefix + ' ' + scope.options.templateOptions[prop] + ' ' + suffix;\n\t\t      } else {\n\t\t        return alternate;\n\t\t      }\n\t\t    };\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyUtil;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUtil() {\n\t\t  return _otherUtils2['default'];\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\texports['default'] = formlyWarn;\n\t\n\t\t// @ngInject\n\t\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t\t  return function warn() {\n\t\t    if (!formlyConfig.disableWarnings) {\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      $log.warn.apply($log, _toConsumableArray(args));\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyCustomValidation;\n\t\n\t\t// @ngInject\n\t\tfunction formlyCustomValidation(formlyUtil) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    require: 'ngModel',\n\t\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t\t      var opts = scope.options;\n\t\t      opts.validation.messages = opts.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t\t        opts.validation.messages[key] = function () {\n\t\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t        };\n\t\t      });\n\t\n\t\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\t\n\t\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t\t        setupMessage(validator, name);\n\t\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t\t        if (useNewValidatorsApi) {\n\t\t          setupWithValidators(validator, name, isAsync);\n\t\t        } else {\n\t\t          setupWithParsers(validator, name, isAsync);\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupMessage(validator, name) {\n\t\t        var message = validator.message;\n\t\t        if (message) {\n\t\t          opts.validation.messages[name] = function () {\n\t\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t          };\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupWithValidators(validator, name, isAsync) {\n\t\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\t\n\t\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t\t        };\n\t\t      }\n\t\n\t\t      function setupWithParsers(validator, name, isAsync) {\n\t\t        var inFlightValidator = undefined;\n\t\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t\t          if (isAsync) {\n\t\t            ctrl.$pending = ctrl.$pending || {};\n\t\t            ctrl.$pending[name] = true;\n\t\t            inFlightValidator = isValid;\n\t\t            isValid.then(function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, true);\n\t\t              }\n\t\t            })['catch'](function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, false);\n\t\t              }\n\t\t            })['finally'](function () {\n\t\t              var $pending = ctrl.$pending || {};\n\t\t              if (Object.keys($pending).length === 1) {\n\t\t                delete ctrl.$pending;\n\t\t              } else {\n\t\t                delete ctrl.$pending[name];\n\t\t              }\n\t\t            });\n\t\t          } else {\n\t\t            ctrl.$setValidity(name, isValid);\n\t\t          }\n\t\t          return viewValue;\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = formlyField;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyField\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t\t  var arrayify = formlyUtil.arrayify;\n\t\n\t\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    transclude: true,\n\t\t    require: '?^formlyForm',\n\t\t    scope: {\n\t\t      options: '=',\n\t\t      model: '=',\n\t\t      originalModel: '=?',\n\t\t      formId: '@', // TODO remove formId in a breaking release\n\t\t      index: '=?',\n\t\t      fields: '=?',\n\t\t      formState: '=?',\n\t\t      formOptions: '=?',\n\t\t      form: '=?' },\n\t\t    // TODO require form in a breaking release\n\t\t    controller: FormlyFieldController,\n\t\t    link: fieldLink\n\t\t  };\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t\t    /* eslint max-statements:[2, 31] */\n\t\t    if ($scope.options.fieldGroup) {\n\t\t      setupFieldGroup();\n\t\t      return;\n\t\t    }\n\t\n\t\t    var fieldType = getFieldType($scope.options);\n\t\t    simplifyLife($scope.options);\n\t\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t\t    checkApi($scope.options);\n\t\t    // set field id to link labels and fields\n\t\n\t\t    // initalization\n\t\t    setFieldIdAndName();\n\t\t    setDefaultValue();\n\t\t    setInitialValue();\n\t\t    runExpressions();\n\t\t    addValidationMessages($scope.options);\n\t\t    invokeControllers($scope, $scope.options, fieldType);\n\t\n\t\t    // function definitions\n\t\t    function runExpressions() {\n\t\t      // must run on next tick to make sure that the current value is correct.\n\t\t      return $timeout(function runExpressionsOnNextTick() {\n\t\t        var field = $scope.options;\n\t\t        var currentValue = valueGetterSetter();\n\t\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t\t          var setter = $parse(prop).assign;\n\t\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t\t          promise.then(function setFieldValue(value) {\n\t\t            setter(field, value);\n\t\t          });\n\t\t        });\n\t\t      }, 0, false);\n\t\t    }\n\t\n\t\t    function valueGetterSetter(newVal) {\n\t\t      if (!$scope.model || !$scope.options.key) {\n\t\t        return undefined;\n\t\t      }\n\t\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t\t        parseSet($scope.options.key, $scope.model, newVal);\n\t\t      }\n\t\t      return parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function parseSet(key, model, newVal) {\n\t\t      // If either of these are null/undefined then just return undefined\n\t\t      if (!key || !model) {\n\t\t        return;\n\t\t      }\n\t\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t\t      if (_angularFix2['default'].isNumber(key)) {\n\t\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t\t        model[key] = newVal;\n\t\t      } else {\n\t\t        var setter = $parse($scope.options.key).assign;\n\t\t        if (setter) {\n\t\t          setter($scope.model, newVal);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function parseGet(key, model) {\n\t\t      // If either of these are null/undefined then just return undefined\n\t\t      if (!key || !model) {\n\t\t        return undefined;\n\t\t      }\n\t\n\t\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t\t      if (_angularFix2['default'].isNumber(key)) {\n\t\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t\t        return model[key];\n\t\t      } else {\n\t\t        return $parse(key)(model);\n\t\t      }\n\t\t    }\n\t\n\t\t    function simplifyLife(options) {\n\t\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t\t      formlyUtil.reverseDeepMerge(options, {\n\t\t        originalModel: options.model,\n\t\t        extras: {},\n\t\t        data: {},\n\t\t        templateOptions: {},\n\t\t        validation: {}\n\t\t      });\n\t\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t\t      $scope.to = $scope.options.templateOptions;\n\t\t      $scope.formOptions = $scope.formOptions || {};\n\t\t    }\n\t\n\t\t    function setFieldIdAndName() {\n\t\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t\t      } else {\n\t\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t\t      }\n\t\t      $scope.options.id = $scope.id;\n\t\t      $scope.name = $scope.options.name || $scope.options.id;\n\t\t      $scope.options.name = $scope.name;\n\t\t    }\n\t\n\t\t    function setDefaultValue() {\n\t\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined(parseGet($scope.options.key, $scope.model))) {\n\t\t        parseSet($scope.options.key, $scope.model, $scope.options.defaultValue);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setInitialValue() {\n\t\t      $scope.options.initialValue = $scope.model && parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t\t      if (type) {\n\t\t        mergeOptions(options, type.defaultOptions);\n\t\t      }\n\t\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t\t      });\n\t\t    }\n\t\n\t\t    function mergeOptions(options, extraOptions) {\n\t\t      if (extraOptions) {\n\t\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t\t          extraOptions = extraOptions(options, $scope);\n\t\t        }\n\t\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t\t      }\n\t\t    }\n\t\n\t\t    function extendOptionsWithDefaults(options, index) {\n\t\t      var key = options.key || index || 0;\n\t\t      _angularFix2['default'].extend(options, {\n\t\t        // attach the key in case the formly-field directive is used directly\n\t\t        key: key,\n\t\t        value: options.value || valueGetterSetter,\n\t\t        runExpressions: runExpressions,\n\t\t        resetModel: resetModel,\n\t\t        updateInitialValue: updateInitialValue\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      parseSet($scope.options.key, $scope.model, $scope.options.initialValue);\n\t\t      if ($scope.options.formControl) {\n\t\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t\t            resetFormControl(formControl, true);\n\t\t          });\n\t\t        } else {\n\t\t          resetFormControl($scope.options.formControl);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function resetFormControl(formControl, isMultiNgModel) {\n\t\t      if (!isMultiNgModel) {\n\t\t        formControl.$setViewValue(parseGet($scope.options.key, $scope.model));\n\t\t      }\n\t\n\t\t      formControl.$render();\n\t\t      formControl.$setUntouched && formControl.$setUntouched();\n\t\t      formControl.$setPristine();\n\t\n\t\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t\t      if (!$scope.$root.$$phase) {\n\t\t        $scope.$digest();\n\t\t      }\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      $scope.options.initialValue = parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function addValidationMessages(options) {\n\t\t      options.validation.messages = options.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t\t        if (!options.validation.messages[name]) {\n\t\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t\t          };\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function invokeControllers(scope) {\n\t\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t\t        if (controller) {\n\t\t          $controller(controller, { $scope: scope });\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupFieldGroup() {\n\t\t      $scope.options.options = $scope.options.options || {};\n\t\t      $scope.options.options.formState = $scope.formState;\n\t\t      $scope.to = $scope.options.templateOptions;\n\t\t    }\n\t\t  }\n\t\n\t\t  // link function\n\t\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t\t    if (scope.options.fieldGroup) {\n\t\t      setFieldGroupTemplate();\n\t\t      return;\n\t\t    }\n\t\n\t\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t\t    if (!formlyFormCtrl && scope.options.model) {\n\t\t      scope.$watch('options.model', function () {\n\t\t        return scope.options.runExpressions();\n\t\t      }, true);\n\t\t    }\n\t\n\t\t    addAttributes();\n\t\t    addClasses();\n\t\n\t\t    var type = getFieldType(scope.options);\n\t\t    var args = arguments;\n\t\t    var thusly = this;\n\t\t    var fieldCount = 0;\n\t\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t\t    });\n\t\n\t\t    function setFieldGroupTemplate() {\n\t\t      checkFieldGroupApi(scope.options);\n\t\t      el.addClass('formly-field-group');\n\t\t      var extraAttributes = '';\n\t\t      if (scope.options.elementAttributes) {\n\t\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t\t        }).join(' ');\n\t\t      }\n\t\t      var modelValue = 'model';\n\t\t      scope.options.form = scope.form;\n\t\t      if (scope.options.key) {\n\t\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t\t      }\n\t\t      getTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ').then(transcludeInWrappers(scope.options, scope.formOptions)).then(setElementTemplate);\n\t\t    }\n\t\n\t\t    function addAttributes() {\n\t\t      if (scope.options.elementAttributes) {\n\t\t        el.attr(scope.options.elementAttributes);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addClasses() {\n\t\t      if (scope.options.className) {\n\t\t        el.addClass(scope.options.className);\n\t\t      }\n\t\t      if (scope.options.type) {\n\t\t        el.addClass('formly-field-' + scope.options.type);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setElementTemplate(templateString) {\n\t\t      el.html(asHtml(templateString));\n\t\t      $compile(el.contents())(scope);\n\t\t      return templateString;\n\t\t    }\n\t\n\t\t    function watchFormControl(templateString) {\n\t\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t\t      if (scope.options.noFormControl) {\n\t\t        return;\n\t\t      }\n\t\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\t\n\t\t      if (ngModelNodes.length) {\n\t\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t\t          fieldCount++;\n\t\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t\t        });\n\t\t      }\n\t\n\t\t      function watchFieldNameOrExistence(name) {\n\t\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t\t        var nameExpression = nameExpressionRegex.exec(name);\n\t\t        if (nameExpression) {\n\t\t          name = $interpolate(name)(scope);\n\t\t        }\n\t\t        watchFieldExistence(name);\n\t\t      }\n\t\n\t\t      function watchFieldExistence(name) {\n\t\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t\t          if (formControl) {\n\t\t            if (fieldCount > 1) {\n\t\t              if (!scope.options.formControl) {\n\t\t                scope.options.formControl = [];\n\t\t              }\n\t\t              scope.options.formControl.push(formControl);\n\t\t            } else {\n\t\t              scope.options.formControl = formControl;\n\t\t            }\n\t\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t\t            stopWatchingShowError();\n\t\t            addShowMessagesWatcher();\n\t\t            addParsers();\n\t\t            addFormatters();\n\t\t          }\n\t\t        });\n\t\t      }\n\t\n\t\t      function addShowMessagesWatcher() {\n\t\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t\t          var options = scope.options;\n\t\t          var formControls = arrayify(scope.fc);\n\t\t          if (!formControls.some(function (fc) {\n\t\t            return fc.$invalid;\n\t\t          })) {\n\t\t            return false;\n\t\t          } else if (typeof options.validation.show === 'boolean') {\n\t\t            return options.validation.show;\n\t\t          } else if (customExpression) {\n\t\t            return formControls.some(function (fc) {\n\t\t              return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t\t            });\n\t\t          } else {\n\t\t            return formControls.some(function (fc) {\n\t\t              var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t\t              return fc.$touched || noTouchedButDirty;\n\t\t            });\n\t\t          }\n\t\t        }, function onShowValidationChange(show) {\n\t\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t\t          scope.showError = show; // shortcut for template authors\n\t\t        });\n\t\t      }\n\t\n\t\t      function addParsers() {\n\t\t        setParsersOrFormatters('parsers');\n\t\t      }\n\t\n\t\t      function addFormatters() {\n\t\t        setParsersOrFormatters('formatters');\n\t\t        var ctrl = scope.fc;\n\t\t        var formWasPristine = scope.form.$pristine;\n\t\t        if (scope.options.formatters) {\n\t\t          (function () {\n\t\t            var value = ctrl.$modelValue;\n\t\t            ctrl.$formatters.forEach(function (formatter) {\n\t\t              value = formatter(value);\n\t\t            });\n\t\n\t\t            ctrl.$setViewValue(value);\n\t\t            ctrl.$render();\n\t\t            ctrl.$setPristine();\n\t\t            if (formWasPristine) {\n\t\t              scope.form.$setPristine();\n\t\t            }\n\t\t          })();\n\t\t        }\n\t\t      }\n\t\n\t\t      function setParsersOrFormatters(which) {\n\t\t        var originalThingProp = 'originalParser';\n\t\t        if (which === 'formatters') {\n\t\t          originalThingProp = 'originalFormatter';\n\t\t        }\n\t\n\t\t        // init with type's parsers\n\t\t        var things = getThingsFromType(type);\n\t\n\t\t        // get optionsTypes things\n\t\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\t\n\t\t        // get field's things\n\t\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\t\n\t\t        // convert things into formlyExpression things\n\t\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t\t          things[index] = getFormlyExpressionThing(thing);\n\t\t        });\n\t\n\t\t        var ngModelCtrls = scope.fc;\n\t\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t\t          ngModelCtrls = [ngModelCtrls];\n\t\t        }\n\t\n\t\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t\t          var _ngModelCtrl;\n\t\n\t\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t\t        });\n\t\n\t\t        function getThingsFromType(theType) {\n\t\t          if (!theType) {\n\t\t            return [];\n\t\t          }\n\t\t          if (_angularFix2['default'].isString(theType)) {\n\t\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t\t          }\n\t\t          var typeThings = [];\n\t\n\t\t          // get things from parent\n\t\t          if (theType['extends']) {\n\t\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t\t          }\n\t\n\t\t          // get own type's things\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\t\n\t\t          // get things from optionsTypes\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\t\n\t\t          return typeThings;\n\t\t        }\n\t\n\t\t        function getThingsFromOptionsTypes() {\n\t\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t\t          var optionsTypesThings = [];\n\t\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t\t          });\n\t\t          return optionsTypesThings;\n\t\t        }\n\t\n\t\t        function getFormlyExpressionThing(thing) {\n\t\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t\t          return formlyExpressionParserOrFormatterFunction;\n\t\n\t\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t\t            var $modelValue = scope.options.value();\n\t\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function callLinkFunctions() {\n\t\t      if (type && type.link) {\n\t\t        type.link.apply(thusly, args);\n\t\t      }\n\t\t      if (scope.options.link) {\n\t\t        scope.options.link.apply(thusly, args);\n\t\t      }\n\t\t    }\n\t\n\t\t    function runManipulators(manipulators) {\n\t\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t\t        var chain = $q.when(templateToManipulate);\n\t\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t\t          chain = chain.then(function (template) {\n\t\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t\t            });\n\t\t          });\n\t\t        });\n\t\t        return chain;\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  // sort-of stateless util functions\n\t\t  function asHtml(el) {\n\t\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t\t    return wrapper.append(el).html();\n\t\t  }\n\t\n\t\t  function getFieldType(options) {\n\t\t    return options.type && formlyConfig.getType(options.type);\n\t\t  }\n\t\n\t\t  function getManipulators(options, formOptions) {\n\t\t    var preWrapper = [];\n\t\t    var postWrapper = [];\n\t\t    addManipulators(options.templateManipulators);\n\t\t    addManipulators(formOptions.templateManipulators);\n\t\t    addManipulators(formlyConfig.templateManipulators);\n\t\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\t\n\t\t    function addManipulators(manipulators) {\n\t\t      /* eslint-disable */ // it doesn't understand this :-(\n\t\n\t\t      var _ref = manipulators || {};\n\t\n\t\t      var _ref$preWrapper = _ref.preWrapper;\n\t\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t\t      var _ref$postWrapper = _ref.postWrapper;\n\t\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\t\n\t\t      preWrapper = preWrapper.concat(pre);\n\t\t      postWrapper = postWrapper.concat(post);\n\t\t      /* eslint-enable */\n\t\t    }\n\t\t  }\n\t\n\t\t  function getFieldTemplate(options) {\n\t\t    function fromOptionsOrType(key, fieldType) {\n\t\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t\t        return options[key];\n\t\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t\t        return fieldType[key];\n\t\t      }\n\t\t    }\n\t\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    var template = fromOptionsOrType('template', type);\n\t\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t\t    }\n\t\n\t\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t\t  }\n\t\n\t\t  function getTemplate(template, isUrl, options) {\n\t\t    var templatePromise = undefined;\n\t\t    if (_angularFix2['default'].isFunction(template)) {\n\t\t      templatePromise = $q.when(template(options));\n\t\t    } else {\n\t\t      templatePromise = $q.when(template);\n\t\t    }\n\t\n\t\t    if (!isUrl) {\n\t\t      return templatePromise;\n\t\t    } else {\n\t\t      var _ret2 = (function () {\n\t\t        var httpOptions = { cache: $templateCache };\n\t\t        return {\n\t\t          v: templatePromise.then(function (url) {\n\t\t            return $http.get(url, httpOptions);\n\t\t          }).then(function (response) {\n\t\t            return response.data;\n\t\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t\t          })\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret2 === 'object') return _ret2.v;\n\t\t    }\n\t\t  }\n\t\n\t\t  function transcludeInWrappers(options, formOptions) {\n\t\t    var wrapper = getWrapperOption(options, formOptions);\n\t\n\t\t    return function transcludeTemplate(template) {\n\t\t      if (!wrapper.length) {\n\t\t        return $q.when(template);\n\t\t      }\n\t\n\t\t      wrapper.forEach(function (aWrapper) {\n\t\t        formlyUsability.checkWrapper(aWrapper, options);\n\t\t        runApiCheck(aWrapper, options);\n\t\t      });\n\t\t      var promises = wrapper.map(function (w) {\n\t\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t\t      });\n\t\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t\t        });\n\t\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t\t        var totalWrapper = wrappersTemplates.shift();\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t\t        });\n\t\t        return doTransclusion(totalWrapper, template);\n\t\t      });\n\t\t    };\n\t\t  }\n\t\n\t\t  function doTransclusion(wrapper, template) {\n\t\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t\t    superWrapper.append(wrapper);\n\t\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t\t    if (!transcludeEl.length) {\n\t\t      // try it using our custom find function\n\t\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t\t    }\n\t\t    transcludeEl.replaceWith(template);\n\t\t    return superWrapper.html();\n\t\t  }\n\t\n\t\t  function getWrapperOption(options, formOptions) {\n\t\t    /* eslint complexity:[2, 6] */\n\t\t    var wrapper = options.wrapper;\n\t\t    // explicit null means no wrapper\n\t\t    if (wrapper === null) {\n\t\t      return [];\n\t\t    }\n\t\n\t\t    // nothing specified means use the default wrapper for the type\n\t\t    if (!wrapper) {\n\t\t      // get all wrappers that specify they apply to this type\n\t\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t\t    } else {\n\t\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t\t    }\n\t\n\t\t    // get all wrappers for that the type specified that it uses.\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    if (type && type.wrapper) {\n\t\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(typeWrappers);\n\t\t    }\n\t\n\t\t    // add form wrappers\n\t\t    if (formOptions.wrapper) {\n\t\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(formWrappers);\n\t\t    }\n\t\n\t\t    // add the default wrapper last\n\t\t    var defaultWrapper = formlyConfig.getWrapper();\n\t\t    if (defaultWrapper) {\n\t\t      wrapper.push(defaultWrapper);\n\t\t    }\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function checkApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t    // validate with the type\n\t\t    var type = options.type && formlyConfig.getType(options.type);\n\t\t    if (type) {\n\t\t      runApiCheck(type, options, true);\n\t\t    }\n\t\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkFieldGroupApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function runApiCheck(_ref2, options, forType) {\n\t\t    var apiCheck = _ref2.apiCheck;\n\t\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\t\n\t\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t\t    if (forType && options.type) {\n\t\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t\t    /* eslint complexity:[2, 9] */\n\t\t    if (!apiCheck) {\n\t\t      return;\n\t\t    }\n\t\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t\t      return;\n\t\t    }\n\t\t    var fn = apiCheckFunction || 'warn';\n\t\t    // this is the new API\n\t\t    var checkerObjects = apiCheck(instance);\n\t\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t\t      var checker = instance.shape(shape);\n\t\t      var checkOptions = _angularFix2['default'].extend({\n\t\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t\t      }, apiCheckOptions);\n\t\t      instance[fn](checker, options[name], checkOptions);\n\t\t    });\n\t\t  }\n\t\t}\n\t\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\t\n\t\t// Stateless util functions\n\t\tfunction getDefaultOptionsOptionsTypes(type) {\n\t\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t\t}\n\t\n\t\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\texports['default'] = formlyFocus;\n\t\n\t\t// @ngInject\n\t\tfunction formlyFocus($timeout, $document) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    link: function formlyFocusLink(scope, element, attrs) {\n\t\t      var previousEl = null;\n\t\t      var el = element[0];\n\t\t      var doc = $document[0];\n\t\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t\t        if (value === 'true') {\n\t\t          $timeout(function setElementFocus() {\n\t\t            previousEl = doc.activeElement;\n\t\t            el.focus();\n\t\t          }, ~ ~attrs.focusWait);\n\t\t        } else if (value === 'false') {\n\t\t          if (doc.activeElement === el) {\n\t\t            el.blur();\n\t\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t\t              previousEl.focus();\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar _slice = Array.prototype.slice;\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyForm;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyForm\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t\t  var currentFormId = 1;\n\t\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    template: formlyFormGetTemplate,\n\t\t    replace: true,\n\t\t    transclude: true,\n\t\t    scope: {\n\t\t      fields: '=',\n\t\t      model: '=',\n\t\t      form: '=?',\n\t\t      options: '=?'\n\t\t    },\n\t\t    controller: FormlyFormController,\n\t\t    link: formlyFormLink\n\t\t  };\n\t\n\t\t  function formlyFormGetTemplate(el, attrs) {\n\t\t    var rootEl = getRootEl();\n\t\t    var fieldRootEl = getFieldRootEl();\n\t\t    var formId = 'formly_' + currentFormId++;\n\t\t    var parentFormAttributes = '';\n\t\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t\t    }\n\t\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\t\n\t\t    function getRootEl() {\n\t\t      return attrs.rootEl || 'ng-form';\n\t\t    }\n\t\n\t\t    function getFieldRootEl() {\n\t\t      return attrs.fieldRootEl || 'div';\n\t\t    }\n\t\n\t\t    function getHideDirective() {\n\t\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t\t    }\n\t\n\t\t    function getTrackBy() {\n\t\t      if (!attrs.trackBy) {\n\t\t        return '';\n\t\t      } else {\n\t\t        return 'track by ' + attrs.trackBy;\n\t\t      }\n\t\t    }\n\t\n\t\t    function getFormName() {\n\t\t      var formName = formId;\n\t\t      var bindName = attrs.bindName;\n\t\t      if (bindName) {\n\t\t        if (_angularFix2['default'].version.minor < 3) {\n\t\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t\t        }\n\t\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t\t      }\n\t\t      return formName;\n\t\t    }\n\t\n\t\t    function getTranscludeClass() {\n\t\t      return attrs.transcludeClass || '';\n\t\t    }\n\t\n\t\t    function copyAttributes(attributes) {\n\t\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t\t      var arrayAttrs = [];\n\t\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t\t        var nodeName = _ref.nodeName;\n\t\t        var value = _ref.value;\n\t\n\t\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t\t        }\n\t\t      });\n\t\t      return arrayAttrs.join(' ');\n\t\t    }\n\t\t  }\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t\t    setupOptions();\n\t\t    $scope.model = $scope.model || {};\n\t\t    setupFields();\n\t\n\t\t    // watch the model and evaluate watch expressions that depend on it.\n\t\t    $scope.$watch('model', onModelOrFormStateChange, true);\n\t\t    if ($scope.options.formState) {\n\t\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t\t    }\n\t\n\t\t    function onModelOrFormStateChange() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function runFieldExpressionProperties(field, index) {\n\t\t        var model = field.model || $scope.model;\n\t\t        var promise = field.runExpressions && field.runExpressions();\n\t\t        if (field.hideExpression) {\n\t\t          // can't use hide with expressionProperties reliably\n\t\t          var val = model[field.key];\n\t\t          field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t\t        }\n\t\t        if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t\t          var validate = field.formControl.$validate;\n\t\t          if (promise) {\n\t\t            promise.then(validate);\n\t\t          } else {\n\t\t            validate();\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupFields() {\n\t\t      $scope.fields = $scope.fields || [];\n\t\n\t\t      checkDeprecatedOptions($scope.options);\n\t\n\t\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\t\n\t\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t\t        fieldTransforms = [fieldTransforms];\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t\t        if (fieldTransform) {\n\t\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t\t          if (!$scope.fields) {\n\t\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t\t          }\n\t\t        }\n\t\t      });\n\t\n\t\t      setupModels();\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t\t    }\n\t\n\t\t    function checkDeprecatedOptions(options) {\n\t\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupOptions() {\n\t\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t\t      $scope.options = $scope.options || {};\n\t\t      $scope.options.formState = $scope.options.formState || {};\n\t\n\t\t      _angularFix2['default'].extend($scope.options, {\n\t\t        updateInitialValue: updateInitialValue,\n\t\t        resetModel: resetModel\n\t\t      });\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.updateInitialValue();\n\t\t        } else {\n\t\t          field.updateInitialValue();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.resetModel();\n\t\t        } else if (field.resetModel) {\n\t\t          field.resetModel();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupModels() {\n\t\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t\t      var watchedModels = [$scope.model];\n\t\n\t\t      if ($scope.options.formState) {\n\t\t        // $scope.options.formState will have its own watcher\n\t\t        watchedModels.push($scope.options.formState);\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        var isNewModel = initModel(field);\n\t\n\t\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1) {\n\t\t          $scope.$watch(function () {\n\t\t            return field.model;\n\t\t          }, onModelOrFormStateChange, true);\n\t\t          watchedModels.push(field.model);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function initModel(field) {\n\t\t      var isNewModel = true;\n\t\n\t\t      if (_angularFix2['default'].isString(field.model)) {\n\t\t        var expression = field.model;\n\t\t        var index = $scope.fields.indexOf(field);\n\t\n\t\t        isNewModel = !refrencesCurrentlyWatchedModel(expression);\n\t\n\t\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t\t        if (!field.model) {\n\t\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t\t        }\n\t\t      }\n\t\t      return isNewModel;\n\t\t    }\n\t\n\t\t    function refrencesCurrentlyWatchedModel(expression) {\n\t\t      return ['model', 'formState'].some(function (item) {\n\t\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t\t      });\n\t\t    }\n\t\n\t\t    function attachKey(field, index) {\n\t\t      if (!isFieldGroup(field)) {\n\t\t        field.key = field.key || index || 0;\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupWatchers(field, index) {\n\t\t      if (isFieldGroup(field) || !_angularFix2['default'].isDefined(field.watcher)) {\n\t\t        return;\n\t\t      }\n\t\t      var watchers = field.watcher;\n\t\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t\t        watchers = [watchers];\n\t\t      }\n\t\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t\t        if (!_angularFix2['default'].isDefined(watcher.listener)) {\n\t\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t\t        }\n\t\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t\t        var watchListener = getWatchListener(watcher, field, index);\n\t\n\t\t        var type = watcher.type || '$watch';\n\t\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t\t      });\n\t\t    }\n\t\n\t\t    function getWatchExpression(watcher, field, index) {\n\t\t      var watchExpression = watcher.expression || 'model[\\'' + field.key + '\\']';\n\t\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t\t        (function () {\n\t\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalExpression = watchExpression;\n\t\t          watchExpression = function formlyWatchExpression() {\n\t\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t\t          };\n\t\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchExpression;\n\t\t    }\n\t\n\t\t    function getWatchListener(watcher, field, index) {\n\t\t      var watchListener = watcher.listener;\n\t\t      if (_angularFix2['default'].isFunction(watchListener)) {\n\t\t        (function () {\n\t\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalListener = watchListener;\n\t\t          watchListener = function formlyWatchListener() {\n\t\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t            return originalListener.apply(undefined, _toConsumableArray(args));\n\t\t          };\n\t\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchListener;\n\t\t    }\n\t\n\t\t    function modifyArgs(watcher, index) {\n\t\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\t        originalArgs[_key - 2] = arguments[_key];\n\t\t      }\n\t\n\t\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t\t    }\n\t\n\t\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t\t    }\n\t\n\t\t    function getFormlyFieldLikeLocals(field, index) {\n\t\t      // this makes it closer to what a regular formlyExpression would be\n\t\t      return {\n\t\t        options: field,\n\t\t        index: index,\n\t\t        formState: $scope.options.formState,\n\t\t        formId: $scope.formId\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function formlyFormLink(scope, el, attrs) {\n\t\t    setFormController();\n\t\t    fixChromeAutocomplete();\n\t\n\t\t    function setFormController() {\n\t\t      var formId = attrs.name;\n\t\t      scope.formId = formId;\n\t\t      scope.theFormlyForm = scope[formId];\n\t\t      if (attrs.form) {\n\t\t        var getter = $parse(attrs.form);\n\t\t        var setter = getter.assign;\n\t\t        var parentForm = getter(scope.$parent);\n\t\t        if (parentForm) {\n\t\t          scope.theFormlyForm = parentForm;\n\t\t          if (scope[formId]) {\n\t\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t\t          }\n\t\n\t\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t\t          // to children forms :-( This line was added to solve this issue:\n\t\t          // https://github.com/formly-js/angular-formly/issues/287\n\t\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t\t          // so I expect it will remain this way for the life of angular 1.x\n\t\t          el.removeData('$formController');\n\t\t        } else {\n\t\t          setter(scope.$parent, scope[formId]);\n\t\t        }\n\t\t      }\n\t\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t\t        /* eslint no-console:0 */\n\t\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t\t      }\n\t\t    }\n\t\n\t\t    /*\n\t\t     * chrome autocomplete lameness\n\t\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t\t     * ლ(ಠ益ಠლ)   (╯°□°)╯︵ ┻━┻    (◞‸◟；)\n\t\t     */\n\t\t    function fixChromeAutocomplete() {\n\t\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t\t      if (global && !offInstance || onInstance) {\n\t\t        var input = document.createElement('input');\n\t\t        input.setAttribute('autocomplete', 'address-level4');\n\t\t        input.setAttribute('hidden', 'true');\n\t\t        el[0].appendChild(input);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  // stateless util functions\n\t\t  function toKebabCase(string) {\n\t\t    if (string) {\n\t\t      return string.replace(/([A-Z])/g, function ($1) {\n\t\t        return '-' + $1.toLowerCase();\n\t\t      });\n\t\t    } else {\n\t\t      return '';\n\t\t    }\n\t\t  }\n\t\n\t\t  function isFieldGroup(field) {\n\t\t    return field && !!field.fieldGroup;\n\t\t  }\n\t\t}\n\t\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\texports['default'] = addFormlyNgModelAttrsManipulator;\n\t\n\t\t// @ngInject\n\t\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t\t    return;\n\t\t  }\n\t\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\t\n\t\t  function ngModelAttrsManipulator(template, options, scope) {\n\t\t    var node = document.createElement('div');\n\t\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t\t    if (skip === true) {\n\t\t      return template;\n\t\t    }\n\t\t    node.innerHTML = template;\n\t\n\t\t    var modelNodes = getNgModelNodes(node, skip);\n\t\t    if (!modelNodes || !modelNodes.length) {\n\t\t      return template;\n\t\t    }\n\t\n\t\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\t\n\t\t    addValidation();\n\t\t    alterNgModelAttr();\n\t\t    addModelOptions();\n\t\t    addTemplateOptionsAttrs();\n\t\t    addNgModelElAttrs();\n\t\n\t\t    return node.innerHTML;\n\t\n\t\t    function addValidation() {\n\t\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t\t      }\n\t\t    }\n\t\n\t\t    function alterNgModelAttr() {\n\t\t      if (isPropertyAccessor(options.key)) {\n\t\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addModelOptions() {\n\t\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t\t        if (options.modelOptions.getterSetter) {\n\t\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function addTemplateOptionsAttrs() {\n\t\t      if (!options.templateOptions && !options.expressionProperties) {\n\t\t        // no need to run these if there are no templateOptions or expressionProperties\n\t\t        return;\n\t\t      }\n\t\t      var to = options.templateOptions || {};\n\t\t      var ep = options.expressionProperties || {};\n\t\n\t\t      var ngModelAttributes = getBuiltInAttributes();\n\t\n\t\t      // extend with the user's specifications winning\n\t\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\t\n\t\t      // Feel free to make this more simple :-)\n\t\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t\t        /* eslint complexity:[2, 14] */\n\t\t        var attrVal = undefined,\n\t\t            attrName = undefined;\n\t\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t\t        var toVal = to[name];\n\t\t        var epVal = getEpValue(ep, name);\n\t\n\t\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t\t        if (val.value) {\n\t\t          // I realize this looks backwards, but it's right, trust me...\n\t\t          attrName = val.value;\n\t\t          attrVal = name;\n\t\t        } else if (val.statement && inTo) {\n\t\t          attrName = val.statement;\n\t\t          if (_angularFix2['default'].isString(to[name])) {\n\t\t            attrVal = '$eval(' + ref + ')';\n\t\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t\t          } else {\n\t\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t\t          }\n\t\t        } else if (val.bound && inEp) {\n\t\t          attrName = val.bound;\n\t\t          attrVal = ref;\n\t\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t\t          attrName = val.attribute || val.boolean;\n\t\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t\t        } else if (val.attribute && inTo) {\n\t\t          attrName = val.attribute;\n\t\t          attrVal = toVal;\n\t\t        } else if (val.boolean) {\n\t\t          if (inTo && !inEp && toVal) {\n\t\t            attrName = val.boolean;\n\t\t            attrVal = true;\n\t\t          } else {\n\t\t            /* eslint no-empty:0 */\n\t\t            // empty to illustrate that a boolean will not be added via val.bound\n\t\t            // if you want it added via val.bound, then put it in expressionProperties\n\t\t          }\n\t\t        } else if (val.bound && inTo) {\n\t\t            attrName = val.bound;\n\t\t            attrVal = ref;\n\t\t          }\n\t\n\t\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function addNgModelElAttrs() {\n\t\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t\t        addRegardlessOfPresence(modelNodes, name, val);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  // Utility functions\n\t\t  function getNgModelNodes(node, skip) {\n\t\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t\t    try {\n\t\t      return node.querySelectorAll(query);\n\t\t    } catch (e) {\n\t\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t\t      //it should be removed when IE8 support is dropped\n\t\t      return getNgModelNodesFallback(node, skip);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getNgModelNodesFallback(node, skip) {\n\t\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t\t    var matchingNgModelNodes = [];\n\t\n\t\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t\t    matchingNgModelNodes.item = function (i) {\n\t\t      return this[i];\n\t\t    };\n\t\n\t\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t\t      var ngModelNode = allNgModelNodes[i];\n\t\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t\t        matchingNgModelNodes.push(ngModelNode);\n\t\t      }\n\t\t    }\n\t\n\t\t    return matchingNgModelNodes;\n\t\t  }\n\t\n\t\t  function nodeMatches(node, selector) {\n\t\t    var div = document.createElement('div');\n\t\t    div.innerHTML = node.outerHTML;\n\t\t    return div.querySelector(selector);\n\t\t  }\n\t\n\t\t  function getBuiltInAttributes() {\n\t\t    var ngModelAttributes = {\n\t\t      focus: {\n\t\t        attribute: 'formly-focus'\n\t\t      }\n\t\t    };\n\t\t    var boundOnly = [];\n\t\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t\t    var attributeOnly = ['placeholder', 'min', 'max', 'tabindex', 'type'];\n\t\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t\t      bothAttributeAndBound.push('maxlength');\n\t\t    } else {\n\t\t      boundOnly.push('maxlength');\n\t\t    }\n\t\n\t\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item };\n\t\t    });\n\t\t    return ngModelAttributes;\n\t\t  }\n\t\n\t\t  function getEpValue(ep, name) {\n\t\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t\t  }\n\t\n\t\t  function addIfNotPresent(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      if (!node.getAttribute(attr)) {\n\t\t        node.setAttribute(attr, val);\n\t\t      }\n\t\t    });\n\t\t  }\n\t\n\t\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      node.setAttribute(attr, val);\n\t\t    });\n\t\t  }\n\t\n\t\t  function isPropertyAccessor(key) {\n\t\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t\t  }\n\t\t}\n\t\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = addCustomTags;\n\t\n\t\t// @ngInject\n\t\tfunction addCustomTags($document) {\n\t\t  // IE8 check ->\n\t\t  // https://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx\n\t\t  if ($document && $document.documentMode < 9) {\n\t\t    (function () {\n\t\t      var document = $document.get(0);\n\t\t      // add the custom elements that we need for formly\n\t\t      var customElements = ['formly-field', 'formly-form'];\n\t\t      _angularFix2['default'].forEach(customElements, function (el) {\n\t\t        document.createElement(el);\n\t\t      });\n\t\t    })();\n\t\t  }\n\t\t}\n\t\taddCustomTags.$inject = [\"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! angular-formly-templates-bootstrap version 6.1.7 built with ♥ by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> (ó ì_í)=óò=(ì_í ò)\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(3), __webpack_require__(7), __webpack_require__(4));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar ngModuleName = 'formlyBootstrap';\n\t\tvar angular = __webpack_require__(2);\n\t\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\t\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t\t  output: {\n\t\t    prefix: 'angular-formly-bootstrap'\n\t\t  }\n\t\t}));\n\t\tngModule.constant('formlyBootstrapVersion', (\"6.1.7\"));\n\t\n\t\t__webpack_require__(6)(ngModule);\n\t\t__webpack_require__(9)(ngModule);\n\t\t__webpack_require__(19)(ngModule);\n\t\n\t\texports['default'] = ngModuleName;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tvar angular = __webpack_require__(3);\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\tmodule.exports = angular;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addWrappers);\n\t\n\t\t  function addWrappers(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setWrapper([{\n\t\t      name: 'bootstrapLabel',\n\t\t      template: __webpack_require__(7),\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string,\n\t\t            required: check.bool.optional,\n\t\t            labelSrOnly: check.bool.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t\t  }\n\t\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  __webpack_require__(10)(ngModule);\n\t\t  __webpack_require__(12)(ngModule);\n\t\t  __webpack_require__(14)(ngModule);\n\t\t  __webpack_require__(15)(ngModule);\n\t\t  __webpack_require__(17)(ngModule);\n\t\t  __webpack_require__(18)(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'checkbox',\n\t\t      template: __webpack_require__(11),\n\t\t      wrapper: ['bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'multiCheckbox',\n\t\t      template: __webpack_require__(13),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      },\n\t\t      defaultOptions: {\n\t\t        noFormControl: false,\n\t\t        ngModelAttrs: {\n\t\t          required: {\n\t\t            attribute: '',\n\t\t            bound: ''\n\t\t          }\n\t\t        }\n\t\t      },\n\t\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t\t        var to = $scope.to;\n\t\t        var opts = $scope.options;\n\t\t        $scope.multiCheckbox = {\n\t\t          checked: [],\n\t\t          change: setModel\n\t\t        };\n\t\n\t\t        // initialize the checkboxes check property\n\t\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t\t          var modelValue, valueProp;\n\t\n\t\t          if (Object.keys(newModelValue).length) {\n\t\t            modelValue = newModelValue[opts.key];\n\t\n\t\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t\t                valueProp = to.valueProp || 'value';\n\t\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t\t                }\n\t\t              }\n\t\t            });\n\t\t          }\n\t\t        }, true);\n\t\n\t\t        function checkValidity(expressionValue) {\n\t\t          var valid;\n\t\n\t\t          if ($scope.to.required) {\n\t\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\t\n\t\t            $scope.fc.$setValidity('required', valid);\n\t\t          }\n\t\t        }\n\t\n\t\t        function setModel() {\n\t\t          $scope.model[opts.key] = [];\n\t\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t\t            if (checkbox) {\n\t\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t\t            }\n\t\t          });\n\t\n\t\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t\t          $scope.fc.$setTouched();\n\t\t          checkValidity(true);\n\t\t        }\n\t\n\t\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t\t          $scope.$watch(function () {\n\t\t            return $scope.to.required;\n\t\t          }, function (newValue) {\n\t\t            checkValidity(newValue);\n\t\t          });\n\t\t        }\n\t\n\t\t        if ($scope.to.required) {\n\t\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t\t            if (!newValue) {\n\t\t              return;\n\t\t            }\n\t\t            checkValidity(true);\n\t\t            unwatchFormControl();\n\t\t          });\n\t\t        }\n\t\t      }]\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addInputType);\n\t\n\t\t  function addInputType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'input',\n\t\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t\t    });\n\t\t  }\n\t\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addRadioType);\n\t\n\t\t  function addRadioType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'radio',\n\t\t      template: __webpack_require__(16),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        noFormControl: false\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addSelectType);\n\t\n\t\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\t\n\t\t  function addSelectType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'select',\n\t\t      template: template,\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: function defaultOptions(options) {\n\t\t        /* jshint maxlen:195 */\n\t\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t\t        return {\n\t\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t\t          })\n\t\t        };\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            optionsAttr: check.string.optional,\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional,\n\t\t            groupProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addTextareaType);\n\t\n\t\t  function addTextareaType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'textarea',\n\t\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        ngModelAttrs: {\n\t\t          rows: { attribute: 'rows' },\n\t\t          cols: { attribute: 'cols' }\n\t\t        }\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            rows: check.number.optional,\n\t\t            cols: check.number.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 19 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _addons = __webpack_require__(20);\n\t\n\t\tvar _addons2 = _interopRequireDefault(_addons);\n\t\n\t\tvar _description = __webpack_require__(22);\n\t\n\t\tvar _description2 = _interopRequireDefault(_description);\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  (0, _addons2['default'])(ngModule);\n\t\t  (0, _description2['default'])(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 20 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addAddonsManipulator);\n\t\n\t\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t\t    var addonTemplate = __webpack_require__(21);\n\t\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t\t      'class': formlyBootstrapApiCheck.string.optional,\n\t\t      text: formlyBootstrapApiCheck.string.optional,\n\t\t      onClick: formlyBootstrapApiCheck.func.optional\n\t\t    }).strict.optional;\n\t\t    var api = formlyBootstrapApiCheck.shape({\n\t\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t\t        addonLeft: addonChecker,\n\t\t        addonRight: addonChecker\n\t\t      })\n\t\t    });\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t\t        return template;\n\t\t      }\n\t\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t\t    });\n\t\t  }\n\t\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 21 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 22 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addDescriptionManipulator);\n\t\n\t\t  function addDescriptionManipulator(formlyConfig) {\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t\t      if (angular.isDefined(options.templateOptions.description)) {\n\t\t        var el = document.createElement('div');\n\t\t        el.appendChild(angular.element(template)[0]);\n\t\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t\t        if (modelEls) {\n\t\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t\t        }\n\t\t        return el.innerHTML;\n\t\t      } else {\n\t\t        return template;\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/**\n\t * angular-permission\n\t * Route permission and access control as simple as it can get\n\t * @version v1.1.1 - 2015-11-09\n\t * @link http://www.rafaelvidaurre.com\n\t * @author Rafael Vidaurre <narzerus@gmail.com>\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular.module('permission', ['ui.router'])\n\t    .run(['$rootScope', 'Permission', '$state', '$q',\n\t    function ($rootScope, Permission, $state, $q) {\n\t      $rootScope.$on('$stateChangeStart',\n\t      function (event, toState, toParams, fromState, fromParams) {\n\t        if (toState.$$finishAuthorize) {\n\t          return;\n\t        }\n\t\n\t        // If there are permissions set then prevent default and attempt to authorize\n\t        var permissions;\n\t        if (toState.data && toState.data.permissions) {\n\t          permissions = toState.data.permissions;\n\t        } else if (toState.permissions) {\n\t          /**\n\t          * This way of defining permissions will be depracated in v1. Should use\n\t          * `data` key instead\n\t          */\n\t          console.log('Deprecation Warning: permissions should be set inside the `data` key ');\n\t          console.log('Setting permissions for a state outside `data` will be depracated in' +\n\t            ' version 1');\n\t          permissions = toState.permissions;\n\t        }\n\t\n\t        if (permissions) {\n\t          event.preventDefault();\n\t          toState = angular.extend({'$$finishAuthorize': true}, toState);\n\t\n\t          if ($rootScope.$broadcast('$stateChangePermissionStart', toState, toParams).defaultPrevented) {\n\t            return;\n\t          }\n\t\n\t          Permission.authorize(permissions, toParams).then(function () {\n\t            // If authorized, use call state.go without triggering the event.\n\t            // Then trigger $stateChangeSuccess manually to resume the rest of the process\n\t            // Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n\t            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n\t              $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams);\n\t\n\t              $state.go(toState.name, toParams, {notify: false}).then(function() {\n\t                $rootScope\n\t                  .$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams);\n\t              });\n\t            }\n\t          }, function () {\n\t            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n\t              $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams);\n\t\n\t              var redirectTo = permissions.redirectTo;\n\t              var result;\n\t\n\t              if (angular.isFunction(redirectTo)) {\n\t                redirectTo = redirectTo();\n\t\n\t                $q.when(redirectTo).then(function (newState) {\n\t                  if (newState) {\n\t                    $state.go(newState, toParams);\n\t                  }\n\t                });\n\t\n\t              } else {\n\t                if (redirectTo) {\n\t                  $state.go(redirectTo, toParams);\n\t                }\n\t              }\n\t            }\n\t          });\n\t        }\n\t      });\n\t    }]);\n\t}());\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular.module('permission')\n\t    .provider('Permission', function () {\n\t      var roleValidationConfig = {};\n\t      var validateRoleDefinitionParams = function (roleName, validationFunction) {\n\t        if (!angular.isString(roleName)) {\n\t          throw new Error('Role name must be a string');\n\t        }\n\t        if (!angular.isFunction(validationFunction)) {\n\t          throw new Error('Validation function not provided correctly');\n\t        }\n\t      };\n\t\n\t      var validateManyRolesDefinitionParams = function(roles, validationFunction) {\n\t        if (!angular.isArray(roles)) {\n\t          throw new Error('Roles must be an array');\n\t        } else {\n\t          for(var i = 0; i < roles.length; i++) {\n\t            validateRoleDefinitionParams(roles[i], validationFunction);\n\t          }\n\t        }\n\t      };\n\t\n\t      this.defineRole = function (roleName, validationFunction) {\n\t        /**\n\t          This method is only available in config-time, and cannot access services, as they are\n\t          not yet injected anywere which makes this kinda useless.\n\t          Should remove if we cannot find a use for it.\n\t        **/\n\t        validateRoleDefinitionParams(roleName, validationFunction);\n\t        roleValidationConfig[roleName] = validationFunction;\n\t\n\t        return this;\n\t      };\n\t\n\t      this.$get = ['$q', function ($q) {\n\t        var Permission = {\n\t          _promiseify: function (value) {\n\t            /**\n\t              Converts a value into a promise, if the value is truthy it resolves it, otherwise\n\t              it rejects it\n\t            **/\n\t            if (value && angular.isFunction(value.then)) {\n\t              return value;\n\t            }\n\t\n\t            var deferred = $q.defer();\n\t            if (value) {\n\t              deferred.resolve();\n\t            } else {\n\t              deferred.reject();\n\t            }\n\t            return deferred.promise;\n\t          },\n\t          _validateRoleMap: function (roleMap) {\n\t            if (typeof(roleMap) !== 'object' || roleMap instanceof Array) {\n\t              throw new Error('Role map has to be an object');\n\t            }\n\t            if (roleMap.only === undefined && roleMap.except === undefined) {\n\t              throw new Error('Either \"only\" or \"except\" keys must me defined');\n\t            }\n\t            if (roleMap.only) {\n\t              if (!(roleMap.only instanceof Array)) {\n\t                throw new Error('Array of roles expected');\n\t              }\n\t            } else if (roleMap.except) {\n\t              if (!(roleMap.except instanceof Array)) {\n\t                throw new Error('Array of roles expected');\n\t              }\n\t            }\n\t          },\n\t          _findMatchingRole: function (rolesArray, toParams) {\n\t            var roles = angular.copy(rolesArray);\n\t            var deferred = $q.defer();\n\t            var currentRole = roles.shift();\n\t\n\t            // If no roles left to validate reject promise\n\t            if (!currentRole) {\n\t              deferred.reject();\n\t              return deferred.promise;\n\t            }\n\t            // Validate role definition exists\n\t            if (!angular.isFunction(Permission.roleValidations[currentRole])) {\n\t              throw new Error('undefined role or invalid role validation');\n\t            }\n\t\n\t            var validatingRole = Permission.roleValidations[currentRole](toParams, currentRole);\n\t            validatingRole = Permission._promiseify(validatingRole);\n\t\n\t            validatingRole.then(function () {\n\t              deferred.resolve();\n\t            }, function () {\n\t              Permission._findMatchingRole(roles, toParams).then(function () {\n\t                deferred.resolve();\n\t              }, function () {\n\t                deferred.reject();\n\t              });\n\t            });\n\t\n\t            return deferred.promise;\n\t          },\n\t          defineRole: function (roleName, validationFunction) {\n\t            /**\n\t              Service-available version of defineRole, the callback passed here lives in the\n\t              scope where it is defined and therefore can interact with other modules\n\t            **/\n\t            validateRoleDefinitionParams(roleName, validationFunction);\n\t            Permission.roleValidations[roleName] = validationFunction;\n\t\n\t            return Permission;\n\t          },\n\t          defineManyRoles: function(roles, validationFunction) {\n\t            validateManyRolesDefinitionParams(roles, validationFunction);\n\t\n\t            var definedPermissions = Permission;\n\t            for(var i = 0; i < roles.length; i++) {\n\t               definedPermissions = definedPermissions.defineRole(roles[i], validationFunction);\n\t            }\n\t\n\t            return definedPermissions;\n\t          },\n\t          resolveIfMatch: function (rolesArray, toParams) {\n\t            var roles = angular.copy(rolesArray);\n\t            var deferred = $q.defer();\n\t            Permission._findMatchingRole(roles, toParams).then(function () {\n\t              // Found role match\n\t              deferred.resolve();\n\t            }, function () {\n\t              // No match\n\t              deferred.reject();\n\t            });\n\t            return deferred.promise;\n\t          },\n\t          rejectIfMatch: function (roles, toParams) {\n\t            var deferred = $q.defer();\n\t            Permission._findMatchingRole(roles, toParams).then(function () {\n\t              // Role found\n\t              deferred.reject();\n\t            }, function () {\n\t              // Role not found\n\t              deferred.resolve();\n\t            });\n\t            return deferred.promise;\n\t          },\n\t          roleValidations: roleValidationConfig,\n\t          authorize: function (roleMap, toParams) {\n\t            // Validate input\n\t            Permission._validateRoleMap(roleMap);\n\t\n\t            var authorizing;\n\t\n\t            if (roleMap.only) {\n\t              authorizing = Permission.resolveIfMatch(roleMap.only, toParams);\n\t            } else {\n\t              authorizing = Permission.rejectIfMatch(roleMap.except, toParams);\n\t            }\n\t\n\t            return authorizing;\n\t          }\n\t        };\n\t\n\t        return Permission;\n\t      }];\n\t    });\n\t\n\t}());\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(31);\n\tmodule.exports = 'ui.bootstrap';\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n\t * @author Mark Lagendijk <mark@lagendijk.info>\r\n\t * @license MIT\r\n\t */\r\n\tangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n\t    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n\t        var self = this;\r\n\t\r\n\t        /**\r\n\t         * Recursively sets the states using $stateProvider.state.\r\n\t         * Child states are defined via a `children` property.\r\n\t         *\r\n\t         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n\t         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n\t         * 3. Sets `parent` property of the descendant states.\r\n\t         *\r\n\t         * @param {Object} state - A regular ui.router state object.\r\n\t         * @param {Array} [state.children] - An optional array of child states.\r\n\t         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n\t         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n\t         * @param {Object} [options] - An optional options object.\r\n\t         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n\t         *     prevents conversion of names to dot notation if true.\r\n\t         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n\t         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n\t         */\r\n\t        this.state = function(state){\r\n\t            var args = Array.prototype.slice.apply(arguments);\r\n\t            var options = {\r\n\t                keepOriginalNames: false,\r\n\t                siblingTraversal: false\r\n\t            };  \r\n\t\r\n\t            if (typeof args[1] === 'boolean') {\r\n\t                options.keepOriginalNames = args[1];\r\n\t            } \r\n\t            else if (typeof args[1] === 'object') {\r\n\t                angular.extend(options, args[1]);\r\n\t            }\r\n\t\r\n\t            if (!options.keepOriginalNames) {\r\n\t                fixStateName(state);\r\n\t            }\r\n\t\r\n\t            $stateProvider.state(state);\r\n\t\r\n\t            if(state.children && state.children.length){\r\n\t                state.children.forEach(function(childState){\r\n\t                    childState.parent = state;\r\n\t                    self.state(childState, options);\r\n\t                });\r\n\t\r\n\t                if (options.siblingTraversal) {\r\n\t                    addSiblings(state);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return self;\r\n\t        };\r\n\t\r\n\t        this.setNestedState = this.state;\r\n\t\r\n\t        self.$get = angular.noop;\r\n\t\r\n\t        /**\r\n\t         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n\t         * @param state\r\n\t         */\r\n\t        function fixStateName(state){\r\n\t            if(state.parent){\r\n\t                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        function addSiblings(state) {\r\n\t            state.children.forEach(function (childState, idx, array) {\r\n\t                if (array[idx + 1]) {\r\n\t                    childState.nextSibling = array[idx + 1].name;\r\n\t                }\r\n\t                if (array[idx - 1]) {\r\n\t                    childState.previousSibling = array[idx - 1].name;\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t    }]);\r\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t/**\n\t * State-based routing for AngularJS\n\t * @version v0.2.15\n\t * @link http://angular-ui.github.com/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n\t  module.exports = 'ui.router';\n\t}\n\t\n\t(function (window, angular, undefined) {\n\t/*jshint globalstrict:true*/\n\t/*global angular:false*/\n\t'use strict';\n\t\n\tvar isDefined = angular.isDefined,\n\t    isFunction = angular.isFunction,\n\t    isString = angular.isString,\n\t    isObject = angular.isObject,\n\t    isArray = angular.isArray,\n\t    forEach = angular.forEach,\n\t    extend = angular.extend,\n\t    copy = angular.copy;\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n\t}\n\t\n\tfunction merge(dst) {\n\t  forEach(arguments, function(obj) {\n\t    if (obj !== dst) {\n\t      forEach(obj, function(value, key) {\n\t        if (!dst.hasOwnProperty(key)) dst[key] = value;\n\t      });\n\t    }\n\t  });\n\t  return dst;\n\t}\n\t\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Object.keys()`.\n\t *\n\t * @param {Object} object A JavaScript object.\n\t * @return {Array} Returns the keys of the object as an array.\n\t */\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  forEach(object, function(val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Array.prototype.indexOf()`.\n\t *\n\t * @param {Array} array A JavaScript array.\n\t * @param {*} value A value to search the array for.\n\t * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n\t */\n\tfunction indexOf(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Merges a set of parameters with all parameters inherited between the common parents of the\n\t * current state and a given destination state.\n\t *\n\t * @param {Object} currentParams The value of the current state parameters ($stateParams).\n\t * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t * @param {Object} $current Internal definition of object representing the current state.\n\t * @param {Object} $to Internal definition of object representing state to transition to.\n\t */\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i].params) continue;\n\t    parentParams = objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t  if (!keys) {\n\t    keys = [];\n\t    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t  }\n\t\n\t  for (var i=0; i<keys.length; i++) {\n\t    var k = keys[i];\n\t    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Returns the subset of an object, based on a list of keys.\n\t *\n\t * @param {Array} keys\n\t * @param {Object} values\n\t * @return {Boolean} Returns a subset of `values`.\n\t */\n\tfunction filterByKeys(keys, values) {\n\t  var filtered = {};\n\t\n\t  forEach(keys, function (name) {\n\t    filtered[name] = values[name];\n\t  });\n\t  return filtered;\n\t}\n\t\n\t// like _.indexBy\n\t// when you know that your index values will be unique, or you want last-one-in to win\n\tfunction indexBy(array, propName) {\n\t  var result = {};\n\t  forEach(array, function(item) {\n\t    result[item[propName]] = item;\n\t  });\n\t  return result;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object only containing the whitelisted properties.\n\tfunction pick(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  forEach(keys, function(key) {\n\t    if (key in obj) copy[key] = obj[key];\n\t  });\n\t  return copy;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object omitting the blacklisted properties.\n\tfunction omit(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  for (var key in obj) {\n\t    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n\t  }\n\t  return copy;\n\t}\n\t\n\tfunction pluck(collection, key) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = isFunction(key) ? key(val) : val[key];\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction filter(collection, callback) {\n\t  var array = isArray(collection);\n\t  var result = array ? [] : {};\n\t  forEach(collection, function(val, i) {\n\t    if (callback(val, i)) {\n\t      result[array ? result.length : i] = val;\n\t    }\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction map(collection, callback) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = callback(val, i);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t * \n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t * \n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t * \n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t * \n\t * ## The main module for ui.router \n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes. \n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router - \n\t * \n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t * \n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.state']);\n\t\n\tangular.module('ui.router.compat', ['ui.router']);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$resolve\n\t *\n\t * @requires $q\n\t * @requires $injector\n\t *\n\t * @description\n\t * Manages resolution of (acyclic) graphs of promises.\n\t */\n\t$Resolve.$inject = ['$q', '$injector'];\n\tfunction $Resolve(  $q,    $injector) {\n\t  \n\t  var VISIT_IN_PROGRESS = 1,\n\t      VISIT_DONE = 2,\n\t      NOTHING = {},\n\t      NO_DEPENDENCIES = [],\n\t      NO_LOCALS = NOTHING,\n\t      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\t  \n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#study\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Studies a set of invocables that are likely to be used multiple times.\n\t   * <pre>\n\t   * $resolve.study(invocables)(locals, parent, self)\n\t   * </pre>\n\t   * is equivalent to\n\t   * <pre>\n\t   * $resolve.resolve(invocables, locals, parent, self)\n\t   * </pre>\n\t   * but the former is more efficient (in fact `resolve` just calls `study` \n\t   * internally).\n\t   *\n\t   * @param {object} invocables Invocable objects\n\t   * @return {function} a function to pass in locals, parent and self\n\t   */\n\t  this.study = function (invocables) {\n\t    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\t    var invocableKeys = objectKeys(invocables || {});\n\t    \n\t    // Perform a topological sort of invocables to build an ordered plan\n\t    var plan = [], cycle = [], visited = {};\n\t    function visit(value, key) {\n\t      if (visited[key] === VISIT_DONE) return;\n\t      \n\t      cycle.push(key);\n\t      if (visited[key] === VISIT_IN_PROGRESS) {\n\t        cycle.splice(0, indexOf(cycle, key));\n\t        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n\t      }\n\t      visited[key] = VISIT_IN_PROGRESS;\n\t      \n\t      if (isString(value)) {\n\t        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n\t      } else {\n\t        var params = $injector.annotate(value);\n\t        forEach(params, function (param) {\n\t          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n\t        });\n\t        plan.push(key, value, params);\n\t      }\n\t      \n\t      cycle.pop();\n\t      visited[key] = VISIT_DONE;\n\t    }\n\t    forEach(invocables, visit);\n\t    invocables = cycle = visited = null; // plan is all that's required\n\t    \n\t    function isResolve(value) {\n\t      return isObject(value) && value.then && value.$$promises;\n\t    }\n\t    \n\t    return function (locals, parent, self) {\n\t      if (isResolve(locals) && self === undefined) {\n\t        self = parent; parent = locals; locals = null;\n\t      }\n\t      if (!locals) locals = NO_LOCALS;\n\t      else if (!isObject(locals)) {\n\t        throw new Error(\"'locals' must be an object\");\n\t      }       \n\t      if (!parent) parent = NO_PARENT;\n\t      else if (!isResolve(parent)) {\n\t        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n\t      }\n\t      \n\t      // To complete the overall resolution, we have to wait for the parent\n\t      // promise and for the promise for each invokable in our plan.\n\t      var resolution = $q.defer(),\n\t          result = resolution.promise,\n\t          promises = result.$$promises = {},\n\t          values = extend({}, locals),\n\t          wait = 1 + plan.length/3,\n\t          merged = false;\n\t          \n\t      function done() {\n\t        // Merge parent values we haven't got yet and publish our own $$values\n\t        if (!--wait) {\n\t          if (!merged) merge(values, parent.$$values); \n\t          result.$$values = values;\n\t          result.$$promises = result.$$promises || true; // keep for isResolve()\n\t          delete result.$$inheritedValues;\n\t          resolution.resolve(values);\n\t        }\n\t      }\n\t      \n\t      function fail(reason) {\n\t        result.$$failure = reason;\n\t        resolution.reject(reason);\n\t      }\n\t\n\t      // Short-circuit if parent has already failed\n\t      if (isDefined(parent.$$failure)) {\n\t        fail(parent.$$failure);\n\t        return result;\n\t      }\n\t      \n\t      if (parent.$$inheritedValues) {\n\t        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n\t      }\n\t\n\t      // Merge parent values if the parent has already resolved, or merge\n\t      // parent promises and wait if the parent resolve is still in progress.\n\t      extend(promises, parent.$$promises);\n\t      if (parent.$$values) {\n\t        merged = merge(values, omit(parent.$$values, invocableKeys));\n\t        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n\t        done();\n\t      } else {\n\t        if (parent.$$inheritedValues) {\n\t          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n\t        }        \n\t        parent.then(done, fail);\n\t      }\n\t      \n\t      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n\t      for (var i=0, ii=plan.length; i<ii; i+=3) {\n\t        if (locals.hasOwnProperty(plan[i])) done();\n\t        else invoke(plan[i], plan[i+1], plan[i+2]);\n\t      }\n\t      \n\t      function invoke(key, invocable, params) {\n\t        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n\t        var invocation = $q.defer(), waitParams = 0;\n\t        function onfailure(reason) {\n\t          invocation.reject(reason);\n\t          fail(reason);\n\t        }\n\t        // Wait for any parameter that we have a promise for (either from parent or from this\n\t        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n\t        forEach(params, function (dep) {\n\t          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n\t            waitParams++;\n\t            promises[dep].then(function (result) {\n\t              values[dep] = result;\n\t              if (!(--waitParams)) proceed();\n\t            }, onfailure);\n\t          }\n\t        });\n\t        if (!waitParams) proceed();\n\t        function proceed() {\n\t          if (isDefined(result.$$failure)) return;\n\t          try {\n\t            invocation.resolve($injector.invoke(invocable, self, values));\n\t            invocation.promise.then(function (result) {\n\t              values[key] = result;\n\t              done();\n\t            }, onfailure);\n\t          } catch (e) {\n\t            onfailure(e);\n\t          }\n\t        }\n\t        // Publish promise synchronously; invocations further down in the plan may depend on it.\n\t        promises[key] = invocation.promise;\n\t      }\n\t      \n\t      return result;\n\t    };\n\t  };\n\t  \n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#resolve\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Resolves a set of invocables. An invocable is a function to be invoked via \n\t   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n\t   * An invocable can either return a value directly,\n\t   * or a `$q` promise. If a promise is returned it will be resolved and the \n\t   * resulting value will be used instead. Dependencies of invocables are resolved \n\t   * (in this order of precedence)\n\t   *\n\t   * - from the specified `locals`\n\t   * - from another invocable that is part of this `$resolve` call\n\t   * - from an invocable that is inherited from a `parent` call to `$resolve` \n\t   *   (or recursively\n\t   * - from any ancestor `$resolve` of that parent).\n\t   *\n\t   * The return value of `$resolve` is a promise for an object that contains \n\t   * (in this order of precedence)\n\t   *\n\t   * - any `locals` (if specified)\n\t   * - the resolved return values of all injectables\n\t   * - any values inherited from a `parent` call to `$resolve` (if specified)\n\t   *\n\t   * The promise will resolve after the `parent` promise (if any) and all promises \n\t   * returned by injectables have been resolved. If any invocable \n\t   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n\t   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n\t   * same error. A rejection of a `parent` promise (if specified) will likewise be \n\t   * propagated immediately. Once the `$resolve` promise has been rejected, no \n\t   * further invocables will be called.\n\t   * \n\t   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n\t   * to throw an error. As a special case, an injectable can depend on a parameter \n\t   * with the same name as the injectable, which will be fulfilled from the `parent` \n\t   * injectable of the same name. This allows inherited values to be decorated. \n\t   * Note that in this case any other injectable in the same `$resolve` with the same\n\t   * dependency would see the decorated value, not the inherited value.\n\t   *\n\t   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n\t   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n\t   * exception.\n\t   *\n\t   * Invocables are invoked eagerly as soon as all dependencies are available. \n\t   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n\t   *\n\t   * As a special case, an invocable can be a string, in which case it is taken to \n\t   * be a service name to be passed to `$injector.get()`. This is supported primarily \n\t   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n\t   * routes.\n\t   *\n\t   * @param {object} invocables functions to invoke or \n\t   * `$injector` services to fetch.\n\t   * @param {object} locals  values to make available to the injectables\n\t   * @param {object} parent  a promise returned by another call to `$resolve`.\n\t   * @param {object} self  the `this` for the invoked methods\n\t   * @return {object} Promise for an object that contains the resolved return value\n\t   * of all invocables, as well as any inherited and local values.\n\t   */\n\t  this.resolve = function (invocables, locals, parent, self) {\n\t    return this.study(invocables)(locals, parent, self);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$resolve', $Resolve);\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$templateFactory\n\t *\n\t * @requires $http\n\t * @requires $templateCache\n\t * @requires $injector\n\t *\n\t * @description\n\t * Service. Manages loading of templates.\n\t */\n\t$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n\tfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromConfig\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a configuration object. \n\t   *\n\t   * @param {object} config Configuration object for which to load a template. \n\t   * The following properties are search in the specified order, and the first one \n\t   * that is defined is used to create the template:\n\t   *\n\t   * @param {string|object} config.template html string template or function to \n\t   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n\t   * @param {string|object} config.templateUrl url to load or a function returning \n\t   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n\t   * @param {Function} config.templateProvider function to invoke via \n\t   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n\t   * @param {object} params  Parameters to pass to the template function.\n\t   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n\t   * via a `templateProvider`. Defaults to `{ params: params }`.\n\t   *\n\t   * @return {string|object}  The template html as a string, or a promise for \n\t   * that string,or `null` if no template is configured.\n\t   */\n\t  this.fromConfig = function (config, params, locals) {\n\t    return (\n\t      isDefined(config.template) ? this.fromString(config.template, params) :\n\t      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n\t      null\n\t    );\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromString\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a string or a function returning a string.\n\t   *\n\t   * @param {string|object} template html template as a string or function that \n\t   * returns an html template as a string.\n\t   * @param {object} params Parameters to pass to the template function.\n\t   *\n\t   * @return {string|object} The template html as a string, or a promise for that \n\t   * string.\n\t   */\n\t  this.fromString = function (template, params) {\n\t    return isFunction(template) ? template(params) : template;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromUrl\n\t   * @methodOf ui.router.util.$templateFactory\n\t   * \n\t   * @description\n\t   * Loads a template from the a URL via `$http` and `$templateCache`.\n\t   *\n\t   * @param {string|Function} url url of the template to load, or a function \n\t   * that returns a url.\n\t   * @param {Object} params Parameters to pass to the url function.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromUrl = function (url, params) {\n\t    if (isFunction(url)) url = url(params);\n\t    if (url == null) return null;\n\t    else return $http\n\t        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n\t        .then(function(response) { return response.data; });\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromProvider\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template by invoking an injectable provider function.\n\t   *\n\t   * @param {Function} provider Function to invoke via `$injector.invoke`\n\t   * @param {Object} params Parameters for the template.\n\t   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n\t   * `{ params: params }`.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromProvider = function (provider, params, locals) {\n\t    return $injector.invoke(provider, null, locals || { params: params });\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\t\n\tvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t *\n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon\n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash:\n\t * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n\t *   an existing UrlMatcher\n\t *\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} source  The pattern that was passed into the constructor\n\t *\n\t * @property {string} sourcePath  The path portion of the source property\n\t *\n\t * @property {string} sourceSearch  The search portion of the source property\n\t *\n\t * @property {string} regex  The constructed regex that will be used to match against the url when\n\t *   it is time to determine which url will match.\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tfunction UrlMatcher(pattern, config, parentMatcher) {\n\t  config = extend({ params: {} }, isObject(config) ? config : {});\n\t\n\t  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t  //   '*' name\n\t  //   ':' name\n\t  //   '{' name '}'\n\t  //   '{' name ':' regexp '}'\n\t  // The regular expression is somewhat complicated due to the need to allow curly braces\n\t  // inside the regular expression. The placeholder regexp breaks down as follows:\n\t  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t  //    \\{([\\w\\[\\]]+)(?:\\:( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t  //    \\\\.                            - a backslash escape\n\t  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      searchPlaceholder = /([:]?)([\\w\\[\\]-]+)|\\{([\\w\\[\\]-]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      compiled = '^', last = 0, m,\n\t      segments = this.segments = [],\n\t      parentParams = parentMatcher ? parentMatcher.params : {},\n\t      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n\t      paramNames = [];\n\t\n\t  function addParameter(id, type, config, location) {\n\t    paramNames.push(id);\n\t    if (parentParams[id]) return parentParams[id];\n\t    if (!/^\\w+(-+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    params[id] = new $$UMFP.Param(id, type, config, location);\n\t    return params[id];\n\t  }\n\t\n\t  function quoteRegExp(string, pattern, squash, optional) {\n\t    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!pattern) return result;\n\t    switch(squash) {\n\t      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n\t      case true:  surroundPattern = ['?(', ')?']; break;\n\t      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n\t    }\n\t    return result + surroundPattern[0] + pattern + surroundPattern[1];\n\t  }\n\t\n\t  this.source = pattern;\n\t\n\t  // Split into static segments separated by path parameter placeholders.\n\t  // The number of segments is always 1 more than the number of parameters.\n\t  function matchDetails(m, isSearch) {\n\t    var id, regexp, segment, type, cfg, arrayMode;\n\t    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n\t    cfg         = config.params[id];\n\t    segment     = pattern.substring(last, m.index);\n\t    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\t    type        = $$UMFP.type(regexp || \"string\") || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n\t    return {\n\t      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n\t    };\n\t  }\n\t\n\t  var p, param, segment;\n\t  while ((m = placeholder.exec(pattern))) {\n\t    p = matchDetails(m, false);\n\t    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\t\n\t    param = addParameter(p.id, p.type, p.cfg, \"path\");\n\t    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n\t    segments.push(p.segment);\n\t    last = placeholder.lastIndex;\n\t  }\n\t  segment = pattern.substring(last);\n\t\n\t  // Find any search parameter names and remove them from the last segment\n\t  var i = segment.indexOf('?');\n\t\n\t  if (i >= 0) {\n\t    var search = this.sourceSearch = segment.substring(i);\n\t    segment = segment.substring(0, i);\n\t    this.sourcePath = pattern.substring(0, last + i);\n\t\n\t    if (search.length > 0) {\n\t      last = 0;\n\t      while ((m = searchPlaceholder.exec(search))) {\n\t        p = matchDetails(m, true);\n\t        param = addParameter(p.id, p.type, p.cfg, \"search\");\n\t        last = placeholder.lastIndex;\n\t        // check if ?&\n\t      }\n\t    }\n\t  } else {\n\t    this.sourcePath = pattern;\n\t    this.sourceSearch = '';\n\t  }\n\t\n\t  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n\t  segments.push(segment);\n\t\n\t  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n\t  this.prefix = segments[0];\n\t  this.$$paramNames = paramNames;\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#concat\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns a new matcher for a pattern constructed by appending the path part and adding the\n\t * search parameters of the specified pattern to this pattern. The current pattern is not\n\t * modified. This can be understood as creating a pattern for URLs that are relative to (or\n\t * suffixes of) the current pattern.\n\t *\n\t * @example\n\t * The following two matchers are equivalent:\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').concat('/details?date');\n\t * new UrlMatcher('/user/{id}/details?q&date');\n\t * </pre>\n\t *\n\t * @param {string} pattern  The pattern to append.\n\t * @param {Object} config  An object hash of the configuration for the matcher.\n\t * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n\t */\n\tUrlMatcher.prototype.concat = function (pattern, config) {\n\t  // Because order of search parameters is irrelevant, we can add our own search\n\t  // parameters to the end of the new pattern. Parse the new pattern by itself\n\t  // and then join the bits together, but it's much easier to do this on a string level.\n\t  var defaultConfig = {\n\t    caseInsensitive: $$UMFP.caseInsensitive(),\n\t    strict: $$UMFP.strictMode(),\n\t    squash: $$UMFP.defaultSquashPolicy()\n\t  };\n\t  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n\t};\n\t\n\tUrlMatcher.prototype.toString = function () {\n\t  return this.source;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#exec\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Tests the specified path against this matcher, and returns an object containing the captured\n\t * parameter values, or null if the path does not match. The returned object contains the values\n\t * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t * they are not present in `searchParams`. This means that search parameters are always treated\n\t * as optional.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t *   x: '1', q: 'hello'\n\t * });\n\t * // returns { id: 'bob', q: 'hello', r: null }\n\t * </pre>\n\t *\n\t * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n\t * @returns {Object}  The captured parameter values.\n\t */\n\tUrlMatcher.prototype.exec = function (path, searchParams) {\n\t  var m = this.regexp.exec(path);\n\t  if (!m) return null;\n\t  searchParams = searchParams || {};\n\t\n\t  var paramNames = this.parameters(), nTotal = paramNames.length,\n\t    nPath = this.segments.length - 1,\n\t    values = {}, i, j, cfg, paramName;\n\t\n\t  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\t\n\t  function decodePathArray(string) {\n\t    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n\t    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\t\n\t    var split = reverseString(string).split(/-(?!\\\\)/);\n\t    var allReversed = map(split, reverseString);\n\t    return map(allReversed, unquoteDashes).reverse();\n\t  }\n\t\n\t  for (i = 0; i < nPath; i++) {\n\t    paramName = paramNames[i];\n\t    var param = this.params[paramName];\n\t    var paramVal = m[i+1];\n\t    // if the param value matches a pre-replace pair, replace the value before decoding.\n\t    for (j = 0; j < param.replace; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t  for (/**/; i < nTotal; i++) {\n\t    paramName = paramNames[i];\n\t    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n\t  }\n\t\n\t  return values;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#parameters\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns the names of all path and search parameters of this pattern in an unspecified order.\n\t *\n\t * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n\t *    pattern has no parameters, an empty array is returned.\n\t */\n\tUrlMatcher.prototype.parameters = function (param) {\n\t  if (!isDefined(param)) return this.$$paramNames;\n\t  return this.params[param] || null;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#validate\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Checks an object hash of parameters to validate their correctness according to the parameter\n\t * types of this `UrlMatcher`.\n\t *\n\t * @param {Object} params The object hash of parameters to validate.\n\t * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t */\n\tUrlMatcher.prototype.validates = function (params) {\n\t  return this.params.$$validates(params);\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#format\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Creates a URL that matches this pattern by substituting the specified values\n\t * for the path and search parameters. Null values for path parameters are\n\t * treated as empty strings.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t * // returns '/user/bob?q=yes'\n\t * </pre>\n\t *\n\t * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t * @returns {string}  the formatted URL (path and optionally search part).\n\t */\n\tUrlMatcher.prototype.format = function (values) {\n\t  values = values || {};\n\t  var segments = this.segments, params = this.parameters(), paramset = this.params;\n\t  if (!this.validates(values)) return null;\n\t\n\t  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\t\n\t  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n\t    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t  }\n\t\n\t  for (i = 0; i < nTotal; i++) {\n\t    var isPathParam = i < nPath;\n\t    var name = params[i], param = paramset[name], value = param.value(values[name]);\n\t    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n\t    var squash = isDefaultValue ? param.squash : false;\n\t    var encoded = param.type.encode(value);\n\t\n\t    if (isPathParam) {\n\t      var nextSegment = segments[i + 1];\n\t      if (squash === false) {\n\t        if (encoded != null) {\n\t          if (isArray(encoded)) {\n\t            result += map(encoded, encodeDashes).join(\"-\");\n\t          } else {\n\t            result += encodeURIComponent(encoded);\n\t          }\n\t        }\n\t        result += nextSegment;\n\t      } else if (squash === true) {\n\t        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n\t        result += nextSegment.match(capture)[1];\n\t      } else if (isString(squash)) {\n\t        result += squash + nextSegment;\n\t      }\n\t    } else {\n\t      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n\t      if (!isArray(encoded)) encoded = [ encoded ];\n\t      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n\t      result += (search ? '&' : '?') + (name + '=' + encoded);\n\t      search = true;\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:Type\n\t *\n\t * @description\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n\t * information on registering custom types.\n\t *\n\t * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n\t *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t * @example\n\t * <pre>\n\t * {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t * </pre>\n\t *\n\t * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n\t *           coming from a substring of a URL.\n\t *\n\t * @returns {Object}  Returns a new `Type` object.\n\t */\n\tfunction Type(config) {\n\t  extend(this, config);\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#is\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Detects whether a value is of a particular type. Accepts a native (decoded) value\n\t * and determines whether it matches the current `Type` object.\n\t *\n\t * @param {*} val  The value to check.\n\t * @param {string} key  Optional. If the type check is happening in the context of a specific\n\t *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n\t *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n\t * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n\t */\n\tType.prototype.is = function(val, key) {\n\t  return true;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#encode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n\t * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n\t * only needs to be a representation of `val` that has been coerced to a string.\n\t *\n\t * @param {*} val  The value to encode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n\t */\n\tType.prototype.encode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#decode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Converts a parameter value (from URL string or transition param) to a custom/native value.\n\t *\n\t * @param {string} val  The URL parameter value to decode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {*}  Returns a custom representation of the URL parameter value.\n\t */\n\tType.prototype.decode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#equals\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Determines whether two decoded values are equivalent.\n\t *\n\t * @param {*} a  A value to compare against.\n\t * @param {*} b  A value to compare against.\n\t * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n\t */\n\tType.prototype.equals = function(a, b) {\n\t  return a == b;\n\t};\n\t\n\tType.prototype.$subPattern = function() {\n\t  var sub = this.pattern.toString();\n\t  return sub.substr(1, sub.length - 2);\n\t};\n\t\n\tType.prototype.pattern = /.*/;\n\t\n\tType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\t\n\t/** Given an encoded string, or a decoded object, returns a decoded object */\n\tType.prototype.$normalize = function(val) {\n\t  return this.is(val) ? val : this.decode(val);\n\t};\n\t\n\t/*\n\t * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t * e.g.:\n\t * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t * - url: \"/path?queryParam=1&queryParam=2\n\t * - $stateParams.queryParam will be [1, 2]\n\t * if `mode` is \"auto\", then\n\t * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t */\n\tType.prototype.$asArray = function(mode, isSearch) {\n\t  if (!mode) return this;\n\t  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\t\n\t  function ArrayType(type, mode) {\n\t    function bindTo(type, callbackName) {\n\t      return function() {\n\t        return type[callbackName].apply(type, arguments);\n\t      };\n\t    }\n\t\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t      switch(val.length) {\n\t        case 0: return undefined;\n\t        case 1: return mode === \"auto\" ? val[0] : val;\n\t        default: return val;\n\t      }\n\t    }\n\t    function falsey(val) { return !val; }\n\t\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t      return function handleArray(val) {\n\t        val = arrayWrap(val);\n\t        var result = map(val, callback);\n\t        if (allTruthyMode === true)\n\t          return filter(result, falsey).length === 0;\n\t        return arrayUnwrap(result);\n\t      };\n\t    }\n\t\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t      return function handleArray(val1, val2) {\n\t        var left = arrayWrap(val1), right = arrayWrap(val2);\n\t        if (left.length !== right.length) return false;\n\t        for (var i = 0; i < left.length; i++) {\n\t          if (!callback(left[i], right[i])) return false;\n\t        }\n\t        return true;\n\t      };\n\t    }\n\t\n\t    this.encode = arrayHandler(bindTo(type, 'encode'));\n\t    this.decode = arrayHandler(bindTo(type, 'decode'));\n\t    this.is     = arrayHandler(bindTo(type, 'is'), true);\n\t    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n\t    this.pattern = type.pattern;\n\t    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n\t    this.name = type.name;\n\t    this.$arrayMode = mode;\n\t  }\n\t\n\t  return new ArrayType(this, mode);\n\t};\n\t\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$urlMatcherFactory\n\t *\n\t * @description\n\t * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n\t * is also available to providers under the name `$urlMatcherFactoryProvider`.\n\t */\n\tfunction $UrlMatcherFactory() {\n\t  $$UMFP = this;\n\t\n\t  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\t\n\t  function valToString(val) { return val != null ? val.toString().replace(/\\//g, \"%2F\") : val; }\n\t  function valFromString(val) { return val != null ? val.toString().replace(/%2F/g, \"/\") : val; }\n\t\n\t  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n\t    string: {\n\t      encode: valToString,\n\t      decode: valFromString,\n\t      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n\t      // In 0.2.x, string params are optional by default for backwards compat\n\t      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n\t      pattern: /[^/]*/\n\t    },\n\t    int: {\n\t      encode: valToString,\n\t      decode: function(val) { return parseInt(val, 10); },\n\t      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n\t      pattern: /\\d+/\n\t    },\n\t    bool: {\n\t      encode: function(val) { return val ? 1 : 0; },\n\t      decode: function(val) { return parseInt(val, 10) !== 0; },\n\t      is: function(val) { return val === true || val === false; },\n\t      pattern: /0|1/\n\t    },\n\t    date: {\n\t      encode: function (val) {\n\t        if (!this.is(val))\n\t          return undefined;\n\t        return [ val.getFullYear(),\n\t          ('0' + (val.getMonth() + 1)).slice(-2),\n\t          ('0' + val.getDate()).slice(-2)\n\t        ].join(\"-\");\n\t      },\n\t      decode: function (val) {\n\t        if (this.is(val)) return val;\n\t        var match = this.capture.exec(val);\n\t        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t      },\n\t      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n\t      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t    },\n\t    json: {\n\t      encode: angular.toJson,\n\t      decode: angular.fromJson,\n\t      is: angular.isObject,\n\t      equals: angular.equals,\n\t      pattern: /[^/]*/\n\t    },\n\t    any: { // does not encode/decode\n\t      encode: angular.identity,\n\t      decode: angular.identity,\n\t      equals: angular.equals,\n\t      pattern: /.*/\n\t    }\n\t  };\n\t\n\t  function getDefaultConfig() {\n\t    return {\n\t      strict: isStrictMode,\n\t      caseInsensitive: isCaseInsensitive\n\t    };\n\t  }\n\t\n\t  function isInjectable(value) {\n\t    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n\t  }\n\t\n\t  /**\n\t   * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t   */\n\t  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n\t    if (!isInjectable(config.value)) return config.value;\n\t    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t    return injector.invoke(config.value);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t   *\n\t   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t   * @returns {boolean} the current value of caseInsensitive\n\t   */\n\t  this.caseInsensitive = function(value) {\n\t    if (isDefined(value))\n\t      isCaseInsensitive = value;\n\t    return isCaseInsensitive;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#strictMode\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t   *\n\t   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n\t   * @returns {boolean} the current value of strictMode\n\t   */\n\t  this.strictMode = function(value) {\n\t    if (isDefined(value))\n\t      isStrictMode = value;\n\t    return isStrictMode;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Sets the default behavior when generating or matching URLs with default parameter values.\n\t   *\n\t   * @param {string} value A string that defines the default parameter URL squashing behavior.\n\t   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t   *             the parameter value from the URL and replace it with this string.\n\t   */\n\t  this.defaultSquashPolicy = function(value) {\n\t    if (!isDefined(value)) return defaultSquashPolicy;\n\t    if (value !== true && value !== false && !isString(value))\n\t      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t    defaultSquashPolicy = value;\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#compile\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n\t   *\n\t   * @param {string} pattern  The URL pattern.\n\t   * @param {Object} config  The config object hash.\n\t   * @returns {UrlMatcher}  The UrlMatcher.\n\t   */\n\t  this.compile = function (pattern, config) {\n\t    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#isMatcher\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n\t   *\n\t   * @param {Object} object  The object to perform the type check against.\n\t   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n\t   *          implementing all the same methods.\n\t   */\n\t  this.isMatcher = function (o) {\n\t    if (!isObject(o)) return false;\n\t    var result = true;\n\t\n\t    forEach(UrlMatcher.prototype, function(val, name) {\n\t      if (isFunction(val)) {\n\t        result = result && (isDefined(o[name]) && isFunction(o[name]));\n\t      }\n\t    });\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#type\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n\t   * generate URLs with typed parameters.\n\t   *\n\t   * @param {string} name  The type name.\n\t   * @param {Object|Function} definition   The type definition. See\n\t   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n\t   *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   *\n\t   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n\t   *\n\t   * @example\n\t   * This is a simple example of a custom type that encodes and decodes items from an\n\t   * array, using the array index as the URL-encoded value:\n\t   *\n\t   * <pre>\n\t   * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t   *\n\t   * $urlMatcherFactoryProvider.type('listItem', {\n\t   *   encode: function(item) {\n\t   *     // Represent the list item in the URL using its corresponding index\n\t   *     return list.indexOf(item);\n\t   *   },\n\t   *   decode: function(item) {\n\t   *     // Look up the list item by index\n\t   *     return list[parseInt(item, 10)];\n\t   *   },\n\t   *   is: function(item) {\n\t   *     // Ensure the item is valid by checking to see that it appears\n\t   *     // in the list\n\t   *     return list.indexOf(item) > -1;\n\t   *   }\n\t   * });\n\t   *\n\t   * $stateProvider.state('list', {\n\t   *   url: \"/list/{item:listItem}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     console.log($stateParams.item);\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t   * $state.go('list', { item: \"Ringo\" });\n\t   * </pre>\n\t   *\n\t   * This is a more complex example of a type that relies on dependency injection to\n\t   * interact with services, and uses the parameter name from the URL to infer how to\n\t   * handle encoding and decoding parameter values:\n\t   *\n\t   * <pre>\n\t   * // Defines a custom type that gets a value from a service,\n\t   * // where each service gets different types of values from\n\t   * // a backend API:\n\t   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n\t   *\n\t   *   // Matches up services to URL parameter names\n\t   *   var services = {\n\t   *     user: Users,\n\t   *     post: Posts\n\t   *   };\n\t   *\n\t   *   return {\n\t   *     encode: function(object) {\n\t   *       // Represent the object in the URL using its unique ID\n\t   *       return object.id;\n\t   *     },\n\t   *     decode: function(value, key) {\n\t   *       // Look up the object by ID, using the parameter\n\t   *       // name (key) to call the correct service\n\t   *       return services[key].findById(value);\n\t   *     },\n\t   *     is: function(object, key) {\n\t   *       // Check that object is a valid dbObject\n\t   *       return angular.isObject(object) && object.id && services[key];\n\t   *     }\n\t   *     equals: function(a, b) {\n\t   *       // Check the equality of decoded objects by comparing\n\t   *       // their unique IDs\n\t   *       return a.id === b.id;\n\t   *     }\n\t   *   };\n\t   * });\n\t   *\n\t   * // In a config() block, you can then attach URLs with\n\t   * // type-annotated parameters:\n\t   * $stateProvider.state('users', {\n\t   *   url: \"/users\",\n\t   *   // ...\n\t   * }).state('users.item', {\n\t   *   url: \"/{user:dbObject}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     // $stateParams.user will now be an object returned from\n\t   *     // the Users service\n\t   *   },\n\t   *   // ...\n\t   * });\n\t   * </pre>\n\t   */\n\t  this.type = function (name, definition, definitionFn) {\n\t    if (!isDefined(definition)) return $types[name];\n\t    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t\n\t    $types[name] = new Type(extend({ name: name }, definition));\n\t    if (definitionFn) {\n\t      typeQueue.push({ name: name, def: definitionFn });\n\t      if (!enqueue) flushTypeQueue();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n\t  function flushTypeQueue() {\n\t    while(typeQueue.length) {\n\t      var type = typeQueue.shift();\n\t      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t      angular.extend($types[type.name], injector.invoke(type.def));\n\t    }\n\t  }\n\t\n\t  // Register default types. Store them in the prototype of $types.\n\t  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n\t  $types = inherit($types, {});\n\t\n\t  /* No need to document $get, since it returns this */\n\t  this.$get = ['$injector', function ($injector) {\n\t    injector = $injector;\n\t    enqueue = false;\n\t    flushTypeQueue();\n\t\n\t    forEach(defaultTypes, function(type, name) {\n\t      if (!$types[name]) $types[name] = new Type(type);\n\t    });\n\t    return this;\n\t  }];\n\t\n\t  this.Param = function Param(id, type, config, location) {\n\t    var self = this;\n\t    config = unwrapShorthand(config);\n\t    type = getType(config, type, location);\n\t    var arrayMode = getArrayMode();\n\t    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n\t    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n\t      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n\t    var isOptional = config.value !== undefined;\n\t    var squash = getSquashPolicy(config, isOptional);\n\t    var replace = getReplace(config, arrayMode, isOptional, squash);\n\t\n\t    function unwrapShorthand(config) {\n\t      var keys = isObject(config) ? objectKeys(config) : [];\n\t      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n\t                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n\t      if (isShorthand) config = { value: config };\n\t      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n\t      return config;\n\t    }\n\t\n\t    function getType(config, urlType, location) {\n\t      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n\t      if (urlType) return urlType;\n\t      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\t      return config.type instanceof Type ? config.type : new Type(config.type);\n\t    }\n\t\n\t    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t    function getArrayMode() {\n\t      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n\t      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t    }\n\t\n\t    /**\n\t     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t     */\n\t    function getSquashPolicy(config, isOptional) {\n\t      var squash = config.squash;\n\t      if (!isOptional || squash === false) return false;\n\t      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n\t      if (squash === true || isString(squash)) return squash;\n\t      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t    }\n\t\n\t    function getReplace(config, arrayMode, isOptional, squash) {\n\t      var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t      ];\n\t      replace = isArray(config.replace) ? config.replace : [];\n\t      if (isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t      configuredKeys = map(replace, function(item) { return item.from; } );\n\t      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n\t    }\n\t\n\t    /**\n\t     * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t     */\n\t    function $$getDefaultValue() {\n\t      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t      var defaultValue = injector.invoke(config.$$fn);\n\t      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n\t        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n\t      return defaultValue;\n\t    }\n\t\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    function $value(value) {\n\t      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n\t      function $replace(value) {\n\t        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n\t        return replacement.length ? replacement[0] : value;\n\t      }\n\t      value = $replace(value);\n\t      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n\t    }\n\t\n\t    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\t\n\t    extend(this, {\n\t      id: id,\n\t      type: type,\n\t      location: location,\n\t      array: arrayMode,\n\t      squash: squash,\n\t      replace: replace,\n\t      isOptional: isOptional,\n\t      value: $value,\n\t      dynamic: undefined,\n\t      config: config,\n\t      toString: toString\n\t    });\n\t  };\n\t\n\t  function ParamSet(params) {\n\t    extend(this, params || {});\n\t  }\n\t\n\t  ParamSet.prototype = {\n\t    $$new: function() {\n\t      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n\t    },\n\t    $$keys: function () {\n\t      var keys = [], chain = [], parent = this,\n\t        ignore = objectKeys(ParamSet.prototype);\n\t      while (parent) { chain.push(parent); parent = parent.$$parent; }\n\t      chain.reverse();\n\t      forEach(chain, function(paramset) {\n\t        forEach(objectKeys(paramset), function(key) {\n\t            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n\t        });\n\t      });\n\t      return keys;\n\t    },\n\t    $$values: function(paramValues) {\n\t      var values = {}, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        values[key] = self[key].value(paramValues && paramValues[key]);\n\t      });\n\t      return values;\n\t    },\n\t    $$equals: function(paramValues1, paramValues2) {\n\t      var equal = true, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n\t        if (!self[key].type.equals(left, right)) equal = false;\n\t      });\n\t      return equal;\n\t    },\n\t    $$validates: function $$validate(paramValues) {\n\t      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n\t      for (i = 0; i < keys.length; i++) {\n\t        param = this[keys[i]];\n\t        rawVal = paramValues[keys[i]];\n\t        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n\t          break; // There was no parameter value, but the param is optional\n\t        normalized = param.type.$normalize(rawVal);\n\t        if (!param.type.is(normalized))\n\t          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n\t        encoded = param.type.encode(normalized);\n\t        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n\t          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t      }\n\t      return true;\n\t    },\n\t    $$parent: undefined\n\t  };\n\t\n\t  this.ParamSet = ParamSet;\n\t}\n\t\n\t// Register as a provider so it's available to other providers\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\tangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`. \n\t * When `$location` changes it runs through a list of rules one by one until a \n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\t$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n\tfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n\t  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\t\n\t  // Returns a string that is a prefix of all strings matching the RegExp\n\t  function regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t  }\n\t\n\t  // Interpolates matched values into a String.replace()-style pattern\n\t  function interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t      return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#rule\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t   * specific URLs.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // Here's an example of how you might allow case insensitive urls\n\t   *   $urlRouterProvider.rule(function ($injector, $location) {\n\t   *     var path = $location.path(),\n\t   *         normalized = path.toLowerCase();\n\t   *\n\t   *     if (path !== normalized) {\n\t   *       return normalized;\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {object} rule Handler function that takes `$injector` and `$location`\n\t   * services as arguments. You can use them to return a valid path as a string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.rule = function (rule) {\n\t    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    rules.push(rule);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouterProvider#otherwise\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines a path that is used when an invalid route is requested.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // if the path doesn't match any of the urls you configured\n\t   *   // otherwise will take care of routing the user to the\n\t   *   // specified url\n\t   *   $urlRouterProvider.otherwise('/index');\n\t   *\n\t   *   // Example of using function rule as param\n\t   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t   *     return '/a/valid/url';\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} rule The url path you want to redirect to or a function \n\t   * rule that returns the url path. The function version is passed two params: \n\t   * `$injector` and `$location` services, and must return a url string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.otherwise = function (rule) {\n\t    if (isString(rule)) {\n\t      var redirect = rule;\n\t      rule = function () { return redirect; };\n\t    }\n\t    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    otherwise = rule;\n\t    return this;\n\t  };\n\t\n\t\n\t  function handleIfMatch($injector, handler, match) {\n\t    if (!match) return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match });\n\t    return isDefined(result) ? result : true;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#when\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Registers a handler for a given url matching. if handle is a string, it is\n\t   * treated as a redirect, and is interpolated according to the syntax of match\n\t   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t   *\n\t   * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t   * matches. You have the option of inject the match object as `$match`.\n\t   *\n\t   * The handler can return\n\t   *\n\t   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t   *   will continue trying to find another one that matches.\n\t   * - **string** which is treated as a redirect and passed to `$location.url()`\n\t   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t   *     if ($state.$current.navigable !== state ||\n\t   *         !equalForKeys($match, $stateParams) {\n\t   *      $state.transitionTo(state, $match, false);\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} what The incoming path that you want to redirect.\n\t   * @param {string|object} handler The path you want to redirect your user to.\n\t   */\n\t  this.when = function (what, handler) {\n\t    var redirect, handlerIsString = isString(handler);\n\t    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\t\n\t    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n\t      throw new Error(\"invalid 'handler' in when()\");\n\t\n\t    var strategies = {\n\t      matcher: function (what, handler) {\n\t        if (handlerIsString) {\n\t          redirect = $urlMatcherFactory.compile(handler);\n\t          handler = ['$match', function ($match) { return redirect.format($match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n\t        }, {\n\t          prefix: isString(what.prefix) ? what.prefix : ''\n\t        });\n\t      },\n\t      regex: function (what, handler) {\n\t        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\t\n\t        if (handlerIsString) {\n\t          redirect = handler;\n\t          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path()));\n\t        }, {\n\t          prefix: regExpPrefix(what)\n\t        });\n\t      }\n\t    };\n\t\n\t    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\t\n\t    for (var n in check) {\n\t      if (check[n]) return this.rule(strategies[n](what, handler));\n\t    }\n\t\n\t    throw new Error(\"invalid 'what' in when()\");\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Disables (or enables) deferring location change interception.\n\t   *\n\t   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t   * defer a transition but maintain the current URL), call this method at configuration time.\n\t   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t   * `$locationChangeSuccess` event handler.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *\n\t   *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t   *   // this allows you to configure custom behavior in between\n\t   *   // location changes and route synchronization:\n\t   *   $urlRouterProvider.deferIntercept();\n\t   *\n\t   * }).run(function ($rootScope, $urlRouter, UserService) {\n\t   *\n\t   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t   *     // UserService is an example service for managing user state\n\t   *     if (UserService.isLoggedIn()) return;\n\t   *\n\t   *     // Prevent $urlRouter's default handler from firing\n\t   *     e.preventDefault();\n\t   *\n\t   *     UserService.handleLogin().then(function() {\n\t   *       // Once the user has logged in, sync the current URL\n\t   *       // to the router:\n\t   *       $urlRouter.sync();\n\t   *     });\n\t   *   });\n\t   *\n\t   *   // Configures $urlRouter's listener *after* your custom listener\n\t   *   $urlRouter.listen();\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t            no parameter is equivalent to `true`.\n\t   */\n\t  this.deferIntercept = function (defer) {\n\t    if (defer === undefined) defer = true;\n\t    interceptDeferred = defer;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouter\n\t   *\n\t   * @requires $location\n\t   * @requires $rootScope\n\t   * @requires $injector\n\t   * @requires $browser\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n\t  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\t\n\t    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\t\n\t    function appendBasePath(url, isHtml5, absolute) {\n\t      if (baseHref === '/') return url;\n\t      if (isHtml5) return baseHref.slice(0, -1) + url;\n\t      if (absolute) return baseHref.slice(1) + url;\n\t      return url;\n\t    }\n\t\n\t    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t    function update(evt) {\n\t      if (evt && evt.defaultPrevented) return;\n\t      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n\t      lastPushedUrl = undefined;\n\t      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n\t      //if (ignoreUpdate) return true;\n\t\n\t      function check(rule) {\n\t        var handled = rule($injector, $location);\n\t\n\t        if (!handled) return false;\n\t        if (isString(handled)) $location.replace().url(handled);\n\t        return true;\n\t      }\n\t      var n = rules.length, i;\n\t\n\t      for (i = 0; i < n; i++) {\n\t        if (check(rules[i])) return;\n\t      }\n\t      // always check otherwise last to allow dynamic updates to the set of rules\n\t      if (otherwise) check(otherwise);\n\t    }\n\t\n\t    function listen() {\n\t      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n\t      return listener;\n\t    }\n\t\n\t    if (!interceptDeferred) listen();\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#sync\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t       * with the transition by calling `$urlRouter.sync()`.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * angular.module('app', ['ui.router'])\n\t       *   .run(function($rootScope, $urlRouter) {\n\t       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t       *       // Halt state change from even starting\n\t       *       evt.preventDefault();\n\t       *       // Perform custom logic\n\t       *       var meetsRequirement = ...\n\t       *       // Continue with the update and state transition if logic allows\n\t       *       if (meetsRequirement) $urlRouter.sync();\n\t       *     });\n\t       * });\n\t       * </pre>\n\t       */\n\t      sync: function() {\n\t        update();\n\t      },\n\t\n\t      listen: function() {\n\t        return listen();\n\t      },\n\t\n\t      update: function(read) {\n\t        if (read) {\n\t          location = $location.url();\n\t          return;\n\t        }\n\t        if ($location.url() === location) return;\n\t\n\t        $location.url(location);\n\t        $location.replace();\n\t      },\n\t\n\t      push: function(urlMatcher, params, options) {\n\t         var url = urlMatcher.format(params || {});\n\t\n\t        // Handle the special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t            url += '#' + params['#'];\n\t        }\n\t\n\t        $location.url(url);\n\t        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n\t        if (options && options.replace) $location.replace();\n\t      },\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#href\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * A URL generation method that returns the compiled URL for a given\n\t       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t       *   person: \"bob\"\n\t       * });\n\t       * // $bob == \"/about/bob\";\n\t       * </pre>\n\t       *\n\t       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t       * @param {object=} options Options object. The options are:\n\t       *\n\t       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t       *\n\t       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t       */\n\t      href: function(urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params)) return null;\n\t\n\t        var isHtml5 = $locationProvider.html5Mode();\n\t        if (angular.isObject(isHtml5)) {\n\t          isHtml5 = isHtml5.enabled;\n\t        }\n\t        \n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t\n\t        if (!isHtml5 && url !== null) {\n\t          url = \"#\" + $locationProvider.hashPrefix() + url;\n\t        }\n\t\n\t        // Handle special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t          url += '#' + params['#'];\n\t        }\n\t\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\n\t        if (!options.absolute || !url) {\n\t          return url;\n\t        }\n\t\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\n\t        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\t$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n\tfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\t\n\t  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\t\n\t  // Builds state properties from definition passed to registerState()\n\t  var stateBuilder = {\n\t\n\t    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n\t    // state.children = [];\n\t    // if (parent) parent.children.push(state);\n\t    parent: function(state) {\n\t      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n\t      // regex matches any valid composite state name\n\t      // would match \"contact.list\" but not \"contacts\"\n\t      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n\t      return compositeName ? findState(compositeName[1]) : root;\n\t    },\n\t\n\t    // inherit 'data' from parent and override by own values (if any)\n\t    data: function(state) {\n\t      if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = extend({}, state.parent.data, state.data);\n\t      }\n\t      return state.data;\n\t    },\n\t\n\t    // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t    url: function(state) {\n\t      var url = state.url, config = { params: state.params || {} };\n\t\n\t      if (isString(url)) {\n\t        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n\t        return (state.parent.navigable || root).url.concat(url, config);\n\t      }\n\t\n\t      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n\t      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t    },\n\t\n\t    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t    navigable: function(state) {\n\t      return state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    },\n\t\n\t    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n\t    ownParams: function(state) {\n\t      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n\t      forEach(state.params || {}, function(config, id) {\n\t        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n\t      });\n\t      return params;\n\t    },\n\t\n\t    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n\t    params: function(state) {\n\t      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();\n\t    },\n\t\n\t    // If there is no explicit multi-view configuration, make one up so we don't have\n\t    // to handle both cases in the view directive later. Note that having an explicit\n\t    // 'views' property will mean the default unnamed view properties are ignored. This\n\t    // is also a good time to resolve view names to absolute names, so everything is a\n\t    // straight lookup at link time.\n\t    views: function(state) {\n\t      var views = {};\n\t\n\t      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n\t        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n\t        views[name] = view;\n\t      });\n\t      return views;\n\t    },\n\t\n\t    // Keep a full path from the root down to this state as this is needed for state activation.\n\t    path: function(state) {\n\t      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n\t    },\n\t\n\t    // Speed up $state.contains() as it's used a lot\n\t    includes: function(state) {\n\t      var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t      includes[state.name] = true;\n\t      return includes;\n\t    },\n\t\n\t    $delegates: {}\n\t  };\n\t\n\t  function isRelative(stateName) {\n\t    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t  }\n\t\n\t  function findState(stateOrName, base) {\n\t    if (!stateOrName) return undefined;\n\t\n\t    var isStr = isString(stateOrName),\n\t        name  = isStr ? stateOrName : stateOrName.name,\n\t        path  = isRelative(name);\n\t\n\t    if (path) {\n\t      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n\t      base = findState(base);\n\t      \n\t      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\t\n\t      for (; i < pathLength; i++) {\n\t        if (rel[i] === \"\" && i === 0) {\n\t          current = base;\n\t          continue;\n\t        }\n\t        if (rel[i] === \"^\") {\n\t          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n\t          current = current.parent;\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t      rel = rel.slice(i).join(\".\");\n\t      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n\t    }\n\t    var state = states[name];\n\t\n\t    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t      return state;\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function queueState(parentName, state) {\n\t    if (!queue[parentName]) {\n\t      queue[parentName] = [];\n\t    }\n\t    queue[parentName].push(state);\n\t  }\n\t\n\t  function flushQueuedChildren(parentName) {\n\t    var queued = queue[parentName] || [];\n\t    while(queued.length) {\n\t      registerState(queued.shift());\n\t    }\n\t  }\n\t\n\t  function registerState(state) {\n\t    // Wrap a new object around the state so we can store our private details easily.\n\t    state = inherit(state, {\n\t      self: state,\n\t      resolve: state.resolve || {},\n\t      toString: function() { return this.name; }\n\t    });\n\t\n\t    var name = state.name;\n\t    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n\t    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\t\n\t    // Get parent name\n\t    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n\t        : (isString(state.parent)) ? state.parent\n\t        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n\t        : '';\n\t\n\t    // If parent is not registered yet, add state to queue and register later\n\t    if (parentName && !states[parentName]) {\n\t      return queueState(parentName, state.self);\n\t    }\n\t\n\t    for (var key in stateBuilder) {\n\t      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n\t    }\n\t    states[name] = state;\n\t\n\t    // Register the state in the global state list and with $urlRouter if necessary.\n\t    if (!state[abstractKey] && state.url) {\n\t      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n\t          $state.transitionTo(state, $match, { inherit: true, location: false });\n\t        }\n\t      }]);\n\t    }\n\t\n\t    // Register any queued children\n\t    flushQueuedChildren(name);\n\t\n\t    return state;\n\t  }\n\t\n\t  // Checks text to see if it looks like a glob.\n\t  function isGlob (text) {\n\t    return text.indexOf('*') > -1;\n\t  }\n\t\n\t  // Returns true if glob matches current $state name.\n\t  function doesStateMatchGlob (glob) {\n\t    var globSegments = glob.split('.'),\n\t        segments = $state.$current.name.split('.');\n\t\n\t    //match single stars\n\t    for (var i = 0, l = globSegments.length; i < l; i++) {\n\t      if (globSegments[i] === '*') {\n\t        segments[i] = '*';\n\t      }\n\t    }\n\t\n\t    //match greedy starts\n\t    if (globSegments[0] === '**') {\n\t       segments = segments.slice(indexOf(segments, globSegments[1]));\n\t       segments.unshift('**');\n\t    }\n\t    //match greedy ends\n\t    if (globSegments[globSegments.length - 1] === '**') {\n\t       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n\t       segments.push('**');\n\t    }\n\t\n\t    if (globSegments.length != segments.length) {\n\t      return false;\n\t    }\n\t\n\t    return segments.join('') === globSegments.join('');\n\t  }\n\t\n\t\n\t  // Implicit root state that is always active\n\t  root = registerState({\n\t    name: '',\n\t    url: '^',\n\t    views: null,\n\t    'abstract': true\n\t  });\n\t  root.navigable = null;\n\t\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#decorator\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Allows you to extend (carefully) or override (at your own peril) the \n\t   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n\t   * to add custom functionality to ui-router, for example inferring templateUrl \n\t   * based on the state name.\n\t   *\n\t   * When passing only a name, it returns the current (original or decorated) builder\n\t   * function that matches `name`.\n\t   *\n\t   * The builder functions that can be decorated are listed below. Though not all\n\t   * necessarily have a good use case for decoration, that is up to you to decide.\n\t   *\n\t   * In addition, users can attach custom decorators, which will generate new \n\t   * properties within the state's internal definition. There is currently no clear \n\t   * use-case for this beyond accessing internal states (i.e. $state.$current), \n\t   * however, expect this to become increasingly relevant as we introduce additional \n\t   * meta-programming features.\n\t   *\n\t   * **Warning**: Decorators should not be interdependent because the order of \n\t   * execution of the builder functions in non-deterministic. Builder functions \n\t   * should only be dependent on the state definition object and super function.\n\t   *\n\t   *\n\t   * Existing builder functions and current return values:\n\t   *\n\t   * - **parent** `{object}` - returns the parent state object.\n\t   * - **data** `{object}` - returns state data, including any inherited data that is not\n\t   *   overridden by own values (if any).\n\t   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t   *   or `null`.\n\t   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n\t   *   navigable).\n\t   * - **params** `{object}` - returns an array of state params that are ensured to \n\t   *   be a super-set of parent's params.\n\t   * - **views** `{object}` - returns a views object where each key is an absolute view \n\t   *   name (i.e. \"viewName@stateName\") and each value is the config object \n\t   *   (template, controller) for the view. Even when you don't use the views object \n\t   *   explicitly on a state config, one is still created for you internally.\n\t   *   So by decorating this builder function you have access to decorating template \n\t   *   and controller properties.\n\t   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n\t   *   not including any params defined by ancestor states.\n\t   * - **path** `{string}` - returns the full path from the root down to this state. \n\t   *   Needed for state activation.\n\t   * - **includes** `{object}` - returns an object that includes every state that \n\t   *   would pass a `$state.includes()` test.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Override the internal 'views' builder with a function that takes the state\n\t   * // definition, and a reference to the internal function being overridden:\n\t   * $stateProvider.decorator('views', function (state, parent) {\n\t   *   var result = {},\n\t   *       views = parent(state);\n\t   *\n\t   *   angular.forEach(views, function (config, name) {\n\t   *     var autoName = (state.name + '.' + name).replace('.', '/');\n\t   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t   *     result[name] = config;\n\t   *   });\n\t   *   return result;\n\t   * });\n\t   *\n\t   * $stateProvider.state('home', {\n\t   *   views: {\n\t   *     'contact.list': { controller: 'ListController' },\n\t   *     'contact.item': { controller: 'ItemController' }\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * $state.go('home');\n\t   * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t   * // and /partials/home/contact/item.html, respectively.\n\t   * </pre>\n\t   *\n\t   * @param {string} name The name of the builder function to decorate. \n\t   * @param {object} func A function that is responsible for decorating the original \n\t   * builder function. The function receives two parameters:\n\t   *\n\t   *   - `{object}` - state - The state config object.\n\t   *   - `{object}` - super - The original builder function.\n\t   *\n\t   * @return {object} $stateProvider - $stateProvider instance\n\t   */\n\t  this.decorator = decorator;\n\t  function decorator(name, func) {\n\t    /*jshint validthis: true */\n\t    if (isString(name) && !isDefined(func)) {\n\t      return stateBuilder[name];\n\t    }\n\t    if (!isFunction(func) || !isString(name)) {\n\t      return this;\n\t    }\n\t    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n\t      stateBuilder.$delegates[name] = stateBuilder[name];\n\t    }\n\t    stateBuilder[name] = func;\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#state\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Registers a state configuration under a given state name. The stateConfig object\n\t   * has the following acceptable properties.\n\t   *\n\t   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t   * @param {object} stateConfig State configuration object.\n\t   * @param {string|function=} stateConfig.template\n\t   * <a id='template'></a>\n\t   *   html template as a string or a function that returns\n\t   *   an html template as a string which should be used by the uiView directives. This property \n\t   *   takes precedence over templateUrl.\n\t   *   \n\t   *   If `template` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t   *     applying the current state\n\t   *\n\t   * <pre>template:\n\t   *   \"<h1>inline template definition</h1>\" +\n\t   *   \"<div ui-view></div>\"</pre>\n\t   * <pre>template: function(params) {\n\t   *       return \"<h1>generated template</h1>\"; }</pre>\n\t   * </div>\n\t   *\n\t   * @param {string|function=} stateConfig.templateUrl\n\t   * <a id='templateUrl'></a>\n\t   *\n\t   *   path or function that returns a path to an html\n\t   *   template that should be used by uiView.\n\t   *   \n\t   *   If `templateUrl` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n\t   *     applying the current state\n\t   *\n\t   * <pre>templateUrl: \"home.html\"</pre>\n\t   * <pre>templateUrl: function(params) {\n\t   *     return myTemplates[params.pageId]; }</pre>\n\t   *\n\t   * @param {function=} stateConfig.templateProvider\n\t   * <a id='templateProvider'></a>\n\t   *    Provider function that returns HTML content string.\n\t   * <pre> templateProvider:\n\t   *       function(MyTemplateService, params) {\n\t   *         return MyTemplateService.getTemplate(params.pageId);\n\t   *       }</pre>\n\t   *\n\t   * @param {string|function=} stateConfig.controller\n\t   * <a id='controller'></a>\n\t   *\n\t   *  Controller fn that should be associated with newly\n\t   *   related scope or the name of a registered controller if passed as a string.\n\t   *   Optionally, the ControllerAs may be declared here.\n\t   * <pre>controller: \"MyRegisteredController\"</pre>\n\t   * <pre>controller:\n\t   *     \"MyRegisteredController as fooCtrl\"}</pre>\n\t   * <pre>controller: function($scope, MyService) {\n\t   *     $scope.data = MyService.getData(); }</pre>\n\t   *\n\t   * @param {function=} stateConfig.controllerProvider\n\t   * <a id='controllerProvider'></a>\n\t   *\n\t   * Injectable provider function that returns the actual controller or string.\n\t   * <pre>controllerProvider:\n\t   *   function(MyResolveData) {\n\t   *     if (MyResolveData.foo)\n\t   *       return \"FooCtrl\"\n\t   *     else if (MyResolveData.bar)\n\t   *       return \"BarCtrl\";\n\t   *     else return function($scope) {\n\t   *       $scope.baz = \"Qux\";\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {string=} stateConfig.controllerAs\n\t   * <a id='controllerAs'></a>\n\t   * \n\t   * A controller alias name. If present the controller will be\n\t   *   published to scope under the controllerAs name.\n\t   * <pre>controllerAs: \"myCtrl\"</pre>\n\t   *\n\t   * @param {string|object=} stateConfig.parent\n\t   * <a id='parent'></a>\n\t   * Optionally specifies the parent state of this state.\n\t   *\n\t   * <pre>parent: 'parentState'</pre>\n\t   * <pre>parent: parentState // JS variable</pre>\n\t   *\n\t   * @param {object=} stateConfig.resolve\n\t   * <a id='resolve'></a>\n\t   *\n\t   * An optional map&lt;string, function&gt; of dependencies which\n\t   *   should be injected into the controller. If any of these dependencies are promises, \n\t   *   the router will wait for them all to be resolved before the controller is instantiated.\n\t   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n\t   *   and the values of the resolved promises are injected into any controllers that reference them.\n\t   *   If any  of the promises are rejected the $stateChangeError event is fired.\n\t   *\n\t   *   The map object is:\n\t   *   \n\t   *   - key - {string}: name of dependency to be injected into controller\n\t   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n\t   *     it is injected and return value it treated as dependency. If result is a promise, it is \n\t   *     resolved before its value is injected into controller.\n\t   *\n\t   * <pre>resolve: {\n\t   *     myResolve1:\n\t   *       function($http, $stateParams) {\n\t   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n\t   *       }\n\t   *     }</pre>\n\t   *\n\t   * @param {string=} stateConfig.url\n\t   * <a id='url'></a>\n\t   *\n\t   *   A url fragment with optional parameters. When a state is navigated or\n\t   *   transitioned to, the `$stateParams` service will be populated with any \n\t   *   parameters that were passed.\n\t   *\n\t   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n\t   *   more details on acceptable patterns )\n\t   *\n\t   * examples:\n\t   * <pre>url: \"/home\"\n\t   * url: \"/users/:userid\"\n\t   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n\t   * url: \"/books/{categoryid:int}\"\n\t   * url: \"/books/{publishername:string}/{categoryid:int}\"\n\t   * url: \"/messages?before&after\"\n\t   * url: \"/messages?{before:date}&{after:date}\"\n\t   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n\t   * </pre>\n\t   *\n\t   * @param {object=} stateConfig.views\n\t   * <a id='views'></a>\n\t   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n\t   * manually/explicitly.\n\t   *\n\t   * Examples:\n\t   *\n\t   * Targets three named `ui-view`s in the parent state's template\n\t   * <pre>views: {\n\t   *     header: {\n\t   *       controller: \"headerCtrl\",\n\t   *       templateUrl: \"header.html\"\n\t   *     }, body: {\n\t   *       controller: \"bodyCtrl\",\n\t   *       templateUrl: \"body.html\"\n\t   *     }, footer: {\n\t   *       controller: \"footCtrl\",\n\t   *       templateUrl: \"footer.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n\t   * <pre>views: {\n\t   *     'header@top': {\n\t   *       controller: \"msgHeaderCtrl\",\n\t   *       templateUrl: \"msgHeader.html\"\n\t   *     }, 'body': {\n\t   *       controller: \"messagesCtrl\",\n\t   *       templateUrl: \"messages.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.abstract=false]\n\t   * <a id='abstract'></a>\n\t   * An abstract state will never be directly activated,\n\t   *   but can provide inherited properties to its common children states.\n\t   * <pre>abstract: true</pre>\n\t   *\n\t   * @param {function=} stateConfig.onEnter\n\t   * <a id='onEnter'></a>\n\t   *\n\t   * Callback function for when a state is entered. Good way\n\t   *   to trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explictly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onEnter: function(MyService, $stateParams) {\n\t   *     MyService.foo($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {function=} stateConfig.onExit\n\t   * <a id='onExit'></a>\n\t   *\n\t   * Callback function for when a state is exited. Good way to\n\t   *   trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explictly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onExit: function(MyService, $stateParams) {\n\t   *     MyService.cleanup($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n\t   * <a id='reloadOnSearch'></a>\n\t   *\n\t   * If `false`, will not retrigger the same state\n\t   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n\t   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t   * <pre>reloadOnSearch: false</pre>\n\t   *\n\t   * @param {object=} stateConfig.data\n\t   * <a id='data'></a>\n\t   *\n\t   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n\t   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n\t   *   the entire subtree via prototypal inheritance.\n\t   *\n\t   * <pre>data: {\n\t   *     requiredRole: 'foo'\n\t   * } </pre>\n\t   *\n\t   * @param {object=} stateConfig.params\n\t   * <a id='params'></a>\n\t   *\n\t   * A map which optionally configures parameters declared in the `url`, or\n\t   *   defines additional non-url parameters.  For each parameter being\n\t   *   configured, add a configuration object keyed to the name of the parameter.\n\t   *\n\t   *   Each parameter configuration object may contain the following properties:\n\t   *\n\t   *   - ** value ** - {object|function=}: specifies the default value for this\n\t   *     parameter.  This implicitly sets this parameter as optional.\n\t   *\n\t   *     When UI-Router routes to a state and no value is\n\t   *     specified for this parameter in the URL or transition, the\n\t   *     default value will be used instead.  If `value` is a function,\n\t   *     it will be injected and invoked, and the return value used.\n\t   *\n\t   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n\t   *     is treated as \"the default value is `null`\".\n\t   *\n\t   *     *Shorthand*: If you only need to configure the default value of the\n\t   *     parameter, you may use a shorthand syntax.   In the **`params`**\n\t   *     map, instead mapping the param name to a full parameter configuration\n\t   *     object, simply set map it to the default parameter value, e.g.:\n\t   *\n\t   * <pre>// define a parameter's default value\n\t   * params: {\n\t   *     param1: { value: \"defaultValue\" }\n\t   * }\n\t   * // shorthand default values\n\t   * params: {\n\t   *     param1: \"defaultValue\",\n\t   *     param2: \"param2Default\"\n\t   * }</pre>\n\t   *\n\t   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n\t   *     treated as an array of values.  If you specified a Type, the value will be\n\t   *     treated as an array of the specified Type.  Note: query parameter values\n\t   *     default to a special `\"auto\"` mode.\n\t   *\n\t   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n\t   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n\t   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n\t   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n\t   *     value (e.g.: `{ foo: '1' }`).\n\t   *\n\t   * <pre>params: {\n\t   *     param1: { array: true }\n\t   * }</pre>\n\t   *\n\t   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n\t   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n\t   *     configured default squash policy.\n\t   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n\t   *\n\t   *   There are three squash settings:\n\t   *\n\t   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n\t   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n\t   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n\t   *       This can allow for cleaner looking URLs.\n\t   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n\t   *\n\t   * <pre>params: {\n\t   *     param1: {\n\t   *       value: \"defaultId\",\n\t   *       squash: true\n\t   * } }\n\t   * // squash \"defaultValue\" to \"~\"\n\t   * params: {\n\t   *     param1: {\n\t   *       value: \"defaultValue\",\n\t   *       squash: \"~\"\n\t   * } }\n\t   * </pre>\n\t   *\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Some state name examples\n\t   *\n\t   * // stateName can be a single top-level name (must be unique).\n\t   * $stateProvider.state(\"home\", {});\n\t   *\n\t   * // Or it can be a nested state name. This state is a child of the\n\t   * // above \"home\" state.\n\t   * $stateProvider.state(\"home.newest\", {});\n\t   *\n\t   * // Nest states as deeply as needed.\n\t   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t   *\n\t   * // state() returns $stateProvider, so you can chain state declarations.\n\t   * $stateProvider\n\t   *   .state(\"home\", {})\n\t   *   .state(\"about\", {})\n\t   *   .state(\"contacts\", {});\n\t   * </pre>\n\t   *\n\t   */\n\t  this.state = state;\n\t  function state(name, definition) {\n\t    /*jshint validthis: true */\n\t    if (isObject(name)) definition = name;\n\t    else definition.name = name;\n\t    registerState(definition);\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$state\n\t   *\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires ui.router.state.$view\n\t   * @requires $injector\n\t   * @requires ui.router.util.$resolve\n\t   * @requires ui.router.state.$stateParams\n\t   * @requires ui.router.router.$urlRouter\n\t   *\n\t   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n\t   * you'd like to test against the current active state.\n\t   * @property {object} current A reference to the state's config object. However \n\t   * you passed it in. Useful for accessing custom data.\n\t   * @property {object} transition Currently pending transition. A promise that'll \n\t   * resolve or reject.\n\t   *\n\t   * @description\n\t   * `$state` service is responsible for representing states as well as transitioning\n\t   * between them. It also provides interfaces to ask for current state or even states\n\t   * you're coming from.\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n\t  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\t\n\t    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n\t    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n\t    var TransitionAborted = $q.reject(new Error('transition aborted'));\n\t    var TransitionFailed = $q.reject(new Error('transition failed'));\n\t\n\t    // Handles the case where a state which is the target of a transition is not found, and the user\n\t    // can optionally retry or defer the transition\n\t    function handleRedirect(redirect, state, params, options) {\n\t      /**\n\t       * @ngdoc event\n\t       * @name ui.router.state.$state#$stateNotFound\n\t       * @eventOf ui.router.state.$state\n\t       * @eventType broadcast on root scope\n\t       * @description\n\t       * Fired when a requested state **cannot be found** using the provided state name during transition.\n\t       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n\t       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n\t       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n\t       *\n\t       * @param {Object} event Event object.\n\t       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n\t       * @param {State} fromState Current state object.\n\t       * @param {Object} fromParams Current state params.\n\t       *\n\t       * @example\n\t       *\n\t       * <pre>\n\t       * // somewhere, assume lazy.state has not been defined\n\t       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n\t       *\n\t       * // somewhere else\n\t       * $scope.$on('$stateNotFound',\n\t       * function(event, unfoundState, fromState, fromParams){\n\t       *     console.log(unfoundState.to); // \"lazy.state\"\n\t       *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t       *     console.log(unfoundState.options); // {inherit:false} + default options\n\t       * })\n\t       * </pre>\n\t       */\n\t      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\t\n\t      if (evt.defaultPrevented) {\n\t        $urlRouter.update();\n\t        return TransitionAborted;\n\t      }\n\t\n\t      if (!evt.retry) {\n\t        return null;\n\t      }\n\t\n\t      // Allow the handler to return a promise to defer state lookup retry\n\t      if (options.$retry) {\n\t        $urlRouter.update();\n\t        return TransitionFailed;\n\t      }\n\t      var retryTransition = $state.transition = $q.when(evt.retry);\n\t\n\t      retryTransition.then(function() {\n\t        if (retryTransition !== $state.transition) return TransitionSuperseded;\n\t        redirect.options.$retry = true;\n\t        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n\t      }, function() {\n\t        return TransitionAborted;\n\t      });\n\t      $urlRouter.update();\n\t\n\t      return retryTransition;\n\t    }\n\t\n\t    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\t\n\t    $state = {\n\t      params: {},\n\t      current: root.self,\n\t      $current: root,\n\t      transition: null\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state. All resolves are re-resolved,\n\t     * controllers reinstantiated, and events re-fired.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t     * @example\n\t     * <pre>\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n\t     * //and current state is 'contacts.detail.item'\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.reload = function reload(state) {\n\t      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls \n\t     * `$state.transitionTo` internally but automatically sets options to \n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n\t     * This allows you to easily use an absolute or relative to path and specify \n\t     * only the parameters you'd like to update (while letting unspecified parameters \n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state, \n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n\t     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    $state.go = function go(to, params, options) {\n\t      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *    if String, then will reload the state with the name given in reload, and any children.\n\t     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.transitionTo = function transitionTo(to, toParams, options) {\n\t      toParams = toParams || {};\n\t      options = extend({\n\t        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n\t      }, options || {});\n\t\n\t      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n\t      var evt, toState = findState(to, options.relative);\n\t\n\t      // Store the hash param for later (since it will be stripped out by various methods)\n\t      var hash = toParams['#'];\n\t\n\t      if (!isDefined(toState)) {\n\t        var redirect = { to: to, toParams: toParams, options: options };\n\t        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\t\n\t        if (redirectResult) {\n\t          return redirectResult;\n\t        }\n\t\n\t        // Always retry once if the $stateNotFound was not prevented\n\t        // (handles either redirect changed or state lazy-definition)\n\t        to = redirect.to;\n\t        toParams = redirect.toParams;\n\t        options = redirect.options;\n\t        toState = findState(to, options.relative);\n\t\n\t        if (!isDefined(toState)) {\n\t          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n\t          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n\t        }\n\t      }\n\t      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n\t      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n\t      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\t\n\t      toParams = toState.params.$$values(toParams);\n\t      to = toState;\n\t\n\t      var toPath = to.path;\n\t\n\t      // Starting from the root of the path, keep all levels that haven't changed\n\t      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\t\n\t      if (!options.reload) {\n\t        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      } else if (isString(options.reload) || isObject(options.reload)) {\n\t        if (isObject(options.reload) && !options.reload.name) {\n\t          throw new Error('Invalid reload state object');\n\t        }\n\t        \n\t        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n\t        if (options.reload && !reloadState) {\n\t          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        }\n\t\n\t        while (state && state === fromPath[keep] && state !== reloadState) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      }\n\t\n\t      // If we're going to the same state and all locals are kept, we've got nothing to do.\n\t      // But clear 'transition', as we still want to cancel any other pending transitions.\n\t      // TODO: We may not want to bump 'transition' if we're called from a location change\n\t      // that we've initiated ourselves, because we might accidentally abort a legitimate\n\t      // transition initiated from code?\n\t      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n\t        if (hash) toParams['#'] = hash;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        if (options.location && to.navigable && to.navigable.url) {\n\t          $urlRouter.push(to.navigable.url, toParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t          $urlRouter.update(true);\n\t        }\n\t        $state.transition = null;\n\t        return $q.when($state.current);\n\t      }\n\t\n\t      // Filter parameters before we pass them to event handlers etc.\n\t      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\t\n\t      // Broadcast start event and cancel the transition if requested\n\t      if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeStart\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n\t         * to prevent the transition from happening and then the transition promise will be\n\t         * rejected with a `'transition prevented'` value.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $rootScope.$on('$stateChangeStart',\n\t         * function(event, toState, toParams, fromState, fromParams){\n\t         *     event.preventDefault();\n\t         *     // transitionTo() promise will be rejected with\n\t         *     // a 'transition prevented' error\n\t         * })\n\t         * </pre>\n\t         */\n\t        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n\t          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n\t          $urlRouter.update();\n\t          return TransitionPrevented;\n\t        }\n\t      }\n\t\n\t      // Resolve locals for the remaining states, but don't update any global state just\n\t      // yet -- if anything fails to resolve the current state needs to remain untouched.\n\t      // We also set up an inheritance chain for the locals here. This allows the view directive\n\t      // to quickly look up the correct definition for each view in the current state. Even\n\t      // though we create the locals object itself outside resolveState(), it is initially\n\t      // empty and gets filled asynchronously. We need to keep track of the promise for the\n\t      // (fully resolved) current locals, and pass this down the chain.\n\t      var resolved = $q.when(locals);\n\t\n\t      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n\t        locals = toLocals[l] = inherit(locals);\n\t        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n\t      }\n\t\n\t      // Once everything is resolved, we are ready to perform the actual transition\n\t      // and return a promise for the new state. We also keep track of what the\n\t      // current promise is, so that we can detect overlapping transitions and\n\t      // keep only the outcome of the last transition.\n\t      var transition = $state.transition = resolved.then(function () {\n\t        var l, entering, exiting;\n\t\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Exit 'from' states not kept\n\t        for (l = fromPath.length - 1; l >= keep; l--) {\n\t          exiting = fromPath[l];\n\t          if (exiting.self.onExit) {\n\t            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n\t          }\n\t          exiting.locals = null;\n\t        }\n\t\n\t        // Enter 'to' states not kept\n\t        for (l = keep; l < toPath.length; l++) {\n\t          entering = toPath[l];\n\t          entering.locals = toLocals[l];\n\t          if (entering.self.onEnter) {\n\t            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n\t          }\n\t        }\n\t\n\t        // Re-add the saved hash before we start returning things\n\t        if (hash) toParams['#'] = hash;\n\t\n\t        // Run it again, to catch any transitions in callbacks\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Update globals in $state\n\t        $state.$current = to;\n\t        $state.current = to.self;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        $state.transition = null;\n\t\n\t        if (options.location && to.navigable) {\n\t          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t        }\n\t\n\t        if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeSuccess\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired once the state transition is **complete**.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         */\n\t          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n\t        }\n\t        $urlRouter.update(true);\n\t\n\t        return $state.current;\n\t      }, function (error) {\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        $state.transition = null;\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeError\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when an **error occurs** during transition. It's important to note that if you\n\t         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t         * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t         * catch **ALL** errors.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         * @param {Error} error The resolve error object.\n\t         */\n\t        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\t\n\t        if (!evt.defaultPrevented) {\n\t            $urlRouter.update();\n\t        }\n\t\n\t        return $q.reject(error);\n\t      });\n\t\n\t      return transition;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be\n\t     * tested for strict equality against the current active params object, so all params\n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     * test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    $state.is = function is(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) { return undefined; }\n\t      if ($state.$current !== state) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t     * .includes will test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    $state.includes = function includes(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      if (isString(stateOrName) && isGlob(stateOrName)) {\n\t        if (!doesStateMatchGlob(stateOrName)) {\n\t          return false;\n\t        }\n\t        stateOrName = $state.$current.name;\n\t      }\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t      if (!isDefined(state)) { return undefined; }\n\t      if (!isDefined($state.$current.includes[state.name])) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n\t    };\n\t\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     * \n\t     * @returns {string} compiled state url\n\t     */\n\t    $state.href = function href(stateOrName, params, options) {\n\t      options = extend({\n\t        lossy:    true,\n\t        inherit:  true,\n\t        absolute: false,\n\t        relative: $state.$current\n\t      }, options || {});\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) return null;\n\t      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\t      \n\t      var nav = (state && options.lossy) ? state.navigable : state;\n\t\n\t      if (!nav || nav.url === undefined || nav.url === null) {\n\t        return null;\n\t      }\n\t      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n\t        absolute: options.absolute\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#get\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Returns the state configuration object for any specific state or all states.\n\t     *\n\t     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n\t     * the requested state. If not provided, returns an array of ALL state configs.\n\t     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n\t     * @returns {Object|Array} State configuration object or array of all objects.\n\t     */\n\t    $state.get = function (stateOrName, context) {\n\t      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n\t      var state = findState(stateOrName, context || $state.$current);\n\t      return (state && state.self) ? state.self : null;\n\t    };\n\t\n\t    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n\t      // Make a restricted $stateParams with only the parameters that apply to this state if\n\t      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n\t      // we also need $stateParams to be available for any $injector calls we make during the\n\t      // dependency resolution process.\n\t      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n\t      var locals = { $stateParams: $stateParams };\n\t\n\t      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n\t      // We're also including $stateParams in this; that way the parameters are restricted\n\t      // to the set that should be visible to the state, and are independent of when we update\n\t      // the global $state and $stateParams values.\n\t      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n\t      var promises = [dst.resolve.then(function (globals) {\n\t        dst.globals = globals;\n\t      })];\n\t      if (inherited) promises.push(inherited);\n\t\n\t      function resolveViews() {\n\t        var viewsPromises = [];\n\t\n\t        // Resolve template and dependencies for all views.\n\t        forEach(state.views, function (view, name) {\n\t          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n\t          injectables.$template = [ function () {\n\t            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n\t          }];\n\t\n\t          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n\t            // References to the controller (only instantiated at link time)\n\t            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n\t              var injectLocals = angular.extend({}, injectables, dst.globals);\n\t              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n\t            } else {\n\t              result.$$controller = view.controller;\n\t            }\n\t            // Provide access to the state itself for internal use\n\t            result.$$state = state;\n\t            result.$$controllerAs = view.controllerAs;\n\t            dst[name] = result;\n\t          }));\n\t        });\n\t\n\t        return $q.all(viewsPromises).then(function(){\n\t          return dst.globals;\n\t        });\n\t      }\n\t\n\t      // Wait for all the promises and then return the activation object\n\t      return $q.all(promises).then(resolveViews).then(function (values) {\n\t        return dst;\n\t      });\n\t    }\n\t\n\t    return $state;\n\t  }\n\t\n\t  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n\t    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n\t    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n\t      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n\t      function notSearchParam(key) {\n\t        return fromAndToState.params[key].location != \"search\";\n\t      }\n\t      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n\t      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n\t      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n\t      return nonQueryParamSet.$$equals(fromParams, toParams);\n\t    }\n\t\n\t    // If reload was not explicitly requested\n\t    // and we're transitioning to the same state we're already in\n\t    // and    the locals didn't change\n\t    //     or they changed in a way that doesn't merit reloading\n\t    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n\t    // Then return true.\n\t    if (!options.reload && to === from &&\n\t      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .value('$stateParams', {})\n\t  .provider('$state', $StateProvider);\n\t\n\t\n\t$ViewProvider.$inject = [];\n\tfunction $ViewProvider() {\n\t\n\t  this.$get = $get;\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$view\n\t   *\n\t   * @requires ui.router.util.$templateFactory\n\t   * @requires $rootScope\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  $get.$inject = ['$rootScope', '$templateFactory'];\n\t  function $get(   $rootScope,   $templateFactory) {\n\t    return {\n\t      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.state.$view#load\n\t       * @methodOf ui.router.state.$view\n\t       *\n\t       * @description\n\t       *\n\t       * @param {string} name name\n\t       * @param {object} options option object.\n\t       */\n\t      load: function load(name, options) {\n\t        var result, defaults = {\n\t          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n\t        };\n\t        options = extend(defaults, options);\n\t\n\t        if (options.view) {\n\t          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n\t        }\n\t        if (result && options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$viewContentLoading\n\t         * @eventOf ui.router.state.$view\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         *\n\t         * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {Object} viewConfig The view config properties (template, controller, etc).\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $scope.$on('$viewContentLoading',\n\t         * function(event, viewConfig){\n\t         *     // Access to all the view config properties.\n\t         *     // and one special property 'targetView'\n\t         *     // viewConfig.targetView\n\t         * });\n\t         * </pre>\n\t         */\n\t          $rootScope.$broadcast('$viewContentLoading', options);\n\t        }\n\t        return result;\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state').provider('$view', $ViewProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t\n\t  var useAnchorScroll = false;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t   * @methodOf ui.router.state.$uiViewScrollProvider\n\t   *\n\t   * @description\n\t   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t   * scrolling based on the url anchor.\n\t   */\n\t  this.useAnchorScroll = function () {\n\t    useAnchorScroll = true;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$uiViewScroll\n\t   *\n\t   * @requires $anchorScroll\n\t   * @requires $timeout\n\t   *\n\t   * @description\n\t   * When called with a jqLite element, it scrolls the element into view (after a\n\t   * `$timeout` so the DOM has time to refresh).\n\t   *\n\t   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t   */\n\t  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t    if (useAnchorScroll) {\n\t      return $anchorScroll;\n\t    }\n\t\n\t    return function ($element) {\n\t      return $timeout(function () {\n\t        $element[0].scrollIntoView();\n\t      }, 0, false);\n\t    };\n\t  }];\n\t}\n\t\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-view\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $compile\n\t * @requires $controller\n\t * @requires $injector\n\t * @requires ui.router.state.$uiViewScroll\n\t * @requires $document\n\t *\n\t * @restrict ECA\n\t *\n\t * @description\n\t * The ui-view directive tells $state where to place your templates.\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t * \n\t * @example\n\t * A view can be unnamed or named. \n\t * <pre>\n\t * <!-- Unnamed -->\n\t * <div ui-view></div> \n\t * \n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * </pre>\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a \n\t * single view and it is unnamed then you can populate it like so:\n\t * <pre>\n\t * <div ui-view></div> \n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * </pre>\n\t * \n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n\t * config property, by name, in this case an empty name:\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * But typically you'll only use the views property if you name your view or have more than one view \n\t * in the same template. There's not really a compelling reason to name a view if its the only one, \n\t * but you could if you wanted, like so:\n\t * <pre>\n\t * <div ui-view=\"main\"></div>\n\t * </pre> \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * Really though, you'll use views to set up multiple views:\n\t * <pre>\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div> \n\t * <div ui-view=\"data\"></div> \n\t * </pre>\n\t * \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * <pre>\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * </pre>\n\t */\n\t$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\n\tfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\t\n\t  function getService() {\n\t    return ($injector.has) ? function(service) {\n\t      return $injector.has(service) ? $injector.get(service) : null;\n\t    } : function(service) {\n\t      try {\n\t        return $injector.get(service);\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var service = getService(),\n\t      $animator = service('$animator'),\n\t      $animate = service('$animate');\n\t\n\t  // Returns a set of DOM manipulation functions based on which Angular version\n\t  // it should use\n\t  function getRenderer(attrs, scope) {\n\t    var statics = function() {\n\t      return {\n\t        enter: function (element, target, cb) { target.after(element); cb(); },\n\t        leave: function (element, cb) { element.remove(); cb(); }\n\t      };\n\t    };\n\t\n\t    if ($animate) {\n\t      return {\n\t        enter: function(element, target, cb) {\n\t          var promise = $animate.enter(element, null, target, cb);\n\t          if (promise && promise.then) promise.then(cb);\n\t        },\n\t        leave: function(element, cb) {\n\t          var promise = $animate.leave(element, cb);\n\t          if (promise && promise.then) promise.then(cb);\n\t        }\n\t      };\n\t    }\n\t\n\t    if ($animator) {\n\t      var animate = $animator && $animator(scope, attrs);\n\t\n\t      return {\n\t        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n\t        leave: function(element, cb) { animate.leave(element); cb(); }\n\t      };\n\t    }\n\t\n\t    return statics();\n\t  }\n\t\n\t  var directive = {\n\t    restrict: 'ECA',\n\t    terminal: true,\n\t    priority: 400,\n\t    transclude: 'element',\n\t    compile: function (tElement, tAttrs, $transclude) {\n\t      return function (scope, $element, attrs) {\n\t        var previousEl, currentEl, currentScope, latestLocals,\n\t            onloadExp     = attrs.onload || '',\n\t            autoScrollExp = attrs.autoscroll,\n\t            renderer      = getRenderer(attrs, scope);\n\t\n\t        scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t        scope.$on('$viewContentLoading', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        updateView(true);\n\t\n\t        function cleanupLastView() {\n\t          if (previousEl) {\n\t            previousEl.remove();\n\t            previousEl = null;\n\t          }\n\t\n\t          if (currentScope) {\n\t            currentScope.$destroy();\n\t            currentScope = null;\n\t          }\n\t\n\t          if (currentEl) {\n\t            renderer.leave(currentEl, function() {\n\t              previousEl = null;\n\t            });\n\t\n\t            previousEl = currentEl;\n\t            currentEl = null;\n\t          }\n\t        }\n\t\n\t        function updateView(firstTime) {\n\t          var newScope,\n\t              name            = getUiViewName(scope, attrs, $element, $interpolate),\n\t              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\t\n\t          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n\t          newScope = scope.$new();\n\t          latestLocals = $state.$current.locals[name];\n\t\n\t          var clone = $transclude(newScope, function(clone) {\n\t            renderer.enter(clone, $element, function onUiViewEnter() {\n\t              if(currentScope) {\n\t                currentScope.$emit('$viewContentAnimationEnded');\n\t              }\n\t\n\t              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                $uiViewScroll(clone);\n\t              }\n\t            });\n\t            cleanupLastView();\n\t          });\n\t\n\t          currentEl = clone;\n\t          currentScope = newScope;\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description           *\n\t           * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           */\n\t          currentScope.$emit('$viewContentLoaded');\n\t          currentScope.$eval(onloadExp);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  return directive;\n\t}\n\t\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\n\tfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n\t  return {\n\t    restrict: 'ECA',\n\t    priority: -400,\n\t    compile: function (tElement) {\n\t      var initial = tElement.html();\n\t      return function (scope, $element, attrs) {\n\t        var current = $state.$current,\n\t            name = getUiViewName(scope, attrs, $element, $interpolate),\n\t            locals  = current && current.locals[name];\n\t\n\t        if (! locals) {\n\t          return;\n\t        }\n\t\n\t        $element.data('$uiView', { name: name, state: locals.$$state });\n\t        $element.html(locals.$template ? locals.$template : initial);\n\t\n\t        var link = $compile($element.contents());\n\t\n\t        if (locals.$$controller) {\n\t          locals.$scope = scope;\n\t          locals.$element = $element;\n\t          var controller = $controller(locals.$$controller, locals);\n\t          if (locals.$$controllerAs) {\n\t            scope[locals.$$controllerAs] = controller;\n\t          }\n\t          $element.data('$ngControllerController', controller);\n\t          $element.children().data('$ngControllerController', controller);\n\t        }\n\t\n\t        link(scope);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Shared ui-view code for both directives:\n\t * Given scope, element, and its attributes, return the view's name\n\t */\n\tfunction getUiViewName(scope, attrs, element, $interpolate) {\n\t  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n\t  var inherited = element.inheritedData('$uiView');\n\t  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n\t}\n\t\n\tangular.module('ui.router.state').directive('uiView', $ViewDirective);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\tfunction parseStateRef(ref, current) {\n\t  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n\t  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t  return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t\n\tfunction stateContext(el) {\n\t  var stateData = el.parent().inheritedData('$uiView');\n\t\n\t  if (stateData && stateData.state && stateData.state.name) {\n\t    return stateData.state;\n\t  }\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $timeout\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n\t * URL, the directive will automatically generate & update the `href` attribute via \n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n\t * the link will trigger a state transition with optional parameters. \n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative \n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the \n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * @example\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n\t * following template:\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t * \n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t * \n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t * \n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n\t */\n\t$StateRefDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDirective($state, $timeout) {\n\t  var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];\n\t\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n\t      var params = null, url = null, base = stateContext(element) || $state.$current;\n\t      // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t      var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?\n\t                 'xlink:href' : 'href';\n\t      var newHref = null, isAnchor = element.prop(\"tagName\").toUpperCase() === \"A\";\n\t      var isForm = element[0].nodeName === \"FORM\";\n\t      var attr = isForm ? \"action\" : hrefKind, nav = true;\n\t\n\t      var options = { relative: base, inherit: true };\n\t      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\t\n\t      angular.forEach(allowedOptions, function(option) {\n\t        if (option in optionsOverride) {\n\t          options[option] = optionsOverride[option];\n\t        }\n\t      });\n\t\n\t      var update = function(newVal) {\n\t        if (newVal) params = angular.copy(newVal);\n\t        if (!nav) return;\n\t\n\t        newHref = $state.href(ref.state, params, options);\n\t\n\t        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n\t        if (activeDirective) {\n\t          activeDirective.$$addStateInfo(ref.state, params);\n\t        }\n\t        if (newHref === null) {\n\t          nav = false;\n\t          return false;\n\t        }\n\t        attrs.$set(attr, newHref);\n\t      };\n\t\n\t      if (ref.paramExpr) {\n\t        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n\t          if (newVal !== params) update(newVal);\n\t        }, true);\n\t        params = angular.copy(scope.$eval(ref.paramExpr));\n\t      }\n\t      update();\n\t\n\t      if (isForm) return;\n\t\n\t      element.bind(\"click\", function(e) {\n\t        var button = e.which || e.button;\n\t        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n\t          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t          var transition = $timeout(function() {\n\t            $state.go(ref.state, params, options);\n\t          });\n\t          e.preventDefault();\n\t\n\t          // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t          var ignorePreventDefaultCount = isAnchor && !newHref ? 1: 0;\n\t          e.preventDefault = function() {\n\t            if (ignorePreventDefaultCount-- <= 0)\n\t              $timeout.cancel(transition);\n\t          };\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use\n\t * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n\t *\n\t * @example\n\t * Given the following template:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active-eq\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n\t * when the exact target state used in the `ui-sref` is active; no child states.\n\t *\n\t */\n\t$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n\tfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n\t  return  {\n\t    restrict: \"A\",\n\t    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n\t      var states = [], activeClass;\n\t\n\t      // There probably isn't much point in $observing this\n\t      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t      // slight difference in logic routing\n\t      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\t\n\t      // Allow uiSref to communicate with uiSrefActive[Equals]\n\t      this.$$addStateInfo = function (newState, newParams) {\n\t        var state = $state.get(newState, stateContext($element));\n\t\n\t        states.push({\n\t          state: state || { name: newState },\n\t          params: newParams\n\t        });\n\t\n\t        update();\n\t      };\n\t\n\t      $scope.$on('$stateChangeSuccess', update);\n\t\n\t      // Update route state\n\t      function update() {\n\t        if (anyMatch()) {\n\t          $element.addClass(activeClass);\n\t        } else {\n\t          $element.removeClass(activeClass);\n\t        }\n\t      }\n\t\n\t      function anyMatch() {\n\t        for (var i = 0; i < states.length; i++) {\n\t          if (isMatch(states[i].state, states[i].params)) {\n\t            return true;\n\t          }\n\t        }\n\t        return false;\n\t      }\n\t\n\t      function isMatch(state, params) {\n\t        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n\t          return $state.is(state.name, params);\n\t        } else {\n\t          return $state.includes(state.name, params);\n\t        }\n\t      }\n\t    }]\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .directive('uiSref', $StateRefDirective)\n\t  .directive('uiSrefActive', $StateRefActiveDirective)\n\t  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t  var isFilter = function (state) {\n\t    return $state.is(state);\n\t  };\n\t  isFilter.$stateful = true;\n\t  return isFilter;\n\t}\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t  var includesFilter = function (state) {\n\t    return $state.includes(state);\n\t  };\n\t  includesFilter.$stateful = true;\n\t  return  includesFilter;\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .filter('isState', $IsStateFilter)\n\t  .filter('includedByState', $IncludedByStateFilter);\n\t})(window, window.angular);\n\n/***/ },\n/* 18 */,\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t  'use strict';\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (root.hasOwnProperty('angular')) {\n\t    // Browser globals (root is window), we don't register it.\n\t    factory(root.angular);\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = factory(require('angular'));\n\t  }\n\t}(this , function (angular) {\n\t    'use strict';\n\t\n\t    // In cases where Angular does not get passed or angular is a truthy value\n\t    // but misses .module we can fall back to using window.\n\t    angular = (angular && angular.module ) ? angular : window.angular;\n\t\n\t    /**\n\t     * @ngdoc overview\n\t     * @name ngStorage\n\t     */\n\t\n\t    return angular.module('ngStorage', [])\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$localStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$localStorage', _storageProvider('localStorage'))\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$sessionStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\t\n\t    function _storageProvider(storageType) {\n\t        return function () {\n\t          var storageKeyPrefix = 'ngStorage-';\n\t\n\t          this.setKeyPrefix = function (prefix) {\n\t            if (typeof prefix !== 'string') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n\t            }\n\t            storageKeyPrefix = prefix;\n\t          };\n\t\n\t          var serializer = angular.toJson;\n\t          var deserializer = angular.fromJson;\n\t\n\t          this.setSerializer = function (s) {\n\t            if (typeof s !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n\t            }\n\t\n\t            serializer = s;\n\t          };\n\t\n\t          this.setDeserializer = function (d) {\n\t            if (typeof d !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n\t            }\n\t\n\t            deserializer = d;\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.get = function (key) {\n\t            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.set = function (key, value) {\n\t            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n\t          };\n\t\n\t          this.$get = [\n\t              '$rootScope',\n\t              '$window',\n\t              '$log',\n\t              '$timeout',\n\t              '$document',\n\t\n\t              function(\n\t                  $rootScope,\n\t                  $window,\n\t                  $log,\n\t                  $timeout,\n\t                  $document\n\t              ){\n\t                function isStorageSupported(storageType) {\n\t\n\t                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n\t                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n\t                    // that error and allow execution to continue.\n\t\n\t                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n\t                    // when \"Block cookies\": \"Always block\" is turned on\n\t                    var supported;\n\t                    try {\n\t                        supported = $window[storageType];\n\t                    }\n\t                    catch (err) {\n\t                        supported = false;\n\t                    }\n\t\n\t                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n\t                    // is available, but trying to call .setItem throws an exception below:\n\t                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n\t                    if (supported && storageType === 'localStorage') {\n\t                        var key = '__' + Math.round(Math.random() * 1e7);\n\t\n\t                        try {\n\t                            localStorage.setItem(key, key);\n\t                            localStorage.removeItem(key);\n\t                        }\n\t                        catch (err) {\n\t                            supported = false;\n\t                        }\n\t                    }\n\t\n\t                    return supported;\n\t                }\n\t\n\t                // The magic number 10 is used which only works for some keyPrefixes...\n\t                // See https://github.com/gsklee/ngStorage/issues/137\n\t                var prefixLength = storageKeyPrefix.length;\n\t\n\t                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n\t                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n\t                    $storage = {\n\t                        $default: function(items) {\n\t                            for (var k in items) {\n\t                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n\t                            }\n\t\n\t                            $storage.$sync();\n\t                            return $storage;\n\t                        },\n\t                        $reset: function(items) {\n\t                            for (var k in $storage) {\n\t                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n\t                            }\n\t\n\t                            return $storage.$default(items);\n\t                        },\n\t                        $sync: function () {\n\t                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n\t                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n\t                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n\t                            }\n\t                        },\n\t                        $apply: function() {\n\t                            var temp$storage;\n\t\n\t                            _debounce = null;\n\t\n\t                            if (!angular.equals($storage, _last$storage)) {\n\t                                temp$storage = angular.copy(_last$storage);\n\t                                angular.forEach($storage, function(v, k) {\n\t                                    if (angular.isDefined(v) && '$' !== k[0]) {\n\t                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n\t                                        delete temp$storage[k];\n\t                                    }\n\t                                });\n\t\n\t                                for (var k in temp$storage) {\n\t                                    webStorage.removeItem(storageKeyPrefix + k);\n\t                                }\n\t\n\t                                _last$storage = angular.copy($storage);\n\t                            }\n\t                        }\n\t                    },\n\t                    _last$storage,\n\t                    _debounce;\n\t\n\t                $storage.$sync();\n\t\n\t                _last$storage = angular.copy($storage);\n\t\n\t                $rootScope.$watch(function() {\n\t                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n\t                });\n\t\n\t                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n\t                $window.addEventListener && $window.addEventListener('storage', function(event) {\n\t                    if (!event.key) {\n\t                      return;\n\t                    }\n\t\n\t                    // Reference doc.\n\t                    var doc = $document[0];\n\t\n\t                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n\t                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\t\n\t                        _last$storage = angular.copy($storage);\n\t\n\t                        $rootScope.$apply();\n\t                    }\n\t                });\n\t\n\t                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n\t                    $storage.$apply();\n\t                });\n\t\n\t                return $storage;\n\t              }\n\t          ];\n\t      };\n\t    }\n\t\n\t}));\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t/**\n\t * oclazyload - Load modules on demand (lazy load) with angularJS\n\t * @version v1.0.9\n\t * @link https://github.com/ocombe/ocLazyLoad\n\t * @license MIT\n\t * @author Olivier Combe <olivier.combe@gmail.com>\n\t */\n\t(function (angular, window) {\n\t    'use strict';\n\t\n\t    var regModules = ['ng', 'oc.lazyLoad'],\n\t        regInvokes = {},\n\t        regConfigs = [],\n\t        modulesToLoad = [],\n\t        // modules to load from angular.module or other sources\n\t    realModules = [],\n\t        // real modules called from angular.module\n\t    recordDeclarations = [],\n\t        broadcast = angular.noop,\n\t        runBlocks = {},\n\t        justLoaded = [];\n\t\n\t    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\t\n\t    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n\t        var modules = {},\n\t            providers = {\n\t            $controllerProvider: $controllerProvider,\n\t            $compileProvider: $compileProvider,\n\t            $filterProvider: $filterProvider,\n\t            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n\t            $injector: $injector,\n\t            $animateProvider: $animateProvider\n\t        },\n\t            debug = false,\n\t            events = false,\n\t            moduleCache = [],\n\t            modulePromises = {};\n\t\n\t        moduleCache.push = function (value) {\n\t            if (this.indexOf(value) === -1) {\n\t                Array.prototype.push.apply(this, arguments);\n\t            }\n\t        };\n\t\n\t        this.config = function (config) {\n\t            // If we want to define modules configs\n\t            if (angular.isDefined(config.modules)) {\n\t                if (angular.isArray(config.modules)) {\n\t                    angular.forEach(config.modules, function (moduleConfig) {\n\t                        modules[moduleConfig.name] = moduleConfig;\n\t                    });\n\t                } else {\n\t                    modules[config.modules.name] = config.modules;\n\t                }\n\t            }\n\t\n\t            if (angular.isDefined(config.debug)) {\n\t                debug = config.debug;\n\t            }\n\t\n\t            if (angular.isDefined(config.events)) {\n\t                events = config.events;\n\t            }\n\t        };\n\t\n\t        /**\n\t         * Get the list of existing registered modules\n\t         * @param element\n\t         */\n\t        this._init = function _init(element) {\n\t            // this is probably useless now because we override angular.bootstrap\n\t            if (modulesToLoad.length === 0) {\n\t                var elements = [element],\n\t                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n\t                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n\t                    append = function append(elm) {\n\t                    return elm && elements.push(elm);\n\t                };\n\t\n\t                angular.forEach(names, function (name) {\n\t                    names[name] = true;\n\t                    append(document.getElementById(name));\n\t                    name = name.replace(':', '\\\\:');\n\t                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n\t                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n\t                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n\t                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n\t                    }\n\t                });\n\t\n\t                angular.forEach(elements, function (elm) {\n\t                    if (modulesToLoad.length === 0) {\n\t                        var className = ' ' + element.className + ' ';\n\t                        var match = NG_APP_CLASS_REGEXP.exec(className);\n\t                        if (match) {\n\t                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n\t                        } else {\n\t                            angular.forEach(elm.attributes, function (attr) {\n\t                                if (modulesToLoad.length === 0 && names[attr.name]) {\n\t                                    modulesToLoad.push(attr.value);\n\t                                }\n\t                            });\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t\n\t            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n\t                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n\t            }\n\t\n\t            var addReg = function addReg(moduleName) {\n\t                if (regModules.indexOf(moduleName) === -1) {\n\t                    // register existing modules\n\t                    regModules.push(moduleName);\n\t                    var mainModule = angular.module(moduleName);\n\t\n\t                    // register existing components (directives, services, ...)\n\t                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n\t                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\t\n\t                    angular.forEach(mainModule.requires, addReg);\n\t                }\n\t            };\n\t\n\t            angular.forEach(modulesToLoad, function (moduleName) {\n\t                addReg(moduleName);\n\t            });\n\t\n\t            modulesToLoad = []; // reset for next bootstrap\n\t            recordDeclarations.pop(); // wait for the next lazy load\n\t        };\n\t\n\t        /**\n\t         * Like JSON.stringify but that doesn't throw on circular references\n\t         * @param obj\n\t         */\n\t        var stringify = function stringify(obj) {\n\t            try {\n\t                return JSON.stringify(obj);\n\t            } catch (e) {\n\t                var cache = [];\n\t                return JSON.stringify(obj, function (key, value) {\n\t                    if (angular.isObject(value) && value !== null) {\n\t                        if (cache.indexOf(value) !== -1) {\n\t                            // Circular reference found, discard key\n\t                            return;\n\t                        }\n\t                        // Store value in our collection\n\t                        cache.push(value);\n\t                    }\n\t                    return value;\n\t                });\n\t            }\n\t        };\n\t\n\t        var hashCode = function hashCode(str) {\n\t            var hash = 0,\n\t                i,\n\t                chr,\n\t                len;\n\t            if (str.length == 0) {\n\t                return hash;\n\t            }\n\t            for (i = 0, len = str.length; i < len; i++) {\n\t                chr = str.charCodeAt(i);\n\t                hash = (hash << 5) - hash + chr;\n\t                hash |= 0; // Convert to 32bit integer\n\t            }\n\t            return hash;\n\t        };\n\t\n\t        function _register(providers, registerModules, params) {\n\t            if (registerModules) {\n\t                var k,\n\t                    moduleName,\n\t                    moduleFn,\n\t                    tempRunBlocks = [];\n\t                for (k = registerModules.length - 1; k >= 0; k--) {\n\t                    moduleName = registerModules[k];\n\t                    if (!angular.isString(moduleName)) {\n\t                        moduleName = getModuleName(moduleName);\n\t                    }\n\t                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n\t                        continue;\n\t                    }\n\t                    // new if not registered\n\t                    var newModule = regModules.indexOf(moduleName) === -1;\n\t                    moduleFn = ngModuleFct(moduleName);\n\t                    if (newModule) {\n\t                        regModules.push(moduleName);\n\t                        _register(providers, moduleFn.requires, params);\n\t                    }\n\t                    if (moduleFn._runBlocks.length > 0) {\n\t                        // new run blocks detected! Replace the old ones (if existing)\n\t                        runBlocks[moduleName] = [];\n\t                        while (moduleFn._runBlocks.length > 0) {\n\t                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n\t                        }\n\t                    }\n\t                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n\t                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n\t                    }\n\t                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n\t                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n\t                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n\t                    registerModules.pop();\n\t                    justLoaded.push(moduleName);\n\t                }\n\t                // execute the run blocks at the end\n\t                var instanceInjector = providers.getInstanceInjector();\n\t                angular.forEach(tempRunBlocks, function (fn) {\n\t                    instanceInjector.invoke(fn);\n\t                });\n\t            }\n\t        }\n\t\n\t        function _registerInvokeList(args, moduleName) {\n\t            var invokeList = args[2][0],\n\t                type = args[1],\n\t                newInvoke = false;\n\t            if (angular.isUndefined(regInvokes[moduleName])) {\n\t                regInvokes[moduleName] = {};\n\t            }\n\t            if (angular.isUndefined(regInvokes[moduleName][type])) {\n\t                regInvokes[moduleName][type] = {};\n\t            }\n\t            var onInvoke = function onInvoke(invokeName, invoke) {\n\t                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n\t                    regInvokes[moduleName][type][invokeName] = [];\n\t                }\n\t                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n\t                    newInvoke = true;\n\t                    regInvokes[moduleName][type][invokeName].push(invoke);\n\t                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n\t                }\n\t            };\n\t\n\t            function checkHashes(potentialNew, invokes) {\n\t                var isNew = true,\n\t                    newHash;\n\t                if (invokes.length) {\n\t                    newHash = signature(potentialNew);\n\t                    angular.forEach(invokes, function (invoke) {\n\t                        isNew = isNew && signature(invoke) !== newHash;\n\t                    });\n\t                }\n\t                return isNew;\n\t            }\n\t\n\t            function signature(data) {\n\t                if (angular.isArray(data)) {\n\t                    // arrays are objects, we need to test for it first\n\t                    return hashCode(data.toString());\n\t                } else if (angular.isObject(data)) {\n\t                    // constants & values for example\n\t                    return hashCode(stringify(data));\n\t                } else {\n\t                    if (angular.isDefined(data) && data !== null) {\n\t                        return hashCode(data.toString());\n\t                    } else {\n\t                        // null & undefined constants\n\t                        return data;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (angular.isString(invokeList)) {\n\t                onInvoke(invokeList, args[2][1]);\n\t            } else if (angular.isObject(invokeList)) {\n\t                angular.forEach(invokeList, function (invoke, key) {\n\t                    if (angular.isString(invoke)) {\n\t                        // decorators for example\n\t                        onInvoke(invoke, invokeList[1]);\n\t                    } else {\n\t                        // components registered as object lists {\"componentName\": function() {}}\n\t                        onInvoke(key, invoke);\n\t                    }\n\t                });\n\t            } else {\n\t                return false;\n\t            }\n\t            return newInvoke;\n\t        }\n\t\n\t        function _invokeQueue(providers, queue, moduleName, reconfig) {\n\t            if (!queue) {\n\t                return;\n\t            }\n\t\n\t            var i, len, args, provider;\n\t            for (i = 0, len = queue.length; i < len; i++) {\n\t                args = queue[i];\n\t                if (angular.isArray(args)) {\n\t                    if (providers !== null) {\n\t                        if (providers.hasOwnProperty(args[0])) {\n\t                            provider = providers[args[0]];\n\t                        } else {\n\t                            throw new Error('unsupported provider ' + args[0]);\n\t                        }\n\t                    }\n\t                    var isNew = _registerInvokeList(args, moduleName);\n\t                    if (args[1] !== 'invoke') {\n\t                        if (isNew && angular.isDefined(provider)) {\n\t                            provider[args[1]].apply(provider, args[2]);\n\t                        }\n\t                    } else {\n\t                        // config block\n\t                        var callInvoke = function callInvoke(fct) {\n\t                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n\t                            if (invoked === -1 || reconfig) {\n\t                                if (invoked === -1) {\n\t                                    regConfigs.push(moduleName + '-' + fct);\n\t                                }\n\t                                if (angular.isDefined(provider)) {\n\t                                    provider[args[1]].apply(provider, args[2]);\n\t                                }\n\t                            }\n\t                        };\n\t                        if (angular.isFunction(args[2][0])) {\n\t                            callInvoke(args[2][0]);\n\t                        } else if (angular.isArray(args[2][0])) {\n\t                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n\t                                if (angular.isFunction(args[2][0][j])) {\n\t                                    callInvoke(args[2][0][j]);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function getModuleName(module) {\n\t            var moduleName = null;\n\t            if (angular.isString(module)) {\n\t                moduleName = module;\n\t            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n\t                moduleName = module.name;\n\t            }\n\t            return moduleName;\n\t        }\n\t\n\t        function moduleExists(moduleName) {\n\t            if (!angular.isString(moduleName)) {\n\t                return false;\n\t            }\n\t            try {\n\t                return ngModuleFct(moduleName);\n\t            } catch (e) {\n\t                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t\n\t        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n\t            var instanceInjector,\n\t                filesCache = $cacheFactory('ocLazyLoad');\n\t\n\t            if (!debug) {\n\t                $log = {};\n\t                $log['error'] = angular.noop;\n\t                $log['warn'] = angular.noop;\n\t                $log['info'] = angular.noop;\n\t            }\n\t\n\t            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n\t            providers.getInstanceInjector = function () {\n\t                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n\t            };\n\t\n\t            broadcast = function broadcast(eventName, params) {\n\t                if (events) {\n\t                    $rootScope.$broadcast(eventName, params);\n\t                }\n\t                if (debug) {\n\t                    $log.info(eventName, params);\n\t                }\n\t            };\n\t\n\t            function reject(e) {\n\t                var deferred = $q.defer();\n\t                $log.error(e.message);\n\t                deferred.reject(e);\n\t                return deferred.promise;\n\t            }\n\t\n\t            return {\n\t                _broadcast: broadcast,\n\t\n\t                _$log: $log,\n\t\n\t                /**\n\t                 * Returns the files cache used by the loaders to store the files currently loading\n\t                 * @returns {*}\n\t                 */\n\t                _getFilesCache: function getFilesCache() {\n\t                    return filesCache;\n\t                },\n\t\n\t                /**\n\t                 * Let the service know that it should monitor angular.module because files are loading\n\t                 * @param watch boolean\n\t                 */\n\t                toggleWatch: function toggleWatch(watch) {\n\t                    if (watch) {\n\t                        recordDeclarations.push(true);\n\t                    } else {\n\t                        recordDeclarations.pop();\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Let you get a module config object\n\t                 * @param moduleName String the name of the module\n\t                 * @returns {*}\n\t                 */\n\t                getModuleConfig: function getModuleConfig(moduleName) {\n\t                    if (!angular.isString(moduleName)) {\n\t                        throw new Error('You need to give the name of the module to get');\n\t                    }\n\t                    if (!modules[moduleName]) {\n\t                        return null;\n\t                    }\n\t                    return angular.copy(modules[moduleName]);\n\t                },\n\t\n\t                /**\n\t                 * Let you define a module config object\n\t                 * @param moduleConfig Object the module config object\n\t                 * @returns {*}\n\t                 */\n\t                setModuleConfig: function setModuleConfig(moduleConfig) {\n\t                    if (!angular.isObject(moduleConfig)) {\n\t                        throw new Error('You need to give the module config object to set');\n\t                    }\n\t                    modules[moduleConfig.name] = moduleConfig;\n\t                    return moduleConfig;\n\t                },\n\t\n\t                /**\n\t                 * Returns the list of loaded modules\n\t                 * @returns {string[]}\n\t                 */\n\t                getModules: function getModules() {\n\t                    return regModules;\n\t                },\n\t\n\t                /**\n\t                 * Let you check if a module has been loaded into Angular or not\n\t                 * @param modulesNames String/Object a module name, or a list of module names\n\t                 * @returns {boolean}\n\t                 */\n\t                isLoaded: function isLoaded(modulesNames) {\n\t                    var moduleLoaded = function moduleLoaded(module) {\n\t                        var isLoaded = regModules.indexOf(module) > -1;\n\t                        if (!isLoaded) {\n\t                            isLoaded = !!moduleExists(module);\n\t                        }\n\t                        return isLoaded;\n\t                    };\n\t                    if (angular.isString(modulesNames)) {\n\t                        modulesNames = [modulesNames];\n\t                    }\n\t                    if (angular.isArray(modulesNames)) {\n\t                        var i, len;\n\t                        for (i = 0, len = modulesNames.length; i < len; i++) {\n\t                            if (!moduleLoaded(modulesNames[i])) {\n\t                                return false;\n\t                            }\n\t                        }\n\t                        return true;\n\t                    } else {\n\t                        throw new Error('You need to define the module(s) name(s)');\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Given a module, return its name\n\t                 * @param module\n\t                 * @returns {String}\n\t                 */\n\t                _getModuleName: getModuleName,\n\t\n\t                /**\n\t                 * Returns a module if it exists\n\t                 * @param moduleName\n\t                 * @returns {module}\n\t                 */\n\t                _getModule: function getModule(moduleName) {\n\t                    try {\n\t                        return ngModuleFct(moduleName);\n\t                    } catch (e) {\n\t                        // this error message really suxx\n\t                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n\t                        }\n\t                        throw e;\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Check if a module exists and returns it if it does\n\t                 * @param moduleName\n\t                 * @returns {boolean}\n\t                 */\n\t                moduleExists: moduleExists,\n\t\n\t                /**\n\t                 * Load the dependencies, and might try to load new files depending on the config\n\t                 * @param moduleName (String or Array of Strings)\n\t                 * @param localParams\n\t                 * @returns {*}\n\t                 * @private\n\t                 */\n\t                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n\t                    var loadedModule,\n\t                        requires,\n\t                        diff,\n\t                        promisesList = [],\n\t                        self = this;\n\t\n\t                    moduleName = self._getModuleName(moduleName);\n\t\n\t                    if (moduleName === null) {\n\t                        return $q.when();\n\t                    } else {\n\t                        try {\n\t                            loadedModule = self._getModule(moduleName);\n\t                        } catch (e) {\n\t                            return reject(e);\n\t                        }\n\t                        // get unloaded requires\n\t                        requires = self.getRequires(loadedModule);\n\t                    }\n\t\n\t                    angular.forEach(requires, function (requireEntry) {\n\t                        // If no configuration is provided, try and find one from a previous load.\n\t                        // If there isn't one, bail and let the normal flow run\n\t                        if (angular.isString(requireEntry)) {\n\t                            var config = self.getModuleConfig(requireEntry);\n\t                            if (config === null) {\n\t                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n\t                                return;\n\t                            }\n\t                            requireEntry = config;\n\t                            // ignore the name because it's probably not a real module name\n\t                            config.name = undefined;\n\t                        }\n\t\n\t                        // Check if this dependency has been loaded previously\n\t                        if (self.moduleExists(requireEntry.name)) {\n\t                            // compare against the already loaded module to see if the new definition adds any new files\n\t                            diff = requireEntry.files.filter(function (n) {\n\t                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n\t                            });\n\t\n\t                            // If the module was redefined, advise via the console\n\t                            if (diff.length !== 0) {\n\t                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n\t                            }\n\t\n\t                            // Push everything to the file loader, it will weed out the duplicates.\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                            return;\n\t                        } else if (angular.isArray(requireEntry)) {\n\t                            var files = [];\n\t                            angular.forEach(requireEntry, function (entry) {\n\t                                // let's check if the entry is a file name or a config name\n\t                                var config = self.getModuleConfig(entry);\n\t                                if (config === null) {\n\t                                    files.push(entry);\n\t                                } else if (config.files) {\n\t                                    files = files.concat(config.files);\n\t                                }\n\t                            });\n\t                            if (files.length > 0) {\n\t                                requireEntry = {\n\t                                    files: files\n\t                                };\n\t                            }\n\t                        } else if (angular.isObject(requireEntry)) {\n\t                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n\t                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n\t                                self.setModuleConfig(requireEntry);\n\t                                moduleCache.push(requireEntry['name']);\n\t                            }\n\t                        }\n\t\n\t                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n\t                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                        }\n\t                    });\n\t\n\t                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n\t                    return $q.all(promisesList);\n\t                },\n\t\n\t                /**\n\t                 * Inject new modules into Angular\n\t                 * @param moduleName\n\t                 * @param localParams\n\t                 * @param real\n\t                 */\n\t                inject: function inject(moduleName) {\n\t                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\t\n\t                    var self = this,\n\t                        deferred = $q.defer();\n\t                    if (angular.isDefined(moduleName) && moduleName !== null) {\n\t                        if (angular.isArray(moduleName)) {\n\t                            var promisesList = [];\n\t                            angular.forEach(moduleName, function (module) {\n\t                                promisesList.push(self.inject(module, localParams, real));\n\t                            });\n\t                            return $q.all(promisesList);\n\t                        } else {\n\t                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n\t                        }\n\t                    }\n\t                    if (modulesToLoad.length > 0) {\n\t                        var res = modulesToLoad.slice(); // clean copy\n\t                        var loadNext = function loadNext(moduleName) {\n\t                            moduleCache.push(moduleName);\n\t                            modulePromises[moduleName] = deferred.promise;\n\t                            self._loadDependencies(moduleName, localParams).then(function success() {\n\t                                try {\n\t                                    justLoaded = [];\n\t                                    _register(providers, moduleCache, localParams);\n\t                                } catch (e) {\n\t                                    self._$log.error(e.message);\n\t                                    deferred.reject(e);\n\t                                    return;\n\t                                }\n\t\n\t                                if (modulesToLoad.length > 0) {\n\t                                    loadNext(modulesToLoad.shift()); // load the next in list\n\t                                } else {\n\t                                        deferred.resolve(res); // everything has been loaded, resolve\n\t                                    }\n\t                            }, function error(err) {\n\t                                deferred.reject(err);\n\t                            });\n\t                        };\n\t\n\t                        // load the first in list\n\t                        loadNext(modulesToLoad.shift());\n\t                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n\t                        return modulePromises[localParams.name];\n\t                    } else {\n\t                        deferred.resolve();\n\t                    }\n\t                    return deferred.promise;\n\t                },\n\t\n\t                /**\n\t                 * Get the list of required modules/services/... for this module\n\t                 * @param module\n\t                 * @returns {Array}\n\t                 */\n\t                getRequires: function getRequires(module) {\n\t                    var requires = [];\n\t                    angular.forEach(module.requires, function (requireModule) {\n\t                        if (regModules.indexOf(requireModule) === -1) {\n\t                            requires.push(requireModule);\n\t                        }\n\t                    });\n\t                    return requires;\n\t                },\n\t\n\t                /**\n\t                 * Invoke the new modules & component by their providers\n\t                 * @param providers\n\t                 * @param queue\n\t                 * @param moduleName\n\t                 * @param reconfig\n\t                 * @private\n\t                 */\n\t                _invokeQueue: _invokeQueue,\n\t\n\t                /**\n\t                 * Check if a module has been invoked and registers it if not\n\t                 * @param args\n\t                 * @param moduleName\n\t                 * @returns {boolean} is new\n\t                 */\n\t                _registerInvokeList: _registerInvokeList,\n\t\n\t                /**\n\t                 * Register a new module and loads it, executing the run/config blocks if needed\n\t                 * @param providers\n\t                 * @param registerModules\n\t                 * @param params\n\t                 * @private\n\t                 */\n\t                _register: _register,\n\t\n\t                /**\n\t                 * Add a module name to the list of modules that will be loaded in the next inject\n\t                 * @param name\n\t                 * @param force\n\t                 * @private\n\t                 */\n\t                _addToLoadList: _addToLoadList,\n\t\n\t                /**\n\t                 * Unregister modules (you shouldn't have to use this)\n\t                 * @param modules\n\t                 */\n\t                _unregister: function _unregister(modules) {\n\t                    if (angular.isDefined(modules)) {\n\t                        if (angular.isArray(modules)) {\n\t                            angular.forEach(modules, function (module) {\n\t                                regInvokes[module] = undefined;\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            };\n\t        }];\n\t\n\t        // Let's get the list of loaded modules & components\n\t        this._init(angular.element(window.document));\n\t    }]);\n\t\n\t    var bootstrapFct = angular.bootstrap;\n\t    angular.bootstrap = function (element, modules, config) {\n\t        // we use slice to make a clean copy\n\t        angular.forEach(modules.slice(), function (module) {\n\t            _addToLoadList(module, true, true);\n\t        });\n\t        return bootstrapFct(element, modules, config);\n\t    };\n\t\n\t    var _addToLoadList = function _addToLoadList(name, force, real) {\n\t        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n\t            modulesToLoad.push(name);\n\t            if (real) {\n\t                realModules.push(name);\n\t            }\n\t        }\n\t    };\n\t\n\t    var ngModuleFct = angular.module;\n\t    angular.module = function (name, requires, configFn) {\n\t        _addToLoadList(name, false, true);\n\t        return ngModuleFct(name, requires, configFn);\n\t    };\n\t\n\t    // CommonJS package manager support:\n\t    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n\t        module.exports = 'oc.lazyLoad';\n\t    }\n\t})(angular, window);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\n\t        return {\n\t            restrict: 'A',\n\t            terminal: true,\n\t            priority: 1000,\n\t            compile: function compile(element, attrs) {\n\t                // we store the content and remove it before compilation\n\t                var content = element[0].innerHTML;\n\t                element.html('');\n\t\n\t                return function ($scope, $element, $attr) {\n\t                    var model = $parse($attr.ocLazyLoad);\n\t                    $scope.$watch(function () {\n\t                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n\t                    }, function (moduleName) {\n\t                        if (angular.isDefined(moduleName)) {\n\t                            $ocLazyLoad.load(moduleName).then(function () {\n\t                                // Attach element contents to DOM and then compile them.\n\t                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\n\t                                // of the compiled contents when attaching to the parent DOM.\n\t                                $animate.enter(content, $element);\n\t                                // get the new content & compile it\n\t                                $compile($element.contents())($scope);\n\t                            });\n\t                        }\n\t                    }, true);\n\t                };\n\t            }\n\t        };\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n\t            var uaCssChecked = false,\n\t                useCssLoadPatch = false,\n\t                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\t\n\t            /**\r\n\t             * Load a js/css file\r\n\t             * @param type\r\n\t             * @param path\r\n\t             * @param params\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.buildElement = function buildElement(type, path, params) {\n\t                var deferred = $q.defer(),\n\t                    el,\n\t                    loaded,\n\t                    filesCache = $delegate._getFilesCache(),\n\t                    cacheBuster = function cacheBuster(url) {\n\t                    var dc = new Date().getTime();\n\t                    if (url.indexOf('?') >= 0) {\n\t                        if (url.substring(0, url.length - 1) === '&') {\n\t                            return url + '_dc=' + dc;\n\t                        }\n\t                        return url + '&_dc=' + dc;\n\t                    } else {\n\t                        return url + '?_dc=' + dc;\n\t                    }\n\t                };\n\t\n\t                // Store the promise early so the file load can be detected by other parallel lazy loads\n\t                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n\t                // as it causes false positive load results.\n\t                if (angular.isUndefined(filesCache.get(path))) {\n\t                    filesCache.put(path, deferred.promise);\n\t                }\n\t\n\t                // Switch in case more content types are added later\n\t                switch (type) {\n\t                    case 'css':\n\t                        el = $window.document.createElement('link');\n\t                        el.type = 'text/css';\n\t                        el.rel = 'stylesheet';\n\t                        el.href = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    case 'js':\n\t                        el = $window.document.createElement('script');\n\t                        el.src = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    default:\n\t                        filesCache.remove(path);\n\t                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n\t                        break;\n\t                }\n\t                el.onload = el['onreadystatechange'] = function (e) {\n\t                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n\t                    el.onload = el['onreadystatechange'] = null;\n\t                    loaded = 1;\n\t                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n\t                    deferred.resolve();\n\t                };\n\t                el.onerror = function () {\n\t                    filesCache.remove(path);\n\t                    deferred.reject(new Error('Unable to load ' + path));\n\t                };\n\t                el.async = params.serie ? 0 : 1;\n\t\n\t                var insertBeforeElem = anchor.lastChild;\n\t                if (params.insertBefore) {\n\t                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n\t                    if (element && element.length > 0) {\n\t                        insertBeforeElem = element[0];\n\t                    }\n\t                }\n\t                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\t\n\t                /*\r\n\t                 The event load or readystatechange doesn't fire in:\r\n\t                 - iOS < 6       (default mobile browser)\r\n\t                 - Android < 4.4 (default mobile browser)\r\n\t                 - Safari < 6    (desktop browser)\r\n\t                 */\n\t                if (type == 'css') {\n\t                    if (!uaCssChecked) {\n\t                        var ua = $window.navigator.userAgent.toLowerCase();\n\t\n\t                        // iOS < 6\n\t                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n\t                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n\t                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n\t                            useCssLoadPatch = iOSVersion < 6;\n\t                        } else if (ua.indexOf(\"android\") > -1) {\n\t                            // Android < 4.4\n\t                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n\t                            useCssLoadPatch = androidVersion < 4.4;\n\t                        } else if (ua.indexOf('safari') > -1) {\n\t                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n\t                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n\t                        }\n\t                    }\n\t\n\t                    if (useCssLoadPatch) {\n\t                        var tries = 1000; // * 20 = 20000 miliseconds\n\t                        var interval = $interval(function () {\n\t                            try {\n\t                                el.sheet.cssRules;\n\t                                $interval.cancel(interval);\n\t                                el.onload();\n\t                            } catch (e) {\n\t                                if (--tries <= 0) {\n\t                                    el.onerror();\n\t                                }\n\t                            }\n\t                        }, 20);\n\t                    }\n\t                }\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\r\n\t             * The function that loads new files\r\n\t             * @param config\r\n\t             * @param params\r\n\t             * @returns {*}\r\n\t             */\n\t            $delegate.filesLoader = function filesLoader(config) {\n\t                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var cssFiles = [],\n\t                    templatesFiles = [],\n\t                    jsFiles = [],\n\t                    promises = [],\n\t                    cachePromise = null,\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                $delegate.toggleWatch(true); // start watching angular.module calls\n\t\n\t                angular.extend(params, config);\n\t\n\t                var pushFile = function pushFile(path) {\n\t                    var file_type = null,\n\t                        m;\n\t                    if (angular.isObject(path)) {\n\t                        file_type = path.type;\n\t                        path = path.path;\n\t                    }\n\t                    cachePromise = filesCache.get(path);\n\t                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\t\n\t                        // always check for requirejs syntax just in case\n\t                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n\t                            // Detect file type using preceding type declaration (ala requireJS)\n\t                            file_type = m[1];\n\t                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n\t                        }\n\t\n\t                        if (!file_type) {\n\t                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n\t                                // Detect file type via file extension\n\t                                file_type = m[1];\n\t                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\n\t                                // requirejs\n\t                                file_type = 'js';\n\t                            } else {\n\t                                $delegate._$log.error('File type could not be determined. ' + path);\n\t                                return;\n\t                            }\n\t                        }\n\t\n\t                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n\t                            cssFiles.push(path);\n\t                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n\t                            templatesFiles.push(path);\n\t                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n\t                            jsFiles.push(path);\n\t                        } else {\n\t                            $delegate._$log.error('File type is not valid. ' + path);\n\t                        }\n\t                    } else if (cachePromise) {\n\t                        promises.push(cachePromise);\n\t                    }\n\t                };\n\t\n\t                if (params.serie) {\n\t                    pushFile(params.files.shift());\n\t                } else {\n\t                    angular.forEach(params.files, function (path) {\n\t                        pushFile(path);\n\t                    });\n\t                }\n\t\n\t                if (cssFiles.length > 0) {\n\t                    var cssDeferred = $q.defer();\n\t                    $delegate.cssLoader(cssFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            cssDeferred.reject(err);\n\t                        } else {\n\t                            cssDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(cssDeferred.promise);\n\t                }\n\t\n\t                if (templatesFiles.length > 0) {\n\t                    var templatesDeferred = $q.defer();\n\t                    $delegate.templatesLoader(templatesFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            templatesDeferred.reject(err);\n\t                        } else {\n\t                            templatesDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(templatesDeferred.promise);\n\t                }\n\t\n\t                if (jsFiles.length > 0) {\n\t                    var jsDeferred = $q.defer();\n\t                    $delegate.jsLoader(jsFiles, function (err) {\n\t                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\n\t                            $delegate._$log.error(err);\n\t                            jsDeferred.reject(err);\n\t                        } else {\n\t                            jsDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(jsDeferred.promise);\n\t                }\n\t\n\t                if (promises.length === 0) {\n\t                    var deferred = $q.defer(),\n\t                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n\t                    $delegate._$log.error(err);\n\t                    deferred.reject(err);\n\t                    return deferred.promise;\n\t                } else if (params.serie && params.files.length > 0) {\n\t                    return $q.all(promises).then(function () {\n\t                        return $delegate.filesLoader(config, params);\n\t                    });\n\t                } else {\n\t                    return $q.all(promises)['finally'](function (res) {\n\t                        $delegate.toggleWatch(false); // stop watching angular.module calls\n\t                        return res;\n\t                    });\n\t                }\n\t            };\n\t\n\t            /**\r\n\t             * Load a module or a list of modules into Angular\r\n\t             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n\t             * @param params Object optional parameters\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.load = function (originalModule) {\n\t                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var self = this,\n\t                    config = null,\n\t                    deferredList = [],\n\t                    deferred = $q.defer(),\n\t                    errText;\n\t\n\t                // clean copy\n\t                var module = angular.copy(originalModule);\n\t                var params = angular.copy(originalParams);\n\t\n\t                // If module is an array, break it down\n\t                if (angular.isArray(module)) {\n\t                    // Resubmit each entry as a single module\n\t                    angular.forEach(module, function (m) {\n\t                        deferredList.push(self.load(m, params));\n\t                    });\n\t\n\t                    // Resolve the promise once everything has loaded\n\t                    $q.all(deferredList).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t\n\t                    return deferred.promise;\n\t                }\n\t\n\t                // Get or Set a configuration depending on what was passed in\n\t                if (angular.isString(module)) {\n\t                    config = self.getModuleConfig(module);\n\t                    if (!config) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    }\n\t                } else if (angular.isObject(module)) {\n\t                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n\t                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    } else {\n\t                        config = self.setModuleConfig(module);\n\t                    }\n\t                }\n\t\n\t                if (config === null) {\n\t                    var moduleName = self._getModuleName(module);\n\t                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n\t                    $delegate._$log.error(errText);\n\t                    deferred.reject(new Error(errText));\n\t                    return deferred.promise;\n\t                } else {\n\t                    // deprecated\n\t                    if (angular.isDefined(config.template)) {\n\t                        if (angular.isUndefined(config.files)) {\n\t                            config.files = [];\n\t                        }\n\t                        if (angular.isString(config.template)) {\n\t                            config.files.push(config.template);\n\t                        } else if (angular.isArray(config.template)) {\n\t                            config.files.concat(config.template);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                var localParams = angular.extend({}, params, config);\n\t\n\t                // if someone used an external loader and called the load function with just the module name\n\t                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n\t                    return $delegate.inject(config.name, localParams, true);\n\t                }\n\t\n\t                $delegate.filesLoader(config, localParams).then(function () {\n\t                    $delegate.inject(null, localParams).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t                }, function (err) {\n\t                    deferred.reject(err);\n\t                });\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            // return the patched service\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * cssLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite cssLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.cssLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('css', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.cssLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * jsLoader function\n\t             * @type Function\n\t             * @param paths array list of js files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite jsLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.jsLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('js', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.jsLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n\t            /**\n\t             * templatesLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters for $http\n\t             * because the user can overwrite templatesLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.templatesLoader = function (paths, callback, params) {\n\t                var promises = [],\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                angular.forEach(paths, function (url) {\n\t                    var deferred = $q.defer();\n\t                    promises.push(deferred.promise);\n\t                    $http.get(url, params).success(function (data) {\n\t                        if (angular.isString(data) && data.length > 0) {\n\t                            angular.forEach(angular.element(data), function (node) {\n\t                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n\t                                    $templateCache.put(node.id, node.innerHTML);\n\t                                }\n\t                            });\n\t                        }\n\t                        if (angular.isUndefined(filesCache.get(url))) {\n\t                            filesCache.put(url, true);\n\t                        }\n\t                        deferred.resolve();\n\t                    }).error(function (err) {\n\t                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n\t                    });\n\t                });\n\t                return $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t// Array.indexOf polyfill for IE8\n\tif (!Array.prototype.indexOf) {\n\t    Array.prototype.indexOf = function (searchElement, fromIndex) {\n\t        var k;\n\t\n\t        // 1. Let O be the result of calling ToObject passing\n\t        //    the this value as the argument.\n\t        if (this == null) {\n\t            throw new TypeError('\"this\" is null or not defined');\n\t        }\n\t\n\t        var O = Object(this);\n\t\n\t        // 2. Let lenValue be the result of calling the Get\n\t        //    internal method of O with the argument \"length\".\n\t        // 3. Let len be ToUint32(lenValue).\n\t        var len = O.length >>> 0;\n\t\n\t        // 4. If len is 0, return -1.\n\t        if (len === 0) {\n\t            return -1;\n\t        }\n\t\n\t        // 5. If argument fromIndex was passed let n be\n\t        //    ToInteger(fromIndex); else let n be 0.\n\t        var n = +fromIndex || 0;\n\t\n\t        if (Math.abs(n) === Infinity) {\n\t            n = 0;\n\t        }\n\t\n\t        // 6. If n >= len, return -1.\n\t        if (n >= len) {\n\t            return -1;\n\t        }\n\t\n\t        // 7. If n >= 0, then Let k be n.\n\t        // 8. Else, n<0, Let k be len - abs(n).\n\t        //    If k is less than 0, then let k be 0.\n\t        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\t\n\t        // 9. Repeat, while k < len\n\t        while (k < len) {\n\t            // a. Let Pk be ToString(k).\n\t            //   This is implicit for LHS operands of the in operator\n\t            // b. Let kPresent be the result of calling the\n\t            //    HasProperty internal method of O with argument Pk.\n\t            //   This step can be combined with c\n\t            // c. If kPresent is true, then\n\t            //    i.  Let elementK be the result of calling the Get\n\t            //        internal method of O with the argument ToString(k).\n\t            //   ii.  Let same be the result of applying the\n\t            //        Strict Equality Comparison Algorithm to\n\t            //        searchElement and elementK.\n\t            //  iii.  If same is true, return k.\n\t            if (k in O && O[k] === searchElement) {\n\t                return k;\n\t            }\n\t            k++;\n\t        }\n\t        return -1;\n\t    };\n\t}\n\n/***/ },\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */\n/***/ function(module, exports) {\n\n\t/*\n\t * angular-ui-bootstrap\n\t * http://angular-ui.github.io/bootstrap/\n\t\n\t * Version: 0.14.3 - 2015-10-23\n\t * License: MIT\n\t */\n\tangular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\n\tangular.module(\"ui.bootstrap.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/carousel/carousel.html\",\"template/carousel/slide.html\",\"template/datepicker/datepicker.html\",\"template/datepicker/day.html\",\"template/datepicker/month.html\",\"template/datepicker/popup.html\",\"template/datepicker/year.html\",\"template/modal/backdrop.html\",\"template/modal/window.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/tooltip/tooltip-template-popup.html\",\"template/popover/popover-html.html\",\"template/popover/popover-template.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/progressbar/progressbar.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/timepicker/timepicker.html\",\"template/typeahead/typeahead-match.html\",\"template/typeahead/typeahead-popup.html\"]);\n\tangular.module('ui.bootstrap.collapse', [])\n\t\n\t  .directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {\n\t    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n\t    return {\n\t      link: function(scope, element, attrs) {\n\t        function expand() {\n\t          element.removeClass('collapse')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', true)\n\t            .attr('aria-hidden', false);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              addClass: 'in',\n\t              easing: 'ease',\n\t              to: { height: element[0].scrollHeight + 'px' }\n\t            }).start().finally(expandDone);\n\t          } else {\n\t            $animate.addClass(element, 'in', {\n\t              to: { height: element[0].scrollHeight + 'px' }\n\t            }).then(expandDone);\n\t          }\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse')\n\t            .css({height: 'auto'});\n\t        }\n\t\n\t        function collapse() {\n\t          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n\t            return collapseDone();\n\t          }\n\t\n\t          element\n\t            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n\t            // Otherwise, the browser attempts to animate from height 0 (in\n\t            // collapsing class) to the given height here.\n\t            .css({height: element[0].scrollHeight + 'px'})\n\t            // initially all panel collapse have the collapse class, this removal\n\t            // prevents the animation from jumping to collapsed state\n\t            .removeClass('collapse')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', false)\n\t            .attr('aria-hidden', true);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              removeClass: 'in',\n\t              to: {height: '0'}\n\t            }).start().finally(collapseDone);\n\t          } else {\n\t            $animate.removeClass(element, 'in', {\n\t              to: {height: '0'}\n\t            }).then(collapseDone);\n\t          }\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse');\n\t        }\n\t\n\t        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\t/* Deprecated collapse below */\n\t\n\tangular.module('ui.bootstrap.collapse')\n\t\n\t  .value('$collapseSuppressWarning', false)\n\t\n\t  .directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {\n\t    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n\t    return {\n\t      link: function(scope, element, attrs) {\n\t        if (!$collapseSuppressWarning) {\n\t          $log.warn('collapse is now deprecated. Use uib-collapse instead.');\n\t        }\n\t\n\t        function expand() {\n\t          element.removeClass('collapse')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', true)\n\t            .attr('aria-hidden', false);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              easing: 'ease',\n\t              to: { height: element[0].scrollHeight + 'px' }\n\t            }).start().done(expandDone);\n\t          } else {\n\t            $animate.animate(element, {}, {\n\t              height: element[0].scrollHeight + 'px'\n\t            }).then(expandDone);\n\t          }\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse in')\n\t            .css({height: 'auto'});\n\t        }\n\t\n\t        function collapse() {\n\t          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n\t            return collapseDone();\n\t          }\n\t\n\t          element\n\t            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n\t            // Otherwise, the browser attempts to animate from height 0 (in\n\t            // collapsing class) to the given height here.\n\t            .css({height: element[0].scrollHeight + 'px'})\n\t            // initially all panel collapse have the collapse class, this removal\n\t            // prevents the animation from jumping to collapsed state\n\t            .removeClass('collapse in')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', false)\n\t            .attr('aria-hidden', true);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              to: {height: '0'}\n\t            }).start().done(collapseDone);\n\t          } else {\n\t            $animate.animate(element, {}, {\n\t              height: '0'\n\t            }).then(collapseDone);\n\t          }\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse');\n\t        }\n\t\n\t        scope.$watch(attrs.collapse, function(shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\t\n\t.constant('uibAccordionConfig', {\n\t  closeOthers: true\n\t})\n\t\n\t.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n\t  // This array keeps track of the accordion groups\n\t  this.groups = [];\n\t\n\t  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n\t  this.closeOthers = function(openGroup) {\n\t    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n\t      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n\t    if (closeOthers) {\n\t      angular.forEach(this.groups, function(group) {\n\t        if (group !== openGroup) {\n\t          group.isOpen = false;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  // This is called from the accordion-group directive to add itself to the accordion\n\t  this.addGroup = function(groupScope) {\n\t    var that = this;\n\t    this.groups.push(groupScope);\n\t\n\t    groupScope.$on('$destroy', function(event) {\n\t      that.removeGroup(groupScope);\n\t    });\n\t  };\n\t\n\t  // This is called from the accordion-group directive when to remove itself\n\t  this.removeGroup = function(group) {\n\t    var index = this.groups.indexOf(group);\n\t    if (index !== -1) {\n\t      this.groups.splice(index, 1);\n\t    }\n\t  };\n\t\n\t}])\n\t\n\t// The accordion directive simply sets up the directive controller\n\t// and adds an accordion CSS class to itself element.\n\t.directive('uibAccordion', function() {\n\t  return {\n\t    controller: 'UibAccordionController',\n\t    controllerAs: 'accordion',\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/accordion/accordion.html';\n\t    }\n\t  };\n\t})\n\t\n\t// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n\t.directive('uibAccordionGroup', function() {\n\t  return {\n\t    require: '^uibAccordion',         // We need this directive to be inside an accordion\n\t    transclude: true,              // It transcludes the contents of the directive into the template\n\t    replace: true,                // The element containing the directive will be replaced with the template\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/accordion/accordion-group.html';\n\t    },\n\t    scope: {\n\t      heading: '@',               // Interpolate the heading attribute onto this scope\n\t      isOpen: '=?',\n\t      isDisabled: '=?'\n\t    },\n\t    controller: function() {\n\t      this.setHeading = function(element) {\n\t        this.heading = element;\n\t      };\n\t    },\n\t    link: function(scope, element, attrs, accordionCtrl) {\n\t      accordionCtrl.addGroup(scope);\n\t\n\t      scope.openClass = attrs.openClass || 'panel-open';\n\t      scope.panelClass = attrs.panelClass;\n\t      scope.$watch('isOpen', function(value) {\n\t        element.toggleClass(scope.openClass, !!value);\n\t        if (value) {\n\t          accordionCtrl.closeOthers(scope);\n\t        }\n\t      });\n\t\n\t      scope.toggleOpen = function($event) {\n\t        if (!scope.isDisabled) {\n\t          if (!$event || $event.which === 32) {\n\t            scope.isOpen = !scope.isOpen;\n\t          }\n\t        }\n\t      };\n\t    }\n\t  };\n\t})\n\t\n\t// Use accordion-heading below an accordion-group to provide a heading containing HTML\n\t.directive('uibAccordionHeading', function() {\n\t  return {\n\t    transclude: true,   // Grab the contents to be used as the heading\n\t    template: '',       // In effect remove this element!\n\t    replace: true,\n\t    require: '^uibAccordionGroup',\n\t    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n\t      // Pass the heading to the accordion-group controller\n\t      // so that it can be transcluded into the right place in the template\n\t      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n\t    }\n\t  };\n\t})\n\t\n\t// Use in the accordion-group template to indicate where you want the heading to be transcluded\n\t// You must provide the property on the accordion-group controller that will hold the transcluded element\n\t.directive('uibAccordionTransclude', function() {\n\t  return {\n\t    require: ['?^uibAccordionGroup', '?^accordionGroup'],\n\t    link: function(scope, element, attrs, controller) {\n\t      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation\n\t      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n\t        if (heading) {\n\t          element.find('span').html('');\n\t          element.find('span').append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated accordion below */\n\t\n\tangular.module('ui.bootstrap.accordion')\n\t\n\t  .value('$accordionSuppressWarning', false)\n\t\n\t  .controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {\n\t    if (!$accordionSuppressWarning) {\n\t      $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibAccordionController', {\n\t      $scope: $scope,\n\t      $attrs: $attrs\n\t    }));\n\t  }])\n\t\n\t  .directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      restrict: 'EA',\n\t      controller: 'AccordionController',\n\t      controllerAs: 'accordion',\n\t      transclude: true,\n\t      replace: false,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.templateUrl || 'template/accordion/accordion.html';\n\t      },\n\t      link: function() {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion is now deprecated. Use uib-accordion instead.');\n\t        }\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      require: '^accordion',         // We need this directive to be inside an accordion\n\t      restrict: 'EA',\n\t      transclude: true,              // It transcludes the contents of the directive into the template\n\t      replace: true,                // The element containing the directive will be replaced with the template\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.templateUrl || 'template/accordion/accordion-group.html';\n\t      },\n\t      scope: {\n\t        heading: '@',               // Interpolate the heading attribute onto this scope\n\t        isOpen: '=?',\n\t        isDisabled: '=?'\n\t      },\n\t      controller: function() {\n\t        this.setHeading = function(element) {\n\t          this.heading = element;\n\t        };\n\t      },\n\t      link: function(scope, element, attrs, accordionCtrl) {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');\n\t        }\n\t\n\t        accordionCtrl.addGroup(scope);\n\t\n\t        scope.openClass = attrs.openClass || 'panel-open';\n\t        scope.panelClass = attrs.panelClass;\n\t        scope.$watch('isOpen', function(value) {\n\t          element.toggleClass(scope.openClass, !!value);\n\t          if (value) {\n\t            accordionCtrl.closeOthers(scope);\n\t          }\n\t        });\n\t\n\t        scope.toggleOpen = function($event) {\n\t          if (!scope.isDisabled) {\n\t            if (!$event || $event.which === 32) {\n\t              scope.isOpen = !scope.isOpen;\n\t            }\n\t          }\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      restrict: 'EA',\n\t      transclude: true,   // Grab the contents to be used as the heading\n\t      template: '',       // In effect remove this element!\n\t      replace: true,\n\t      require: '^accordionGroup',\n\t      link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');\n\t        }\n\t        // Pass the heading to the accordion-group controller\n\t        // so that it can be transcluded into the right place in the template\n\t        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      require: '^accordionGroup',\n\t      link: function(scope, element, attr, controller) {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');\n\t        }\n\t\n\t        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n\t          if (heading) {\n\t            element.find('span').html('');\n\t            element.find('span').append(heading);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\t\n\tangular.module('ui.bootstrap.alert', [])\n\t\n\t.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n\t  $scope.closeable = !!$attrs.close;\n\t\n\t  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n\t    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\t\n\t  if (dismissOnTimeout) {\n\t    $timeout(function() {\n\t      $scope.close();\n\t    }, parseInt(dismissOnTimeout, 10));\n\t  }\n\t}])\n\t\n\t.directive('uibAlert', function() {\n\t  return {\n\t    controller: 'UibAlertController',\n\t    controllerAs: 'alert',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/alert/alert.html';\n\t    },\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@',\n\t      close: '&'\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated alert below */\n\t\n\tangular.module('ui.bootstrap.alert')\n\t\n\t  .value('$alertSuppressWarning', false)\n\t\n\t  .controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {\n\t    if (!$alertSuppressWarning) {\n\t      $log.warn('AlertController is now deprecated. Use UibAlertController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibAlertController', {\n\t      $scope: $scope,\n\t      $attrs: $attrs\n\t    }));\n\t  }])\n\t\n\t  .directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {\n\t    return {\n\t      controller: 'AlertController',\n\t      controllerAs: 'alert',\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.templateUrl || 'template/alert/alert.html';\n\t      },\n\t      transclude: true,\n\t      replace: true,\n\t      scope: {\n\t        type: '@',\n\t        close: '&'\n\t      },\n\t      link: function() {\n\t        if (!$alertSuppressWarning) {\n\t          $log.warn('alert is now deprecated. Use uib-alert instead.');\n\t        }\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.buttons', [])\n\t\n\t.constant('uibButtonConfig', {\n\t  activeClass: 'active',\n\t  toggleEvent: 'click'\n\t})\n\t\n\t.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n\t  this.activeClass = buttonConfig.activeClass || 'active';\n\t  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n\t}])\n\t\n\t.directive('uibBtnRadio', function() {\n\t  return {\n\t    require: ['uibBtnRadio', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'buttons',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n\t            ngModelCtrl.$render();\n\t          });\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibBtnCheckbox', function() {\n\t  return {\n\t    require: ['uibBtnCheckbox', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'button',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      function getTrueValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t      }\n\t\n\t      function getFalseValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t      }\n\t\n\t      function getCheckboxValue(attribute, defaultValue) {\n\t        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n\t      }\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        scope.$apply(function() {\n\t          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t          ngModelCtrl.$render();\n\t        });\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated buttons below */\n\t\n\tangular.module('ui.bootstrap.buttons')\n\t\n\t  .value('$buttonsSuppressWarning', false)\n\t\n\t  .controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {\n\t    if (!$buttonsSuppressWarning) {\n\t      $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibButtonsController'));\n\t  }])\n\t\n\t  .directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {\n\t    return {\n\t      require: ['btnRadio', 'ngModel'],\n\t      controller: 'ButtonsController',\n\t      controllerAs: 'buttons',\n\t      link: function(scope, element, attrs, ctrls) {\n\t        if (!$buttonsSuppressWarning) {\n\t          $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');\n\t        }\n\t\n\t        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t        element.find('input').css({display: 'none'});\n\t\n\t        //model -> UI\n\t        ngModelCtrl.$render = function() {\n\t          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n\t        };\n\t\n\t        //ui->model\n\t        element.bind(buttonsCtrl.toggleEvent, function() {\n\t          if (attrs.disabled) {\n\t            return;\n\t          }\n\t\n\t          var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t          if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t            scope.$apply(function() {\n\t              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n\t              ngModelCtrl.$render();\n\t            });\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {\n\t    return {\n\t      require: ['btnCheckbox', 'ngModel'],\n\t      controller: 'ButtonsController',\n\t      controllerAs: 'button',\n\t      link: function(scope, element, attrs, ctrls) {\n\t        if (!$buttonsSuppressWarning) {\n\t          $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');\n\t        }\n\t\n\t        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t        element.find('input').css({display: 'none'});\n\t\n\t        function getTrueValue() {\n\t          return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t        }\n\t\n\t        function getFalseValue() {\n\t          return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t        }\n\t\n\t        function getCheckboxValue(attributeValue, defaultValue) {\n\t          var val = scope.$eval(attributeValue);\n\t          return angular.isDefined(val) ? val : defaultValue;\n\t        }\n\t\n\t        //model -> UI\n\t        ngModelCtrl.$render = function() {\n\t          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t        };\n\t\n\t        //ui->model\n\t        element.bind(buttonsCtrl.toggleEvent, function() {\n\t          if (attrs.disabled) {\n\t            return;\n\t          }\n\t\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t            ngModelCtrl.$render();\n\t          });\n\t        });\n\t\n\t        //accessibility\n\t        element.on('keypress', function(e) {\n\t          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {\n\t            return;\n\t          }\n\t\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t            ngModelCtrl.$render();\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.bootstrap.carousel\n\t *\n\t * @description\n\t * AngularJS version of an image carousel.\n\t *\n\t */\n\tangular.module('ui.bootstrap.carousel', [])\n\t\n\t.controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {\n\t  var self = this,\n\t    slides = self.slides = $scope.slides = [],\n\t    NEW_ANIMATE = angular.version.minor >= 4,\n\t    NO_TRANSITION = 'uib-noTransition',\n\t    SLIDE_DIRECTION = 'uib-slideDirection',\n\t    currentIndex = -1,\n\t    currentInterval, isPlaying;\n\t  self.currentSlide = null;\n\t\n\t  var destroyed = false;\n\t  /* direction: \"prev\" or \"next\" */\n\t  self.select = $scope.select = function(nextSlide, direction) {\n\t    var nextIndex = $scope.indexOfSlide(nextSlide);\n\t    //Decide direction if it's not given\n\t    if (direction === undefined) {\n\t      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n\t    }\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {\n\t      goNext(nextSlide, nextIndex, direction);\n\t    }\n\t  };\n\t\n\t  function goNext(slide, index, direction) {\n\t    // Scope has been destroyed, stop here.\n\t    if (destroyed) { return; }\n\t\n\t    angular.extend(slide, {direction: direction, active: true});\n\t    angular.extend(self.currentSlide || {}, {direction: direction, active: false});\n\t    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&\n\t      slide.$element && self.slides.length > 1) {\n\t      slide.$element.data(SLIDE_DIRECTION, slide.direction);\n\t      if (self.currentSlide && self.currentSlide.$element) {\n\t        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);\n\t      }\n\t\n\t      $scope.$currentTransition = true;\n\t      if (NEW_ANIMATE) {\n\t        $animate.on('addClass', slide.$element, function(element, phase) {\n\t          if (phase === 'close') {\n\t            $scope.$currentTransition = null;\n\t            $animate.off('addClass', element);\n\t          }\n\t        });\n\t      } else {\n\t        slide.$element.one('$animate:close', function closeFn() {\n\t          $scope.$currentTransition = null;\n\t        });\n\t      }\n\t    }\n\t\n\t    self.currentSlide = slide;\n\t    currentIndex = index;\n\t\n\t    //every time you change slides, reset the timer\n\t    restartTimer();\n\t  }\n\t\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t  });\n\t\n\t  function getSlideByIndex(index) {\n\t    if (angular.isUndefined(slides[index].index)) {\n\t      return slides[index];\n\t    }\n\t    var i, len = slides.length;\n\t    for (i = 0; i < slides.length; ++i) {\n\t      if (slides[i].index == index) {\n\t        return slides[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  self.getCurrentIndex = function() {\n\t    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {\n\t      return +self.currentSlide.index;\n\t    }\n\t    return currentIndex;\n\t  };\n\t\n\t  /* Allow outside people to call indexOf on slides array */\n\t  $scope.indexOfSlide = function(slide) {\n\t    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);\n\t  };\n\t\n\t  $scope.next = function() {\n\t    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\t\n\t    if (newIndex === 0 && $scope.noWrap()) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(getSlideByIndex(newIndex), 'next');\n\t  };\n\t\n\t  $scope.prev = function() {\n\t    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\t\n\t    if ($scope.noWrap() && newIndex === slides.length - 1) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(getSlideByIndex(newIndex), 'prev');\n\t  };\n\t\n\t  $scope.isActive = function(slide) {\n\t     return self.currentSlide === slide;\n\t  };\n\t\n\t  $scope.$watch('interval', restartTimer);\n\t  $scope.$watchCollection('slides', resetTransition);\n\t  $scope.$on('$destroy', resetTimer);\n\t\n\t  function restartTimer() {\n\t    resetTimer();\n\t    var interval = +$scope.interval;\n\t    if (!isNaN(interval) && interval > 0) {\n\t      currentInterval = $interval(timerFn, interval);\n\t    }\n\t  }\n\t\n\t  function resetTimer() {\n\t    if (currentInterval) {\n\t      $interval.cancel(currentInterval);\n\t      currentInterval = null;\n\t    }\n\t  }\n\t\n\t  function timerFn() {\n\t    var interval = +$scope.interval;\n\t    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n\t      $scope.next();\n\t    } else {\n\t      $scope.pause();\n\t    }\n\t  }\n\t\n\t  function resetTransition(slides) {\n\t    if (!slides.length) {\n\t      $scope.$currentTransition = null;\n\t    }\n\t  }\n\t\n\t  $scope.play = function() {\n\t    if (!isPlaying) {\n\t      isPlaying = true;\n\t      restartTimer();\n\t    }\n\t  };\n\t  $scope.pause = function() {\n\t    if (!$scope.noPause) {\n\t      isPlaying = false;\n\t      resetTimer();\n\t    }\n\t  };\n\t\n\t  self.addSlide = function(slide, element) {\n\t    slide.$element = element;\n\t    slides.push(slide);\n\t    //if this is the first slide or the slide is set to active, select it\n\t    if (slides.length === 1 || slide.active) {\n\t      self.select(slides[slides.length - 1]);\n\t      if (slides.length === 1) {\n\t        $scope.play();\n\t      }\n\t    } else {\n\t      slide.active = false;\n\t    }\n\t  };\n\t\n\t  self.removeSlide = function(slide) {\n\t    if (angular.isDefined(slide.index)) {\n\t      slides.sort(function(a, b) {\n\t        return +a.index > +b.index;\n\t      });\n\t    }\n\t    //get the index of the slide inside the carousel\n\t    var index = slides.indexOf(slide);\n\t    slides.splice(index, 1);\n\t    if (slides.length > 0 && slide.active) {\n\t      if (index >= slides.length) {\n\t        self.select(slides[index - 1]);\n\t      } else {\n\t        self.select(slides[index]);\n\t      }\n\t    } else if (currentIndex > index) {\n\t      currentIndex--;\n\t    }\n\t\n\t    //clean the currentSlide when no more slide\n\t    if (slides.length === 0) {\n\t      self.currentSlide = null;\n\t    }\n\t  };\n\t\n\t  $scope.$watch('noTransition', function(noTransition) {\n\t    $element.data(NO_TRANSITION, noTransition);\n\t  });\n\t\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:carousel\n\t * @restrict EA\n\t *\n\t * @description\n\t * Carousel is the outer container for a set of image 'slides' to showcase.\n\t *\n\t * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n\t * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n\t * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <uib-carousel>\n\t      <uib-slide>\n\t        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>Beautiful!</p>\n\t        </div>\n\t      </uib-slide>\n\t      <uib-slide>\n\t        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>D'aww!</p>\n\t        </div>\n\t      </uib-slide>\n\t    </uib-carousel>\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t */\n\t.directive('uibCarousel', [function() {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'UibCarouselController',\n\t    controllerAs: 'carousel',\n\t    require: 'carousel',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/carousel.html';\n\t    },\n\t    scope: {\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '=',\n\t      noWrap: '&'\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:slide\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n\t *\n\t * @param {boolean=} active Model binding, whether or not this slide is currently active.\n\t * @param {number=} index The index of the slide. The slides will be sorted by this parameter.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t<div ng-controller=\"CarouselDemoCtrl\">\n\t  <uib-carousel>\n\t    <uib-slide ng-repeat=\"slide in slides\" active=\"slide.active\" index=\"$index\">\n\t      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n\t      <div class=\"carousel-caption\">\n\t        <h4>Slide {{$index}}</h4>\n\t        <p>{{slide.text}}</p>\n\t      </div>\n\t    </uib-slide>\n\t  </uib-carousel>\n\t  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n\t  <br />Enter a negative number to stop the interval.\n\t</div>\n\t  </file>\n\t  <file name=\"script.js\">\n\tfunction CarouselDemoCtrl($scope) {\n\t  $scope.myInterval = 5000;\n\t}\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t*/\n\t\n\t.directive('uibSlide', function() {\n\t  return {\n\t    require: '^uibCarousel',\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/slide.html';\n\t    },\n\t    scope: {\n\t      active: '=?',\n\t      actual: '=?',\n\t      index: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          carouselCtrl.select(scope);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.animation('.item', [\n\t         '$injector', '$animate',\n\tfunction ($injector, $animate) {\n\t  var NO_TRANSITION = 'uib-noTransition',\n\t    SLIDE_DIRECTION = 'uib-slideDirection',\n\t    $animateCss = null;\n\t\n\t  if ($injector.has('$animateCss')) {\n\t    $animateCss = $injector.get('$animateCss');\n\t  }\n\t\n\t  function removeClass(element, className, callback) {\n\t    element.removeClass(className);\n\t    if (callback) {\n\t      callback();\n\t    }\n\t  }\n\t\n\t  return {\n\t    beforeAddClass: function(element, className, done) {\n\t      // Due to transclusion, noTransition property is on parent's scope\n\t      if (className == 'active' && element.parent() && element.parent().parent() &&\n\t          !element.parent().parent().data(NO_TRANSITION)) {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction == 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element,\n\t          directionClass + ' ' + direction, done);\n\t        element.addClass(direction);\n\t\n\t        if ($animateCss) {\n\t          $animateCss(element, {addClass: directionClass})\n\t            .start()\n\t            .done(removeClassFn);\n\t        } else {\n\t          $animate.addClass(element, directionClass).then(function () {\n\t            if (!stopped) {\n\t              removeClassFn();\n\t            }\n\t            done();\n\t          });\n\t        }\n\t\n\t        return function () {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    },\n\t    beforeRemoveClass: function (element, className, done) {\n\t      // Due to transclusion, noTransition property is on parent's scope\n\t      if (className === 'active' && element.parent() && element.parent().parent() &&\n\t          !element.parent().parent().data(NO_TRANSITION)) {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction == 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\t\n\t        if ($animateCss) {\n\t          $animateCss(element, {addClass: directionClass})\n\t            .start()\n\t            .done(removeClassFn);\n\t        } else {\n\t          $animate.addClass(element, directionClass).then(function() {\n\t            if (!stopped) {\n\t              removeClassFn();\n\t            }\n\t            done();\n\t          });\n\t        }\n\t        return function() {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    }\n\t  };\n\t}]);\n\t\n\t/* deprecated carousel below */\n\t\n\tangular.module('ui.bootstrap.carousel')\n\t\n\t.value('$carouselSuppressWarning', false)\n\t\n\t.controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {\n\t  if (!$carouselSuppressWarning) {\n\t    $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');\n\t  }\n\t\n\t  angular.extend(this, $controller('UibCarouselController', {\n\t    $scope: $scope,\n\t    $element: $element\n\t  }));\n\t}])\n\t\n\t.directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'CarouselController',\n\t    controllerAs: 'carousel',\n\t    require: 'carousel',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/carousel.html';\n\t    },\n\t    scope: {\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '=',\n\t      noWrap: '&'\n\t    },\n\t    link: function() {\n\t      if (!$carouselSuppressWarning) {\n\t        $log.warn('carousel is now deprecated. Use uib-carousel instead.');\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n\t  return {\n\t    require: '^carousel',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/slide.html';\n\t    },\n\t    scope: {\n\t      active: '=?',\n\t      actual: '=?',\n\t      index: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      if (!$carouselSuppressWarning) {\n\t        $log.warn('slide is now deprecated. Use uib-slide instead.');\n\t      }\n\t\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          carouselCtrl.select(scope);\n\t        }\n\t      });\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.dateparser', [])\n\t\n\t.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {\n\t  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n\t  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\t\n\t  var localeId;\n\t  var formatCodeToRegex;\n\t\n\t  this.init = function() {\n\t    localeId = $locale.id;\n\t\n\t    this.parsers = {};\n\t\n\t    formatCodeToRegex = {\n\t      'yyyy': {\n\t        regex: '\\\\d{4}',\n\t        apply: function(value) { this.year = +value; }\n\t      },\n\t      'yy': {\n\t        regex: '\\\\d{2}',\n\t        apply: function(value) { this.year = +value + 2000; }\n\t      },\n\t      'y': {\n\t        regex: '\\\\d{1,4}',\n\t        apply: function(value) { this.year = +value; }\n\t      },\n\t      'MMMM': {\n\t        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n\t      },\n\t      'MMM': {\n\t        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n\t      },\n\t      'MM': {\n\t        regex: '0[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; }\n\t      },\n\t      'M': {\n\t        regex: '[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; }\n\t      },\n\t      'dd': {\n\t        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; }\n\t      },\n\t      'd': {\n\t        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; }\n\t      },\n\t      'EEEE': {\n\t        regex: $locale.DATETIME_FORMATS.DAY.join('|')\n\t      },\n\t      'EEE': {\n\t        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n\t      },\n\t      'HH': {\n\t        regex: '(?:0|1)[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'hh': {\n\t        regex: '0[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'H': {\n\t        regex: '1?[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'h': {\n\t        regex: '[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'mm': {\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; }\n\t      },\n\t      'm': {\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; }\n\t      },\n\t      'sss': {\n\t        regex: '[0-9][0-9][0-9]',\n\t        apply: function(value) { this.milliseconds = +value; }\n\t      },\n\t      'ss': {\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; }\n\t      },\n\t      's': {\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; }\n\t      },\n\t      'a': {\n\t        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n\t        apply: function(value) {\n\t          if (this.hours === 12) {\n\t            this.hours = 0;\n\t          }\n\t\n\t          if (value === 'PM') {\n\t            this.hours += 12;\n\t          }\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  this.init();\n\t\n\t  function createParser(format) {\n\t    var map = [], regex = format.split('');\n\t\n\t    angular.forEach(formatCodeToRegex, function(data, code) {\n\t      var index = format.indexOf(code);\n\t\n\t      if (index > -1) {\n\t        format = format.split('');\n\t\n\t        regex[index] = '(' + data.regex + ')';\n\t        format[index] = '$'; // Custom symbol to define consumed part of format\n\t        for (var i = index + 1, n = index + code.length; i < n; i++) {\n\t          regex[i] = '';\n\t          format[i] = '$';\n\t        }\n\t        format = format.join('');\n\t\n\t        map.push({ index: index, apply: data.apply });\n\t      }\n\t    });\n\t\n\t    return {\n\t      regex: new RegExp('^' + regex.join('') + '$'),\n\t      map: orderByFilter(map, 'index')\n\t    };\n\t  }\n\t\n\t  this.parse = function(input, format, baseDate) {\n\t    if (!angular.isString(input) || !format) {\n\t      return input;\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\t\n\t    if ($locale.id !== localeId) {\n\t      this.init();\n\t    }\n\t\n\t    if (!this.parsers[format]) {\n\t      this.parsers[format] = createParser(format);\n\t    }\n\t\n\t    var parser = this.parsers[format],\n\t        regex = parser.regex,\n\t        map = parser.map,\n\t        results = input.match(regex);\n\t\n\t    if (results && results.length) {\n\t      var fields, dt;\n\t      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n\t        fields = {\n\t          year: baseDate.getFullYear(),\n\t          month: baseDate.getMonth(),\n\t          date: baseDate.getDate(),\n\t          hours: baseDate.getHours(),\n\t          minutes: baseDate.getMinutes(),\n\t          seconds: baseDate.getSeconds(),\n\t          milliseconds: baseDate.getMilliseconds()\n\t        };\n\t      } else {\n\t        if (baseDate) {\n\t          $log.warn('dateparser:', 'baseDate is not a valid date');\n\t        }\n\t        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n\t      }\n\t\n\t      for (var i = 1, n = results.length; i < n; i++) {\n\t        var mapper = map[i-1];\n\t        if (mapper.apply) {\n\t          mapper.apply.call(fields, results[i]);\n\t        }\n\t      }\n\t\n\t      if (isValid(fields.year, fields.month, fields.date)) {\n\t        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n\t          dt = new Date(baseDate);\n\t          dt.setFullYear(fields.year, fields.month, fields.date,\n\t            fields.hours, fields.minutes, fields.seconds,\n\t            fields.milliseconds || 0);\n\t        } else {\n\t          dt = new Date(fields.year, fields.month, fields.date,\n\t            fields.hours, fields.minutes, fields.seconds,\n\t            fields.milliseconds || 0);\n\t        }\n\t      }\n\t\n\t      return dt;\n\t    }\n\t  };\n\t\n\t  // Check if date is valid for specific month (and year for February).\n\t  // Month: 0 = Jan, 1 = Feb, etc\n\t  function isValid(year, month, date) {\n\t    if (date < 1) {\n\t      return false;\n\t    }\n\t\n\t    if (month === 1 && date > 28) {\n\t      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n\t    }\n\t\n\t    if (month === 3 || month === 5 || month === 8 || month === 10) {\n\t      return date < 31;\n\t    }\n\t\n\t    return true;\n\t  }\n\t}]);\n\t\n\t/* Deprecated dateparser below */\n\t\n\tangular.module('ui.bootstrap.dateparser')\n\t\n\t.value('$dateParserSuppressWarning', false)\n\t\n\t.service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {\n\t  if (!$dateParserSuppressWarning) {\n\t    $log.warn('dateParser is now deprecated. Use uibDateParser instead.');\n\t  }\n\t\n\t  angular.extend(this, uibDateParser);\n\t}]);\n\t\n\tangular.module('ui.bootstrap.position', [])\n\t\n\t/**\n\t * A set of utility methods that can be use to retrieve position of DOM elements.\n\t * It is meant to be used where we need to absolute-position DOM elements in\n\t * relation to other, existing elements (this is the case for tooltips, popovers,\n\t * typeahead suggestions etc.).\n\t */\n\t  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n\t    function getStyle(el, cssprop) {\n\t      if (el.currentStyle) { //IE\n\t        return el.currentStyle[cssprop];\n\t      } else if ($window.getComputedStyle) {\n\t        return $window.getComputedStyle(el)[cssprop];\n\t      }\n\t      // finally try and get inline style\n\t      return el.style[cssprop];\n\t    }\n\t\n\t    /**\n\t     * Checks if a given element is statically positioned\n\t     * @param element - raw DOM element\n\t     */\n\t    function isStaticPositioned(element) {\n\t      return (getStyle(element, 'position') || 'static' ) === 'static';\n\t    }\n\t\n\t    /**\n\t     * returns the closest, non-statically positioned parentOffset of a given element\n\t     * @param element\n\t     */\n\t    var parentOffsetEl = function(element) {\n\t      var docDomEl = $document[0];\n\t      var offsetParent = element.offsetParent || docDomEl;\n\t      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n\t        offsetParent = offsetParent.offsetParent;\n\t      }\n\t      return offsetParent || docDomEl;\n\t    };\n\t\n\t    return {\n\t      /**\n\t       * Provides read-only equivalent of jQuery's position function:\n\t       * http://api.jquery.com/position/\n\t       */\n\t      position: function(element) {\n\t        var elBCR = this.offset(element);\n\t        var offsetParentBCR = { top: 0, left: 0 };\n\t        var offsetParentEl = parentOffsetEl(element[0]);\n\t        if (offsetParentEl != $document[0]) {\n\t          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n\t          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n\t          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n\t        }\n\t\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: elBCR.top - offsetParentBCR.top,\n\t          left: elBCR.left - offsetParentBCR.left\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's offset function:\n\t       * http://api.jquery.com/offset/\n\t       */\n\t      offset: function(element) {\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n\t          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides coordinates for the targetEl in relation to hostEl\n\t       */\n\t      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {\n\t        var positionStrParts = positionStr.split('-');\n\t        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\t\n\t        var hostElPos,\n\t          targetElWidth,\n\t          targetElHeight,\n\t          targetElPos;\n\t\n\t        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\t\n\t        targetElWidth = targetEl.prop('offsetWidth');\n\t        targetElHeight = targetEl.prop('offsetHeight');\n\t\n\t        var shiftWidth = {\n\t          center: function() {\n\t            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n\t          },\n\t          left: function() {\n\t            return hostElPos.left;\n\t          },\n\t          right: function() {\n\t            return hostElPos.left + hostElPos.width;\n\t          }\n\t        };\n\t\n\t        var shiftHeight = {\n\t          center: function() {\n\t            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n\t          },\n\t          top: function() {\n\t            return hostElPos.top;\n\t          },\n\t          bottom: function() {\n\t            return hostElPos.top + hostElPos.height;\n\t          }\n\t        };\n\t\n\t        switch (pos0) {\n\t          case 'right':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: shiftWidth[pos0]()\n\t            };\n\t            break;\n\t          case 'left':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: hostElPos.left - targetElWidth\n\t            };\n\t            break;\n\t          case 'bottom':\n\t            targetElPos = {\n\t              top: shiftHeight[pos0](),\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t          default:\n\t            targetElPos = {\n\t              top: hostElPos.top - targetElHeight,\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t        }\n\t\n\t        return targetElPos;\n\t      }\n\t    };\n\t  }]);\n\t\n\t/* Deprecated position below */\n\t\n\tangular.module('ui.bootstrap.position')\n\t\n\t.value('$positionSuppressWarning', false)\n\t\n\t.service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {\n\t  if (!$positionSuppressWarning) {\n\t    $log.warn('$position is now deprecated. Use $uibPosition instead.');\n\t  }\n\t\n\t  angular.extend(this, $uibPosition);\n\t}]);\n\t\n\tangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\t\n\t.value('$datepickerSuppressError', false)\n\t\n\t.constant('uibDatepickerConfig', {\n\t  formatDay: 'dd',\n\t  formatMonth: 'MMMM',\n\t  formatYear: 'yyyy',\n\t  formatDayHeader: 'EEE',\n\t  formatDayTitle: 'MMMM yyyy',\n\t  formatMonthTitle: 'yyyy',\n\t  datepickerMode: 'day',\n\t  minMode: 'day',\n\t  maxMode: 'year',\n\t  showWeeks: true,\n\t  startingDay: 0,\n\t  yearRange: 20,\n\t  minDate: null,\n\t  maxDate: null,\n\t  shortcutPropagation: false\n\t})\n\t\n\t.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\t\n\t  // Modes chain\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  // Configuration attributes\n\t  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n\t                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n\t    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n\t  });\n\t\n\t  // Watchable date attributes\n\t  angular.forEach(['minDate', 'maxDate'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = value ? new Date(value) : null;\n\t        self.refreshView();\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n\t    }\n\t  });\n\t\n\t  angular.forEach(['minMode', 'maxMode'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = angular.isDefined(value) ? value : $attrs[key];\n\t        $scope[key] = self[key];\n\t        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n\t          $scope.datepickerMode = self[key];\n\t        }\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] || null;\n\t      $scope[key] = self[key];\n\t    }\n\t  });\n\t\n\t  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t\n\t  if (angular.isDefined($attrs.initDate)) {\n\t    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n\t    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n\t      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t        self.activeDate = initDate;\n\t        self.refreshView();\n\t      }\n\t    });\n\t  } else {\n\t    this.activeDate = new Date();\n\t  }\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if (ngModelCtrl.$viewValue) {\n\t      var date = new Date(ngModelCtrl.$viewValue),\n\t          isValid = !isNaN(date);\n\t\n\t      if (isValid) {\n\t        this.activeDate = date;\n\t      } else if (!$datepickerSuppressError) {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t      }\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if (this.element) {\n\t      this._refreshView();\n\t\n\t      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t    return {\n\t      date: date,\n\t      label: dateFilter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0,\n\t      customClass: this.customClass(date)\n\t    };\n\t  };\n\t\n\t  this.isDisabled = function(date) {\n\t    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n\t  };\n\t\n\t  this.customClass = function(date) {\n\t    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  $scope.select = function(date) {\n\t    if ($scope.datepickerMode === self.minMode) {\n\t      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n\t      ngModelCtrl.$setViewValue(dt);\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n\t    }\n\t  };\n\t\n\t  $scope.move = function(direction) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function(direction) {\n\t    direction = direction || 1;\n\t\n\t    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n\t      return;\n\t    }\n\t\n\t    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\t\n\t  var focusElement = function() {\n\t    self.element[0].focus();\n\t  };\n\t\n\t  // Listen for focus requests from popup directive\n\t  $scope.$on('uib:datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function(evt) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if (!key || evt.shiftKey || evt.altKey) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    if (!self.shortcutPropagation) {\n\t      evt.stopPropagation();\n\t    }\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if (self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\t\n\t  this.step = { months: 1 };\n\t  this.element = $element;\n\t  function getDaysInMonth(year, month) {\n\t    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n\t  }\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    scope.showWeeks = ctrl.showWeeks;\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this.getDates = function(startDate, n) {\n\t    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n\t    while (i < n) {\n\t      date = new Date(current);\n\t      dates[i++] = date;\n\t      current.setDate(current.getDate() + 1);\n\t    }\n\t    return dates;\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var year = this.activeDate.getFullYear(),\n\t      month = this.activeDate.getMonth(),\n\t      firstDayOfMonth = new Date(this.activeDate);\n\t\n\t    firstDayOfMonth.setFullYear(year, month, 1);\n\t\n\t    var difference = this.startingDay - firstDayOfMonth.getDay(),\n\t      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n\t      firstDate = new Date(firstDayOfMonth);\n\t\n\t    if (numDisplayedFromPreviousMonth > 0) {\n\t      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n\t    }\n\t\n\t    // 42 is the number of days on a six-month calendar\n\t    var days = this.getDates(firstDate, 42);\n\t    for (var i = 0; i < 42; i ++) {\n\t      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n\t        secondary: days[i].getMonth() !== month,\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.labels = new Array(7);\n\t    for (var j = 0; j < 7; j++) {\n\t      scope.labels[j] = {\n\t        abbr: dateFilter(days[j].date, this.formatDayHeader),\n\t        full: dateFilter(days[j].date, 'EEEE')\n\t      };\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n\t    scope.rows = this.split(days, 7);\n\t\n\t    if (scope.showWeeks) {\n\t      scope.weekNumbers = [];\n\t      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n\t          numWeeks = scope.rows.length;\n\t      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n\t        scope.weekNumbers.push(\n\t          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n\t      }\n\t    }\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n\t  };\n\t\n\t  function getISO8601WeekNumber(date) {\n\t    var checkDate = new Date(date);\n\t    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n\t    var time = checkDate.getTime();\n\t    checkDate.setMonth(0); // Compare with Jan 1\n\t    checkDate.setDate(1);\n\t    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t  }\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getDate();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;   // up\n\t    } else if (key === 'up') {\n\t      date = date - 7;   // down\n\t    } else if (key === 'right') {\n\t      date = date + 1;   // down\n\t    } else if (key === 'down') {\n\t      date = date + 7;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setMonth(month, 1);\n\t      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n\t    } else if (key === 'home') {\n\t      date = 1;\n\t    } else if (key === 'end') {\n\t      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n\t    }\n\t    this.activeDate.setDate(date);\n\t  };\n\t}])\n\t\n\t.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  this.step = { years: 1 };\n\t  this.element = $element;\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var months = new Array(12),\n\t        year = this.activeDate.getFullYear(),\n\t        date;\n\t\n\t    for (var i = 0; i < 12; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(year, i, 1);\n\t      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n\t    scope.rows = this.split(months, 3);\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getMonth();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;   // up\n\t    } else if (key === 'up') {\n\t      date = date - 3;   // down\n\t    } else if (key === 'right') {\n\t      date = date + 1;   // down\n\t    } else if (key === 'down') {\n\t      date = date + 3;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setFullYear(year);\n\t    } else if (key === 'home') {\n\t      date = 0;\n\t    } else if (key === 'end') {\n\t      date = 11;\n\t    }\n\t    this.activeDate.setMonth(date);\n\t  };\n\t}])\n\t\n\t.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var range;\n\t  this.element = $element;\n\t\n\t  function getStartingYear(year) {\n\t    return parseInt((year - 1) / range, 10) * range + 1;\n\t  }\n\t\n\t  this.yearpickerInit = function() {\n\t    range = this.yearRange;\n\t    this.step = { years: range };\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var years = new Array(range), date;\n\t\n\t    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(start + i, 0, 1);\n\t      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n\t    scope.rows = this.split(years, 5);\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return date1.getFullYear() - date2.getFullYear();\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getFullYear();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;   // up\n\t    } else if (key === 'up') {\n\t      date = date - 5;   // down\n\t    } else if (key === 'right') {\n\t      date = date + 1;   // down\n\t    } else if (key === 'down') {\n\t      date = date + 5;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      date += (key === 'pageup' ? - 1 : 1) * this.step.years;\n\t    } else if (key === 'home') {\n\t      date = getStartingYear(this.activeDate.getFullYear());\n\t    } else if (key === 'end') {\n\t      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n\t    }\n\t    this.activeDate.setFullYear(date);\n\t  };\n\t}])\n\t\n\t.directive('uibDatepicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n\t    },\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      dateDisabled: '&',\n\t      customClass: '&',\n\t      shortcutPropagation: '&?'\n\t    },\n\t    require: ['uibDatepicker', '^ngModel'],\n\t    controller: 'UibDatepickerController',\n\t    controllerAs: 'datepicker',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      datepickerCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDaypicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/day.html';\n\t    },\n\t    require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],\n\t    controller: 'UibDaypickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0] || ctrls[2],\n\t        daypickerCtrl = ctrls[1];\n\t\n\t      daypickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibMonthpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/month.html';\n\t    },\n\t    require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],\n\t    controller: 'UibMonthpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0] || ctrls[2],\n\t        monthpickerCtrl = ctrls[1];\n\t\n\t      monthpickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibYearpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/year.html';\n\t    },\n\t    require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],\n\t    controller: 'UibYearpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ctrl = ctrls[0] || ctrls[2];\n\t      angular.extend(ctrl, ctrls[1]);\n\t      ctrl.yearpickerInit();\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t})\n\t\n\t.constant('uibDatepickerPopupConfig', {\n\t  datepickerPopup: 'yyyy-MM-dd',\n\t  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',\n\t  datepickerTemplateUrl: 'template/datepicker/datepicker.html',\n\t  html5Types: {\n\t    date: 'yyyy-MM-dd',\n\t    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n\t    'month': 'yyyy-MM'\n\t  },\n\t  currentText: 'Today',\n\t  clearText: 'Clear',\n\t  closeText: 'Done',\n\t  closeOnDateSelection: true,\n\t  appendToBody: false,\n\t  showButtonBar: true,\n\t  onOpenFocus: true\n\t})\n\t\n\t.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout',\n\tfunction(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {\n\t  var self = this;\n\t  var cache = {},\n\t    isHtml5DateInput = false;\n\t  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n\t    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,\n\t    ngModel, $popup;\n\t\n\t  scope.watchData = {};\n\t\n\t  this.init = function(_ngModel_) {\n\t    ngModel = _ngModel_;\n\t    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n\t    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n\t    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n\t    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;\n\t    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\t\n\t    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\t\n\t    if (datepickerPopupConfig.html5Types[attrs.type]) {\n\t      dateFormat = datepickerPopupConfig.html5Types[attrs.type];\n\t      isHtml5DateInput = true;\n\t    } else {\n\t      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n\t      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n\t          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n\t          // Invalidate the $modelValue to ensure that formatters re-run\n\t          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n\t          if (newDateFormat !== dateFormat) {\n\t            dateFormat = newDateFormat;\n\t            ngModel.$modelValue = null;\n\t\n\t            if (!dateFormat) {\n\t              throw new Error('uibDatepickerPopup must have a date format specified.');\n\t            }\n\t          }\n\t      });\n\t    }\n\t\n\t    if (!dateFormat) {\n\t      throw new Error('uibDatepickerPopup must have a date format specified.');\n\t    }\n\t\n\t    if (isHtml5DateInput && attrs.datepickerPopup) {\n\t      throw new Error('HTML5 date input types do not support custom formats.');\n\t    }\n\t\n\t    // popup element used to display calendar\n\t    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n\t    popupEl.attr({\n\t      'ng-model': 'date',\n\t      'ng-change': 'dateSelection(date)',\n\t      'template-url': datepickerPopupTemplateUrl\n\t    });\n\t\n\t    // datepicker element\n\t    datepickerEl = angular.element(popupEl.children()[0]);\n\t    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\t\n\t    if (isHtml5DateInput) {\n\t      if (attrs.type === 'month') {\n\t        datepickerEl.attr('datepicker-mode', '\"month\"');\n\t        datepickerEl.attr('min-mode', 'month');\n\t      }\n\t    }\n\t\n\t    if (attrs.datepickerOptions) {\n\t      var options = scope.$parent.$eval(attrs.datepickerOptions);\n\t      if (options && options.initDate) {\n\t        scope.initDate = options.initDate;\n\t        datepickerEl.attr('init-date', 'initDate');\n\t        delete options.initDate;\n\t      }\n\t      angular.forEach(options, function(value, option) {\n\t        datepickerEl.attr(cameltoDash(option), value);\n\t      });\n\t    }\n\t\n\t    angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {\n\t      if (attrs[key]) {\n\t        var getAttribute = $parse(attrs[key]);\n\t        scope.$parent.$watch(getAttribute, function(value) {\n\t          scope.watchData[key] = value;\n\t          if (key === 'minDate' || key === 'maxDate') {\n\t            cache[key] = new Date(value);\n\t          }\n\t        });\n\t        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\t\n\t        // Propagate changes from datepicker to outside\n\t        if (key === 'datepickerMode') {\n\t          var setAttribute = getAttribute.assign;\n\t          scope.$watch('watchData.' + key, function(value, oldvalue) {\n\t            if (angular.isFunction(setAttribute) && value !== oldvalue) {\n\t              setAttribute(scope.$parent, value);\n\t            }\n\t          });\n\t        }\n\t      }\n\t    });\n\t    if (attrs.dateDisabled) {\n\t      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n\t    }\n\t\n\t    if (attrs.showWeeks) {\n\t      datepickerEl.attr('show-weeks', attrs.showWeeks);\n\t    }\n\t\n\t    if (attrs.customClass) {\n\t      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n\t    }\n\t\n\t    if (!isHtml5DateInput) {\n\t      // Internal API to maintain the correct ng-invalid-[key] class\n\t      ngModel.$$parserName = 'date';\n\t      ngModel.$validators.date = validator;\n\t      ngModel.$parsers.unshift(parseDate);\n\t      ngModel.$formatters.push(function(value) {\n\t        scope.date = value;\n\t        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);\n\t      });\n\t    } else {\n\t      ngModel.$formatters.push(function(value) {\n\t        scope.date = value;\n\t        return value;\n\t      });\n\t    }\n\t\n\t    // Detect changes in the view from the text box\n\t    ngModel.$viewChangeListeners.push(function() {\n\t      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);\n\t    });\n\t\n\t    element.bind('keydown', inputKeydownBind);\n\t\n\t    $popup = $compile(popupEl)(scope);\n\t    // Prevent jQuery cache memory leak (template is now redundant after linking)\n\t    popupEl.remove();\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    scope.$on('$destroy', function() {\n\t      if (scope.isOpen === true) {\n\t        if (!$rootScope.$$phase) {\n\t          scope.$apply(function() {\n\t            scope.isOpen = false;\n\t          });\n\t        }\n\t      }\n\t\n\t      $popup.remove();\n\t      element.unbind('keydown', inputKeydownBind);\n\t      $document.unbind('click', documentClickBind);\n\t    });\n\t  };\n\t\n\t  scope.getText = function(key) {\n\t    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n\t  };\n\t\n\t  scope.isDisabled = function(date) {\n\t    if (date === 'today') {\n\t      date = new Date();\n\t    }\n\t\n\t    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||\n\t      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));\n\t  };\n\t\n\t  scope.compare = function(date1, date2) {\n\t    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n\t  };\n\t\n\t  // Inner change\n\t  scope.dateSelection = function(dt) {\n\t    if (angular.isDefined(dt)) {\n\t      scope.date = dt;\n\t    }\n\t    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n\t    element.val(date);\n\t    ngModel.$setViewValue(date);\n\t\n\t    if (closeOnDateSelection) {\n\t      scope.isOpen = false;\n\t      element[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.keydown = function(evt) {\n\t    if (evt.which === 27) {\n\t      scope.isOpen = false;\n\t      element[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.select = function(date) {\n\t    if (date === 'today') {\n\t      var today = new Date();\n\t      if (angular.isDate(scope.date)) {\n\t        date = new Date(scope.date);\n\t        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n\t      } else {\n\t        date = new Date(today.setHours(0, 0, 0, 0));\n\t      }\n\t    }\n\t    scope.dateSelection(date);\n\t  };\n\t\n\t  scope.close = function() {\n\t    scope.isOpen = false;\n\t    element[0].focus();\n\t  };\n\t\n\t  scope.$watch('isOpen', function(value) {\n\t    if (value) {\n\t      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t      scope.position.top = scope.position.top + element.prop('offsetHeight');\n\t\n\t      $timeout(function() {\n\t        if (onOpenFocus) {\n\t          scope.$broadcast('uib:datepicker.focus');\n\t        }\n\t        $document.bind('click', documentClickBind);\n\t      }, 0, false);\n\t    } else {\n\t      $document.unbind('click', documentClickBind);\n\t    }\n\t  });\n\t\n\t  function cameltoDash(string) {\n\t    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n\t  }\n\t\n\t  function parseDate(viewValue) {\n\t    if (angular.isNumber(viewValue)) {\n\t      // presumably timestamp to date object\n\t      viewValue = new Date(viewValue);\n\t    }\n\t\n\t    if (!viewValue) {\n\t      return null;\n\t    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n\t      return viewValue;\n\t    } else if (angular.isString(viewValue)) {\n\t      var date = dateParser.parse(viewValue, dateFormat, scope.date);\n\t      if (isNaN(date)) {\n\t        return undefined;\n\t      } else {\n\t        return date;\n\t      }\n\t    } else {\n\t      return undefined;\n\t    }\n\t  }\n\t\n\t  function validator(modelValue, viewValue) {\n\t    var value = modelValue || viewValue;\n\t\n\t    if (!attrs.ngRequired && !value) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isNumber(value)) {\n\t      value = new Date(value);\n\t    }\n\t    if (!value) {\n\t      return true;\n\t    } else if (angular.isDate(value) && !isNaN(value)) {\n\t      return true;\n\t    } else if (angular.isString(value)) {\n\t      var date = dateParser.parse(value, dateFormat);\n\t      return !isNaN(date);\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  function documentClickBind(event) {\n\t    var popup = $popup[0];\n\t    var dpContainsTarget = element[0].contains(event.target);\n\t    // The popup node may not be an element node\n\t    // In some browsers (IE) only element nodes have the 'contains' function\n\t    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n\t    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n\t      scope.$apply(function() {\n\t        scope.isOpen = false;\n\t      });\n\t    }\n\t  }\n\t\n\t  function inputKeydownBind(evt) {\n\t    if (evt.which === 27 && scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      scope.$apply(function() {\n\t        scope.isOpen = false;\n\t      });\n\t      element[0].focus();\n\t    } else if (evt.which === 40 && !scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      scope.$apply(function() {\n\t        scope.isOpen = true;\n\t      });\n\t    }\n\t  }\n\t}])\n\t\n\t.directive('uibDatepickerPopup', function() {\n\t  return {\n\t    require: ['ngModel', 'uibDatepickerPopup'],\n\t    controller: 'UibDatepickerPopupController',\n\t    scope: {\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&',\n\t      customClass: '&'\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ngModel = ctrls[0],\n\t        ctrl = ctrls[1];\n\t\n\t      ctrl.init(ngModel);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDatepickerPopupWrap', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/popup.html';\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated datepicker below */\n\t\n\tangular.module('ui.bootstrap.datepicker')\n\t\n\t.value('$datepickerSuppressWarning', false)\n\t\n\t.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {\n\t  if (!$datepickerSuppressWarning) {\n\t    $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\t\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n\t    'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n\t    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n\t  });\n\t\n\t  angular.forEach(['minDate', 'maxDate'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = value ? new Date(value) : null;\n\t        self.refreshView();\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n\t    }\n\t  });\n\t\n\t  angular.forEach(['minMode', 'maxMode'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = angular.isDefined(value) ? value : $attrs[key];\n\t        $scope[key] = self[key];\n\t        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n\t          $scope.datepickerMode = self[key];\n\t        }\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] || null;\n\t      $scope[key] = self[key];\n\t    }\n\t  });\n\t\n\t  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t\n\t  if (angular.isDefined($attrs.initDate)) {\n\t    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n\t    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n\t      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t        self.activeDate = initDate;\n\t        self.refreshView();\n\t      }\n\t    });\n\t  } else {\n\t    this.activeDate = new Date();\n\t  }\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if (ngModelCtrl.$viewValue) {\n\t      var date = new Date(ngModelCtrl.$viewValue),\n\t        isValid = !isNaN(date);\n\t\n\t      if (isValid) {\n\t        this.activeDate = date;\n\t      } else if (!$datepickerSuppressError) {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t      }\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if (this.element) {\n\t      this._refreshView();\n\t\n\t      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t    return {\n\t      date: date,\n\t      label: dateFilter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0,\n\t      customClass: this.customClass(date)\n\t    };\n\t  };\n\t\n\t  this.isDisabled = function(date) {\n\t    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n\t  };\n\t\n\t  this.customClass = function(date) {\n\t    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  this.fixTimeZone = function(date) {\n\t    var hours = date.getHours();\n\t    date.setHours(hours === 23 ? hours + 2 : 0);\n\t  };\n\t\n\t  $scope.select = function(date) {\n\t    if ($scope.datepickerMode === self.minMode) {\n\t      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n\t      ngModelCtrl.$setViewValue(dt);\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n\t    }\n\t  };\n\t\n\t  $scope.move = function(direction) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t      month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function(direction) {\n\t    direction = direction || 1;\n\t\n\t    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n\t      return;\n\t    }\n\t\n\t    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\t\n\t  var focusElement = function() {\n\t    self.element[0].focus();\n\t  };\n\t\n\t  $scope.$on('uib:datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function(evt) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if (!key || evt.shiftKey || evt.altKey) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    if (!self.shortcutPropagation) {\n\t      evt.stopPropagation();\n\t    }\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if (self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n\t    },\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      dateDisabled: '&',\n\t      customClass: '&',\n\t      shortcutPropagation: '&?'\n\t    },\n\t    require: ['datepicker', '^ngModel'],\n\t    controller: 'DatepickerController',\n\t    controllerAs: 'datepicker',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');\n\t      }\n\t\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      datepickerCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/day.html',\n\t    require: ['^datepicker', 'daypicker'],\n\t    controller: 'UibDaypickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');\n\t      }\n\t\n\t      var datepickerCtrl = ctrls[0],\n\t        daypickerCtrl = ctrls[1];\n\t\n\t      daypickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/month.html',\n\t    require: ['^datepicker', 'monthpicker'],\n\t    controller: 'UibMonthpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');\n\t      }\n\t\n\t      var datepickerCtrl = ctrls[0],\n\t        monthpickerCtrl = ctrls[1];\n\t\n\t      monthpickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/year.html',\n\t    require: ['^datepicker', 'yearpicker'],\n\t    controller: 'UibYearpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');\n\t      }\n\t\n\t      var ctrl = ctrls[0];\n\t      angular.extend(ctrl, ctrls[1]);\n\t      ctrl.yearpickerInit();\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    require: ['ngModel', 'datepickerPopup'],\n\t    controller: 'UibDatepickerPopupController',\n\t    scope: {\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&',\n\t      customClass: '&'\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');\n\t      }\n\t\n\t      var ngModel = ctrls[0],\n\t        ctrl = ctrls[1];\n\t\n\t      ctrl.init(ngModel);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/popup.html';\n\t    },\n\t    link: function() {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\t\n\t.constant('uibDropdownConfig', {\n\t  openClass: 'open'\n\t})\n\t\n\t.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n\t  var openScope = null;\n\t\n\t  this.open = function(dropdownScope) {\n\t    if (!openScope) {\n\t      $document.bind('click', closeDropdown);\n\t      $document.bind('keydown', keybindFilter);\n\t    }\n\t\n\t    if (openScope && openScope !== dropdownScope) {\n\t      openScope.isOpen = false;\n\t    }\n\t\n\t    openScope = dropdownScope;\n\t  };\n\t\n\t  this.close = function(dropdownScope) {\n\t    if (openScope === dropdownScope) {\n\t      openScope = null;\n\t      $document.unbind('click', closeDropdown);\n\t      $document.unbind('keydown', keybindFilter);\n\t    }\n\t  };\n\t\n\t  var closeDropdown = function(evt) {\n\t    // This method may still be called during the same mouse event that\n\t    // unbound this event handler. So check openScope before proceeding.\n\t    if (!openScope) { return; }\n\t\n\t    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }\n\t\n\t    var toggleElement = openScope.getToggleElement();\n\t    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    var dropdownElement = openScope.getDropdownElement();\n\t    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n\t      dropdownElement && dropdownElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    openScope.isOpen = false;\n\t\n\t    if (!$rootScope.$$phase) {\n\t      openScope.$apply();\n\t    }\n\t  };\n\t\n\t  var keybindFilter = function(evt) {\n\t    if (evt.which === 27) {\n\t      openScope.focusToggleElement();\n\t      closeDropdown();\n\t    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      openScope.focusDropdownEntry(evt.which);\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n\t  var self = this,\n\t    scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t    templateScope,\n\t    openClass = dropdownConfig.openClass,\n\t    getIsOpen,\n\t    setIsOpen = angular.noop,\n\t    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n\t    appendToBody = false,\n\t    keynavEnabled =false,\n\t    selectedOption = null;\n\t\n\t\n\t  $element.addClass('dropdown');\n\t\n\t  this.init = function() {\n\t    if ($attrs.isOpen) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t\n\t    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n\t    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\t\n\t    if (appendToBody && self.dropdownMenu) {\n\t      $document.find('body').append(self.dropdownMenu);\n\t      $element.on('$destroy', function handleDestroyEvent() {\n\t        self.dropdownMenu.remove();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function(open) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.getAutoClose = function() {\n\t    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n\t  };\n\t\n\t  scope.getElement = function() {\n\t    return $element;\n\t  };\n\t\n\t  scope.isKeynavEnabled = function() {\n\t    return keynavEnabled;\n\t  };\n\t\n\t  scope.focusDropdownEntry = function(keyCode) {\n\t    var elems = self.dropdownMenu ? //If append to body is used.\n\t      (angular.element(self.dropdownMenu).find('a')) :\n\t      (angular.element($element).find('ul').eq(0).find('a'));\n\t\n\t    switch (keyCode) {\n\t      case (40): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = 0;\n\t        } else {\n\t          self.selectedOption = (self.selectedOption === elems.length - 1 ?\n\t            self.selectedOption :\n\t            self.selectedOption + 1);\n\t        }\n\t        break;\n\t      }\n\t      case (38): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = elems.length - 1;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === 0 ?\n\t            0 : self.selectedOption - 1;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    elems[self.selectedOption].focus();\n\t  };\n\t\n\t  scope.getDropdownElement = function() {\n\t    return self.dropdownMenu;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if (self.toggleElement) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function(isOpen, wasOpen) {\n\t    if (appendToBody && self.dropdownMenu) {\n\t      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n\t      var css = {\n\t        top: pos.top + 'px',\n\t        display: isOpen ? 'block' : 'none'\n\t      };\n\t\n\t      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n\t      if (!rightalign) {\n\t        css.left = pos.left + 'px';\n\t        css.right = 'auto';\n\t      } else {\n\t        css.left = 'auto';\n\t        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n\t      }\n\t\n\t      self.dropdownMenu.css(css);\n\t    }\n\t\n\t    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n\t      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t        toggleInvoker($scope, { open: !!isOpen });\n\t      }\n\t    });\n\t\n\t    if (isOpen) {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n\t          templateScope = scope.$new();\n\t          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n\t            var newEl = dropdownElement;\n\t            self.dropdownMenu.replaceWith(newEl);\n\t            self.dropdownMenu = newEl;\n\t          });\n\t        });\n\t      }\n\t\n\t      scope.focusToggleElement();\n\t      uibDropdownService.open(scope);\n\t    } else {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        if (templateScope) {\n\t          templateScope.$destroy();\n\t        }\n\t        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n\t        self.dropdownMenu.replaceWith(newEl);\n\t        self.dropdownMenu = newEl;\n\t      }\n\t\n\t      uibDropdownService.close(scope);\n\t      self.selectedOption = null;\n\t    }\n\t\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen($scope, isOpen);\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    if (scope.getAutoClose() !== 'disabled') {\n\t      scope.isOpen = false;\n\t    }\n\t  });\n\t\n\t  var offDestroy = $scope.$on('$destroy', function() {\n\t    scope.$destroy();\n\t  });\n\t  scope.$on('$destroy', offDestroy);\n\t}])\n\t\n\t.directive('uibDropdown', function() {\n\t  return {\n\t    controller: 'UibDropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      dropdownCtrl.init();\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownMenu', function() {\n\t  return {\n\t    restrict: 'AC',\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-menu');\n\t\n\t      var tplUrl = attrs.templateUrl;\n\t      if (tplUrl) {\n\t        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n\t      }\n\t\n\t      if (!dropdownCtrl.dropdownMenu) {\n\t        dropdownCtrl.dropdownMenu = element;\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibKeyboardNav', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      element.bind('keydown', function(e) {\n\t        if ([38, 40].indexOf(e.which) !== -1) {\n\t          e.preventDefault();\n\t          e.stopPropagation();\n\t\n\t          var elems = dropdownCtrl.dropdownMenu.find('a');\n\t\n\t          switch (e.which) {\n\t            case (40): { // Down\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = 0;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n\t                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n\t              }\n\t              break;\n\t            }\n\t            case (38): { // Up\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = elems.length - 1;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n\t                  0 : dropdownCtrl.selectedOption - 1;\n\t              }\n\t              break;\n\t            }\n\t          }\n\t          elems[dropdownCtrl.selectedOption].focus();\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownToggle', function() {\n\t  return {\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-toggle');\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if (!element.hasClass('disabled') && !attrs.disabled) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated dropdown below */\n\t\n\tangular.module('ui.bootstrap.dropdown')\n\t\n\t.value('$dropdownSuppressWarning', false)\n\t\n\t.service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {\n\t  if (!$dropdownSuppressWarning) {\n\t    $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');\n\t  }\n\t\n\t  angular.extend(this, uibDropdownService);\n\t}])\n\t\n\t.controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {\n\t  if (!$dropdownSuppressWarning) {\n\t    $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t    templateScope,\n\t    openClass = dropdownConfig.openClass,\n\t    getIsOpen,\n\t    setIsOpen = angular.noop,\n\t    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n\t    appendToBody = false,\n\t    keynavEnabled =false,\n\t    selectedOption = null;\n\t\n\t\n\t  $element.addClass('dropdown');\n\t\n\t  this.init = function() {\n\t    if ($attrs.isOpen) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t\n\t    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n\t    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\t\n\t    if (appendToBody && self.dropdownMenu) {\n\t      $document.find('body').append(self.dropdownMenu);\n\t      $element.on('$destroy', function handleDestroyEvent() {\n\t        self.dropdownMenu.remove();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function(open) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.getAutoClose = function() {\n\t    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n\t  };\n\t\n\t  scope.getElement = function() {\n\t    return $element;\n\t  };\n\t\n\t  scope.isKeynavEnabled = function() {\n\t    return keynavEnabled;\n\t  };\n\t\n\t  scope.focusDropdownEntry = function(keyCode) {\n\t    var elems = self.dropdownMenu ? //If append to body is used.\n\t      (angular.element(self.dropdownMenu).find('a')) :\n\t      (angular.element($element).find('ul').eq(0).find('a'));\n\t\n\t    switch (keyCode) {\n\t      case (40): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = 0;\n\t        } else {\n\t          self.selectedOption = (self.selectedOption === elems.length -1 ?\n\t            self.selectedOption :\n\t          self.selectedOption + 1);\n\t        }\n\t        break;\n\t      }\n\t      case (38): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = elems.length - 1;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === 0 ?\n\t            0 : self.selectedOption - 1;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    elems[self.selectedOption].focus();\n\t  };\n\t\n\t  scope.getDropdownElement = function() {\n\t    return self.dropdownMenu;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if (self.toggleElement) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function(isOpen, wasOpen) {\n\t    if (appendToBody && self.dropdownMenu) {\n\t      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n\t      var css = {\n\t        top: pos.top + 'px',\n\t        display: isOpen ? 'block' : 'none'\n\t      };\n\t\n\t      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n\t      if (!rightalign) {\n\t        css.left = pos.left + 'px';\n\t        css.right = 'auto';\n\t      } else {\n\t        css.left = 'auto';\n\t        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n\t      }\n\t\n\t      self.dropdownMenu.css(css);\n\t    }\n\t\n\t    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n\t      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t        toggleInvoker($scope, { open: !!isOpen });\n\t      }\n\t    });\n\t\n\t    if (isOpen) {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n\t          templateScope = scope.$new();\n\t          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n\t            var newEl = dropdownElement;\n\t            self.dropdownMenu.replaceWith(newEl);\n\t            self.dropdownMenu = newEl;\n\t          });\n\t        });\n\t      }\n\t\n\t      scope.focusToggleElement();\n\t      uibDropdownService.open(scope);\n\t    } else {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        if (templateScope) {\n\t          templateScope.$destroy();\n\t        }\n\t        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n\t        self.dropdownMenu.replaceWith(newEl);\n\t        self.dropdownMenu = newEl;\n\t      }\n\t\n\t      uibDropdownService.close(scope);\n\t      self.selectedOption = null;\n\t    }\n\t\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen($scope, isOpen);\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    if (scope.getAutoClose() !== 'disabled') {\n\t      scope.isOpen = false;\n\t    }\n\t  });\n\t\n\t  var offDestroy = $scope.$on('$destroy', function() {\n\t    scope.$destroy();\n\t  });\n\t  scope.$on('$destroy', offDestroy);\n\t}])\n\t\n\t.directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    controller: 'DropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');\n\t      }\n\t\n\t      dropdownCtrl.init();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    restrict: 'AC',\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n\t        return;\n\t      }\n\t\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');\n\t      }\n\t\n\t      element.addClass('dropdown-menu');\n\t\n\t      var tplUrl = attrs.templateUrl;\n\t      if (tplUrl) {\n\t        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n\t      }\n\t\n\t      if (!dropdownCtrl.dropdownMenu) {\n\t        dropdownCtrl.dropdownMenu = element;\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');\n\t      }\n\t\n\t      element.bind('keydown', function(e) {\n\t        if ([38, 40].indexOf(e.which) !== -1) {\n\t          e.preventDefault();\n\t          e.stopPropagation();\n\t\n\t          var elems = dropdownCtrl.dropdownMenu.find('a');\n\t\n\t          switch (e.which) {\n\t            case (40): { // Down\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = 0;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n\t                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n\t              }\n\t              break;\n\t            }\n\t            case (38): { // Up\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = elems.length - 1;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n\t                  0 : dropdownCtrl.selectedOption - 1;\n\t              }\n\t              break;\n\t            }\n\t          }\n\t          elems[dropdownCtrl.selectedOption].focus();\n\t        }\n\t      });\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');\n\t      }\n\t\n\t      if (!dropdownCtrl) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-toggle');\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if (!element.hasClass('disabled') && !attrs.disabled) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.stackedMap', [])\n\t/**\n\t * A helper, internal data structure that acts as a map but also allows getting / removing\n\t * elements in the LIFO order\n\t */\n\t  .factory('$$stackedMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var stack = [];\n\t\n\t        return {\n\t          add: function(key, value) {\n\t            stack.push({\n\t              key: key,\n\t              value: value\n\t            });\n\t          },\n\t          get: function(key) {\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                return stack[i];\n\t              }\n\t            }\n\t          },\n\t          keys: function() {\n\t            var keys = [];\n\t            for (var i = 0; i < stack.length; i++) {\n\t              keys.push(stack[i].key);\n\t            }\n\t            return keys;\n\t          },\n\t          top: function() {\n\t            return stack[stack.length - 1];\n\t          },\n\t          remove: function(key) {\n\t            var idx = -1;\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                idx = i;\n\t                break;\n\t              }\n\t            }\n\t            return stack.splice(idx, 1)[0];\n\t          },\n\t          removeTop: function() {\n\t            return stack.splice(stack.length - 1, 1)[0];\n\t          },\n\t          length: function() {\n\t            return stack.length;\n\t          }\n\t        };\n\t      }\n\t    };\n\t  });\n\tangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n\t/**\n\t * A helper, internal data structure that stores all references attached to key\n\t */\n\t  .factory('$$multiMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var map = {};\n\t\n\t        return {\n\t          entries: function() {\n\t            return Object.keys(map).map(function(key) {\n\t              return {\n\t                key: key,\n\t                value: map[key]\n\t              };\n\t            });\n\t          },\n\t          get: function(key) {\n\t            return map[key];\n\t          },\n\t          hasKey: function(key) {\n\t            return !!map[key];\n\t          },\n\t          keys: function() {\n\t            return Object.keys(map);\n\t          },\n\t          put: function(key, value) {\n\t            if (!map[key]) {\n\t              map[key] = [];\n\t            }\n\t\n\t            map[key].push(value);\n\t          },\n\t          remove: function(key, value) {\n\t            var values = map[key];\n\t\n\t            if (!values) {\n\t              return;\n\t            }\n\t\n\t            var idx = values.indexOf(value);\n\t\n\t            if (idx !== -1) {\n\t              values.splice(idx, 1);\n\t            }\n\t\n\t            if (!values.length) {\n\t              delete map[key];\n\t            }\n\t          }\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t/**\n\t * A helper directive for the $modal service. It creates a backdrop element.\n\t */\n\t  .directive('uibModalBackdrop', [\n\t           '$animate', '$injector', '$uibModalStack',\n\t  function($animate ,  $injector,   $modalStack) {\n\t    var $animateCss = null;\n\t\n\t    if ($injector.has('$animateCss')) {\n\t      $animateCss = $injector.get('$animateCss');\n\t    }\n\t\n\t    return {\n\t      replace: true,\n\t      templateUrl: 'template/modal/backdrop.html',\n\t      compile: function(tElement, tAttrs) {\n\t        tElement.addClass(tAttrs.backdropClass);\n\t        return linkFn;\n\t      }\n\t    };\n\t\n\t    function linkFn(scope, element, attrs) {\n\t      // Temporary fix for prefixing\n\t      element.addClass('modal-backdrop');\n\t\n\t      if (attrs.modalInClass) {\n\t        if ($animateCss) {\n\t          $animateCss(element, {\n\t            addClass: attrs.modalInClass\n\t          }).start();\n\t        } else {\n\t          $animate.addClass(element, attrs.modalInClass);\n\t        }\n\t\n\t        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t          var done = setIsAsync();\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              removeClass: attrs.modalInClass\n\t            }).start().then(done);\n\t          } else {\n\t            $animate.removeClass(element, attrs.modalInClass).then(done);\n\t          }\n\t        });\n\t      }\n\t    }\n\t  }])\n\t\n\t  .directive('uibModalWindow', [\n\t           '$uibModalStack', '$q', '$animate', '$injector',\n\t  function($modalStack ,  $q ,  $animate,   $injector) {\n\t    var $animateCss = null;\n\t\n\t    if ($injector.has('$animateCss')) {\n\t      $animateCss = $injector.get('$animateCss');\n\t    }\n\t\n\t    return {\n\t      scope: {\n\t        index: '@'\n\t      },\n\t      replace: true,\n\t      transclude: true,\n\t      templateUrl: function(tElement, tAttrs) {\n\t        return tAttrs.templateUrl || 'template/modal/window.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        element.addClass(attrs.windowClass || '');\n\t        element.addClass(attrs.windowTopClass || '');\n\t        scope.size = attrs.size;\n\t\n\t        scope.close = function(evt) {\n\t          var modal = $modalStack.getTop();\n\t          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n\t            evt.preventDefault();\n\t            evt.stopPropagation();\n\t            $modalStack.dismiss(modal.key, 'backdrop click');\n\t          }\n\t        };\n\t\n\t        // moved from template to fix issue #2280\n\t        element.on('click', scope.close);\n\t\n\t        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n\t        // We can detect that by using this property in the template associated with this directive and then use\n\t        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n\t        scope.$isRendered = true;\n\t\n\t        // Deferred object that will be resolved when this modal is render.\n\t        var modalRenderDeferObj = $q.defer();\n\t        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n\t        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n\t        attrs.$observe('modalRender', function(value) {\n\t          if (value == 'true') {\n\t            modalRenderDeferObj.resolve();\n\t          }\n\t        });\n\t\n\t        modalRenderDeferObj.promise.then(function() {\n\t          var animationPromise = null;\n\t\n\t          if (attrs.modalInClass) {\n\t            if ($animateCss) {\n\t              animationPromise = $animateCss(element, {\n\t                addClass: attrs.modalInClass\n\t              }).start();\n\t            } else {\n\t              animationPromise = $animate.addClass(element, attrs.modalInClass);\n\t            }\n\t\n\t            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t              var done = setIsAsync();\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  removeClass: attrs.modalInClass\n\t                }).start().then(done);\n\t              } else {\n\t                $animate.removeClass(element, attrs.modalInClass).then(done);\n\t              }\n\t            });\n\t          }\n\t\n\t\n\t          $q.when(animationPromise).then(function() {\n\t            var inputWithAutofocus = element[0].querySelector('[autofocus]');\n\t            /**\n\t             * Auto-focusing of a freshly-opened modal element causes any child elements\n\t             * with the autofocus attribute to lose focus. This is an issue on touch\n\t             * based devices which will show and then hide the onscreen keyboard.\n\t             * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t             * the modal element if the modal does not contain an autofocus element.\n\t             */\n\t            if (inputWithAutofocus) {\n\t              inputWithAutofocus.focus();\n\t            } else {\n\t              element[0].focus();\n\t            }\n\t          });\n\t\n\t          // Notify {@link $modalStack} that modal is rendered.\n\t          var modal = $modalStack.getTop();\n\t          if (modal) {\n\t            $modalStack.modalRendered(modal.key);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('uibModalAnimationClass', function() {\n\t    return {\n\t      compile: function(tElement, tAttrs) {\n\t        if (tAttrs.modalAnimation) {\n\t          tElement.addClass(tAttrs.uibModalAnimationClass);\n\t        }\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibModalTransclude', function() {\n\t    return {\n\t      link: function($scope, $element, $attrs, controller, $transclude) {\n\t        $transclude($scope.$parent, function(clone) {\n\t          $element.empty();\n\t          $element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  })\n\t\n\t  .factory('$uibModalStack', [\n\t             '$animate', '$timeout', '$document', '$compile', '$rootScope',\n\t             '$q',\n\t             '$injector',\n\t             '$$multiMap',\n\t             '$$stackedMap',\n\t    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n\t              $q,\n\t              $injector,\n\t              $$multiMap,\n\t              $$stackedMap) {\n\t      var $animateCss = null;\n\t\n\t      if ($injector.has('$animateCss')) {\n\t        $animateCss = $injector.get('$animateCss');\n\t      }\n\t\n\t      var OPENED_MODAL_CLASS = 'modal-open';\n\t\n\t      var backdropDomEl, backdropScope;\n\t      var openedWindows = $$stackedMap.createNew();\n\t      var openedClasses = $$multiMap.createNew();\n\t      var $modalStack = {\n\t        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n\t      };\n\t\n\t      //Modal focus behavior\n\t      var focusableElementList;\n\t      var focusIndex = 0;\n\t      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n\t        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n\t        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\t\n\t      function backdropIndex() {\n\t        var topBackdropIndex = -1;\n\t        var opened = openedWindows.keys();\n\t        for (var i = 0; i < opened.length; i++) {\n\t          if (openedWindows.get(opened[i]).value.backdrop) {\n\t            topBackdropIndex = i;\n\t          }\n\t        }\n\t        return topBackdropIndex;\n\t      }\n\t\n\t      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n\t        if (backdropScope) {\n\t          backdropScope.index = newBackdropIndex;\n\t        }\n\t      });\n\t\n\t      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n\t        var body = $document.find('body').eq(0);\n\t        var modalWindow = openedWindows.get(modalInstance).value;\n\t\n\t        //clean up the stack\n\t        openedWindows.remove(modalInstance);\n\t\n\t        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n\t          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n\t          openedClasses.remove(modalBodyClass, modalInstance);\n\t          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n\t          toggleTopWindowClass(true);\n\t        });\n\t        checkRemoveBackdrop();\n\t\n\t        //move focus to specified element if available, or else to body\n\t        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n\t          elementToReceiveFocus.focus();\n\t        } else {\n\t          body.focus();\n\t        }\n\t      }\n\t\n\t      // Add or remove \"windowTopClass\" from the top window in the stack\n\t      function toggleTopWindowClass(toggleSwitch) {\n\t        var modalWindow;\n\t\n\t        if (openedWindows.length() > 0) {\n\t          modalWindow = openedWindows.top().value;\n\t          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n\t        }\n\t      }\n\t\n\t      function checkRemoveBackdrop() {\n\t        //remove backdrop if no longer needed\n\t        if (backdropDomEl && backdropIndex() == -1) {\n\t          var backdropScopeRef = backdropScope;\n\t          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n\t            backdropScopeRef = null;\n\t          });\n\t          backdropDomEl = undefined;\n\t          backdropScope = undefined;\n\t        }\n\t      }\n\t\n\t      function removeAfterAnimate(domEl, scope, done) {\n\t        var asyncDeferred;\n\t        var asyncPromise = null;\n\t        var setIsAsync = function() {\n\t          if (!asyncDeferred) {\n\t            asyncDeferred = $q.defer();\n\t            asyncPromise = asyncDeferred.promise;\n\t          }\n\t\n\t          return function asyncDone() {\n\t            asyncDeferred.resolve();\n\t          };\n\t        };\n\t        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\t\n\t        // Note that it's intentional that asyncPromise might be null.\n\t        // That's when setIsAsync has not been called during the\n\t        // NOW_CLOSING_EVENT broadcast.\n\t        return $q.when(asyncPromise).then(afterAnimating);\n\t\n\t        function afterAnimating() {\n\t          if (afterAnimating.done) {\n\t            return;\n\t          }\n\t          afterAnimating.done = true;\n\t\n\t          if ($animateCss) {\n\t            $animateCss(domEl, {\n\t              event: 'leave'\n\t            }).start().then(function() {\n\t              domEl.remove();\n\t            });\n\t          } else {\n\t            $animate.leave(domEl);\n\t          }\n\t          scope.$destroy();\n\t          if (done) {\n\t            done();\n\t          }\n\t        }\n\t      }\n\t\n\t      $document.bind('keydown', function(evt) {\n\t        if (evt.isDefaultPrevented()) {\n\t          return evt;\n\t        }\n\t\n\t        var modal = openedWindows.top();\n\t        if (modal && modal.value.keyboard) {\n\t          switch (evt.which) {\n\t            case 27: {\n\t              evt.preventDefault();\n\t              $rootScope.$apply(function() {\n\t                $modalStack.dismiss(modal.key, 'escape key press');\n\t              });\n\t              break;\n\t            }\n\t            case 9: {\n\t              $modalStack.loadFocusElementList(modal);\n\t              var focusChanged = false;\n\t              if (evt.shiftKey) {\n\t                if ($modalStack.isFocusInFirstItem(evt)) {\n\t                  focusChanged = $modalStack.focusLastFocusableElement();\n\t                }\n\t              } else {\n\t                if ($modalStack.isFocusInLastItem(evt)) {\n\t                  focusChanged = $modalStack.focusFirstFocusableElement();\n\t                }\n\t              }\n\t\n\t              if (focusChanged) {\n\t                evt.preventDefault();\n\t                evt.stopPropagation();\n\t              }\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      });\n\t\n\t      $modalStack.open = function(modalInstance, modal) {\n\t        var modalOpener = $document[0].activeElement,\n\t          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\t\n\t        toggleTopWindowClass(false);\n\t\n\t        openedWindows.add(modalInstance, {\n\t          deferred: modal.deferred,\n\t          renderDeferred: modal.renderDeferred,\n\t          modalScope: modal.scope,\n\t          backdrop: modal.backdrop,\n\t          keyboard: modal.keyboard,\n\t          openedClass: modal.openedClass,\n\t          windowTopClass: modal.windowTopClass\n\t        });\n\t\n\t        openedClasses.put(modalBodyClass, modalInstance);\n\t\n\t        var body = $document.find('body').eq(0),\n\t            currBackdropIndex = backdropIndex();\n\t\n\t        if (currBackdropIndex >= 0 && !backdropDomEl) {\n\t          backdropScope = $rootScope.$new(true);\n\t          backdropScope.index = currBackdropIndex;\n\t          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n\t          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n\t          if (modal.animation) {\n\t            angularBackgroundDomEl.attr('modal-animation', 'true');\n\t          }\n\t          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n\t          body.append(backdropDomEl);\n\t        }\n\t\n\t        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n\t        angularDomEl.attr({\n\t          'template-url': modal.windowTemplateUrl,\n\t          'window-class': modal.windowClass,\n\t          'window-top-class': modal.windowTopClass,\n\t          'size': modal.size,\n\t          'index': openedWindows.length() - 1,\n\t          'animate': 'animate'\n\t        }).html(modal.content);\n\t        if (modal.animation) {\n\t          angularDomEl.attr('modal-animation', 'true');\n\t        }\n\t\n\t        var modalDomEl = $compile(angularDomEl)(modal.scope);\n\t        openedWindows.top().value.modalDomEl = modalDomEl;\n\t        openedWindows.top().value.modalOpener = modalOpener;\n\t        body.append(modalDomEl);\n\t        body.addClass(modalBodyClass);\n\t\n\t        $modalStack.clearFocusListCache();\n\t      };\n\t\n\t      function broadcastClosing(modalWindow, resultOrReason, closing) {\n\t        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n\t      }\n\t\n\t      $modalStack.close = function(modalInstance, result) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.resolve(result);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismiss = function(modalInstance, reason) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.reject(reason);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismissAll = function(reason) {\n\t        var topModal = this.getTop();\n\t        while (topModal && this.dismiss(topModal.key, reason)) {\n\t          topModal = this.getTop();\n\t        }\n\t      };\n\t\n\t      $modalStack.getTop = function() {\n\t        return openedWindows.top();\n\t      };\n\t\n\t      $modalStack.modalRendered = function(modalInstance) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.renderDeferred.resolve();\n\t        }\n\t      };\n\t\n\t      $modalStack.focusFirstFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[0].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t      $modalStack.focusLastFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[focusableElementList.length - 1].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInFirstItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) == focusableElementList[0];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInLastItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.clearFocusListCache = function() {\n\t        focusableElementList = [];\n\t        focusIndex = 0;\n\t      };\n\t\n\t      $modalStack.loadFocusElementList = function(modalWindow) {\n\t        if (focusableElementList === undefined || !focusableElementList.length) {\n\t          if (modalWindow) {\n\t            var modalDomE1 = modalWindow.value.modalDomEl;\n\t            if (modalDomE1 && modalDomE1.length) {\n\t              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      return $modalStack;\n\t    }])\n\t\n\t  .provider('$uibModal', function() {\n\t    var $modalProvider = {\n\t      options: {\n\t        animation: true,\n\t        backdrop: true, //can also be false or 'static'\n\t        keyboard: true\n\t      },\n\t      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log',\n\t        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {\n\t          var $modal = {};\n\t\n\t          function getTemplatePromise(options) {\n\t            return options.template ? $q.when(options.template) :\n\t              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);\n\t          }\n\t\n\t          function getResolvePromises(resolves) {\n\t            var promisesArr = [];\n\t            angular.forEach(resolves, function(value) {\n\t              if (angular.isFunction(value) || angular.isArray(value)) {\n\t                promisesArr.push($q.when($injector.invoke(value)));\n\t              } else if (angular.isString(value)) {\n\t                promisesArr.push($q.when($injector.get(value)));\n\t              } else {\n\t                promisesArr.push($q.when(value));\n\t              }\n\t            });\n\t            return promisesArr;\n\t          }\n\t\n\t          var promiseChain = null;\n\t          $modal.getPromiseChain = function() {\n\t            return promiseChain;\n\t          };\n\t\n\t          $modal.open = function(modalOptions) {\n\t            var modalResultDeferred = $q.defer();\n\t            var modalOpenedDeferred = $q.defer();\n\t            var modalRenderDeferred = $q.defer();\n\t\n\t            //prepare an instance of a modal to be injected into controllers and returned to a caller\n\t            var modalInstance = {\n\t              result: modalResultDeferred.promise,\n\t              opened: modalOpenedDeferred.promise,\n\t              rendered: modalRenderDeferred.promise,\n\t              close: function (result) {\n\t                return $modalStack.close(modalInstance, result);\n\t              },\n\t              dismiss: function (reason) {\n\t                return $modalStack.dismiss(modalInstance, reason);\n\t              }\n\t            };\n\t\n\t            //merge and clean up options\n\t            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n\t            modalOptions.resolve = modalOptions.resolve || {};\n\t\n\t            //verify options\n\t            if (!modalOptions.template && !modalOptions.templateUrl) {\n\t              throw new Error('One of template or templateUrl options is required.');\n\t            }\n\t\n\t            var templateAndResolvePromise =\n\t              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\t\n\t            function resolveWithTemplate() {\n\t              return templateAndResolvePromise;\n\t            }\n\t\n\t            // Wait for the resolution of the existing promise chain.\n\t            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n\t            // Then add to $modalStack and resolve opened.\n\t            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n\t            var samePromise;\n\t            samePromise = promiseChain = $q.all([promiseChain])\n\t              .then(resolveWithTemplate, resolveWithTemplate)\n\t              .then(function resolveSuccess(tplAndVars) {\n\t\n\t                var modalScope = (modalOptions.scope || $rootScope).$new();\n\t                modalScope.$close = modalInstance.close;\n\t                modalScope.$dismiss = modalInstance.dismiss;\n\t\n\t                modalScope.$on('$destroy', function() {\n\t                  if (!modalScope.$$uibDestructionScheduled) {\n\t                    modalScope.$dismiss('$uibUnscheduledDestruction');\n\t                  }\n\t                });\n\t\n\t                var ctrlInstance, ctrlLocals = {};\n\t                var resolveIter = 1;\n\t\n\t                //controllers\n\t                if (modalOptions.controller) {\n\t                  ctrlLocals.$scope = modalScope;\n\t                  ctrlLocals.$uibModalInstance = modalInstance;\n\t                  Object.defineProperty(ctrlLocals, '$modalInstance', {\n\t                    get: function() {\n\t                      if (!$modalSuppressWarning) {\n\t                        $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');\n\t                      }\n\t\n\t                      return modalInstance;\n\t                    }\n\t                  });\n\t                  angular.forEach(modalOptions.resolve, function(value, key) {\n\t                    ctrlLocals[key] = tplAndVars[resolveIter++];\n\t                  });\n\t\n\t                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n\t                  if (modalOptions.controllerAs) {\n\t                    if (modalOptions.bindToController) {\n\t                      angular.extend(ctrlInstance, modalScope);\n\t                    }\n\t\n\t                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n\t                  }\n\t                }\n\t\n\t                $modalStack.open(modalInstance, {\n\t                  scope: modalScope,\n\t                  deferred: modalResultDeferred,\n\t                  renderDeferred: modalRenderDeferred,\n\t                  content: tplAndVars[0],\n\t                  animation: modalOptions.animation,\n\t                  backdrop: modalOptions.backdrop,\n\t                  keyboard: modalOptions.keyboard,\n\t                  backdropClass: modalOptions.backdropClass,\n\t                  windowTopClass: modalOptions.windowTopClass,\n\t                  windowClass: modalOptions.windowClass,\n\t                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n\t                  size: modalOptions.size,\n\t                  openedClass: modalOptions.openedClass\n\t                });\n\t                modalOpenedDeferred.resolve(true);\n\t\n\t            }, function resolveError(reason) {\n\t              modalOpenedDeferred.reject(reason);\n\t              modalResultDeferred.reject(reason);\n\t            })\n\t            .finally(function() {\n\t              if (promiseChain === samePromise) {\n\t                promiseChain = null;\n\t              }\n\t            });\n\t\n\t            return modalInstance;\n\t          };\n\t\n\t          return $modal;\n\t        }\n\t      ]\n\t    };\n\t\n\t    return $modalProvider;\n\t  });\n\t\n\t/* deprecated modal below */\n\t\n\tangular.module('ui.bootstrap.modal')\n\t\n\t  .value('$modalSuppressWarning', false)\n\t\n\t  /**\n\t   * A helper directive for the $modal service. It creates a backdrop element.\n\t   */\n\t  .directive('modalBackdrop', [\n\t    '$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning',\n\t    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {\n\t      var $animateCss = null;\n\t\n\t      if ($injector.has('$animateCss')) {\n\t        $animateCss = $injector.get('$animateCss');\n\t      }\n\t\n\t      return {\n\t        replace: true,\n\t        templateUrl: 'template/modal/backdrop.html',\n\t        compile: function(tElement, tAttrs) {\n\t          tElement.addClass(tAttrs.backdropClass);\n\t          return linkFn;\n\t        }\n\t      };\n\t\n\t      function linkFn(scope, element, attrs) {\n\t        if (!$modalSuppressWarning) {\n\t          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');\n\t        }\n\t        element.addClass('modal-backdrop');\n\t\n\t        if (attrs.modalInClass) {\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              addClass: attrs.modalInClass\n\t            }).start();\n\t          } else {\n\t            $animate.addClass(element, attrs.modalInClass);\n\t          }\n\t\n\t          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t            var done = setIsAsync();\n\t            if ($animateCss) {\n\t              $animateCss(element, {\n\t                removeClass: attrs.modalInClass\n\t              }).start().then(done);\n\t            } else {\n\t              $animate.removeClass(element, attrs.modalInClass).then(done);\n\t            }\n\t          });\n\t        }\n\t      }\n\t    }])\n\t\n\t  .directive('modalWindow', [\n\t    '$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning',\n\t    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {\n\t      var $animateCss = null;\n\t\n\t      if ($injector.has('$animateCss')) {\n\t        $animateCss = $injector.get('$animateCss');\n\t      }\n\t\n\t      return {\n\t        scope: {\n\t          index: '@'\n\t        },\n\t        replace: true,\n\t        transclude: true,\n\t        templateUrl: function(tElement, tAttrs) {\n\t          return tAttrs.templateUrl || 'template/modal/window.html';\n\t        },\n\t        link: function(scope, element, attrs) {\n\t          if (!$modalSuppressWarning) {\n\t            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');\n\t          }\n\t          element.addClass(attrs.windowClass || '');\n\t          element.addClass(attrs.windowTopClass || '');\n\t          scope.size = attrs.size;\n\t\n\t          scope.close = function(evt) {\n\t            var modal = $modalStack.getTop();\n\t            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n\t              evt.preventDefault();\n\t              evt.stopPropagation();\n\t              $modalStack.dismiss(modal.key, 'backdrop click');\n\t            }\n\t          };\n\t\n\t          // moved from template to fix issue #2280\n\t          element.on('click', scope.close);\n\t\n\t          // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n\t          // We can detect that by using this property in the template associated with this directive and then use\n\t          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n\t          scope.$isRendered = true;\n\t\n\t          // Deferred object that will be resolved when this modal is render.\n\t          var modalRenderDeferObj = $q.defer();\n\t          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n\t          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n\t          attrs.$observe('modalRender', function(value) {\n\t            if (value == 'true') {\n\t              modalRenderDeferObj.resolve();\n\t            }\n\t          });\n\t\n\t          modalRenderDeferObj.promise.then(function() {\n\t            var animationPromise = null;\n\t\n\t            if (attrs.modalInClass) {\n\t              if ($animateCss) {\n\t                animationPromise = $animateCss(element, {\n\t                  addClass: attrs.modalInClass\n\t                }).start();\n\t              } else {\n\t                animationPromise = $animate.addClass(element, attrs.modalInClass);\n\t              }\n\t\n\t              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t                var done = setIsAsync();\n\t                if ($animateCss) {\n\t                  $animateCss(element, {\n\t                    removeClass: attrs.modalInClass\n\t                  }).start().then(done);\n\t                } else {\n\t                  $animate.removeClass(element, attrs.modalInClass).then(done);\n\t                }\n\t              });\n\t            }\n\t\n\t\n\t            $q.when(animationPromise).then(function() {\n\t              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n\t              /**\n\t               * Auto-focusing of a freshly-opened modal element causes any child elements\n\t               * with the autofocus attribute to lose focus. This is an issue on touch\n\t               * based devices which will show and then hide the onscreen keyboard.\n\t               * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t               * the modal element if the modal does not contain an autofocus element.\n\t               */\n\t              if (inputWithAutofocus) {\n\t                inputWithAutofocus.focus();\n\t              } else {\n\t                element[0].focus();\n\t              }\n\t            });\n\t\n\t            // Notify {@link $modalStack} that modal is rendered.\n\t            var modal = $modalStack.getTop();\n\t            if (modal) {\n\t              $modalStack.modalRendered(modal.key);\n\t            }\n\t          });\n\t        }\n\t      };\n\t    }])\n\t\n\t  .directive('modalAnimationClass', [\n\t    '$log', '$modalSuppressWarning',\n\t    function ($log, $modalSuppressWarning) {\n\t      return {\n\t        compile: function(tElement, tAttrs) {\n\t          if (!$modalSuppressWarning) {\n\t            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');\n\t          }\n\t          if (tAttrs.modalAnimation) {\n\t            tElement.addClass(tAttrs.modalAnimationClass);\n\t          }\n\t        }\n\t      };\n\t    }])\n\t\n\t  .directive('modalTransclude', [\n\t    '$log', '$modalSuppressWarning',\n\t    function ($log, $modalSuppressWarning) {\n\t    return {\n\t      link: function($scope, $element, $attrs, controller, $transclude) {\n\t        if (!$modalSuppressWarning) {\n\t          $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');\n\t        }\n\t        $transclude($scope.$parent, function(clone) {\n\t          $element.empty();\n\t          $element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .service('$modalStack', [\n\t    '$animate', '$timeout', '$document', '$compile', '$rootScope',\n\t    '$q',\n\t    '$injector',\n\t    '$$multiMap',\n\t    '$$stackedMap',\n\t    '$uibModalStack',\n\t    '$log',\n\t    '$modalSuppressWarning',\n\t    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n\t             $q,\n\t             $injector,\n\t             $$multiMap,\n\t             $$stackedMap,\n\t             $uibModalStack,\n\t             $log,\n\t             $modalSuppressWarning) {\n\t      if (!$modalSuppressWarning) {\n\t        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');\n\t      }\n\t\n\t      angular.extend(this, $uibModalStack);\n\t    }])\n\t\n\t  .provider('$modal', ['$uibModalProvider', function($uibModalProvider) {\n\t    angular.extend(this, $uibModalProvider);\n\t\n\t    this.$get = ['$injector', '$log', '$modalSuppressWarning',\n\t      function ($injector, $log, $modalSuppressWarning) {\n\t        if (!$modalSuppressWarning) {\n\t          $log.warn('$modal is now deprecated. Use $uibModal instead.');\n\t        }\n\t\n\t        return $injector.invoke($uibModalProvider.$get);\n\t      }];\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.pagination', [])\n\t.controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t\n\t  this.init = function(ngModelCtrl_, config) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    this.config = config;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t\n\t    if ($attrs.itemsPerPage) {\n\t      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n\t        self.itemsPerPage = parseInt(value, 10);\n\t        $scope.totalPages = self.calculateTotalPages();\n\t      });\n\t    } else {\n\t      this.itemsPerPage = config.itemsPerPage;\n\t    }\n\t\n\t    $scope.$watch('totalItems', function() {\n\t      $scope.totalPages = self.calculateTotalPages();\n\t    });\n\t\n\t    $scope.$watch('totalPages', function(value) {\n\t      setNumPages($scope.$parent, value); // Readonly variable\n\t\n\t      if ( $scope.page > value ) {\n\t        $scope.selectPage(value);\n\t      } else {\n\t        ngModelCtrl.$render();\n\t      }\n\t    });\n\t  };\n\t\n\t  this.calculateTotalPages = function() {\n\t    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n\t    return Math.max(totalPages || 0, 1);\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n\t  };\n\t\n\t  $scope.selectPage = function(page, evt) {\n\t    if (evt) {\n\t      evt.preventDefault();\n\t    }\n\t\n\t    var clickAllowed = !$scope.ngDisabled || !evt;\n\t    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t      if (evt && evt.target) {\n\t        evt.target.blur();\n\t      }\n\t      ngModelCtrl.$setViewValue(page);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.getText = function(key) {\n\t    return $scope[key + 'Text'] || self.config[key + 'Text'];\n\t  };\n\t\n\t  $scope.noPrevious = function() {\n\t    return $scope.page === 1;\n\t  };\n\t\n\t  $scope.noNext = function() {\n\t    return $scope.page === $scope.totalPages;\n\t  };\n\t}])\n\t\n\t.constant('uibPaginationConfig', {\n\t  itemsPerPage: 10,\n\t  boundaryLinks: false,\n\t  directionLinks: true,\n\t  firstText: 'First',\n\t  previousText: 'Previous',\n\t  nextText: 'Next',\n\t  lastText: 'Last',\n\t  rotate: true\n\t})\n\t\n\t.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@',\n\t      ngDisabled:'='\n\t    },\n\t    require: ['uibPagination', '?ngModel'],\n\t    controller: 'UibPaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pagination.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      // Setup configuration parameters\n\t      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n\t          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n\t      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n\t      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\t\n\t      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\t\n\t      if (attrs.maxSize) {\n\t        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n\t          maxSize = parseInt(value, 10);\n\t          paginationCtrl.render();\n\t        });\n\t      }\n\t\n\t      // Create page object used in template\n\t      function makePage(number, text, isActive) {\n\t        return {\n\t          number: number,\n\t          text: text,\n\t          active: isActive\n\t        };\n\t      }\n\t\n\t      function getPages(currentPage, totalPages) {\n\t        var pages = [];\n\t\n\t        // Default page limits\n\t        var startPage = 1, endPage = totalPages;\n\t        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\t\n\t        // recompute if maxSize\n\t        if (isMaxSized) {\n\t          if (rotate) {\n\t            // Current page is displayed in the middle of the visible ones\n\t            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n\t            endPage   = startPage + maxSize - 1;\n\t\n\t            // Adjust if limit is exceeded\n\t            if (endPage > totalPages) {\n\t              endPage   = totalPages;\n\t              startPage = endPage - maxSize + 1;\n\t            }\n\t          } else {\n\t            // Visible pages are paginated with maxSize\n\t            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\t\n\t            // Adjust last page if limit is exceeded\n\t            endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t          }\n\t        }\n\t\n\t        // Add page number links\n\t        for (var number = startPage; number <= endPage; number++) {\n\t          var page = makePage(number, number, number === currentPage);\n\t          pages.push(page);\n\t        }\n\t\n\t        // Add links to move between page sets\n\t        if (isMaxSized && ! rotate) {\n\t          if (startPage > 1) {\n\t            var previousPageSet = makePage(startPage - 1, '...', false);\n\t            pages.unshift(previousPageSet);\n\t          }\n\t\n\t          if (endPage < totalPages) {\n\t            var nextPageSet = makePage(endPage + 1, '...', false);\n\t            pages.push(nextPageSet);\n\t          }\n\t        }\n\t\n\t        return pages;\n\t      }\n\t\n\t      var originalRender = paginationCtrl.render;\n\t      paginationCtrl.render = function() {\n\t        originalRender();\n\t        if (scope.page > 0 && scope.page <= scope.totalPages) {\n\t          scope.pages = getPages(scope.page, scope.totalPages);\n\t        }\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('uibPagerConfig', {\n\t  itemsPerPage: 10,\n\t  previousText: '« Previous',\n\t  nextText: 'Next »',\n\t  align: true\n\t})\n\t\n\t.directive('uibPager', ['uibPagerConfig', function(pagerConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      ngDisabled: '='\n\t    },\n\t    require: ['uibPager', '?ngModel'],\n\t    controller: 'UibPaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pager.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n\t      paginationCtrl.init(ngModelCtrl, pagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/* Deprecated Pagination Below */\n\t\n\tangular.module('ui.bootstrap.pagination')\n\t.value('$paginationSuppressWarning', false)\n\t.controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {\n\t  if (!$paginationSuppressWarning) {\n\t    $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t\n\t  this.init = function(ngModelCtrl_, config) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    this.config = config;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t\n\t    if ($attrs.itemsPerPage) {\n\t      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n\t        self.itemsPerPage = parseInt(value, 10);\n\t        $scope.totalPages = self.calculateTotalPages();\n\t      });\n\t    } else {\n\t      this.itemsPerPage = config.itemsPerPage;\n\t    }\n\t\n\t    $scope.$watch('totalItems', function() {\n\t      $scope.totalPages = self.calculateTotalPages();\n\t    });\n\t\n\t    $scope.$watch('totalPages', function(value) {\n\t      setNumPages($scope.$parent, value); // Readonly variable\n\t\n\t      if ( $scope.page > value ) {\n\t        $scope.selectPage(value);\n\t      } else {\n\t        ngModelCtrl.$render();\n\t      }\n\t    });\n\t  };\n\t\n\t  this.calculateTotalPages = function() {\n\t    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n\t    return Math.max(totalPages || 0, 1);\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n\t  };\n\t\n\t  $scope.selectPage = function(page, evt) {\n\t    if (evt) {\n\t      evt.preventDefault();\n\t    }\n\t\n\t    var clickAllowed = !$scope.ngDisabled || !evt;\n\t    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t      if (evt && evt.target) {\n\t        evt.target.blur();\n\t      }\n\t      ngModelCtrl.$setViewValue(page);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.getText = function(key) {\n\t    return $scope[key + 'Text'] || self.config[key + 'Text'];\n\t  };\n\t\n\t  $scope.noPrevious = function() {\n\t    return $scope.page === 1;\n\t  };\n\t\n\t  $scope.noNext = function() {\n\t    return $scope.page === $scope.totalPages;\n\t  };\n\t}])\n\t.directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@',\n\t      ngDisabled:'='\n\t    },\n\t    require: ['pagination', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pagination.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$paginationSuppressWarning) {\n\t        $log.warn('pagination is now deprecated. Use uib-pagination instead.');\n\t      }\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      // Setup configuration parameters\n\t      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n\t          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n\t      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n\t      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\t\n\t      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\t\n\t      if (attrs.maxSize) {\n\t        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n\t          maxSize = parseInt(value, 10);\n\t          paginationCtrl.render();\n\t        });\n\t      }\n\t\n\t      // Create page object used in template\n\t      function makePage(number, text, isActive) {\n\t        return {\n\t          number: number,\n\t          text: text,\n\t          active: isActive\n\t        };\n\t      }\n\t\n\t      function getPages(currentPage, totalPages) {\n\t        var pages = [];\n\t\n\t        // Default page limits\n\t        var startPage = 1, endPage = totalPages;\n\t        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\t\n\t        // recompute if maxSize\n\t        if (isMaxSized) {\n\t          if (rotate) {\n\t            // Current page is displayed in the middle of the visible ones\n\t            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n\t            endPage   = startPage + maxSize - 1;\n\t\n\t            // Adjust if limit is exceeded\n\t            if (endPage > totalPages) {\n\t              endPage   = totalPages;\n\t              startPage = endPage - maxSize + 1;\n\t            }\n\t          } else {\n\t            // Visible pages are paginated with maxSize\n\t            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\t\n\t            // Adjust last page if limit is exceeded\n\t            endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t          }\n\t        }\n\t\n\t        // Add page number links\n\t        for (var number = startPage; number <= endPage; number++) {\n\t          var page = makePage(number, number, number === currentPage);\n\t          pages.push(page);\n\t        }\n\t\n\t        // Add links to move between page sets\n\t        if (isMaxSized && ! rotate) {\n\t          if (startPage > 1) {\n\t            var previousPageSet = makePage(startPage - 1, '...', false);\n\t            pages.unshift(previousPageSet);\n\t          }\n\t\n\t          if (endPage < totalPages) {\n\t            var nextPageSet = makePage(endPage + 1, '...', false);\n\t            pages.push(nextPageSet);\n\t          }\n\t        }\n\t\n\t        return pages;\n\t      }\n\t\n\t      var originalRender = paginationCtrl.render;\n\t      paginationCtrl.render = function() {\n\t        originalRender();\n\t        if (scope.page > 0 && scope.page <= scope.totalPages) {\n\t          scope.pages = getPages(scope.page, scope.totalPages);\n\t        }\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      ngDisabled: '='\n\t    },\n\t    require: ['pager', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pager.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$paginationSuppressWarning) {\n\t        $log.warn('pager is now deprecated. Use uib-pager instead.');\n\t      }\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n\t      paginationCtrl.init(ngModelCtrl, pagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html tooltips, and selector delegation.\n\t */\n\tangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\t\n\t/**\n\t * The $tooltip service creates tooltip- and popover-like directives as well as\n\t * houses global options for them.\n\t */\n\t.provider('$uibTooltip', function() {\n\t  // The default options tooltip and popover.\n\t  var defaultOptions = {\n\t    placement: 'top',\n\t    animation: true,\n\t    popupDelay: 0,\n\t    popupCloseDelay: 0,\n\t    useContentExp: false\n\t  };\n\t\n\t  // Default hide triggers for each show trigger\n\t  var triggerMap = {\n\t    'mouseenter': 'mouseleave',\n\t    'click': 'click',\n\t    'focus': 'blur',\n\t    'none': ''\n\t  };\n\t\n\t  // The options specified to the provider globally.\n\t  var globalOptions = {};\n\t\n\t  /**\n\t   * `options({})` allows global configuration of all tooltips in the\n\t   * application.\n\t   *\n\t   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n\t   *     // place tooltips left instead of top by default\n\t   *     $tooltipProvider.options( { placement: 'left' } );\n\t   *   });\n\t   */\n\t\tthis.options = function(value) {\n\t\t\tangular.extend(globalOptions, value);\n\t\t};\n\t\n\t  /**\n\t   * This allows you to extend the set of trigger mappings available. E.g.:\n\t   *\n\t   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n\t   */\n\t  this.setTriggers = function setTriggers(triggers) {\n\t    angular.extend(triggerMap, triggers);\n\t  };\n\t\n\t  /**\n\t   * This is a helper function for translating camel-case to snake-case.\n\t   */\n\t  function snake_case(name) {\n\t    var regexp = /[A-Z]/g;\n\t    var separator = '-';\n\t    return name.replace(regexp, function(letter, pos) {\n\t      return (pos ? separator : '') + letter.toLowerCase();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns the actual instance of the $tooltip service.\n\t   * TODO support multiple triggers\n\t   */\n\t  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n\t    var openedTooltips = $$stackedMap.createNew();\n\t    $document.on('keypress', function(e) {\n\t      if (e.which === 27) {\n\t        var last = openedTooltips.top();\n\t        if (last) {\n\t          last.value.close();\n\t          openedTooltips.removeTop();\n\t          last = null;\n\t        }\n\t      }\n\t    });\n\t\n\t    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n\t      options = angular.extend({}, defaultOptions, globalOptions, options);\n\t\n\t      /**\n\t       * Returns an object of show and hide triggers.\n\t       *\n\t       * If a trigger is supplied,\n\t       * it is used to show the tooltip; otherwise, it will use the `trigger`\n\t       * option passed to the `$tooltipProvider.options` method; else it will\n\t       * default to the trigger supplied to this directive factory.\n\t       *\n\t       * The hide trigger is based on the show trigger. If the `trigger` option\n\t       * was passed to the `$tooltipProvider.options` method, it will use the\n\t       * mapped trigger from `triggerMap` or the passed trigger if the map is\n\t       * undefined; otherwise, it uses the `triggerMap` value of the show\n\t       * trigger; else it will just use the show trigger.\n\t       */\n\t      function getTriggers(trigger) {\n\t        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n\t        var hide = show.map(function(trigger) {\n\t          return triggerMap[trigger] || trigger;\n\t        });\n\t        return {\n\t          show: show,\n\t          hide: hide\n\t        };\n\t      }\n\t\n\t      var directiveName = snake_case(ttType);\n\t\n\t      var startSym = $interpolate.startSymbol();\n\t      var endSym = $interpolate.endSymbol();\n\t      var template =\n\t        '<div '+ directiveName + '-popup '+\n\t          'title=\"' + startSym + 'title' + endSym + '\" '+\n\t          (options.useContentExp ?\n\t            'content-exp=\"contentExp()\" ' :\n\t            'content=\"' + startSym + 'content' + endSym + '\" ') +\n\t          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n\t          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n\t          'animation=\"animation\" ' +\n\t          'is-open=\"isOpen\"' +\n\t          'origin-scope=\"origScope\" ' +\n\t          'style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"' +\n\t          '>' +\n\t        '</div>';\n\t\n\t      return {\n\t        compile: function(tElem, tAttrs) {\n\t          var tooltipLinker = $compile(template);\n\t\n\t          return function link(scope, element, attrs, tooltipCtrl) {\n\t            var tooltip;\n\t            var tooltipLinkedScope;\n\t            var transitionTimeout;\n\t            var showTimeout;\n\t            var hideTimeout;\n\t            var positionTimeout;\n\t            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n\t            var triggers = getTriggers(undefined);\n\t            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n\t            var ttScope = scope.$new(true);\n\t            var repositionScheduled = false;\n\t            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n\t            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n\t            var observers = [];\n\t\n\t            var positionTooltip = function() {\n\t              // check if tooltip exists and is not empty\n\t              if (!tooltip || !tooltip.html()) { return; }\n\t\n\t              if (!positionTimeout) {\n\t                positionTimeout = $timeout(function() {\n\t                  // Reset the positioning.\n\t                  tooltip.css({ top: 0, left: 0 });\n\t\n\t                  // Now set the calculated positioning.\n\t                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n\t                  ttCss.top += 'px';\n\t                  ttCss.left += 'px';\n\t                  ttCss.visibility = 'visible';\n\t                  tooltip.css(ttCss);\n\t\n\t                  positionTimeout = null;\n\t                }, 0, false);\n\t              }\n\t            };\n\t\n\t            // Set up the correct scope to allow transclusion later\n\t            ttScope.origScope = scope;\n\t\n\t            // By default, the tooltip is not open.\n\t            // TODO add ability to start tooltip opened\n\t            ttScope.isOpen = false;\n\t            openedTooltips.add(ttScope, {\n\t              close: hide\n\t            });\n\t\n\t            function toggleTooltipBind() {\n\t              if (!ttScope.isOpen) {\n\t                showTooltipBind();\n\t              } else {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip with delay if specified, otherwise show it immediately\n\t            function showTooltipBind() {\n\t              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n\t                return;\n\t              }\n\t\n\t              cancelHide();\n\t              prepareTooltip();\n\t\n\t              if (ttScope.popupDelay) {\n\t                // Do nothing if the tooltip was already scheduled to pop-up.\n\t                // This happens if show is triggered multiple times before any hide is triggered.\n\t                if (!showTimeout) {\n\t                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n\t                }\n\t              } else {\n\t                show();\n\t              }\n\t            }\n\t\n\t            function hideTooltipBind() {\n\t              cancelShow();\n\t\n\t              if (ttScope.popupCloseDelay) {\n\t                if (!hideTimeout) {\n\t                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n\t                }\n\t              } else {\n\t                hide();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip popup element.\n\t            function show() {\n\t              cancelShow();\n\t              cancelHide();\n\t\n\t              // Don't show empty tooltips.\n\t              if (!ttScope.content) {\n\t                return angular.noop;\n\t              }\n\t\n\t              createTooltip();\n\t\n\t              // And show the tooltip.\n\t              ttScope.$evalAsync(function() {\n\t                ttScope.isOpen = true;\n\t                assignIsOpen(true);\n\t                positionTooltip();\n\t              });\n\t            }\n\t\n\t            function cancelShow() {\n\t              if (showTimeout) {\n\t                $timeout.cancel(showTimeout);\n\t                showTimeout = null;\n\t              }\n\t\n\t              if (positionTimeout) {\n\t                $timeout.cancel(positionTimeout);\n\t                positionTimeout = null;\n\t              }\n\t            }\n\t\n\t            // Hide the tooltip popup element.\n\t            function hide() {\n\t              cancelShow();\n\t              cancelHide();\n\t\n\t              if (!ttScope) {\n\t                return;\n\t              }\n\t\n\t              // First things first: we don't show it anymore.\n\t              ttScope.$evalAsync(function() {\n\t                ttScope.isOpen = false;\n\t                assignIsOpen(false);\n\t                // And now we remove it from the DOM. However, if we have animation, we\n\t                // need to wait for it to expire beforehand.\n\t                // FIXME: this is a placeholder for a port of the transitions library.\n\t                // The fade transition in TWBS is 150ms.\n\t                if (ttScope.animation) {\n\t                  if (!transitionTimeout) {\n\t                    transitionTimeout = $timeout(removeTooltip, 150, false);\n\t                  }\n\t                } else {\n\t                  removeTooltip();\n\t                }\n\t              });\n\t            }\n\t\n\t            function cancelHide() {\n\t              if (hideTimeout) {\n\t                $timeout.cancel(hideTimeout);\n\t                hideTimeout = null;\n\t              }\n\t              if (transitionTimeout) {\n\t                $timeout.cancel(transitionTimeout);\n\t                transitionTimeout = null;\n\t              }\n\t            }\n\t\n\t            function createTooltip() {\n\t              // There can only be one tooltip element per directive shown at once.\n\t              if (tooltip) {\n\t                return;\n\t              }\n\t\n\t              tooltipLinkedScope = ttScope.$new();\n\t              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n\t                if (appendToBody) {\n\t                  $document.find('body').append(tooltip);\n\t                } else {\n\t                  element.after(tooltip);\n\t                }\n\t              });\n\t\n\t              prepObservers();\n\t            }\n\t\n\t            function removeTooltip() {\n\t              unregisterObservers();\n\t\n\t              transitionTimeout = null;\n\t              if (tooltip) {\n\t                tooltip.remove();\n\t                tooltip = null;\n\t              }\n\t              if (tooltipLinkedScope) {\n\t                tooltipLinkedScope.$destroy();\n\t                tooltipLinkedScope = null;\n\t              }\n\t            }\n\t\n\t            /**\n\t             * Set the inital scope values. Once\n\t             * the tooltip is created, the observers\n\t             * will be added to keep things in synch.\n\t             */\n\t            function prepareTooltip() {\n\t              ttScope.title = attrs[prefix + 'Title'];\n\t              if (contentParse) {\n\t                ttScope.content = contentParse(scope);\n\t              } else {\n\t                ttScope.content = attrs[ttType];\n\t              }\n\t\n\t              ttScope.popupClass = attrs[prefix + 'Class'];\n\t              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\t\n\t              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n\t              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n\t              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n\t              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n\t            }\n\t\n\t            function assignIsOpen(isOpen) {\n\t              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n\t                isOpenParse.assign(scope, isOpen);\n\t              }\n\t            }\n\t\n\t            ttScope.contentExp = function() {\n\t              return ttScope.content;\n\t            };\n\t\n\t            /**\n\t             * Observe the relevant attributes.\n\t             */\n\t            attrs.$observe('disabled', function(val) {\n\t              if (val) {\n\t                cancelShow();\n\t              }\n\t\n\t              if (val && ttScope.isOpen) {\n\t                hide();\n\t              }\n\t            });\n\t\n\t            if (isOpenParse) {\n\t              scope.$watch(isOpenParse, function(val) {\n\t                /*jshint -W018 */\n\t                if (ttScope && !val === ttScope.isOpen) {\n\t                  toggleTooltipBind();\n\t                }\n\t                /*jshint +W018 */\n\t              });\n\t            }\n\t\n\t            function prepObservers() {\n\t              observers.length = 0;\n\t\n\t              if (contentParse) {\n\t                observers.push(\n\t                  scope.$watch(contentParse, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    }\n\t                  })\n\t                );\n\t\n\t                observers.push(\n\t                  tooltipLinkedScope.$watch(function() {\n\t                    if (!repositionScheduled) {\n\t                      repositionScheduled = true;\n\t                      tooltipLinkedScope.$$postDigest(function() {\n\t                        repositionScheduled = false;\n\t                        if (ttScope && ttScope.isOpen) {\n\t                          positionTooltip();\n\t                        }\n\t                      });\n\t                    }\n\t                  })\n\t                );\n\t              } else {\n\t                observers.push(\n\t                  attrs.$observe(ttType, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    } else {\n\t                      positionTooltip();\n\t                    }\n\t                  })\n\t                );\n\t              }\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Title', function(val) {\n\t                  ttScope.title = val;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Placement', function(val) {\n\t                  ttScope.placement = val ? val : options.placement;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t            }\n\t\n\t            function unregisterObservers() {\n\t              if (observers.length) {\n\t                angular.forEach(observers, function(observer) {\n\t                  observer();\n\t                });\n\t                observers.length = 0;\n\t              }\n\t            }\n\t\n\t            var unregisterTriggers = function() {\n\t              triggers.show.forEach(function(trigger) {\n\t                element.unbind(trigger, showTooltipBind);\n\t              });\n\t              triggers.hide.forEach(function(trigger) {\n\t                trigger.split(' ').forEach(function(hideTrigger) {\n\t                  element[0].removeEventListener(hideTrigger, hideTooltipBind);\n\t                });\n\t              });\n\t            };\n\t\n\t            function prepTriggers() {\n\t              var val = attrs[prefix + 'Trigger'];\n\t              unregisterTriggers();\n\t\n\t              triggers = getTriggers(val);\n\t\n\t              if (triggers.show !== 'none') {\n\t                triggers.show.forEach(function(trigger, idx) {\n\t                  // Using raw addEventListener due to jqLite/jQuery bug - #4060\n\t                  if (trigger === triggers.hide[idx]) {\n\t                    element[0].addEventListener(trigger, toggleTooltipBind);\n\t                  } else if (trigger) {\n\t                    element[0].addEventListener(trigger, showTooltipBind);\n\t                    triggers.hide[idx].split(' ').forEach(function(trigger) {\n\t                      element[0].addEventListener(trigger, hideTooltipBind);\n\t                    });\n\t                  }\n\t\n\t                  element.on('keypress', function(e) {\n\t                    if (e.which === 27) {\n\t                      hideTooltipBind();\n\t                    }\n\t                  });\n\t                });\n\t              }\n\t            }\n\t\n\t            prepTriggers();\n\t\n\t            var animation = scope.$eval(attrs[prefix + 'Animation']);\n\t            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\t\n\t            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);\n\t            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\t\n\t            // if a tooltip is attached to <body> we need to remove it on\n\t            // location change as its parent scope will probably not be destroyed\n\t            // by the change.\n\t            if (appendToBody) {\n\t              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {\n\t                if (ttScope.isOpen) {\n\t                  hide();\n\t                }\n\t              });\n\t            }\n\t\n\t            // Make sure tooltip is destroyed and removed.\n\t            scope.$on('$destroy', function onDestroyTooltip() {\n\t              cancelShow();\n\t              cancelHide();\n\t              unregisterTriggers();\n\t              removeTooltip();\n\t              openedTooltips.remove(ttScope);\n\t              ttScope = null;\n\t            });\n\t          };\n\t        }\n\t      };\n\t    };\n\t  }];\n\t})\n\t\n\t// This is mostly ngInclude code but with a custom scope\n\t.directive('uibTooltipTemplateTransclude', [\n\t         '$animate', '$sce', '$compile', '$templateRequest',\n\tfunction ($animate ,  $sce ,  $compile ,  $templateRequest) {\n\t  return {\n\t    link: function(scope, elem, attrs) {\n\t      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\t\n\t      var changeCounter = 0,\n\t        currentScope,\n\t        previousElement,\n\t        currentElement;\n\t\n\t      var cleanupLastIncludeContent = function() {\n\t        if (previousElement) {\n\t          previousElement.remove();\n\t          previousElement = null;\n\t        }\n\t\n\t        if (currentScope) {\n\t          currentScope.$destroy();\n\t          currentScope = null;\n\t        }\n\t\n\t        if (currentElement) {\n\t          $animate.leave(currentElement).then(function() {\n\t            previousElement = null;\n\t          });\n\t          previousElement = currentElement;\n\t          currentElement = null;\n\t        }\n\t      };\n\t\n\t      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n\t        var thisChangeId = ++changeCounter;\n\t\n\t        if (src) {\n\t          //set the 2nd param to true to ignore the template request error so that the inner\n\t          //contents and scope can be cleaned up.\n\t          $templateRequest(src, true).then(function(response) {\n\t            if (thisChangeId !== changeCounter) { return; }\n\t            var newScope = origScope.$new();\n\t            var template = response;\n\t\n\t            var clone = $compile(template)(newScope, function(clone) {\n\t              cleanupLastIncludeContent();\n\t              $animate.enter(clone, elem);\n\t            });\n\t\n\t            currentScope = newScope;\n\t            currentElement = clone;\n\t\n\t            currentScope.$emit('$includeContentLoaded', src);\n\t          }, function() {\n\t            if (thisChangeId === changeCounter) {\n\t              cleanupLastIncludeContent();\n\t              scope.$emit('$includeContentError', src);\n\t            }\n\t          });\n\t          scope.$emit('$includeContentRequested', src);\n\t        } else {\n\t          cleanupLastIncludeContent();\n\t        }\n\t      });\n\t\n\t      scope.$on('$destroy', cleanupLastIncludeContent);\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * Note that it's intentional that these classes are *not* applied through $animate.\n\t * They must not be animated as they're expected to be present on the tooltip on\n\t * initialization.\n\t */\n\t.directive('uibTooltipClasses', function() {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attrs) {\n\t      if (scope.placement) {\n\t        element.addClass(scope.placement);\n\t      }\n\t\n\t      if (scope.popupClass) {\n\t        element.addClass(scope.popupClass);\n\t      }\n\t\n\t      if (scope.animation()) {\n\t        element.addClass(attrs.tooltipAnimationClass);\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltipPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-popup.html',\n\t    link: function(scope, element) {\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n\t}])\n\t\n\t.directive('uibTooltipTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n\t    link: function(scope, element) {\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibTooltipHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n\t    link: function(scope, element) {\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}]);\n\t\n\t/* Deprecated tooltip below */\n\t\n\tangular.module('ui.bootstrap.tooltip')\n\t\n\t.value('$tooltipSuppressWarning', false)\n\t\n\t.provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {\n\t  angular.extend(this, $uibTooltipProvider);\n\t\n\t  this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {\n\t    if (!$tooltipSuppressWarning) {\n\t      $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');\n\t    }\n\t\n\t    return $injector.invoke($uibTooltipProvider.$get);\n\t  }];\n\t}])\n\t\n\t// This is mostly ngInclude code but with a custom scope\n\t.directive('tooltipTemplateTransclude', [\n\t         '$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning',\n\tfunction ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {\n\t  return {\n\t    link: function(scope, elem, attrs) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');\n\t      }\n\t\n\t      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\t\n\t      var changeCounter = 0,\n\t        currentScope,\n\t        previousElement,\n\t        currentElement;\n\t\n\t      var cleanupLastIncludeContent = function() {\n\t        if (previousElement) {\n\t          previousElement.remove();\n\t          previousElement = null;\n\t        }\n\t        if (currentScope) {\n\t          currentScope.$destroy();\n\t          currentScope = null;\n\t        }\n\t        if (currentElement) {\n\t          $animate.leave(currentElement).then(function() {\n\t            previousElement = null;\n\t          });\n\t          previousElement = currentElement;\n\t          currentElement = null;\n\t        }\n\t      };\n\t\n\t      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {\n\t        var thisChangeId = ++changeCounter;\n\t\n\t        if (src) {\n\t          //set the 2nd param to true to ignore the template request error so that the inner\n\t          //contents and scope can be cleaned up.\n\t          $templateRequest(src, true).then(function(response) {\n\t            if (thisChangeId !== changeCounter) { return; }\n\t            var newScope = origScope.$new();\n\t            var template = response;\n\t\n\t            var clone = $compile(template)(newScope, function(clone) {\n\t              cleanupLastIncludeContent();\n\t              $animate.enter(clone, elem);\n\t            });\n\t\n\t            currentScope = newScope;\n\t            currentElement = clone;\n\t\n\t            currentScope.$emit('$includeContentLoaded', src);\n\t          }, function() {\n\t            if (thisChangeId === changeCounter) {\n\t              cleanupLastIncludeContent();\n\t              scope.$emit('$includeContentError', src);\n\t            }\n\t          });\n\t          scope.$emit('$includeContentRequested', src);\n\t        } else {\n\t          cleanupLastIncludeContent();\n\t        }\n\t      });\n\t\n\t      scope.$on('$destroy', cleanupLastIncludeContent);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attrs) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');\n\t      }\n\t\n\t      if (scope.placement) {\n\t        element.addClass(scope.placement);\n\t      }\n\t      if (scope.popupClass) {\n\t        element.addClass(scope.popupClass);\n\t      }\n\t      if (scope.animation()) {\n\t        element.addClass(attrs.tooltipAnimationClass);\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-popup.html',\n\t    link: function(scope, element) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');\n\t      }\n\t\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltip', ['$tooltip', function($tooltip) {\n\t  return $tooltip('tooltip', 'tooltip', 'mouseenter');\n\t}])\n\t\n\t.directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n\t    link: function(scope, element) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');\n\t      }\n\t\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipTemplate', ['$tooltip', function($tooltip) {\n\t  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n\t    link: function(scope, element) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');\n\t      }\n\t\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipHtml', ['$tooltip', function($tooltip) {\n\t  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: popup delay, animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, and selector delegatation.\n\t */\n\tangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\t\n\t.directive('uibPopoverTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/popover/popover-template.html',\n\t    link: function(scope, element) {\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover-html.html',\n\t    link: function(scope, element) {\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover.html',\n\t    link: function(scope, element) {\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopover', 'popover', 'click');\n\t}]);\n\t\n\t/* Deprecated popover below */\n\t\n\tangular.module('ui.bootstrap.popover')\n\t\n\t.value('$popoverSuppressWarning', false)\n\t\n\t.directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/popover/popover-template.html',\n\t    link: function(scope, element) {\n\t      if (!$popoverSuppressWarning) {\n\t        $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');\n\t      }\n\t\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('popoverTemplate', ['$tooltip', function($tooltip) {\n\t  return $tooltip('popoverTemplate', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover-html.html',\n\t    link: function(scope, element) {\n\t      if (!$popoverSuppressWarning) {\n\t        $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');\n\t      }\n\t\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('popoverHtml', ['$tooltip', function($tooltip) {\n\t  return $tooltip('popoverHtml', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover.html',\n\t    link: function(scope, element) {\n\t      if (!$popoverSuppressWarning) {\n\t        $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');\n\t      }\n\t\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('popover', ['$tooltip', function($tooltip) {\n\t\n\t  return $tooltip('popover', 'popover', 'click');\n\t}]);\n\t\n\tangular.module('ui.bootstrap.progressbar', [])\n\t\n\t.constant('uibProgressConfig', {\n\t  animate: true,\n\t  max: 100\n\t})\n\t\n\t.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n\t  var self = this,\n\t      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t  this.bars = [];\n\t  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\t\n\t  this.addBar = function(bar, element, attrs) {\n\t    if (!animate) {\n\t      element.css({'transition': 'none'});\n\t    }\n\t\n\t    this.bars.push(bar);\n\t\n\t    bar.max = $scope.max;\n\t    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\t\n\t    bar.$watch('value', function(value) {\n\t      bar.recalculatePercentage();\n\t    });\n\t\n\t    bar.recalculatePercentage = function() {\n\t      var totalPercentage = self.bars.reduce(function(total, bar) {\n\t        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\t        return total + bar.percent;\n\t      }, 0);\n\t\n\t      if (totalPercentage > 100) {\n\t        bar.percent -= totalPercentage - 100;\n\t      }\n\t    };\n\t\n\t    bar.$on('$destroy', function() {\n\t      element = null;\n\t      self.removeBar(bar);\n\t    });\n\t  };\n\t\n\t  this.removeBar = function(bar) {\n\t    this.bars.splice(this.bars.indexOf(bar), 1);\n\t    this.bars.forEach(function (bar) {\n\t      bar.recalculatePercentage();\n\t    });\n\t  };\n\t\n\t  $scope.$watch('max', function(max) {\n\t    self.bars.forEach(function(bar) {\n\t      bar.max = $scope.max;\n\t      bar.recalculatePercentage();\n\t    });\n\t  });\n\t}])\n\t\n\t.directive('uibProgress', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    require: 'uibProgress',\n\t    scope: {\n\t      max: '=?'\n\t    },\n\t    templateUrl: 'template/progressbar/progress.html'\n\t  };\n\t})\n\t\n\t.directive('uibBar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    require: '^uibProgress',\n\t    scope: {\n\t      value: '=',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/bar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, element, attrs);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibProgressbar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    scope: {\n\t      value: '=',\n\t      max: '=?',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/progressbar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated progressbar below */\n\t\n\tangular.module('ui.bootstrap.progressbar')\n\t\n\t.value('$progressSuppressWarning', false)\n\t\n\t.controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {\n\t  if (!$progressSuppressWarning) {\n\t    $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t  this.bars = [];\n\t  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\t\n\t  this.addBar = function(bar, element, attrs) {\n\t    if (!animate) {\n\t      element.css({'transition': 'none'});\n\t    }\n\t\n\t    this.bars.push(bar);\n\t\n\t    bar.max = $scope.max;\n\t    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\t\n\t    bar.$watch('value', function(value) {\n\t      bar.recalculatePercentage();\n\t    });\n\t\n\t    bar.recalculatePercentage = function() {\n\t      bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\t\n\t      var totalPercentage = self.bars.reduce(function(total, bar) {\n\t        return total + bar.percent;\n\t      }, 0);\n\t\n\t      if (totalPercentage > 100) {\n\t        bar.percent -= totalPercentage - 100;\n\t      }\n\t    };\n\t\n\t    bar.$on('$destroy', function() {\n\t      element = null;\n\t      self.removeBar(bar);\n\t    });\n\t  };\n\t\n\t  this.removeBar = function(bar) {\n\t    this.bars.splice(this.bars.indexOf(bar), 1);\n\t  };\n\t\n\t  $scope.$watch('max', function(max) {\n\t    self.bars.forEach(function(bar) {\n\t      bar.max = $scope.max;\n\t      bar.recalculatePercentage();\n\t    });\n\t  });\n\t}])\n\t\n\t.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'ProgressController',\n\t    require: 'progress',\n\t    scope: {\n\t      max: '=?',\n\t      title: '@?'\n\t    },\n\t    templateUrl: 'template/progressbar/progress.html',\n\t    link: function() {\n\t      if (!$progressSuppressWarning) {\n\t        $log.warn('progress is now deprecated. Use uib-progress instead.');\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    require: '^progress',\n\t    scope: {\n\t      value: '=',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/bar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      if (!$progressSuppressWarning) {\n\t        $log.warn('bar is now deprecated. Use uib-bar instead.');\n\t      }\n\t      progressCtrl.addBar(scope, element);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'ProgressController',\n\t    scope: {\n\t      value: '=',\n\t      max: '=?',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/progressbar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      if (!$progressSuppressWarning) {\n\t        $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');\n\t      }\n\t      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.rating', [])\n\t\n\t.constant('uibRatingConfig', {\n\t  max: 5,\n\t  stateOn: null,\n\t  stateOff: null,\n\t  titles : ['one', 'two', 'three', 'four', 'five']\n\t})\n\t\n\t.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n\t  var ngModelCtrl  = { $setViewValue: angular.noop };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.push(function(value) {\n\t      if (angular.isNumber(value) && value << 0 !== value) {\n\t        value = Math.round(value);\n\t      }\n\t      return value;\n\t    });\n\t\n\t    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n\t    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\t    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n\t    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n\t      tmpTitles : ratingConfig.titles;\n\t\n\t    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n\t      $scope.$parent.$eval($attrs.ratingStates) :\n\t      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n\t    $scope.range = this.buildTemplateObjects(ratingStates);\n\t  };\n\t\n\t  this.buildTemplateObjects = function(states) {\n\t    for (var i = 0, n = states.length; i < n; i++) {\n\t      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n\t    }\n\t    return states;\n\t  };\n\t\n\t  this.getTitle = function(index) {\n\t    if (index >= this.titles.length) {\n\t      return index + 1;\n\t    } else {\n\t      return this.titles[index];\n\t    }\n\t  };\n\t\n\t  $scope.rate = function(value) {\n\t    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n\t      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.enter = function(value) {\n\t    if (!$scope.readonly) {\n\t      $scope.value = value;\n\t    }\n\t    $scope.onHover({value: value});\n\t  };\n\t\n\t  $scope.reset = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t    $scope.onLeave();\n\t  };\n\t\n\t  $scope.onKeydown = function(evt) {\n\t    if (/(37|38|39|40)/.test(evt.which)) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n\t    }\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t  };\n\t}])\n\t\n\t.directive('uibRating', function() {\n\t  return {\n\t    require: ['uibRating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'UibRatingController',\n\t    templateUrl: 'template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      ratingCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated rating below */\n\t\n\tangular.module('ui.bootstrap.rating')\n\t\n\t.value('$ratingSuppressWarning', false)\n\t\n\t.controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {\n\t  if (!$ratingSuppressWarning) {\n\t    $log.warn('RatingController is now deprecated. Use UibRatingController instead.');\n\t  }\n\t\n\t  angular.extend(this, $controller('UibRatingController', {\n\t    $scope: $scope,\n\t    $attrs: $attrs\n\t  }));\n\t}])\n\t\n\t.directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {\n\t  return {\n\t    require: ['rating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'RatingController',\n\t    templateUrl: 'template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$ratingSuppressWarning) {\n\t        $log.warn('rating is now deprecated. Use uib-rating instead.');\n\t      }\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      ratingCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t}]);\n\t\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.bootstrap.tabs\n\t *\n\t * @description\n\t * AngularJS version of the tabs directive.\n\t */\n\t\n\tangular.module('ui.bootstrap.tabs', [])\n\t\n\t.controller('UibTabsetController', ['$scope', function ($scope) {\n\t  var ctrl = this,\n\t      tabs = ctrl.tabs = $scope.tabs = [];\n\t\n\t  ctrl.select = function(selectedTab) {\n\t    angular.forEach(tabs, function(tab) {\n\t      if (tab.active && tab !== selectedTab) {\n\t        tab.active = false;\n\t        tab.onDeselect();\n\t        selectedTab.selectCalled = false;\n\t      }\n\t    });\n\t    selectedTab.active = true;\n\t    // only call select if it has not already been called\n\t    if (!selectedTab.selectCalled) {\n\t      selectedTab.onSelect();\n\t      selectedTab.selectCalled = true;\n\t    }\n\t  };\n\t\n\t  ctrl.addTab = function addTab(tab) {\n\t    tabs.push(tab);\n\t    // we can't run the select function on the first tab\n\t    // since that would select it twice\n\t    if (tabs.length === 1 && tab.active !== false) {\n\t      tab.active = true;\n\t    } else if (tab.active) {\n\t      ctrl.select(tab);\n\t    } else {\n\t      tab.active = false;\n\t    }\n\t  };\n\t\n\t  ctrl.removeTab = function removeTab(tab) {\n\t    var index = tabs.indexOf(tab);\n\t    //Select a new tab if the tab to be removed is selected and not destroyed\n\t    if (tab.active && tabs.length > 1 && !destroyed) {\n\t      //If this is the last tab, select the previous tab. else, the next tab.\n\t      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n\t      ctrl.select(tabs[newActiveIndex]);\n\t    }\n\t    tabs.splice(index, 1);\n\t  };\n\t\n\t  var destroyed;\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t  });\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabset\n\t * @restrict EA\n\t *\n\t * @description\n\t * Tabset is the outer container for the tabs directive\n\t *\n\t * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n\t * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <uib-tabset>\n\t      <uib-tab heading=\"Tab 1\"><b>First</b> Content!</uib-tab>\n\t      <uib-tab heading=\"Tab 2\"><i>Second</i> Content!</uib-tab>\n\t    </uib-tabset>\n\t    <hr />\n\t    <uib-tabset vertical=\"true\">\n\t      <uib-tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</uib-tab>\n\t      <uib-tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</uib-tab>\n\t    </uib-tabset>\n\t    <uib-tabset justified=\"true\">\n\t      <uib-tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</uib-tab>\n\t      <uib-tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</uib-tab>\n\t    </uib-tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('uibTabset', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@'\n\t    },\n\t    controller: 'UibTabsetController',\n\t    templateUrl: 'template/tabs/tabset.html',\n\t    link: function(scope, element, attrs) {\n\t      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n\t      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n\t    }\n\t  };\n\t})\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tab\n\t * @restrict EA\n\t *\n\t * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n\t * @param {string=} select An expression to evaluate when the tab is selected.\n\t * @param {boolean=} active A binding, telling whether or not this tab is selected.\n\t * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n\t *\n\t * @description\n\t * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <div ng-controller=\"TabsDemoCtrl\">\n\t      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n\t        Select item 1, using active binding\n\t      </button>\n\t      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n\t        Enable/disable item 2, using disabled binding\n\t      </button>\n\t      <br />\n\t      <uib-tabset>\n\t        <uib-tab heading=\"Tab 1\">First Tab</uib-tab>\n\t        <uib-tab select=\"alertMe()\">\n\t          <uib-tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n\t          Second Tab, with alert callback and html heading!\n\t        </uib-tab>\n\t        <uib-tab ng-repeat=\"item in items\"\n\t          heading=\"{{item.title}}\"\n\t          disabled=\"item.disabled\"\n\t          active=\"item.active\">\n\t          {{item.content}}\n\t        </uib-tab>\n\t      </uib-tabset>\n\t    </div>\n\t  </file>\n\t  <file name=\"script.js\">\n\t    function TabsDemoCtrl($scope) {\n\t      $scope.items = [\n\t        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n\t        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n\t      ];\n\t\n\t      $scope.alertMe = function() {\n\t        setTimeout(function() {\n\t          alert(\"You've selected the alert tab!\");\n\t        });\n\t      };\n\t    };\n\t  </file>\n\t</example>\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabHeading\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <uib-tabset>\n\t      <uib-tab>\n\t        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>\n\t        And some content, too!\n\t      </uib-tab>\n\t      <uib-tab>\n\t        <uib-tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n\t        That's right.\n\t      </uib-tab>\n\t    </uib-tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('uibTab', ['$parse', function($parse) {\n\t  return {\n\t    require: '^uibTabset',\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/tabs/tab.html',\n\t    transclude: true,\n\t    scope: {\n\t      active: '=?',\n\t      heading: '@',\n\t      onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t                          //once it inserts the tab's content into the dom\n\t      onDeselect: '&deselect'\n\t    },\n\t    controller: function() {\n\t      //Empty controller so other directives can require being 'under' a tab\n\t    },\n\t    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          tabsetCtrl.select(scope);\n\t        }\n\t      });\n\t\n\t      scope.disabled = false;\n\t      if (attrs.disable) {\n\t        scope.$parent.$watch($parse(attrs.disable), function(value) {\n\t          scope.disabled = !! value;\n\t        });\n\t      }\n\t\n\t      scope.select = function() {\n\t        if (!scope.disabled) {\n\t          scope.active = true;\n\t        }\n\t      };\n\t\n\t      tabsetCtrl.addTab(scope);\n\t      scope.$on('$destroy', function() {\n\t        tabsetCtrl.removeTab(scope);\n\t      });\n\t\n\t      //We need to transclude later, once the content container is ready.\n\t      //when this link happens, we're inside a tab heading.\n\t      scope.$transcludeFn = transclude;\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTabHeadingTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uibTab', '?^tab'], // TODO: change to '^uibTab' after deprecation removal\n\t    link: function(scope, elm) {\n\t      scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t        if (heading) {\n\t          elm.html('');\n\t          elm.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTabContentTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uibTabset', '?^tabset'], // TODO: change to '^uibTabset' after deprecation removal\n\t    link: function(scope, elm, attrs) {\n\t      var tab = scope.$eval(attrs.uibTabContentTransclude);\n\t\n\t      //Now our tab is ready to be transcluded: both the tab heading area\n\t      //and the tab content area are loaded.  Transclude 'em both.\n\t      tab.$transcludeFn(tab.$parent, function(contents) {\n\t        angular.forEach(contents, function(node) {\n\t          if (isTabHeading(node)) {\n\t            //Let tabHeadingTransclude know.\n\t            tab.headingElement = node;\n\t          } else {\n\t            elm.append(node);\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t\n\t  function isTabHeading(node) {\n\t    return node.tagName && (\n\t      node.hasAttribute('tab-heading') || // TODO: remove after deprecation removal\n\t      node.hasAttribute('data-tab-heading') || // TODO: remove after deprecation removal\n\t      node.hasAttribute('x-tab-heading') || // TODO: remove after deprecation removal\n\t      node.hasAttribute('uib-tab-heading') ||\n\t      node.hasAttribute('data-uib-tab-heading') ||\n\t      node.hasAttribute('x-uib-tab-heading') ||\n\t      node.tagName.toLowerCase() === 'tab-heading' || // TODO: remove after deprecation removal\n\t      node.tagName.toLowerCase() === 'data-tab-heading' || // TODO: remove after deprecation removal\n\t      node.tagName.toLowerCase() === 'x-tab-heading' || // TODO: remove after deprecation removal\n\t      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n\t    );\n\t  }\n\t});\n\t\n\t/* deprecated tabs below */\n\t\n\tangular.module('ui.bootstrap.tabs')\n\t\n\t  .value('$tabsSuppressWarning', false)\n\t\n\t  .controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {\n\t    if (!$tabsSuppressWarning) {\n\t      $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibTabsetController', {\n\t      $scope: $scope\n\t    }));\n\t  }])\n\t\n\t  .directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n\t    return {\n\t      restrict: 'EA',\n\t      transclude: true,\n\t      replace: true,\n\t      scope: {\n\t        type: '@'\n\t      },\n\t      controller: 'TabsetController',\n\t      templateUrl: 'template/tabs/tabset.html',\n\t      link: function(scope, element, attrs) {\n\t\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tabset is now deprecated. Use uib-tabset instead.');\n\t        }\n\t        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n\t        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {\n\t    return {\n\t      require: '^tabset',\n\t      restrict: 'EA',\n\t      replace: true,\n\t      templateUrl: 'template/tabs/tab.html',\n\t      transclude: true,\n\t      scope: {\n\t        active: '=?',\n\t        heading: '@',\n\t        onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t        //once it inserts the tab's content into the dom\n\t        onDeselect: '&deselect'\n\t      },\n\t      controller: function() {\n\t        //Empty controller so other directives can require being 'under' a tab\n\t      },\n\t      link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tab is now deprecated. Use uib-tab instead.');\n\t        }\n\t\n\t        scope.$watch('active', function(active) {\n\t          if (active) {\n\t            tabsetCtrl.select(scope);\n\t          }\n\t        });\n\t\n\t        scope.disabled = false;\n\t        if (attrs.disable) {\n\t          scope.$parent.$watch($parse(attrs.disable), function(value) {\n\t            scope.disabled = !!value;\n\t          });\n\t        }\n\t\n\t        scope.select = function() {\n\t          if (!scope.disabled) {\n\t            scope.active = true;\n\t          }\n\t        };\n\t\n\t        tabsetCtrl.addTab(scope);\n\t        scope.$on('$destroy', function() {\n\t          tabsetCtrl.removeTab(scope);\n\t        });\n\t\n\t        //We need to transclude later, once the content container is ready.\n\t        //when this link happens, we're inside a tab heading.\n\t        scope.$transcludeFn = transclude;\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n\t    return {\n\t      restrict: 'A',\n\t      require: '^tab',\n\t      link: function(scope, elm) {\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');\n\t        }\n\t\n\t        scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t          if (heading) {\n\t            elm.html('');\n\t            elm.append(heading);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n\t    return {\n\t      restrict: 'A',\n\t      require: '^tabset',\n\t      link: function(scope, elm, attrs) {\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');\n\t        }\n\t\n\t        var tab = scope.$eval(attrs.tabContentTransclude);\n\t\n\t        //Now our tab is ready to be transcluded: both the tab heading area\n\t        //and the tab content area are loaded.  Transclude 'em both.\n\t        tab.$transcludeFn(tab.$parent, function(contents) {\n\t          angular.forEach(contents, function(node) {\n\t            if (isTabHeading(node)) {\n\t              //Let tabHeadingTransclude know.\n\t              tab.headingElement = node;\n\t            }\n\t            else {\n\t              elm.append(node);\n\t            }\n\t          });\n\t        });\n\t      }\n\t    };\n\t\n\t    function isTabHeading(node) {\n\t      return node.tagName && (\n\t          node.hasAttribute('tab-heading') ||\n\t          node.hasAttribute('data-tab-heading') ||\n\t          node.hasAttribute('x-tab-heading') ||\n\t          node.tagName.toLowerCase() === 'tab-heading' ||\n\t          node.tagName.toLowerCase() === 'data-tab-heading' ||\n\t          node.tagName.toLowerCase() === 'x-tab-heading'\n\t        );\n\t    }\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.timepicker', [])\n\t\n\t.constant('uibTimepickerConfig', {\n\t  hourStep: 1,\n\t  minuteStep: 1,\n\t  showMeridian: true,\n\t  meridians: null,\n\t  readonlyInput: false,\n\t  mousewheel: true,\n\t  arrowkeys: true,\n\t  showSpinners: true\n\t})\n\t\n\t.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n\t  var selected = new Date(),\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\t\n\t  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n\t  $element.removeAttr('tabindex');\n\t\n\t  this.init = function(ngModelCtrl_, inputs) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.unshift(function(modelValue) {\n\t      return modelValue ? new Date(modelValue) : null;\n\t    });\n\t\n\t    var hoursInputEl = inputs.eq(0),\n\t        minutesInputEl = inputs.eq(1);\n\t\n\t    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\t    if (mousewheel) {\n\t      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);\n\t    }\n\t\n\t    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n\t    if (arrowkeys) {\n\t      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);\n\t    }\n\t\n\t    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n\t    this.setupInputEvents(hoursInputEl, minutesInputEl);\n\t  };\n\t\n\t  var hourStep = timepickerConfig.hourStep;\n\t  if ($attrs.hourStep) {\n\t    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n\t      hourStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  var minuteStep = timepickerConfig.minuteStep;\n\t  if ($attrs.minuteStep) {\n\t    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n\t      minuteStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  var min;\n\t  $scope.$parent.$watch($parse($attrs.min), function(value) {\n\t    var dt = new Date(value);\n\t    min = isNaN(dt) ? undefined : dt;\n\t  });\n\t\n\t  var max;\n\t  $scope.$parent.$watch($parse($attrs.max), function(value) {\n\t    var dt = new Date(value);\n\t    max = isNaN(dt) ? undefined : dt;\n\t  });\n\t\n\t  $scope.noIncrementHours = function() {\n\t    var incrementedSelected = addMinutes(selected, hourStep * 60);\n\t    return incrementedSelected > max ||\n\t      (incrementedSelected < selected && incrementedSelected < min);\n\t  };\n\t\n\t  $scope.noDecrementHours = function() {\n\t    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n\t    return decrementedSelected < min ||\n\t      (decrementedSelected > selected && decrementedSelected > max);\n\t  };\n\t\n\t  $scope.noIncrementMinutes = function() {\n\t    var incrementedSelected = addMinutes(selected, minuteStep);\n\t    return incrementedSelected > max ||\n\t      (incrementedSelected < selected && incrementedSelected < min);\n\t  };\n\t\n\t  $scope.noDecrementMinutes = function() {\n\t    var decrementedSelected = addMinutes(selected, -minuteStep);\n\t    return decrementedSelected < min ||\n\t      (decrementedSelected > selected && decrementedSelected > max);\n\t  };\n\t\n\t  $scope.noToggleMeridian = function() {\n\t    if (selected.getHours() < 13) {\n\t      return addMinutes(selected, 12 * 60) > max;\n\t    } else {\n\t      return addMinutes(selected, -12 * 60) < min;\n\t    }\n\t  };\n\t\n\t  // 12H / 24H mode\n\t  $scope.showMeridian = timepickerConfig.showMeridian;\n\t  if ($attrs.showMeridian) {\n\t    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n\t      $scope.showMeridian = !!value;\n\t\n\t      if (ngModelCtrl.$error.time) {\n\t        // Evaluate from template\n\t        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n\t        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t          selected.setHours(hours);\n\t          refresh();\n\t        }\n\t      } else {\n\t        updateTemplate();\n\t      }\n\t    });\n\t  }\n\t\n\t  // Get $scope.hours in 24H mode if valid\n\t  function getHoursFromTemplate() {\n\t    var hours = parseInt($scope.hours, 10);\n\t    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n\t    if (!valid) {\n\t      return undefined;\n\t    }\n\t\n\t    if ($scope.showMeridian) {\n\t      if (hours === 12) {\n\t        hours = 0;\n\t      }\n\t      if ($scope.meridian === meridians[1]) {\n\t        hours = hours + 12;\n\t      }\n\t    }\n\t    return hours;\n\t  }\n\t\n\t  function getMinutesFromTemplate() {\n\t    var minutes = parseInt($scope.minutes, 10);\n\t    return (minutes >= 0 && minutes < 60) ? minutes : undefined;\n\t  }\n\t\n\t  function pad(value) {\n\t    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();\n\t  }\n\t\n\t  // Respond on mousewheel spin\n\t  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {\n\t    var isScrollingUp = function(e) {\n\t      if (e.originalEvent) {\n\t        e = e.originalEvent;\n\t      }\n\t      //pick correct delta variable depending on event\n\t      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n\t      return (e.detail || delta > 0);\n\t    };\n\t\n\t    hoursInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n\t      e.preventDefault();\n\t    });\n\t\n\t    minutesInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n\t      e.preventDefault();\n\t    });\n\t\n\t  };\n\t\n\t  // Respond on up/down arrowkeys\n\t  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {\n\t    hoursInputEl.bind('keydown', function(e) {\n\t      if (e.which === 38) { // up\n\t        e.preventDefault();\n\t        $scope.incrementHours();\n\t        $scope.$apply();\n\t      } else if (e.which === 40) { // down\n\t        e.preventDefault();\n\t        $scope.decrementHours();\n\t        $scope.$apply();\n\t      }\n\t    });\n\t\n\t    minutesInputEl.bind('keydown', function(e) {\n\t      if (e.which === 38) { // up\n\t        e.preventDefault();\n\t        $scope.incrementMinutes();\n\t        $scope.$apply();\n\t      } else if (e.which === 40) { // down\n\t        e.preventDefault();\n\t        $scope.decrementMinutes();\n\t        $scope.$apply();\n\t      }\n\t    });\n\t  };\n\t\n\t  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {\n\t    if ($scope.readonlyInput) {\n\t      $scope.updateHours = angular.noop;\n\t      $scope.updateMinutes = angular.noop;\n\t      return;\n\t    }\n\t\n\t    var invalidate = function(invalidHours, invalidMinutes) {\n\t      ngModelCtrl.$setViewValue(null);\n\t      ngModelCtrl.$setValidity('time', false);\n\t      if (angular.isDefined(invalidHours)) {\n\t        $scope.invalidHours = invalidHours;\n\t      }\n\t      if (angular.isDefined(invalidMinutes)) {\n\t        $scope.invalidMinutes = invalidMinutes;\n\t      }\n\t    };\n\t\n\t    $scope.updateHours = function() {\n\t      var hours = getHoursFromTemplate(),\n\t        minutes = getMinutesFromTemplate();\n\t\n\t      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t        selected.setHours(hours);\n\t        if (selected < min || selected > max) {\n\t          invalidate(true);\n\t        } else {\n\t          refresh('h');\n\t        }\n\t      } else {\n\t        invalidate(true);\n\t      }\n\t    };\n\t\n\t    hoursInputEl.bind('blur', function(e) {\n\t      if (!$scope.invalidHours && $scope.hours < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.hours = pad($scope.hours);\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateMinutes = function() {\n\t      var minutes = getMinutesFromTemplate(),\n\t        hours = getHoursFromTemplate();\n\t\n\t      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n\t        selected.setMinutes(minutes);\n\t        if (selected < min || selected > max) {\n\t          invalidate(undefined, true);\n\t        } else {\n\t          refresh('m');\n\t        }\n\t      } else {\n\t        invalidate(undefined, true);\n\t      }\n\t    };\n\t\n\t    minutesInputEl.bind('blur', function(e) {\n\t      if (!$scope.invalidMinutes && $scope.minutes < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.minutes = pad($scope.minutes);\n\t        });\n\t      }\n\t    });\n\t\n\t  };\n\t\n\t  this.render = function() {\n\t    var date = ngModelCtrl.$viewValue;\n\t\n\t    if (isNaN(date)) {\n\t      ngModelCtrl.$setValidity('time', false);\n\t      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t    } else {\n\t      if (date) {\n\t        selected = date;\n\t      }\n\t\n\t      if (selected < min || selected > max) {\n\t        ngModelCtrl.$setValidity('time', false);\n\t        $scope.invalidHours = true;\n\t        $scope.invalidMinutes = true;\n\t      } else {\n\t        makeValid();\n\t      }\n\t      updateTemplate();\n\t    }\n\t  };\n\t\n\t  // Call internally when we know that model is valid.\n\t  function refresh(keyboardChange) {\n\t    makeValid();\n\t    ngModelCtrl.$setViewValue(new Date(selected));\n\t    updateTemplate(keyboardChange);\n\t  }\n\t\n\t  function makeValid() {\n\t    ngModelCtrl.$setValidity('time', true);\n\t    $scope.invalidHours = false;\n\t    $scope.invalidMinutes = false;\n\t  }\n\t\n\t  function updateTemplate(keyboardChange) {\n\t    var hours = selected.getHours(), minutes = selected.getMinutes();\n\t\n\t    if ($scope.showMeridian) {\n\t      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system\n\t    }\n\t\n\t    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n\t    if (keyboardChange !== 'm') {\n\t      $scope.minutes = pad(minutes);\n\t    }\n\t    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t  }\n\t\n\t  function addMinutes(date, minutes) {\n\t    var dt = new Date(date.getTime() + minutes * 60000);\n\t    var newDate = new Date(date);\n\t    newDate.setHours(dt.getHours(), dt.getMinutes());\n\t    return newDate;\n\t  }\n\t\n\t  function addMinutesToSelected(minutes) {\n\t    selected = addMinutes(selected, minutes);\n\t    refresh();\n\t  }\n\t\n\t  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n\t    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\t\n\t  $scope.incrementHours = function() {\n\t    if (!$scope.noIncrementHours()) {\n\t      addMinutesToSelected(hourStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.decrementHours = function() {\n\t    if (!$scope.noDecrementHours()) {\n\t      addMinutesToSelected(-hourStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.incrementMinutes = function() {\n\t    if (!$scope.noIncrementMinutes()) {\n\t      addMinutesToSelected(minuteStep);\n\t    }\n\t  };\n\t\n\t  $scope.decrementMinutes = function() {\n\t    if (!$scope.noDecrementMinutes()) {\n\t      addMinutesToSelected(-minuteStep);\n\t    }\n\t  };\n\t\n\t  $scope.toggleMeridian = function() {\n\t    if (!$scope.noToggleMeridian()) {\n\t      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTimepicker', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['uibTimepicker', '?^ngModel'],\n\t    controller: 'UibTimepickerController',\n\t    controllerAs: 'timepicker',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (ngModelCtrl) {\n\t        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n\t      }\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated timepicker below */\n\t\n\tangular.module('ui.bootstrap.timepicker')\n\t\n\t.value('$timepickerSuppressWarning', false)\n\t\n\t.controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {\n\t  if (!$timepickerSuppressWarning) {\n\t    $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');\n\t  }\n\t\n\t  angular.extend(this, $controller('UibTimepickerController', {\n\t    $scope: $scope,\n\t    $element: $element,\n\t    $attrs: $attrs\n\t  }));\n\t}])\n\t\n\t.directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['timepicker', '?^ngModel'],\n\t    controller: 'TimepickerController',\n\t    controllerAs: 'timepicker',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$timepickerSuppressWarning) {\n\t        $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');\n\t      }\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (ngModelCtrl) {\n\t        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])\n\t\n\t/**\n\t * A helper service that can parse typeahead's syntax (string provided by users)\n\t * Extracted to a separate service for ease of unit testing\n\t */\n\t  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n\t    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n\t    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\t    return {\n\t      parse: function(input) {\n\t        var match = input.match(TYPEAHEAD_REGEXP);\n\t        if (!match) {\n\t          throw new Error(\n\t            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n\t              ' but got \"' + input + '\".');\n\t        }\n\t\n\t        return {\n\t          itemName: match[3],\n\t          source: $parse(match[4]),\n\t          viewMapper: $parse(match[2] || match[1]),\n\t          modelMapper: $parse(match[1])\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser',\n\t    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {\n\t    var HOT_KEYS = [9, 13, 27, 38, 40];\n\t    var eventDebounceTime = 200;\n\t    var modelCtrl, ngModelOptions;\n\t    //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t    //minimal no of characters that needs to be entered before typeahead kicks-in\n\t    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n\t    if (!minLength && minLength !== 0) {\n\t      minLength = 1;\n\t    }\n\t\n\t    //minimal wait time after last character typed before typeahead kicks-in\n\t    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t    //should it restrict model values to the ones selected from the popup only?\n\t    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t\n\t    //binding to a variable that indicates if matches are being retrieved asynchronously\n\t    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t    //a callback executed when a match is selected\n\t    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t    //should it select highlighted popup value when losing focus?\n\t    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\t\n\t    //binding to a variable that indicates if there were no results after the query is completed\n\t    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\t\n\t    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t    var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\t\n\t    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\t\n\t    //If input matches an item of the list exactly, select it automatically\n\t    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\t\n\t    //INTERNAL VARIABLES\n\t\n\t    //model setter executed upon match selection\n\t    var parsedModel = $parse(attrs.ngModel);\n\t    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n\t    var $setModelValue = function(scope, newValue) {\n\t      if (angular.isFunction(parsedModel(originalScope)) &&\n\t        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n\t        return invokeModelSetter(scope, {$$$p: newValue});\n\t      } else {\n\t        return parsedModel.assign(scope, newValue);\n\t      }\n\t    };\n\t\n\t    //expressions used by typeahead\n\t    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\t\n\t    var hasFocus;\n\t\n\t    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n\t    //mousedown & mouseup events\n\t    //Issue #3699\n\t    var selected;\n\t\n\t    //create a child scope for the typeahead directive so we are not polluting original scope\n\t    //with typeahead-specific data (matches, query etc.)\n\t    var scope = originalScope.$new();\n\t    var offDestroy = originalScope.$on('$destroy', function() {\n\t      scope.$destroy();\n\t    });\n\t    scope.$on('$destroy', offDestroy);\n\t\n\t    // WAI-ARIA\n\t    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t    element.attr({\n\t      'aria-autocomplete': 'list',\n\t      'aria-expanded': false,\n\t      'aria-owns': popupId\n\t    });\n\t\n\t    //pop-up element used to display matches\n\t    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n\t    popUpEl.attr({\n\t      id: popupId,\n\t      matches: 'matches',\n\t      active: 'activeIdx',\n\t      select: 'select(activeIdx)',\n\t      'move-in-progress': 'moveInProgress',\n\t      query: 'query',\n\t      position: 'position'\n\t    });\n\t    //custom item template\n\t    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t    }\n\t\n\t    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n\t      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n\t    }\n\t\n\t    var resetMatches = function() {\n\t      scope.matches = [];\n\t      scope.activeIdx = -1;\n\t      element.attr('aria-expanded', false);\n\t    };\n\t\n\t    var getMatchId = function(index) {\n\t      return popupId + '-option-' + index;\n\t    };\n\t\n\t    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t    // This attribute is added or removed automatically when the `activeIdx` changes.\n\t    scope.$watch('activeIdx', function(index) {\n\t      if (index < 0) {\n\t        element.removeAttr('aria-activedescendant');\n\t      } else {\n\t        element.attr('aria-activedescendant', getMatchId(index));\n\t      }\n\t    });\n\t\n\t    var inputIsExactMatch = function(inputValue, index) {\n\t      if (scope.matches.length > index && inputValue) {\n\t        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    var getMatchesAsync = function(inputValue) {\n\t      var locals = {$viewValue: inputValue};\n\t      isLoadingSetter(originalScope, true);\n\t      isNoResultsSetter(originalScope, false);\n\t      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t        //it might happen that several async queries were in progress if a user were typing fast\n\t        //but we are interested only in responses that correspond to the current view value\n\t        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n\t        if (onCurrentRequest && hasFocus) {\n\t          if (matches && matches.length > 0) {\n\t            scope.activeIdx = focusFirst ? 0 : -1;\n\t            isNoResultsSetter(originalScope, false);\n\t            scope.matches.length = 0;\n\t\n\t            //transform labels\n\t            for (var i = 0; i < matches.length; i++) {\n\t              locals[parserResult.itemName] = matches[i];\n\t              scope.matches.push({\n\t                id: getMatchId(i),\n\t                label: parserResult.viewMapper(scope, locals),\n\t                model: matches[i]\n\t              });\n\t            }\n\t\n\t            scope.query = inputValue;\n\t            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t            //due to other elements being rendered\n\t            recalculatePosition();\n\t\n\t            element.attr('aria-expanded', true);\n\t\n\t            //Select the single remaining option if user input matches\n\t            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n\t              scope.select(0);\n\t            }\n\t          } else {\n\t            resetMatches();\n\t            isNoResultsSetter(originalScope, true);\n\t          }\n\t        }\n\t        if (onCurrentRequest) {\n\t          isLoadingSetter(originalScope, false);\n\t        }\n\t      }, function() {\n\t        resetMatches();\n\t        isLoadingSetter(originalScope, false);\n\t        isNoResultsSetter(originalScope, true);\n\t      });\n\t    };\n\t\n\t    // bind events only if appendToBody params exist - performance feature\n\t    if (appendToBody) {\n\t      angular.element($window).bind('resize', fireRecalculating);\n\t      $document.find('body').bind('scroll', fireRecalculating);\n\t    }\n\t\n\t    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t    var timeoutEventPromise;\n\t\n\t    // Default progress type\n\t    scope.moveInProgress = false;\n\t\n\t    function fireRecalculating() {\n\t      if (!scope.moveInProgress) {\n\t        scope.moveInProgress = true;\n\t        scope.$digest();\n\t      }\n\t\n\t      // Cancel previous timeout\n\t      if (timeoutEventPromise) {\n\t        $timeout.cancel(timeoutEventPromise);\n\t      }\n\t\n\t      // Debounced executing recalculate after events fired\n\t      timeoutEventPromise = $timeout(function() {\n\t        // if popup is visible\n\t        if (scope.matches.length) {\n\t          recalculatePosition();\n\t        }\n\t\n\t        scope.moveInProgress = false;\n\t      }, eventDebounceTime);\n\t    }\n\t\n\t    // recalculate actual position and set new values to scope\n\t    // after digest loop is popup in right position\n\t    function recalculatePosition() {\n\t      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t      scope.position.top += element.prop('offsetHeight');\n\t    }\n\t\n\t    //we need to propagate user's query so we can higlight matches\n\t    scope.query = undefined;\n\t\n\t    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t    var timeoutPromise;\n\t\n\t    var scheduleSearchWithTimeout = function(inputValue) {\n\t      timeoutPromise = $timeout(function() {\n\t        getMatchesAsync(inputValue);\n\t      }, waitTime);\n\t    };\n\t\n\t    var cancelPreviousTimeout = function() {\n\t      if (timeoutPromise) {\n\t        $timeout.cancel(timeoutPromise);\n\t      }\n\t    };\n\t\n\t    resetMatches();\n\t\n\t    scope.select = function(activeIdx) {\n\t      //called from within the $digest() cycle\n\t      var locals = {};\n\t      var model, item;\n\t\n\t      selected = true;\n\t      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t      model = parserResult.modelMapper(originalScope, locals);\n\t      $setModelValue(originalScope, model);\n\t      modelCtrl.$setValidity('editable', true);\n\t      modelCtrl.$setValidity('parse', true);\n\t\n\t      onSelectCallback(originalScope, {\n\t        $item: item,\n\t        $model: model,\n\t        $label: parserResult.viewMapper(originalScope, locals)\n\t      });\n\t\n\t      resetMatches();\n\t\n\t      //return focus to the input element if a match was selected via a mouse click event\n\t      // use timeout to avoid $rootScope:inprog error\n\t      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n\t        $timeout(function() { element[0].focus(); }, 0, false);\n\t      }\n\t    };\n\t\n\t    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t    element.bind('keydown', function(evt) {\n\t      //typeahead is open and an \"interesting\" key was pressed\n\t      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t        return;\n\t      }\n\t\n\t      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n\t      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n\t        resetMatches();\n\t        scope.$digest();\n\t        return;\n\t      }\n\t\n\t      evt.preventDefault();\n\t\n\t      if (evt.which === 40) {\n\t        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t        scope.$digest();\n\t      } else if (evt.which === 38) {\n\t        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n\t        scope.$digest();\n\t      } else if (evt.which === 13 || evt.which === 9) {\n\t        scope.$apply(function () {\n\t          scope.select(scope.activeIdx);\n\t        });\n\t      } else if (evt.which === 27) {\n\t        evt.stopPropagation();\n\t\n\t        resetMatches();\n\t        scope.$digest();\n\t      }\n\t    });\n\t\n\t    element.bind('blur', function() {\n\t      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n\t        selected = true;\n\t        scope.$apply(function() {\n\t          scope.select(scope.activeIdx);\n\t        });\n\t      }\n\t      hasFocus = false;\n\t      selected = false;\n\t    });\n\t\n\t    // Keep reference to click handler to unbind it.\n\t    var dismissClickHandler = function(evt) {\n\t      // Issue #3973\n\t      // Firefox treats right click as a click on document\n\t      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n\t        resetMatches();\n\t        if (!$rootScope.$$phase) {\n\t          scope.$digest();\n\t        }\n\t      }\n\t    };\n\t\n\t    $document.bind('click', dismissClickHandler);\n\t\n\t    originalScope.$on('$destroy', function() {\n\t      $document.unbind('click', dismissClickHandler);\n\t      if (appendToBody || appendToElementId) {\n\t        $popup.remove();\n\t      }\n\t\n\t      if (appendToBody) {\n\t        angular.element($window).unbind('resize', fireRecalculating);\n\t        $document.find('body').unbind('scroll', fireRecalculating);\n\t      }\n\t      // Prevent jQuery cache memory leak\n\t      popUpEl.remove();\n\t    });\n\t\n\t    var $popup = $compile(popUpEl)(scope);\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else if (appendToElementId !== false) {\n\t      angular.element($document[0].getElementById(appendToElementId)).append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    this.init = function(_modelCtrl, _ngModelOptions) {\n\t      modelCtrl = _modelCtrl;\n\t      ngModelOptions = _ngModelOptions;\n\t\n\t      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t      modelCtrl.$parsers.unshift(function(inputValue) {\n\t        hasFocus = true;\n\t\n\t        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n\t          if (waitTime > 0) {\n\t            cancelPreviousTimeout();\n\t            scheduleSearchWithTimeout(inputValue);\n\t          } else {\n\t            getMatchesAsync(inputValue);\n\t          }\n\t        } else {\n\t          isLoadingSetter(originalScope, false);\n\t          cancelPreviousTimeout();\n\t          resetMatches();\n\t        }\n\t\n\t        if (isEditable) {\n\t          return inputValue;\n\t        } else {\n\t          if (!inputValue) {\n\t            // Reset in case user had typed something previously.\n\t            modelCtrl.$setValidity('editable', true);\n\t            return null;\n\t          } else {\n\t            modelCtrl.$setValidity('editable', false);\n\t            return undefined;\n\t          }\n\t        }\n\t      });\n\t\n\t      modelCtrl.$formatters.push(function(modelValue) {\n\t        var candidateViewValue, emptyViewValue;\n\t        var locals = {};\n\t\n\t        // The validity may be set to false via $parsers (see above) if\n\t        // the model is restricted to selected values. If the model\n\t        // is set manually it is considered to be valid.\n\t        if (!isEditable) {\n\t          modelCtrl.$setValidity('editable', true);\n\t        }\n\t\n\t        if (inputFormatter) {\n\t          locals.$model = modelValue;\n\t          return inputFormatter(originalScope, locals);\n\t        } else {\n\t          //it might happen that we don't have enough info to properly render input value\n\t          //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t          locals[parserResult.itemName] = modelValue;\n\t          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t          locals[parserResult.itemName] = undefined;\n\t          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n\t        }\n\t      });\n\t    };\n\t  }])\n\t\n\t  .directive('uibTypeahead', function() {\n\t    return {\n\t      controller: 'UibTypeaheadController',\n\t      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n\t      link: function(originalScope, element, attrs, ctrls) {\n\t        ctrls[2].init(ctrls[0], ctrls[1]);\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibTypeaheadPopup', function() {\n\t    return {\n\t      scope: {\n\t        matches: '=',\n\t        query: '=',\n\t        active: '=',\n\t        position: '&',\n\t        moveInProgress: '=',\n\t        select: '&'\n\t      },\n\t      replace: true,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function() {\n\t          return scope.matches.length > 0;\n\t        };\n\t\n\t        scope.isActive = function(matchIdx) {\n\t          return scope.active == matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function(matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function(activeIdx) {\n\t          scope.select({activeIdx:activeIdx});\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n\t    return {\n\t      scope: {\n\t        index: '=',\n\t        match: '=',\n\t        query: '='\n\t      },\n\t      link:function(scope, element, attrs) {\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n\t        $templateRequest(tplUrl).then(function(tplContent) {\n\t          $compile(tplContent.trim())(scope, function(clonedElement) {\n\t            element.replaceWith(clonedElement);\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n\t    var isSanitizePresent;\n\t    isSanitizePresent = $injector.has('$sanitize');\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      // Regex: capture the whole query string and replace it with the string that will be used to match\n\t      // the results, for example if the capture is \"a\" the result will be \\a\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    function containsHtml(matchItem) {\n\t      return /<.*>/g.test(matchItem);\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      if (!isSanitizePresent && containsHtml(matchItem)) {\n\t        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n\t      }\n\t      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n\t      if (!isSanitizePresent) {\n\t        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n\t      }\n\t      return matchItem;\n\t    };\n\t  }]);\n\t\n\t/* Deprecated typeahead below */\n\t  \n\tangular.module('ui.bootstrap.typeahead')\n\t  .value('$typeaheadSuppressWarning', false)\n\t  .service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {\n\t    if (!$typeaheadSuppressWarning) {\n\t      $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');\n\t    }\n\t\n\t    return uibTypeaheadParser;\n\t  }])\n\t\n\t  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning',\n\t    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {\n\t    var HOT_KEYS = [9, 13, 27, 38, 40];\n\t    var eventDebounceTime = 200;\n\t    return {\n\t      require: ['ngModel', '^?ngModelOptions'],\n\t      link: function(originalScope, element, attrs, ctrls) {\n\t        if (!$typeaheadSuppressWarning) {\n\t          $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');\n\t        }\n\t        var modelCtrl = ctrls[0];\n\t        var ngModelOptions = ctrls[1];\n\t        //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t        //minimal no of characters that needs to be entered before typeahead kicks-in\n\t        var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n\t        if (!minLength && minLength !== 0) {\n\t          minLength = 1;\n\t        }\n\t\n\t        //minimal wait time after last character typed before typeahead kicks-in\n\t        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t        //should it restrict model values to the ones selected from the popup only?\n\t        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t\n\t        //binding to a variable that indicates if matches are being retrieved asynchronously\n\t        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t        //a callback executed when a match is selected\n\t        var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t        //should it select highlighted popup value when losing focus?\n\t        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\t\n\t        //binding to a variable that indicates if there were no results after the query is completed\n\t        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\t\n\t        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t        var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\t\n\t        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\t\n\t        //If input matches an item of the list exactly, select it automatically\n\t        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\t\n\t        //INTERNAL VARIABLES\n\t\n\t        //model setter executed upon match selection\n\t        var parsedModel = $parse(attrs.ngModel);\n\t        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n\t        var $setModelValue = function(scope, newValue) {\n\t          if (angular.isFunction(parsedModel(originalScope)) &&\n\t            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n\t            return invokeModelSetter(scope, {$$$p: newValue});\n\t          } else {\n\t            return parsedModel.assign(scope, newValue);\n\t          }\n\t        };\n\t\n\t        //expressions used by typeahead\n\t        var parserResult = typeaheadParser.parse(attrs.typeahead);\n\t\n\t        var hasFocus;\n\t\n\t        //Used to avoid bug in iOS webview where iOS keyboard does not fire\n\t        //mousedown & mouseup events\n\t        //Issue #3699\n\t        var selected;\n\t\n\t        //create a child scope for the typeahead directive so we are not polluting original scope\n\t        //with typeahead-specific data (matches, query etc.)\n\t        var scope = originalScope.$new();\n\t        var offDestroy = originalScope.$on('$destroy', function() {\n\t\t\t\t    scope.$destroy();\n\t        });\n\t        scope.$on('$destroy', offDestroy);\n\t\n\t        // WAI-ARIA\n\t        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t        element.attr({\n\t          'aria-autocomplete': 'list',\n\t          'aria-expanded': false,\n\t          'aria-owns': popupId\n\t        });\n\t\n\t        //pop-up element used to display matches\n\t        var popUpEl = angular.element('<div typeahead-popup></div>');\n\t        popUpEl.attr({\n\t          id: popupId,\n\t          matches: 'matches',\n\t          active: 'activeIdx',\n\t          select: 'select(activeIdx)',\n\t          'move-in-progress': 'moveInProgress',\n\t          query: 'query',\n\t          position: 'position'\n\t        });\n\t        //custom item template\n\t        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t        }\n\t\n\t        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n\t          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n\t        }\n\t\n\t        var resetMatches = function() {\n\t          scope.matches = [];\n\t          scope.activeIdx = -1;\n\t          element.attr('aria-expanded', false);\n\t        };\n\t\n\t        var getMatchId = function(index) {\n\t          return popupId + '-option-' + index;\n\t        };\n\t\n\t        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t        // This attribute is added or removed automatically when the `activeIdx` changes.\n\t        scope.$watch('activeIdx', function(index) {\n\t          if (index < 0) {\n\t            element.removeAttr('aria-activedescendant');\n\t          } else {\n\t            element.attr('aria-activedescendant', getMatchId(index));\n\t          }\n\t        });\n\t\n\t        var inputIsExactMatch = function(inputValue, index) {\n\t          if (scope.matches.length > index && inputValue) {\n\t            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n\t          }\n\t\n\t          return false;\n\t        };\n\t\n\t        var getMatchesAsync = function(inputValue) {\n\t          var locals = {$viewValue: inputValue};\n\t          isLoadingSetter(originalScope, true);\n\t          isNoResultsSetter(originalScope, false);\n\t          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t            //it might happen that several async queries were in progress if a user were typing fast\n\t            //but we are interested only in responses that correspond to the current view value\n\t            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n\t            if (onCurrentRequest && hasFocus) {\n\t              if (matches && matches.length > 0) {\n\t                scope.activeIdx = focusFirst ? 0 : -1;\n\t                isNoResultsSetter(originalScope, false);\n\t                scope.matches.length = 0;\n\t\n\t                //transform labels\n\t                for (var i = 0; i < matches.length; i++) {\n\t                  locals[parserResult.itemName] = matches[i];\n\t                  scope.matches.push({\n\t                    id: getMatchId(i),\n\t                    label: parserResult.viewMapper(scope, locals),\n\t                    model: matches[i]\n\t                  });\n\t                }\n\t\n\t                scope.query = inputValue;\n\t                //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t                //due to other elements being rendered\n\t                recalculatePosition();\n\t\n\t                element.attr('aria-expanded', true);\n\t\n\t                //Select the single remaining option if user input matches\n\t                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n\t                  scope.select(0);\n\t                }\n\t              } else {\n\t                resetMatches();\n\t                isNoResultsSetter(originalScope, true);\n\t              }\n\t            }\n\t            if (onCurrentRequest) {\n\t              isLoadingSetter(originalScope, false);\n\t            }\n\t          }, function() {\n\t            resetMatches();\n\t            isLoadingSetter(originalScope, false);\n\t            isNoResultsSetter(originalScope, true);\n\t          });\n\t        };\n\t\n\t        // bind events only if appendToBody params exist - performance feature\n\t        if (appendToBody) {\n\t          angular.element($window).bind('resize', fireRecalculating);\n\t          $document.find('body').bind('scroll', fireRecalculating);\n\t        }\n\t\n\t        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t        var timeoutEventPromise;\n\t\n\t        // Default progress type\n\t        scope.moveInProgress = false;\n\t\n\t        function fireRecalculating() {\n\t          if (!scope.moveInProgress) {\n\t            scope.moveInProgress = true;\n\t            scope.$digest();\n\t          }\n\t\n\t          // Cancel previous timeout\n\t          if (timeoutEventPromise) {\n\t            $timeout.cancel(timeoutEventPromise);\n\t          }\n\t\n\t          // Debounced executing recalculate after events fired\n\t          timeoutEventPromise = $timeout(function() {\n\t            // if popup is visible\n\t            if (scope.matches.length) {\n\t              recalculatePosition();\n\t            }\n\t\n\t            scope.moveInProgress = false;\n\t          }, eventDebounceTime);\n\t        }\n\t\n\t        // recalculate actual position and set new values to scope\n\t        // after digest loop is popup in right position\n\t        function recalculatePosition() {\n\t          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t          scope.position.top += element.prop('offsetHeight');\n\t        }\n\t\n\t        resetMatches();\n\t\n\t        //we need to propagate user's query so we can higlight matches\n\t        scope.query = undefined;\n\t\n\t        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t        var timeoutPromise;\n\t\n\t        var scheduleSearchWithTimeout = function(inputValue) {\n\t          timeoutPromise = $timeout(function() {\n\t            getMatchesAsync(inputValue);\n\t          }, waitTime);\n\t        };\n\t\n\t        var cancelPreviousTimeout = function() {\n\t          if (timeoutPromise) {\n\t            $timeout.cancel(timeoutPromise);\n\t          }\n\t        };\n\t\n\t        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t        modelCtrl.$parsers.unshift(function(inputValue) {\n\t          hasFocus = true;\n\t\n\t          if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n\t            if (waitTime > 0) {\n\t              cancelPreviousTimeout();\n\t              scheduleSearchWithTimeout(inputValue);\n\t            } else {\n\t              getMatchesAsync(inputValue);\n\t            }\n\t          } else {\n\t            isLoadingSetter(originalScope, false);\n\t            cancelPreviousTimeout();\n\t            resetMatches();\n\t          }\n\t\n\t          if (isEditable) {\n\t            return inputValue;\n\t          } else {\n\t            if (!inputValue) {\n\t              // Reset in case user had typed something previously.\n\t              modelCtrl.$setValidity('editable', true);\n\t              return null;\n\t            } else {\n\t              modelCtrl.$setValidity('editable', false);\n\t              return undefined;\n\t            }\n\t          }\n\t        });\n\t\n\t        modelCtrl.$formatters.push(function(modelValue) {\n\t          var candidateViewValue, emptyViewValue;\n\t          var locals = {};\n\t\n\t          // The validity may be set to false via $parsers (see above) if\n\t          // the model is restricted to selected values. If the model\n\t          // is set manually it is considered to be valid.\n\t          if (!isEditable) {\n\t            modelCtrl.$setValidity('editable', true);\n\t          }\n\t\n\t          if (inputFormatter) {\n\t            locals.$model = modelValue;\n\t            return inputFormatter(originalScope, locals);\n\t          } else {\n\t            //it might happen that we don't have enough info to properly render input value\n\t            //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t            locals[parserResult.itemName] = modelValue;\n\t            candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t            locals[parserResult.itemName] = undefined;\n\t            emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n\t          }\n\t        });\n\t\n\t        scope.select = function(activeIdx) {\n\t          //called from within the $digest() cycle\n\t          var locals = {};\n\t          var model, item;\n\t\n\t          selected = true;\n\t          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t          model = parserResult.modelMapper(originalScope, locals);\n\t          $setModelValue(originalScope, model);\n\t          modelCtrl.$setValidity('editable', true);\n\t          modelCtrl.$setValidity('parse', true);\n\t\n\t          onSelectCallback(originalScope, {\n\t            $item: item,\n\t            $model: model,\n\t            $label: parserResult.viewMapper(originalScope, locals)\n\t          });\n\t\n\t          resetMatches();\n\t\n\t          //return focus to the input element if a match was selected via a mouse click event\n\t          // use timeout to avoid $rootScope:inprog error\n\t          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n\t            $timeout(function() { element[0].focus(); }, 0, false);\n\t          }\n\t        };\n\t\n\t        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t        element.bind('keydown', function(evt) {\n\t          //typeahead is open and an \"interesting\" key was pressed\n\t          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t            return;\n\t          }\n\t\n\t          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n\t          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n\t            resetMatches();\n\t            scope.$digest();\n\t            return;\n\t          }\n\t\n\t          evt.preventDefault();\n\t\n\t          if (evt.which === 40) {\n\t            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t            scope.$digest();\n\t          } else if (evt.which === 38) {\n\t            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n\t            scope.$digest();\n\t          } else if (evt.which === 13 || evt.which === 9) {\n\t            scope.$apply(function () {\n\t              scope.select(scope.activeIdx);\n\t            });\n\t          } else if (evt.which === 27) {\n\t            evt.stopPropagation();\n\t\n\t            resetMatches();\n\t            scope.$digest();\n\t          }\n\t        });\n\t\n\t        element.bind('blur', function() {\n\t          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n\t            selected = true;\n\t            scope.$apply(function() {\n\t              scope.select(scope.activeIdx);\n\t            });\n\t          }\n\t          hasFocus = false;\n\t          selected = false;\n\t        });\n\t\n\t        // Keep reference to click handler to unbind it.\n\t        var dismissClickHandler = function(evt) {\n\t          // Issue #3973\n\t          // Firefox treats right click as a click on document\n\t          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n\t            resetMatches();\n\t            if (!$rootScope.$$phase) {\n\t              scope.$digest();\n\t            }\n\t          }\n\t        };\n\t\n\t        $document.bind('click', dismissClickHandler);\n\t\n\t        originalScope.$on('$destroy', function() {\n\t          $document.unbind('click', dismissClickHandler);\n\t          if (appendToBody || appendToElementId) {\n\t            $popup.remove();\n\t          }\n\t\n\t          if (appendToBody) {\n\t            angular.element($window).unbind('resize', fireRecalculating);\n\t            $document.find('body').unbind('scroll', fireRecalculating);\n\t          }\n\t          // Prevent jQuery cache memory leak\n\t          popUpEl.remove();\n\t        });\n\t\n\t        var $popup = $compile(popUpEl)(scope);\n\t\n\t        if (appendToBody) {\n\t          $document.find('body').append($popup);\n\t        } else if (appendToElementId !== false) {\n\t          angular.element($document[0].getElementById(appendToElementId)).append($popup);\n\t        } else {\n\t          element.after($popup);\n\t        }\n\t      }\n\t    };\n\t  }])\n\t  \n\t  .directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {\n\t    return {\n\t      scope: {\n\t        matches: '=',\n\t        query: '=',\n\t        active: '=',\n\t        position: '&',\n\t        moveInProgress: '=',\n\t        select: '&'\n\t      },\n\t      replace: true,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        \n\t        if (!$typeaheadSuppressWarning) {\n\t          $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');\n\t        }\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function() {\n\t          return scope.matches.length > 0;\n\t        };\n\t\n\t        scope.isActive = function(matchIdx) {\n\t          return scope.active == matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function(matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function(activeIdx) {\n\t          scope.select({activeIdx:activeIdx});\n\t        };\n\t      }\n\t    };\n\t  }])\n\t  \n\t  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {\n\t    return {\n\t      restrict: 'EA',\n\t      scope: {\n\t        index: '=',\n\t        match: '=',\n\t        query: '='\n\t      },\n\t      link:function(scope, element, attrs) {\n\t        if (!$typeaheadSuppressWarning) {\n\t          $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');\n\t        }\n\t\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n\t        $templateRequest(tplUrl).then(function(tplContent) {\n\t          $compile(tplContent.trim())(scope, function(clonedElement) {\n\t            element.replaceWith(clonedElement);\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }])\n\t  \n\t  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {\n\t    var isSanitizePresent;\n\t    isSanitizePresent = $injector.has('$sanitize');\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      // Regex: capture the whole query string and replace it with the string that will be used to match\n\t      // the results, for example if the capture is \"a\" the result will be \\a\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    function containsHtml(matchItem) {\n\t      return /<.*>/g.test(matchItem);\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      if (!$typeaheadSuppressWarning) {\n\t        $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');\n\t      }\n\t\n\t      if (!isSanitizePresent && containsHtml(matchItem)) {\n\t        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n\t      }\n\t\n\t      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n\t      if (!isSanitizePresent) {\n\t        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n\t      }\n\t\n\t      return matchItem;\n\t    };\n\t  }]);\n\t\n\tangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/accordion/accordion-group.html\",\n\t    \"<div class=\\\"panel {{panelClass || 'panel-default'}}\\\">\\n\" +\n\t    \"  <div class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n\t    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n\t    \"      <a href tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n\t    \"    </h4>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"  <div class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n\t    \"\t  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/accordion/accordion.html\",\n\t    \"<div class=\\\"panel-group\\\" ng-transclude></div>\");\n\t}]);\n\t\n\tangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/alert/alert.html\",\n\t    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n\t    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n\t    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n\t    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n\t    \"    </button>\\n\" +\n\t    \"    <div ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/carousel/carousel.html\",\n\t    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n\t    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n\t    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"  </ol>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/carousel/slide.html\",\n\t    \"<div ng-class=\\\"{\\n\" +\n\t    \"    'active': active\\n\" +\n\t    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/datepicker.html\",\n\t    \"<div ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n\t    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n\t    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n\t    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/day.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n\t    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default btn-sm\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/month.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" dropdown-nested ng-if=\\\"isOpen\\\" style=\\\"display: block\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n\t    \"\t<li ng-transclude></li>\\n\" +\n\t    \"\t<li ng-if=\\\"showButtonBar\\\" style=\\\"padding:10px 9px 2px\\\">\\n\" +\n\t    \"\t\t<span class=\\\"btn-group pull-left\\\">\\n\" +\n\t    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-info\\\" ng-click=\\\"select('today')\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n\t    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n\t    \"\t\t</span>\\n\" +\n\t    \"\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n\t    \"\t</li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/year.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"3\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/modal/backdrop.html\",\n\t    \"<div uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"     modal-in-class=\\\"in\\\"\\n\" +\n\t    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n\t    \"></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/modal/window.html\",\n\t    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n\t    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"    modal-in-class=\\\"in\\\"\\n\" +\n\t    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n\t    \"    <div class=\\\"modal-dialog\\\" ng-class=\\\"size ? 'modal-' + size : ''\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/pagination/pager.html\",\n\t    \"<ul class=\\\"pager\\\">\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/pagination/pagination.html\",\n\t    \"<ul class=\\\"pagination\\\">\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-html-popup.html\",\n\t    \"<div\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\n\t    \"<div\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-template-popup.html\",\n\t    \"<div\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n\t    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover-html.html\",\n\t    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover-template.html\",\n\t    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\"\\n\" +\n\t    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover.html\",\n\t    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/bar.html\",\n\t    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/progress.html\",\n\t    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/progressbar.html\",\n\t    \"<div class=\\\"progress\\\">\\n\" +\n\t    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/rating/rating.html\",\n\t    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n\t    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n\t    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n\t    \"</span>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tabs/tab.html\",\n\t    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\">\\n\" +\n\t    \"  <a href ng-click=\\\"select()\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n\t    \"</li>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tabs/tabset.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n\t    \"  <div class=\\\"tab-content\\\">\\n\" +\n\t    \"    <div class=\\\"tab-pane\\\" \\n\" +\n\t    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n\t    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n\t    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n\t    \"    </div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/timepicker/timepicker.html\",\n\t    \"<table>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td>:</td>\\n\" +\n\t    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/typeahead/typeahead-match.html\",\n\t    \"<a href tabindex=\\\"-1\\\" ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"></a>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/typeahead/typeahead-popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" style=\\\"display: block;\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n\t    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t!angular.$$csp() && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendors.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t2:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".app.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c16d6e7161dc5f4d53c1\n **/","module.exports = angular;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 3\n ** module chunks = 2\n **/","//! api-check version 7.5.5 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) (ó ì_í)=óò=(ì_í ò)\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"apiCheck\"] = factory();\n\telse\n\t\troot[\"apiCheck\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _apiCheck = __webpack_require__(1);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = _apiCheck2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\tvar apiCheckUtil = __webpack_require__(3);\n\tvar each = apiCheckUtil.each;\n\tvar isError = apiCheckUtil.isError;\n\tvar t = apiCheckUtil.t;\n\tvar arrayify = apiCheckUtil.arrayify;\n\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\tvar typeOf = apiCheckUtil.typeOf;\n\tvar getError = apiCheckUtil.getError;\n\n\tvar checkers = __webpack_require__(4);\n\tvar apiCheckApis = getApiCheckApis();\n\n\tmodule.exports = getApiCheckInstance;\n\tmodule.exports.VERSION = (\"7.5.5\");\n\tmodule.exports.utils = apiCheckUtil;\n\tmodule.exports.globalConfig = {\n\t  verbose: false,\n\t  disabled: false\n\t};\n\n\tvar apiCheckApiCheck = getApiCheckInstance({\n\t  output: { prefix: 'apiCheck' }\n\t});\n\tmodule.exports.internalChecker = apiCheckApiCheck;\n\n\teach(checkers, function (checker, name) {\n\t  return module.exports[name] = checker;\n\t});\n\n\tfunction getApiCheckInstance() {\n\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t  /* eslint complexity:[2, 6] */\n\t  if (apiCheckApiCheck && arguments.length) {\n\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t      prefix: 'creating an apiCheck instance'\n\t    });\n\t  }\n\n\t  var additionalProperties = {\n\t    'throw': getApiCheck(true),\n\t    warn: getApiCheck(false),\n\t    getErrorMessage: getErrorMessage,\n\t    handleErrorMessage: handleErrorMessage,\n\t    config: {\n\t      output: config.output || {\n\t        prefix: '',\n\t        suffix: '',\n\t        docsBaseUrl: ''\n\t      },\n\t      verbose: config.verbose || false,\n\t      disabled: config.disabled || false\n\t    },\n\t    utils: apiCheckUtil\n\t  };\n\n\t  each(additionalProperties, function (wrapper, name) {\n\t    return apiCheck[name] = wrapper;\n\t  });\n\n\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\t  each(extraCheckers, function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\n\t  return apiCheck;\n\n\t  /**\n\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t   * @param {Array} api - the checkers to check with\n\t   * @param {Array} args - the args to check\n\t   * @param {Object} output - output options\n\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t   */\n\t  function apiCheck(api, args, output) {\n\t    /* eslint complexity:[2, 8] */\n\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t      return {\n\t        apiTypes: {}, argTypes: {},\n\t        passed: true, message: '',\n\t        failed: false\n\t      }; // empty version of what is normally returned\n\t    }\n\t    checkApiCheckApi(arguments);\n\t    if (!Array.isArray(api)) {\n\t      api = [api];\n\t      args = [args];\n\t    } else {\n\t      // turn arguments into an array\n\t      args = Array.prototype.slice.call(args);\n\t    }\n\t    var messages = checkEnoughArgs(api, args);\n\t    if (!messages.length) {\n\t      // this is where we actually go perform the checks.\n\t      messages = checkApiWithArgs(api, args);\n\t    }\n\n\t    var returnObject = getTypes(api, args);\n\t    returnObject.args = args;\n\t    if (messages.length) {\n\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t      returnObject.failed = true;\n\t      returnObject.passed = false;\n\t    } else {\n\t      returnObject.message = '';\n\t      returnObject.failed = false;\n\t      returnObject.passed = true;\n\t    }\n\t    return returnObject;\n\t  }\n\n\t  /**\n\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t   */\n\t  function checkApiCheckApi(checkApiArgs) {\n\t    var api = checkApiArgs[0];\n\t    var args = checkApiArgs[1];\n\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\n\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t    }\n\t    // dog fooding here\n\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t    if (errors.length) {\n\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t        prefix: 'apiCheck'\n\t      });\n\t      apiCheck.handleErrorMessage(message, true);\n\t    }\n\t  }\n\n\t  function getApiCheck(shouldThrow) {\n\t    return function apiCheckWrapper(api, args, output) {\n\t      var result = apiCheck(api, args, output);\n\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t      return result; // wont get here if an error is thrown\n\t    };\n\t  }\n\n\t  function handleErrorMessage(message, shouldThrow) {\n\t    if (shouldThrow && message) {\n\t      throw new Error(message);\n\t    } else if (message) {\n\t      /* eslint no-console:0 */\n\t      console.warn(message);\n\t    }\n\t  }\n\n\t  function getErrorMessage(api, args) {\n\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n\t    var gOut = apiCheck.config.output || {};\n\t    var prefix = getPrefix();\n\t    var suffix = getSuffix();\n\t    var url = getUrl();\n\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\n\t    function getPrefix() {\n\t      var p = output.onlyPrefix;\n\t      if (!p) {\n\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t      }\n\t      return p;\n\t    }\n\n\t    function getSuffix() {\n\t      var s = output.onlySuffix;\n\t      if (!s) {\n\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t      }\n\t      return s;\n\t    }\n\n\t    function getUrl() {\n\t      var u = output.url;\n\t      if (!u) {\n\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t      }\n\t      return u;\n\t    }\n\t  }\n\n\t  function buildMessageFromApiAndArgs(api, args) {\n\t    var _getTypes = getTypes(api, args);\n\n\t    var apiTypes = _getTypes.apiTypes;\n\t    var argTypes = _getTypes.argTypes;\n\n\t    var copy = Array.prototype.slice.call(args || []);\n\t    var replacedItems = [];\n\t    replaceFunctionWithName(copy);\n\t    var passedArgs = getObjectString(copy);\n\t    argTypes = getObjectString(argTypes);\n\t    apiTypes = getObjectString(apiTypes);\n\n\t    return generateMessage();\n\n\t    // functions\n\n\t    function replaceFunctionWithName(obj) {\n\t      each(obj, function (val, name) {\n\t        /* eslint complexity:[2, 6] */\n\t        if (replacedItems.indexOf(val) === -1) {\n\t          // avoid recursive problems\n\t          replacedItems.push(val);\n\t          if (typeof val === 'object') {\n\t            replaceFunctionWithName(obj);\n\t          } else if (typeof val === 'function') {\n\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t          }\n\t        }\n\t      });\n\t    }\n\n\t    function getObjectString(types) {\n\t      if (!types || !types.length) {\n\t        return 'nothing';\n\t      } else if (types && types.length === 1) {\n\t        types = types[0];\n\t      }\n\t      return stringify(types, null, 2);\n\t    }\n\n\t    function generateMessage() {\n\t      var n = '\\n';\n\t      var useS = true;\n\t      if (args && args.length === 1) {\n\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t          useS = !!Object.keys(args[0]).length;\n\t        } else {\n\t          useS = false;\n\t        }\n\t      }\n\t      var types = 'type' + (useS ? 's' : '');\n\t      var newLine = n + n;\n\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t    }\n\t  }\n\n\t  function getTypes(api, args) {\n\t    api = arrayify(api);\n\t    args = arrayify(args);\n\t    var apiTypes = api.map(function (checker, index) {\n\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t      return getCheckerDisplay(checker, {\n\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t        obj: args[index],\n\t        addHelpers: true\n\t      });\n\t    });\n\t    var argTypes = args.map(function (arg) {\n\t      return getArgDisplay(arg, []);\n\t    });\n\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t  }\n\t}\n\n\t// STATELESS FUNCTIONS\n\n\t/**\n\t * This is where the magic happens for actually checking the arguments with the api.\n\t * @param {Array} api - checkers\n\t * @param  {Array} args - and arguments object\n\t * @returns {Array} - the error messages\n\t */\n\tfunction checkApiWithArgs(api, args) {\n\t  /* eslint complexity:[2, 7] */\n\t  var messages = [];\n\t  var failed = false;\n\t  var checkerIndex = 0;\n\t  var argIndex = 0;\n\t  var arg = undefined,\n\t      checker = undefined,\n\t      res = undefined,\n\t      lastChecker = undefined,\n\t      argName = undefined,\n\t      argFailed = undefined,\n\t      skipPreviousChecker = undefined;\n\t  /* jshint -W084 */\n\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t    arg = args[argIndex++];\n\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t    res = checker(arg, 'value', argName);\n\t    argFailed = isError(res);\n\t    lastChecker = checkerIndex >= api.length;\n\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t      failed = true;\n\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t    } else if (argFailed && checker.isOptional) {\n\t      argIndex--;\n\t    } else {\n\t      messages.push(t(argName) + ' passed');\n\t    }\n\t  }\n\t  return failed ? messages : [];\n\t}\n\n\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\tfunction checkerTypeType(checkerType, name, location) {\n\t  var apiCheckDataChecker = checkers.shape({\n\t    type: checkers.string,\n\t    optional: checkers.bool\n\t  });\n\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t  if (isError(wrongShape)) {\n\t    return wrongShape;\n\t  }\n\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t    return getError(name, location, checkerTypeType.type);\n\t  }\n\t}\n\n\tfunction getCheckerErrorMessage(res, checker, val) {\n\t  var checkerHelp = getCheckerHelp(checker, val);\n\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t  return res.message + checkerHelp;\n\t}\n\n\tfunction getCheckerHelp(_ref, val) {\n\t  var help = _ref.help;\n\n\t  if (!help) {\n\t    return '';\n\t  }\n\t  if (typeof help === 'function') {\n\t    help = help(val);\n\t  }\n\t  return help;\n\t}\n\n\tfunction checkEnoughArgs(api, args) {\n\t  var requiredArgs = api.filter(function (a) {\n\t    return !a.isOptional;\n\t  });\n\t  if (args.length < requiredArgs.length) {\n\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t  } else {\n\t    return [];\n\t  }\n\t}\n\n\tfunction getArgDisplay(arg, gottenArgs) {\n\t  /* eslint complexity:[2, 7] */\n\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t  var type = typeOf(arg);\n\t  if (type === 'function') {\n\t    if (hasKeys()) {\n\t      var properties = stringify(getDisplayIfNotGotten());\n\t      return cName + ' (with properties: ' + properties + ')';\n\t    }\n\t    return cName;\n\t  }\n\n\t  if (arg === null) {\n\t    return 'null';\n\t  }\n\n\t  if (type !== 'array' && type !== 'object') {\n\t    return type;\n\t  }\n\n\t  if (hasKeys()) {\n\t    return getDisplayIfNotGotten();\n\t  }\n\n\t  return cName;\n\n\t  // utility functions\n\t  function hasKeys() {\n\t    return arg && Object.keys(arg).length;\n\t  }\n\n\t  function getDisplayIfNotGotten() {\n\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t      return '[Circular]';\n\t    }\n\t    gottenArgs.push(arg);\n\t    return getDisplay(arg, gottenArgs);\n\t  }\n\t}\n\n\tfunction getDisplay(obj, gottenArgs) {\n\t  var argDisplay = {};\n\t  each(obj, function (v, k) {\n\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t  });\n\t  return argDisplay;\n\t}\n\n\tfunction getApiCheckApis() {\n\t  var os = checkers.string.optional;\n\n\t  var checkerFnChecker = checkers.func.withProperties({\n\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t    displayName: checkers.string.optional,\n\t    shortType: checkers.string.optional,\n\t    notOptional: checkers.bool.optional,\n\t    notRequired: checkers.bool.optional\n\t  });\n\n\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t    output: checkers.shape({\n\t      prefix: checkers.string.optional,\n\t      suffix: checkers.string.optional,\n\t      docsBaseUrl: checkers.string.optional\n\t    }).strict.optional,\n\t    verbose: checkers.bool.optional,\n\t    disabled: checkers.bool.optional\n\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\n\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t  }).strict.optional];\n\n\t  return {\n\t    checkerFnChecker: checkerFnChecker,\n\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t    checkApiCheckApi: checkApiCheckApi\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = stringify;\n\n\tfunction getSerialize (fn, decycle) {\n\t  var seen = [], keys = [];\n\t  decycle = decycle || function(key, value) {\n\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t  };\n\t  return function(key, value) {\n\t    var ret = value;\n\t    if (typeof value === 'object' && value) {\n\t      if (seen.indexOf(value) !== -1)\n\t        ret = decycle(key, value);\n\t      else {\n\t        seen.push(value);\n\t        keys.push(key);\n\t      }\n\t    }\n\t    if (fn) ret = fn(key, ret);\n\t    return ret;\n\t  }\n\t}\n\n\tfunction getPath (value, seen, keys) {\n\t  var index = seen.indexOf(value);\n\t  var path = [ keys[index] ];\n\t  for (index--; index >= 0; index--) {\n\t    if (seen[index][ path[0] ] === value) {\n\t      value = seen[index];\n\t      path.unshift(keys[index]);\n\t    }\n\t  }\n\t  return '~' + path.join('.');\n\t}\n\n\tfunction stringify(obj, fn, spaces, decycle) {\n\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t}\n\n\tstringify.getSerialize = getSerialize;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\tvar stringify = __webpack_require__(2);\n\tvar checkerHelpers = {\n\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t};\n\n\tmodule.exports = {\n\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t  noop: noop\n\t};\n\n\tfunction copy(obj) {\n\t  var type = typeOf(obj);\n\t  var daCopy = undefined;\n\t  if (type === 'array') {\n\t    daCopy = [];\n\t  } else if (type === 'object') {\n\t    daCopy = {};\n\t  } else {\n\t    return obj;\n\t  }\n\t  each(obj, function (val, key) {\n\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t  });\n\t  return daCopy;\n\t}\n\n\tfunction typeOf(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return 'array';\n\t  } else if (obj instanceof RegExp) {\n\t    return 'object';\n\t  } else {\n\t    return typeof obj;\n\t  }\n\t}\n\n\tfunction getCheckerDisplay(checker, options) {\n\t  /* eslint complexity:[2, 7] */\n\t  var display = undefined;\n\t  var short = options && options.short;\n\t  if (short && checker.shortType) {\n\t    display = checker.shortType;\n\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t    display = getCheckerType(checker, options);\n\t  } else {\n\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t  }\n\t  return display;\n\t}\n\n\tfunction getCheckerType(_ref, options) {\n\t  var type = _ref.type;\n\n\t  if (typeof type === 'function') {\n\t    var __apiCheckData = type.__apiCheckData;\n\t    var typeTypes = type(options);\n\t    type = _defineProperty({\n\t      __apiCheckData: __apiCheckData\n\t    }, __apiCheckData.type, typeTypes);\n\t  }\n\t  return type;\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (!obj) {\n\t    return [];\n\t  } else if (Array.isArray(obj)) {\n\t    return obj;\n\t  } else {\n\t    return [obj];\n\t  }\n\t}\n\n\tfunction each(obj, iterator, context) {\n\t  if (Array.isArray(obj)) {\n\t    return eachArry(obj, iterator, context);\n\t  } else {\n\t    return eachObj(obj, iterator, context);\n\t  }\n\t}\n\n\tfunction eachObj(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t  for (var key in obj) {\n\t    if (hasOwn.call(obj, key)) {\n\t      ret = iterator.call(context, obj[key], key, obj);\n\t      if (ret === false) {\n\t        return ret;\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction eachArry(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var length = obj.length;\n\t  for (var i = 0; i < length; i++) {\n\t    ret = iterator.call(context, obj[i], i, obj);\n\t    if (ret === false) {\n\t      return ret;\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction isError(obj) {\n\t  return obj instanceof Error;\n\t}\n\n\tfunction list(arry, join, finalJoin) {\n\t  arry = arrayify(arry);\n\t  var copy = arry.slice();\n\t  var last = copy.pop();\n\t  if (copy.length === 1) {\n\t    join = ' ';\n\t  }\n\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t}\n\n\tfunction getError(name, location, checkerType) {\n\t  if (typeof checkerType === 'function') {\n\t    checkerType = checkerType({ short: true });\n\t  }\n\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t}\n\n\tfunction nAtL(name, location) {\n\t  var tName = t(name || 'value');\n\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t  return '' + tName + tLocation;\n\t}\n\n\tfunction t(thing) {\n\t  return '`' + thing + '`';\n\t}\n\n\tfunction undef(thing) {\n\t  return typeof thing === 'undefined';\n\t}\n\n\t/**\n\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t * optional version\n\t *\n\t * @param {Function} checker - the checker to setup with properties\n\t * @param {Object} properties - properties to add to the checker\n\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t * @returns {Function} checker - the setup checker\n\t */\n\tfunction setupChecker(checker, properties, disabled) {\n\t  /* eslint complexity:[2, 9] */\n\t  if (disabled) {\n\t    // swap out the checker for its own copy of noop\n\t    checker = getNoop();\n\t    checker.isNoop = true;\n\t  }\n\n\t  if (typeof checker.type === 'string') {\n\t    checker.shortType = checker.type;\n\t  }\n\n\t  // assign all properties given\n\t  each(properties, function (prop, name) {\n\t    return checker[name] = prop;\n\t  });\n\n\t  if (!checker.displayName) {\n\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t  }\n\n\t  if (!checker.notRequired) {\n\t    checker = getRequiredVersion(checker, disabled);\n\t  }\n\n\t  if (!checker.notNullable) {\n\t    addNullable(checker, disabled);\n\t  }\n\n\t  if (!checker.notOptional) {\n\t    addOptional(checker, disabled);\n\t  }\n\n\t  return checker;\n\t}\n\n\tfunction getRequiredVersion(checker, disabled) {\n\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t    if (undef(val) && !checker.isOptional) {\n\t      var tLocation = location ? ' in ' + t(location) : '';\n\t      var type = getCheckerDisplay(checker, { short: true });\n\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t    } else {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  copyProps(checker, requiredChecker);\n\t  requiredChecker.originalChecker = checker;\n\t  return requiredChecker;\n\t}\n\n\tfunction addOptional(checker, disabled) {\n\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t    if (!undef(val)) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, optionalCheck);\n\n\t  optionalCheck.isOptional = true;\n\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t  optionalCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .optional to the end of the checkers\n\t  checker.optional = optionalCheck;\n\n\t  fixType(checker, checker.optional);\n\t}\n\n\tfunction addNullable(checker, disabled) {\n\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t    if (val !== null) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, nullableCheck);\n\n\t  nullableCheck.isNullable = true;\n\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t  nullableCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t  checker.nullable = nullableCheck;\n\n\t  fixType(checker, checker.nullable);\n\t  if (!checker.notOptional) {\n\t    addOptional(checker.nullable, disabled);\n\t  }\n\t}\n\n\tfunction fixType(checker, checkerCopy) {\n\t  // fix type, because it's not a straight copy...\n\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t  // we also want to add \"(optional)\" to the types with a string\n\t  if (typeof checkerCopy.type === 'object') {\n\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t  } else if (typeof checkerCopy.type === 'function') {\n\t      checkerCopy.type = function () {\n\t        return checker.type.apply(checker, arguments);\n\t      };\n\t    } else {\n\t      checkerCopy.type += ' (optional)';\n\t      return;\n\t    }\n\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t  checkerCopy.type.__apiCheckData.optional = true;\n\t}\n\n\t// UTILS\n\n\tfunction copyProps(src, dest) {\n\t  each(Object.keys(src), function (key) {\n\t    return dest[key] = src[key];\n\t  });\n\t}\n\n\tfunction noop() {}\n\n\tfunction getNoop() {\n\t  /* eslint no-shadow:0 */\n\t  /* istanbul ignore next */\n\t  return function noop() {};\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\n\tvar _require = __webpack_require__(3);\n\n\tvar typeOf = _require.typeOf;\n\tvar each = _require.each;\n\tvar copy = _require.copy;\n\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\tvar isError = _require.isError;\n\tvar arrayify = _require.arrayify;\n\tvar list = _require.list;\n\tvar getError = _require.getError;\n\tvar nAtL = _require.nAtL;\n\tvar t = _require.t;\n\tvar checkerHelpers = _require.checkerHelpers;\n\tvar undef = _require.undef;\n\tvar setupChecker = checkerHelpers.setupChecker;\n\n\tvar checkers = module.exports = getCheckers();\n\tmodule.exports.getCheckers = getCheckers;\n\n\tfunction getCheckers(disabled) {\n\t  return {\n\t    array: typeOfCheckGetter('Array'),\n\t    bool: typeOfCheckGetter('Boolean'),\n\t    number: typeOfCheckGetter('Number'),\n\t    string: typeOfCheckGetter('String'),\n\t    func: funcCheckGetter(),\n\t    object: objectCheckGetter(),\n\n\t    emptyObject: emptyObjectCheckGetter(),\n\n\t    instanceOf: instanceCheckGetter,\n\t    oneOf: oneOfCheckGetter,\n\t    oneOfType: oneOfTypeCheckGetter,\n\n\t    arrayOf: arrayOfCheckGetter,\n\t    objectOf: objectOfCheckGetter,\n\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\n\t    range: rangeCheckGetter,\n\t    lessThan: lessThanCheckGetter,\n\t    greaterThan: greaterThanCheckGetter,\n\n\t    shape: getShapeCheckGetter(),\n\t    args: argumentsCheckerGetter(),\n\n\t    any: anyCheckGetter(),\n\t    'null': nullCheckGetter()\n\n\t  };\n\n\t  function typeOfCheckGetter(type) {\n\t    var lType = type.toLowerCase();\n\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== lType) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function funcCheckGetter() {\n\t    var type = 'Function';\n\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'function') {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\n\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t      if (isError(apiError)) {\n\t        throw apiError;\n\t      }\n\t      var shapeChecker = checkers.shape(properties, true);\n\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\n\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t        var notFunction = checkers.func(val, name, location);\n\t        if (isError(notFunction)) {\n\t          return notFunction;\n\t        }\n\t        return shapeChecker(val, name, location);\n\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t    };\n\t    return functionChecker;\n\t  }\n\n\t  function objectCheckGetter() {\n\t    var type = 'Object';\n\t    var nullType = 'Object (null ok)';\n\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'object') {\n\t        return getError(name, location, nullType);\n\t      }\n\t    }, { type: nullType }, disabled);\n\n\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t        return getError(name, location, objectChecker.type);\n\t      }\n\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\n\t    return objectChecker;\n\t  }\n\n\t  function instanceCheckGetter(classToCheck) {\n\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t      if (!(val instanceof classToCheck)) {\n\t        return getError(name, location, classToCheck.name);\n\t      }\n\t    }, { type: classToCheck.name }, disabled);\n\t  }\n\n\t  function oneOfCheckGetter(enums) {\n\t    var type = {\n\t      __apiCheckData: { optional: false, type: 'enum' },\n\t      'enum': enums\n\t    };\n\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t      return stringify(enm);\n\t    }).join(', ') + ']';\n\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t      if (!enums.some(function (enm) {\n\t        return enm === val;\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t      return getCheckerDisplay(checker, { short: true });\n\t    });\n\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return typeCheckers.map(function (checker) {\n\t        return getCheckerDisplay(checker, options);\n\t      });\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t      if (!typeCheckers.some(function (checker) {\n\t        return !isError(checker(val, name, location));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function arrayOfCheckGetter(checker) {\n\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\n\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t        return !isError(checker(item));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function objectOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\n\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t      var notObject = checkers.object(val, name, location);\n\t      if (isError(notObject)) {\n\t        return notObject;\n\t      }\n\t      var allTypesSuccess = each(val, function (item, key) {\n\t        if (isError(checker(item, key, name))) {\n\t          return false;\n\t        }\n\t      });\n\t      if (!allTypesSuccess) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function typeOrArrayOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\n\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function getShapeCheckGetter() {\n\t    function shapeCheckGetter(shape, nonObject) {\n\t      var shapeTypes = {};\n\t      each(shape, function (checker, prop) {\n\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t      });\n\t      function type() {\n\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t        var ret = {};\n\t        var terse = options.terse;\n\t        var obj = options.obj;\n\t        var addHelpers = options.addHelpers;\n\n\t        var parentRequired = options.required;\n\t        each(shape, function (checker, prop) {\n\t          /* eslint complexity:[2, 6] */\n\t          var specified = obj && obj.hasOwnProperty(prop);\n\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t          if (!terse || (specified || !checker.isOptional)) {\n\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t          }\n\t          if (addHelpers) {\n\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t          }\n\t        });\n\t        return ret;\n\n\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t          if (!specified && required && !checker.isOptional) {\n\t            var item = 'ITEM';\n\t            if (checker.type && checker.type.__apiCheckData) {\n\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t            }\n\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t          } else if (specified) {\n\t            var error = checker(obj[prop], prop, null, obj);\n\t            if (isError(error)) {\n\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t            }\n\t          }\n\n\t          function addHelper(property, objectMessage, stringMessage) {\n\t            if (typeof theRet[prop] === 'string') {\n\t              theRet[prop] += stringMessage;\n\t            } else {\n\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t        /* eslint complexity:[2, 6] */\n\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t        if (isError(isObject)) {\n\t          return isObject;\n\t        }\n\t        var shapePropError = undefined;\n\t        location = location ? location + (name ? '/' : '') : '';\n\t        name = name || '';\n\t        each(shape, function (checker, prop) {\n\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t            return !isError(shapePropError);\n\t          }\n\t        });\n\t        if (isError(shapePropError)) {\n\t          return shapePropError;\n\t        }\n\t      }, { type: type, shortType: 'shape' }, disabled);\n\n\t      function strictType() {\n\t        return type.apply(undefined, arguments);\n\t      }\n\n\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t      strictType.__apiCheckData.strict = true;\n\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t        var shapeError = shapeChecker(val, name, location);\n\t        if (isError(shapeError)) {\n\t          return shapeError;\n\t        }\n\t        var allowedProperties = Object.keys(shape);\n\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t          return allowedProperties.indexOf(prop) === -1;\n\t        });\n\t        if (extraProps.length) {\n\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t        }\n\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\n\t      return shapeChecker;\n\t    }\n\n\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t      } else {\n\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (propExists === otherPropsExist) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t      otherProps = arrayify(otherProps);\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t      } else {\n\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t        var othersPresent = otherProps.every(function (property) {\n\t          return obj.hasOwnProperty(property);\n\t        });\n\t        if (!othersPresent) {\n\t          return getError(propName, location, type);\n\t        } else {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        throw new Error('requiredIfNot.all must be passed an array');\n\t      }\n\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t    };\n\n\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t      var props = t(otherProps.join(', '));\n\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var iteration = all ? 'every' : 'some';\n\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (!otherPropsExist && !propExists) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, notRequired: true }, disabled);\n\t    }\n\n\t    return shapeCheckGetter;\n\n\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t      function type(options) {\n\t        if (options && options.short) {\n\t          return shortType;\n\t        }\n\t        return getCheckerDisplay(propChecker);\n\t      }\n\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t      return type;\n\t    }\n\t  }\n\n\t  function argumentsCheckerGetter() {\n\t    var type = 'function arguments';\n\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function anyCheckGetter() {\n\t    return setupChecker(function anyCheckerDefinition() {\n\t      // don't do anything\n\t    }, { type: 'any' }, disabled);\n\t  }\n\n\t  function nullCheckGetter() {\n\t    var type = 'null';\n\t    return setupChecker(function nullChecker(val, name, location) {\n\t      if (val !== null) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function rangeCheckGetter(min, max) {\n\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t    return setupChecker(function rangeChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < min || val > max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function lessThanCheckGetter(min) {\n\t    var type = 'lessThan[' + min + ']';\n\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val > min) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function greaterThanCheckGetter(max) {\n\t    var type = 'greaterThan[' + max + ']';\n\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function emptyObjectCheckGetter() {\n\t    var type = 'empty object';\n\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/api-check/dist/api-check.js\n ** module id = 4\n ** module chunks = 2\n **/","/*!\n* angular-formly JavaScript Library v7.3.4\n*\n* @license MIT (http://license.angular-formly.com)\n*\n* built with ♥ by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n* (ó ì_í)=óò=(ì_í ò)\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _indexCommon = __webpack_require__(1);\n\n\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\n\texports['default'] = _indexCommon2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\n\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\n\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\n\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\n\tvar _providersFormlyUsability = __webpack_require__(7);\n\n\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\n\tvar _providersFormlyConfig = __webpack_require__(8);\n\n\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\n\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\n\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\n\tvar _servicesFormlyUtil = __webpack_require__(11);\n\n\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\n\tvar _servicesFormlyWarn = __webpack_require__(12);\n\n\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\n\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\n\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\n\tvar _directivesFormlyField = __webpack_require__(14);\n\n\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\n\tvar _directivesFormlyFocus = __webpack_require__(15);\n\n\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\n\tvar _directivesFormlyForm = __webpack_require__(16);\n\n\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\n\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\n\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\n\tvar _runFormlyCustomTags = __webpack_require__(18);\n\n\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\n\tvar ngModuleName = 'formly';\n\n\texports['default'] = ngModuleName;\n\n\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\n\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\tngModule.constant('formlyVersion', (\"7.3.4\")); // <-- webpack variable\n\n\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\n\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\n\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\n\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\tngModule.run(_runFormlyCustomTags2['default']);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar angular = __webpack_require__(3);\n\n\t/* istanbul ignore next */\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\texports['default'] = angular;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\tvar apiCheck = (0, _apiCheck2['default'])({\n\t  output: {\n\t    prefix: 'angular-formly:',\n\t    docsBaseUrl: __webpack_require__(6)\n\t  }\n\t});\n\n\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t    otherProps = [otherProps];\n\t  }\n\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\n\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t      return obj && obj.hasOwnProperty(otherProp);\n\t    });\n\t    if (!otherPropsExist && !propExists) {\n\t      return apiCheck.utils.getError(propName, location, type);\n\t    } else if (propExists) {\n\t      return propChecker(prop, propName, location, obj);\n\t    }\n\t  }\n\n\t  shapeRequiredIfNotDefinition.type = type;\n\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t}\n\n\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\n\tvar apiCheckProperty = apiCheck.func;\n\n\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t  warn: apiCheck.func,\n\t  'throw': apiCheck.func,\n\t  shape: apiCheck.func\n\t}));\n\n\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\n\tvar formlyWrapperType = apiCheck.shape({\n\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  overwriteOk: apiCheck.bool.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional\n\t}).strict;\n\n\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\n\tvar templateManipulators = apiCheck.shape({\n\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t}).strict.nullable;\n\n\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar fieldOptionsApiShape = {\n\t  $$hashKey: apiCheck.any.optional,\n\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  model: modelChecker.optional,\n\t  originalModel: modelChecker.optional,\n\t  className: apiCheck.string.optional,\n\t  id: apiCheck.string.optional,\n\t  name: apiCheck.string.optional,\n\t  expressionProperties: expressionProperties.optional,\n\t  extras: apiCheck.shape({\n\t    validateOnModelChange: apiCheck.bool.optional,\n\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t  }).strict.optional,\n\t  data: apiCheck.object.optional,\n\t  templateOptions: apiCheck.object.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  modelOptions: apiCheck.shape({\n\t    updateOn: apiCheck.string.optional,\n\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t    allowInvalid: apiCheck.bool.optional,\n\t    getterSetter: apiCheck.bool.optional,\n\t    timezone: apiCheck.string.optional\n\t  }).optional,\n\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t    expression: formlyExpression.optional,\n\t    listener: formlyExpression\n\t  })).optional,\n\t  validators: validatorChecker.optional,\n\t  asyncValidators: validatorChecker.optional,\n\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t  noFormControl: apiCheck.bool.optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t  }).strict).optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  link: apiCheck.func.optional,\n\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t  validation: apiCheck.shape({\n\t    show: apiCheck.bool.nullable.optional,\n\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t  }).optional,\n\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t  value: apiCheck.func.optional,\n\t  runExpressions: apiCheck.func.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  initialValue: apiCheck.any.optional,\n\t  defaultValue: apiCheck.any.optional\n\t};\n\n\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\n\tvar formOptionsApi = apiCheck.shape({\n\t  formState: apiCheck.object.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t  data: apiCheck.object.optional\n\t}).strict;\n\n\tvar fieldGroup = apiCheck.shape({\n\t  $$hashKey: apiCheck.any.optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  // danger. Nested field groups wont get api-checked...\n\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t  className: apiCheck.string.optional,\n\t  options: formOptionsApi.optional,\n\t  templateOptions: apiCheck.object.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  data: apiCheck.object.optional,\n\t  model: modelChecker.optional,\n\t  form: apiCheck.object.optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t}).strict;\n\n\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\n\tvar formlyTypeOptions = apiCheck.shape({\n\t  name: apiCheck.string,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t  link: apiCheck.func.optional,\n\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t  'extends': apiCheck.string.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  data: apiCheck.object.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional,\n\t  overwriteOk: apiCheck.bool.optional\n\t}).strict;\n\n\t_angularFix2['default'].extend(apiCheck, {\n\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t});\n\n\texports['default'] = apiCheck;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.3.4\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyUsability;\n\n\t// @ngInject\n\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t  var _this = this;\n\n\t  _angularFix2['default'].extend(this, {\n\t    getFormlyError: getFormlyError,\n\t    getFieldError: getFieldError,\n\t    checkWrapper: checkWrapper,\n\t    checkWrapperTemplate: checkWrapperTemplate,\n\t    getErrorMessage: getErrorMessage,\n\t    $get: function $get() {\n\t      return _this;\n\t    }\n\t  });\n\n\t  function getFieldError(errorInfoSlug, message, field) {\n\t    if (arguments.length < 3) {\n\t      field = message;\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t  }\n\n\t  function getFormlyError(errorInfoSlug, message) {\n\t    if (!message) {\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t  }\n\n\t  function getErrorMessage(errorInfoSlug, message) {\n\t    var url = '';\n\t    if (errorInfoSlug !== null) {\n\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t    }\n\t    return 'Formly Error: ' + message + '. ' + url;\n\t  }\n\n\t  function checkWrapper(wrapper) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t      prefix: 'formlyConfig.setWrapper',\n\t      urlSuffix: 'setwrapper-validation-failed'\n\t    });\n\t  }\n\n\t  function checkWrapperTemplate(template, additionalInfo) {\n\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t    if (template.indexOf(formlyTransclude) === -1) {\n\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t    }\n\t  }\n\t}\n\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyConfig;\n\n\t// @ngInject\n\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t  var _this2 = this;\n\n\t  var typeMap = {};\n\t  var templateWrappersMap = {};\n\t  var defaultWrapperName = 'default';\n\t  var _this = this;\n\t  var getError = formlyUsabilityProvider.getFormlyError;\n\n\t  _angularFix2['default'].extend(this, {\n\t    setType: setType,\n\t    getType: getType,\n\t    getTypeHeritage: getTypeHeritage,\n\t    setWrapper: setWrapper,\n\t    getWrapper: getWrapper,\n\t    getWrapperByType: getWrapperByType,\n\t    removeWrapperByName: removeWrapperByName,\n\t    removeWrappersForType: removeWrappersForType,\n\t    disableWarnings: false,\n\t    extras: {\n\t      disableNgModelAttrsManipulator: false,\n\t      fieldTransform: [],\n\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t      removeChromeAutoComplete: false,\n\t      defaultHideDirective: 'ng-if',\n\t      getFieldId: null\n\t    },\n\t    templateManipulators: {\n\t      preWrapper: [],\n\t      postWrapper: []\n\t    },\n\t    $get: function $get() {\n\t      return _this2;\n\t    }\n\t  });\n\n\t  function setType(options) {\n\t    if (_angularFix2['default'].isArray(options)) {\n\t      var _ret = (function () {\n\t        var allTypes = [];\n\t        _angularFix2['default'].forEach(options, function (item) {\n\t          allTypes.push(setType(item));\n\t        });\n\t        return {\n\t          v: allTypes\n\t        };\n\t      })();\n\n\t      if (typeof _ret === 'object') return _ret.v;\n\t    } else if (_angularFix2['default'].isObject(options)) {\n\t      checkType(options);\n\t      if (options['extends']) {\n\t        extendTypeOptions(options);\n\t      }\n\t      typeMap[options.name] = options;\n\t      return typeMap[options.name];\n\t    } else {\n\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t    }\n\t  }\n\n\t  function checkType(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t      prefix: 'formlyConfig.setType',\n\t      url: 'settype-validation-failed'\n\t    });\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t    } else {\n\t      options.overwriteOk = undefined;\n\t    }\n\t  }\n\n\t  function extendTypeOptions(options) {\n\t    var extendsType = getType(options['extends'], true, options);\n\t    extendTypeControllerFunction(options, extendsType);\n\t    extendTypeLinkFunction(options, extendsType);\n\t    extendTypeDefaultOptions(options, extendsType);\n\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t    extendTemplate(options, extendsType);\n\t  }\n\n\t  function extendTemplate(options, extendsType) {\n\t    if (options.template && extendsType.templateUrl) {\n\t      delete options.templateUrl;\n\t    } else if (options.templateUrl && extendsType.template) {\n\t      delete options.template;\n\t    }\n\t  }\n\n\t  function extendTypeControllerFunction(options, extendsType) {\n\t    var extendsCtrl = extendsType.controller;\n\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t      return;\n\t    }\n\t    var optionsCtrl = options.controller;\n\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t      options.controller = function ($scope, $controller) {\n\t        $controller(extendsCtrl, { $scope: $scope });\n\t        $controller(optionsCtrl, { $scope: $scope });\n\t      };\n\t      options.controller.$inject = ['$scope', '$controller'];\n\t    } else {\n\t      options.controller = extendsCtrl;\n\t    }\n\t  }\n\n\t  function extendTypeLinkFunction(options, extendsType) {\n\t    var extendsFn = extendsType.link;\n\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t      return;\n\t    }\n\t    var optionsFn = options.link;\n\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t      options.link = function () {\n\t        extendsFn.apply(undefined, arguments);\n\t        optionsFn.apply(undefined, arguments);\n\t      };\n\t    } else {\n\t      options.link = extendsFn;\n\t    }\n\t  }\n\n\t  function extendTypeDefaultOptions(options, extendsType) {\n\t    var extendsDO = extendsType.defaultOptions;\n\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t      return;\n\t    }\n\t    var optionsDO = options.defaultOptions;\n\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t    if (extendsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t        var mergedDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t        var extenderOptionsDefaultOptions = optionsDO;\n\t        if (optionsDOIsFn) {\n\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t        }\n\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t        return extendsDefaultOptions;\n\t      };\n\t    } else if (optionsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var newDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t        return optionsDO(newDefaultOptions, scope);\n\t      };\n\t    }\n\t  }\n\n\t  function getType(name, throwError, errorContext) {\n\t    if (!name) {\n\t      return undefined;\n\t    }\n\t    var type = typeMap[name];\n\t    if (!type && throwError === true) {\n\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t    } else {\n\t      return type;\n\t    }\n\t  }\n\n\t  function getTypeHeritage(parent) {\n\t    var heritage = [];\n\t    var type = parent;\n\t    if (_angularFix2['default'].isString(type)) {\n\t      type = getType(parent);\n\t    }\n\t    parent = type['extends'];\n\t    while (parent) {\n\t      type = getType(parent);\n\t      heritage.push(type);\n\t      parent = type['extends'];\n\t    }\n\t    return heritage;\n\t  }\n\n\t  function setWrapper(_x, _x2) {\n\t    var _again = true;\n\n\t    _function: while (_again) {\n\t      var options = _x,\n\t          name = _x2;\n\t      _again = false;\n\n\t      if (_angularFix2['default'].isArray(options)) {\n\t        return options.map(function (wrapperOptions) {\n\t          return setWrapper(wrapperOptions);\n\t        });\n\t      } else if (_angularFix2['default'].isObject(options)) {\n\t        options.types = getOptionsTypes(options);\n\t        options.name = getOptionsName(options, name);\n\t        checkWrapperAPI(options);\n\t        templateWrappersMap[options.name] = options;\n\t        return options;\n\t      } else if (_angularFix2['default'].isString(options)) {\n\t        _x = {\n\t          template: options,\n\t          name: name\n\t        };\n\t        _x2 = undefined;\n\t        _again = true;\n\t        continue _function;\n\t      }\n\t    }\n\t  }\n\n\t  function getOptionsTypes(options) {\n\t    if (_angularFix2['default'].isString(options.types)) {\n\t      return [options.types];\n\t    }\n\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t      return [];\n\t    } else {\n\t      return options.types;\n\t    }\n\t  }\n\n\t  function getOptionsName(options, name) {\n\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t  }\n\n\t  function checkWrapperAPI(options) {\n\t    formlyUsabilityProvider.checkWrapper(options);\n\t    if (options.template) {\n\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t    }\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t    } else {\n\t      delete options.overwriteOk;\n\t    }\n\t    checkWrapperTypes(options);\n\t  }\n\n\t  function checkWrapperTypes(options) {\n\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t    if (shouldThrow) {\n\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t    }\n\t  }\n\n\t  function checkOverwrite(property, object, newValue, objectName) {\n\t    if (object.hasOwnProperty(property)) {\n\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t    }\n\t  }\n\n\t  function getWrapper(name) {\n\t    return templateWrappersMap[name || defaultWrapperName];\n\t  }\n\n\t  function getWrapperByType(type) {\n\t    /* eslint prefer-const:0 */\n\t    var wrappers = [];\n\t    for (var _name in templateWrappersMap) {\n\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t          wrappers.push(templateWrappersMap[_name]);\n\t        }\n\t      }\n\t    }\n\t    return wrappers;\n\t  }\n\n\t  function removeWrapperByName(name) {\n\t    var wrapper = templateWrappersMap[name];\n\t    delete templateWrappersMap[name];\n\t    return wrapper;\n\t  }\n\n\t  function removeWrappersForType(type) {\n\t    var wrappers = getWrapperByType(type);\n\t    if (!wrappers) {\n\t      return undefined;\n\t    }\n\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t      return removeWrapperByName(wrappers.name);\n\t    } else {\n\t      wrappers.forEach(function (wrapper) {\n\t        return removeWrapperByName(wrapper.name);\n\t      });\n\t      return wrappers;\n\t    }\n\t  }\n\n\t  function warn() {\n\t    if (!_this.disableWarnings && console.warn) {\n\t      /* eslint no-console:0 */\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      console.warn.apply(console, _toConsumableArray(args));\n\t    }\n\t  }\n\t}\n\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = {\n\t  formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName, arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t};\n\n\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t  if (_angularFix2['default'].isFunction(expression)) {\n\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t  } else {\n\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t  }\n\t}\n\n\tfunction getFieldId(formId, options, index) {\n\t  if (options.id) {\n\t    return options.id;\n\t  }\n\t  var type = options.type;\n\t  if (!type && options.template) {\n\t    type = 'template';\n\t  } else if (!type && options.templateUrl) {\n\t    type = 'templateUrl';\n\t  }\n\n\t  return [formId, type, options.key, index].join('_');\n\t}\n\n\tfunction reverseDeepMerge(dest) {\n\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t    if (!index) {\n\t      return;\n\t    }\n\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t        dest[prop] = _angularFix2['default'].copy(val);\n\t      } else if (objAndSameType(dest[prop], val)) {\n\t        reverseDeepMerge(dest[prop], val);\n\t      }\n\t    });\n\t  });\n\t  return dest;\n\t}\n\n\tfunction objAndSameType(obj1, obj2) {\n\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t}\n\n\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\tfunction findByNodeName(el, nodeName) {\n\t  if (!el.prop) {\n\t    // not a jQuery or jqLite object -> wrap it\n\t    el = _angularFix2['default'].element(el);\n\t  }\n\n\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t    return el;\n\t  }\n\n\t  var c = el.children();\n\t  for (var i = 0; c && i < c.length; i++) {\n\t    var node = findByNodeName(c[i], nodeName);\n\t    if (node) {\n\t      return node;\n\t    }\n\t  }\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t    obj = [obj];\n\t  } else if (!obj) {\n\t    obj = [];\n\t  }\n\t  return obj;\n\t}\n\n\tfunction extendFunction() {\n\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t    fns[_key] = arguments[_key];\n\t  }\n\n\t  return function extendedFunction() {\n\t    var args = arguments;\n\t    fns.forEach(function (fn) {\n\t      return fn.apply(null, args);\n\t    });\n\t  };\n\t}\n\n\tfunction extendArray(primary, secondary, property) {\n\t  if (property) {\n\t    primary = primary[property];\n\t    secondary = secondary[property];\n\t  }\n\t  if (secondary && primary) {\n\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t      if (primary.indexOf(item) === -1) {\n\t        primary.push(item);\n\t      }\n\t    });\n\t    return primary;\n\t  } else if (secondary) {\n\t    return secondary;\n\t  } else {\n\t    return primary;\n\t  }\n\t}\n\n\tfunction startsWith(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n\tfunction contains(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = formlyValidationMessages;\n\n\t// @ngInject\n\tfunction formlyValidationMessages() {\n\n\t  var validationMessages = {\n\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t    addStringMessage: addStringMessage,\n\t    messages: {}\n\t  };\n\n\t  return validationMessages;\n\n\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t  }\n\n\t  function addStringMessage(name, string) {\n\t    validationMessages.messages[name] = function () {\n\t      return string;\n\t    };\n\t  }\n\n\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t      if (typeof scope.options.templateOptions[prop] !== 'undefined') {\n\t        return prefix + ' ' + scope.options.templateOptions[prop] + ' ' + suffix;\n\t      } else {\n\t        return alternate;\n\t      }\n\t    };\n\t  }\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyUtil;\n\n\t// @ngInject\n\tfunction formlyUtil() {\n\t  return _otherUtils2['default'];\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\texports['default'] = formlyWarn;\n\n\t// @ngInject\n\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t  return function warn() {\n\t    if (!formlyConfig.disableWarnings) {\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      $log.warn.apply($log, _toConsumableArray(args));\n\t    }\n\t  };\n\t}\n\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyCustomValidation;\n\n\t// @ngInject\n\tfunction formlyCustomValidation(formlyUtil) {\n\t  return {\n\t    restrict: 'A',\n\t    require: 'ngModel',\n\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t      var opts = scope.options;\n\t      opts.validation.messages = opts.validation.messages || {};\n\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t        opts.validation.messages[key] = function () {\n\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t        };\n\t      });\n\n\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\n\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t        setupMessage(validator, name);\n\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t        if (useNewValidatorsApi) {\n\t          setupWithValidators(validator, name, isAsync);\n\t        } else {\n\t          setupWithParsers(validator, name, isAsync);\n\t        }\n\t      }\n\n\t      function setupMessage(validator, name) {\n\t        var message = validator.message;\n\t        if (message) {\n\t          opts.validation.messages[name] = function () {\n\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t          };\n\t        }\n\t      }\n\n\t      function setupWithValidators(validator, name, isAsync) {\n\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\n\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t        };\n\t      }\n\n\t      function setupWithParsers(validator, name, isAsync) {\n\t        var inFlightValidator = undefined;\n\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t          if (isAsync) {\n\t            ctrl.$pending = ctrl.$pending || {};\n\t            ctrl.$pending[name] = true;\n\t            inFlightValidator = isValid;\n\t            isValid.then(function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, true);\n\t              }\n\t            })['catch'](function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, false);\n\t              }\n\t            })['finally'](function () {\n\t              var $pending = ctrl.$pending || {};\n\t              if (Object.keys($pending).length === 1) {\n\t                delete ctrl.$pending;\n\t              } else {\n\t                delete ctrl.$pending[name];\n\t              }\n\t            });\n\t          } else {\n\t            ctrl.$setValidity(name, isValid);\n\t          }\n\t          return viewValue;\n\t        });\n\t      }\n\t    }\n\t  };\n\t}\n\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = formlyField;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyField\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t  var arrayify = formlyUtil.arrayify;\n\n\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t  return {\n\t    restrict: 'AE',\n\t    transclude: true,\n\t    require: '?^formlyForm',\n\t    scope: {\n\t      options: '=',\n\t      model: '=',\n\t      originalModel: '=?',\n\t      formId: '@', // TODO remove formId in a breaking release\n\t      index: '=?',\n\t      fields: '=?',\n\t      formState: '=?',\n\t      formOptions: '=?',\n\t      form: '=?' },\n\t    // TODO require form in a breaking release\n\t    controller: FormlyFieldController,\n\t    link: fieldLink\n\t  };\n\n\t  // @ngInject\n\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t    /* eslint max-statements:[2, 31] */\n\t    if ($scope.options.fieldGroup) {\n\t      setupFieldGroup();\n\t      return;\n\t    }\n\n\t    var fieldType = getFieldType($scope.options);\n\t    simplifyLife($scope.options);\n\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t    checkApi($scope.options);\n\t    // set field id to link labels and fields\n\n\t    // initalization\n\t    setFieldIdAndName();\n\t    setDefaultValue();\n\t    setInitialValue();\n\t    runExpressions();\n\t    addValidationMessages($scope.options);\n\t    invokeControllers($scope, $scope.options, fieldType);\n\n\t    // function definitions\n\t    function runExpressions() {\n\t      // must run on next tick to make sure that the current value is correct.\n\t      return $timeout(function runExpressionsOnNextTick() {\n\t        var field = $scope.options;\n\t        var currentValue = valueGetterSetter();\n\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t          var setter = $parse(prop).assign;\n\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t          promise.then(function setFieldValue(value) {\n\t            setter(field, value);\n\t          });\n\t        });\n\t      }, 0, false);\n\t    }\n\n\t    function valueGetterSetter(newVal) {\n\t      if (!$scope.model || !$scope.options.key) {\n\t        return undefined;\n\t      }\n\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t        parseSet($scope.options.key, $scope.model, newVal);\n\t      }\n\t      return parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function parseSet(key, model, newVal) {\n\t      // If either of these are null/undefined then just return undefined\n\t      if (!key || !model) {\n\t        return;\n\t      }\n\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t      if (_angularFix2['default'].isNumber(key)) {\n\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t        model[key] = newVal;\n\t      } else {\n\t        var setter = $parse($scope.options.key).assign;\n\t        if (setter) {\n\t          setter($scope.model, newVal);\n\t        }\n\t      }\n\t    }\n\n\t    function parseGet(key, model) {\n\t      // If either of these are null/undefined then just return undefined\n\t      if (!key || !model) {\n\t        return undefined;\n\t      }\n\n\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t      if (_angularFix2['default'].isNumber(key)) {\n\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t        return model[key];\n\t      } else {\n\t        return $parse(key)(model);\n\t      }\n\t    }\n\n\t    function simplifyLife(options) {\n\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t      formlyUtil.reverseDeepMerge(options, {\n\t        originalModel: options.model,\n\t        extras: {},\n\t        data: {},\n\t        templateOptions: {},\n\t        validation: {}\n\t      });\n\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t      $scope.to = $scope.options.templateOptions;\n\t      $scope.formOptions = $scope.formOptions || {};\n\t    }\n\n\t    function setFieldIdAndName() {\n\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t      } else {\n\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t      }\n\t      $scope.options.id = $scope.id;\n\t      $scope.name = $scope.options.name || $scope.options.id;\n\t      $scope.options.name = $scope.name;\n\t    }\n\n\t    function setDefaultValue() {\n\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined(parseGet($scope.options.key, $scope.model))) {\n\t        parseSet($scope.options.key, $scope.model, $scope.options.defaultValue);\n\t      }\n\t    }\n\n\t    function setInitialValue() {\n\t      $scope.options.initialValue = $scope.model && parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t      if (type) {\n\t        mergeOptions(options, type.defaultOptions);\n\t      }\n\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t      });\n\t    }\n\n\t    function mergeOptions(options, extraOptions) {\n\t      if (extraOptions) {\n\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t          extraOptions = extraOptions(options, $scope);\n\t        }\n\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t      }\n\t    }\n\n\t    function extendOptionsWithDefaults(options, index) {\n\t      var key = options.key || index || 0;\n\t      _angularFix2['default'].extend(options, {\n\t        // attach the key in case the formly-field directive is used directly\n\t        key: key,\n\t        value: options.value || valueGetterSetter,\n\t        runExpressions: runExpressions,\n\t        resetModel: resetModel,\n\t        updateInitialValue: updateInitialValue\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      parseSet($scope.options.key, $scope.model, $scope.options.initialValue);\n\t      if ($scope.options.formControl) {\n\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t            resetFormControl(formControl, true);\n\t          });\n\t        } else {\n\t          resetFormControl($scope.options.formControl);\n\t        }\n\t      }\n\t    }\n\n\t    function resetFormControl(formControl, isMultiNgModel) {\n\t      if (!isMultiNgModel) {\n\t        formControl.$setViewValue(parseGet($scope.options.key, $scope.model));\n\t      }\n\n\t      formControl.$render();\n\t      formControl.$setUntouched && formControl.$setUntouched();\n\t      formControl.$setPristine();\n\n\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t      if (!$scope.$root.$$phase) {\n\t        $scope.$digest();\n\t      }\n\t    }\n\n\t    function updateInitialValue() {\n\t      $scope.options.initialValue = parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function addValidationMessages(options) {\n\t      options.validation.messages = options.validation.messages || {};\n\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t        if (!options.validation.messages[name]) {\n\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t          };\n\t        }\n\t      });\n\t    }\n\n\t    function invokeControllers(scope) {\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t        if (controller) {\n\t          $controller(controller, { $scope: scope });\n\t        }\n\t      });\n\t    }\n\n\t    function setupFieldGroup() {\n\t      $scope.options.options = $scope.options.options || {};\n\t      $scope.options.options.formState = $scope.formState;\n\t      $scope.to = $scope.options.templateOptions;\n\t    }\n\t  }\n\n\t  // link function\n\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t    if (scope.options.fieldGroup) {\n\t      setFieldGroupTemplate();\n\t      return;\n\t    }\n\n\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t    if (!formlyFormCtrl && scope.options.model) {\n\t      scope.$watch('options.model', function () {\n\t        return scope.options.runExpressions();\n\t      }, true);\n\t    }\n\n\t    addAttributes();\n\t    addClasses();\n\n\t    var type = getFieldType(scope.options);\n\t    var args = arguments;\n\t    var thusly = this;\n\t    var fieldCount = 0;\n\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t    });\n\n\t    function setFieldGroupTemplate() {\n\t      checkFieldGroupApi(scope.options);\n\t      el.addClass('formly-field-group');\n\t      var extraAttributes = '';\n\t      if (scope.options.elementAttributes) {\n\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t        }).join(' ');\n\t      }\n\t      var modelValue = 'model';\n\t      scope.options.form = scope.form;\n\t      if (scope.options.key) {\n\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t      }\n\t      getTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ').then(transcludeInWrappers(scope.options, scope.formOptions)).then(setElementTemplate);\n\t    }\n\n\t    function addAttributes() {\n\t      if (scope.options.elementAttributes) {\n\t        el.attr(scope.options.elementAttributes);\n\t      }\n\t    }\n\n\t    function addClasses() {\n\t      if (scope.options.className) {\n\t        el.addClass(scope.options.className);\n\t      }\n\t      if (scope.options.type) {\n\t        el.addClass('formly-field-' + scope.options.type);\n\t      }\n\t    }\n\n\t    function setElementTemplate(templateString) {\n\t      el.html(asHtml(templateString));\n\t      $compile(el.contents())(scope);\n\t      return templateString;\n\t    }\n\n\t    function watchFormControl(templateString) {\n\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t      if (scope.options.noFormControl) {\n\t        return;\n\t      }\n\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\n\t      if (ngModelNodes.length) {\n\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t          fieldCount++;\n\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t        });\n\t      }\n\n\t      function watchFieldNameOrExistence(name) {\n\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t        var nameExpression = nameExpressionRegex.exec(name);\n\t        if (nameExpression) {\n\t          name = $interpolate(name)(scope);\n\t        }\n\t        watchFieldExistence(name);\n\t      }\n\n\t      function watchFieldExistence(name) {\n\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t          if (formControl) {\n\t            if (fieldCount > 1) {\n\t              if (!scope.options.formControl) {\n\t                scope.options.formControl = [];\n\t              }\n\t              scope.options.formControl.push(formControl);\n\t            } else {\n\t              scope.options.formControl = formControl;\n\t            }\n\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t            stopWatchingShowError();\n\t            addShowMessagesWatcher();\n\t            addParsers();\n\t            addFormatters();\n\t          }\n\t        });\n\t      }\n\n\t      function addShowMessagesWatcher() {\n\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t          var options = scope.options;\n\t          var formControls = arrayify(scope.fc);\n\t          if (!formControls.some(function (fc) {\n\t            return fc.$invalid;\n\t          })) {\n\t            return false;\n\t          } else if (typeof options.validation.show === 'boolean') {\n\t            return options.validation.show;\n\t          } else if (customExpression) {\n\t            return formControls.some(function (fc) {\n\t              return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t            });\n\t          } else {\n\t            return formControls.some(function (fc) {\n\t              var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t              return fc.$touched || noTouchedButDirty;\n\t            });\n\t          }\n\t        }, function onShowValidationChange(show) {\n\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t          scope.showError = show; // shortcut for template authors\n\t        });\n\t      }\n\n\t      function addParsers() {\n\t        setParsersOrFormatters('parsers');\n\t      }\n\n\t      function addFormatters() {\n\t        setParsersOrFormatters('formatters');\n\t        var ctrl = scope.fc;\n\t        var formWasPristine = scope.form.$pristine;\n\t        if (scope.options.formatters) {\n\t          (function () {\n\t            var value = ctrl.$modelValue;\n\t            ctrl.$formatters.forEach(function (formatter) {\n\t              value = formatter(value);\n\t            });\n\n\t            ctrl.$setViewValue(value);\n\t            ctrl.$render();\n\t            ctrl.$setPristine();\n\t            if (formWasPristine) {\n\t              scope.form.$setPristine();\n\t            }\n\t          })();\n\t        }\n\t      }\n\n\t      function setParsersOrFormatters(which) {\n\t        var originalThingProp = 'originalParser';\n\t        if (which === 'formatters') {\n\t          originalThingProp = 'originalFormatter';\n\t        }\n\n\t        // init with type's parsers\n\t        var things = getThingsFromType(type);\n\n\t        // get optionsTypes things\n\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\n\t        // get field's things\n\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\n\t        // convert things into formlyExpression things\n\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t          things[index] = getFormlyExpressionThing(thing);\n\t        });\n\n\t        var ngModelCtrls = scope.fc;\n\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t          ngModelCtrls = [ngModelCtrls];\n\t        }\n\n\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t          var _ngModelCtrl;\n\n\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t        });\n\n\t        function getThingsFromType(theType) {\n\t          if (!theType) {\n\t            return [];\n\t          }\n\t          if (_angularFix2['default'].isString(theType)) {\n\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t          }\n\t          var typeThings = [];\n\n\t          // get things from parent\n\t          if (theType['extends']) {\n\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t          }\n\n\t          // get own type's things\n\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\n\t          // get things from optionsTypes\n\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\n\t          return typeThings;\n\t        }\n\n\t        function getThingsFromOptionsTypes() {\n\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n\t          var optionsTypesThings = [];\n\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t          });\n\t          return optionsTypesThings;\n\t        }\n\n\t        function getFormlyExpressionThing(thing) {\n\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t          return formlyExpressionParserOrFormatterFunction;\n\n\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t            var $modelValue = scope.options.value();\n\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    function callLinkFunctions() {\n\t      if (type && type.link) {\n\t        type.link.apply(thusly, args);\n\t      }\n\t      if (scope.options.link) {\n\t        scope.options.link.apply(thusly, args);\n\t      }\n\t    }\n\n\t    function runManipulators(manipulators) {\n\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t        var chain = $q.when(templateToManipulate);\n\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t          chain = chain.then(function (template) {\n\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t            });\n\t          });\n\t        });\n\t        return chain;\n\t      };\n\t    }\n\t  }\n\n\t  // sort-of stateless util functions\n\t  function asHtml(el) {\n\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t    return wrapper.append(el).html();\n\t  }\n\n\t  function getFieldType(options) {\n\t    return options.type && formlyConfig.getType(options.type);\n\t  }\n\n\t  function getManipulators(options, formOptions) {\n\t    var preWrapper = [];\n\t    var postWrapper = [];\n\t    addManipulators(options.templateManipulators);\n\t    addManipulators(formOptions.templateManipulators);\n\t    addManipulators(formlyConfig.templateManipulators);\n\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\n\t    function addManipulators(manipulators) {\n\t      /* eslint-disable */ // it doesn't understand this :-(\n\n\t      var _ref = manipulators || {};\n\n\t      var _ref$preWrapper = _ref.preWrapper;\n\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t      var _ref$postWrapper = _ref.postWrapper;\n\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\n\t      preWrapper = preWrapper.concat(pre);\n\t      postWrapper = postWrapper.concat(post);\n\t      /* eslint-enable */\n\t    }\n\t  }\n\n\t  function getFieldTemplate(options) {\n\t    function fromOptionsOrType(key, fieldType) {\n\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t        return options[key];\n\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t        return fieldType[key];\n\t      }\n\t    }\n\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    var template = fromOptionsOrType('template', type);\n\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t    }\n\n\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t  }\n\n\t  function getTemplate(template, isUrl, options) {\n\t    var templatePromise = undefined;\n\t    if (_angularFix2['default'].isFunction(template)) {\n\t      templatePromise = $q.when(template(options));\n\t    } else {\n\t      templatePromise = $q.when(template);\n\t    }\n\n\t    if (!isUrl) {\n\t      return templatePromise;\n\t    } else {\n\t      var _ret2 = (function () {\n\t        var httpOptions = { cache: $templateCache };\n\t        return {\n\t          v: templatePromise.then(function (url) {\n\t            return $http.get(url, httpOptions);\n\t          }).then(function (response) {\n\t            return response.data;\n\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t          })\n\t        };\n\t      })();\n\n\t      if (typeof _ret2 === 'object') return _ret2.v;\n\t    }\n\t  }\n\n\t  function transcludeInWrappers(options, formOptions) {\n\t    var wrapper = getWrapperOption(options, formOptions);\n\n\t    return function transcludeTemplate(template) {\n\t      if (!wrapper.length) {\n\t        return $q.when(template);\n\t      }\n\n\t      wrapper.forEach(function (aWrapper) {\n\t        formlyUsability.checkWrapper(aWrapper, options);\n\t        runApiCheck(aWrapper, options);\n\t      });\n\t      var promises = wrapper.map(function (w) {\n\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t      });\n\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t        });\n\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t        var totalWrapper = wrappersTemplates.shift();\n\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t        });\n\t        return doTransclusion(totalWrapper, template);\n\t      });\n\t    };\n\t  }\n\n\t  function doTransclusion(wrapper, template) {\n\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t    superWrapper.append(wrapper);\n\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t    if (!transcludeEl.length) {\n\t      // try it using our custom find function\n\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t    }\n\t    transcludeEl.replaceWith(template);\n\t    return superWrapper.html();\n\t  }\n\n\t  function getWrapperOption(options, formOptions) {\n\t    /* eslint complexity:[2, 6] */\n\t    var wrapper = options.wrapper;\n\t    // explicit null means no wrapper\n\t    if (wrapper === null) {\n\t      return [];\n\t    }\n\n\t    // nothing specified means use the default wrapper for the type\n\t    if (!wrapper) {\n\t      // get all wrappers that specify they apply to this type\n\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t    } else {\n\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t    }\n\n\t    // get all wrappers for that the type specified that it uses.\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    if (type && type.wrapper) {\n\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(typeWrappers);\n\t    }\n\n\t    // add form wrappers\n\t    if (formOptions.wrapper) {\n\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(formWrappers);\n\t    }\n\n\t    // add the default wrapper last\n\t    var defaultWrapper = formlyConfig.getWrapper();\n\t    if (defaultWrapper) {\n\t      wrapper.push(defaultWrapper);\n\t    }\n\t    return wrapper;\n\t  }\n\n\t  function checkApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t    // validate with the type\n\t    var type = options.type && formlyConfig.getType(options.type);\n\t    if (type) {\n\t      runApiCheck(type, options, true);\n\t    }\n\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t    }\n\t  }\n\n\t  function checkFieldGroupApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t  }\n\n\t  function runApiCheck(_ref2, options, forType) {\n\t    var apiCheck = _ref2.apiCheck;\n\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\n\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t    if (forType && options.type) {\n\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t      });\n\t    }\n\t  }\n\n\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t    /* eslint complexity:[2, 9] */\n\t    if (!apiCheck) {\n\t      return;\n\t    }\n\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t      return;\n\t    }\n\t    var fn = apiCheckFunction || 'warn';\n\t    // this is the new API\n\t    var checkerObjects = apiCheck(instance);\n\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t      var checker = instance.shape(shape);\n\t      var checkOptions = _angularFix2['default'].extend({\n\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t      }, apiCheckOptions);\n\t      instance[fn](checker, options[name], checkOptions);\n\t    });\n\t  }\n\t}\n\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\n\t// Stateless util functions\n\tfunction getDefaultOptionsOptionsTypes(type) {\n\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t}\n\n\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = formlyFocus;\n\n\t// @ngInject\n\tfunction formlyFocus($timeout, $document) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function formlyFocusLink(scope, element, attrs) {\n\t      var previousEl = null;\n\t      var el = element[0];\n\t      var doc = $document[0];\n\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t        if (value === 'true') {\n\t          $timeout(function setElementFocus() {\n\t            previousEl = doc.activeElement;\n\t            el.focus();\n\t          }, ~ ~attrs.focusWait);\n\t        } else if (value === 'false') {\n\t          if (doc.activeElement === el) {\n\t            el.blur();\n\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t              previousEl.focus();\n\t            }\n\t          }\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar _slice = Array.prototype.slice;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyForm;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyForm\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t  var currentFormId = 1;\n\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t  return {\n\t    restrict: 'AE',\n\t    template: formlyFormGetTemplate,\n\t    replace: true,\n\t    transclude: true,\n\t    scope: {\n\t      fields: '=',\n\t      model: '=',\n\t      form: '=?',\n\t      options: '=?'\n\t    },\n\t    controller: FormlyFormController,\n\t    link: formlyFormLink\n\t  };\n\n\t  function formlyFormGetTemplate(el, attrs) {\n\t    var rootEl = getRootEl();\n\t    var fieldRootEl = getFieldRootEl();\n\t    var formId = 'formly_' + currentFormId++;\n\t    var parentFormAttributes = '';\n\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t    }\n\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\n\t    function getRootEl() {\n\t      return attrs.rootEl || 'ng-form';\n\t    }\n\n\t    function getFieldRootEl() {\n\t      return attrs.fieldRootEl || 'div';\n\t    }\n\n\t    function getHideDirective() {\n\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t    }\n\n\t    function getTrackBy() {\n\t      if (!attrs.trackBy) {\n\t        return '';\n\t      } else {\n\t        return 'track by ' + attrs.trackBy;\n\t      }\n\t    }\n\n\t    function getFormName() {\n\t      var formName = formId;\n\t      var bindName = attrs.bindName;\n\t      if (bindName) {\n\t        if (_angularFix2['default'].version.minor < 3) {\n\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t        }\n\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t      }\n\t      return formName;\n\t    }\n\n\t    function getTranscludeClass() {\n\t      return attrs.transcludeClass || '';\n\t    }\n\n\t    function copyAttributes(attributes) {\n\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t      var arrayAttrs = [];\n\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t        var nodeName = _ref.nodeName;\n\t        var value = _ref.value;\n\n\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t        }\n\t      });\n\t      return arrayAttrs.join(' ');\n\t    }\n\t  }\n\n\t  // @ngInject\n\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t    setupOptions();\n\t    $scope.model = $scope.model || {};\n\t    setupFields();\n\n\t    // watch the model and evaluate watch expressions that depend on it.\n\t    $scope.$watch('model', onModelOrFormStateChange, true);\n\t    if ($scope.options.formState) {\n\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t    }\n\n\t    function onModelOrFormStateChange() {\n\t      _angularFix2['default'].forEach($scope.fields, function runFieldExpressionProperties(field, index) {\n\t        var model = field.model || $scope.model;\n\t        var promise = field.runExpressions && field.runExpressions();\n\t        if (field.hideExpression) {\n\t          // can't use hide with expressionProperties reliably\n\t          var val = model[field.key];\n\t          field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t        }\n\t        if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t          var validate = field.formControl.$validate;\n\t          if (promise) {\n\t            promise.then(validate);\n\t          } else {\n\t            validate();\n\t          }\n\t        }\n\t      });\n\t    }\n\n\t    function setupFields() {\n\t      $scope.fields = $scope.fields || [];\n\n\t      checkDeprecatedOptions($scope.options);\n\n\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\n\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t        fieldTransforms = [fieldTransforms];\n\t      }\n\n\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t        if (fieldTransform) {\n\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t          if (!$scope.fields) {\n\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t          }\n\t        }\n\t      });\n\n\t      setupModels();\n\n\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t    }\n\n\t    function checkDeprecatedOptions(options) {\n\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t      }\n\t    }\n\n\t    function setupOptions() {\n\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t      $scope.options = $scope.options || {};\n\t      $scope.options.formState = $scope.options.formState || {};\n\n\t      _angularFix2['default'].extend($scope.options, {\n\t        updateInitialValue: updateInitialValue,\n\t        resetModel: resetModel\n\t      });\n\t    }\n\n\t    function updateInitialValue() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.updateInitialValue();\n\t        } else {\n\t          field.updateInitialValue();\n\t        }\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.resetModel();\n\t        } else if (field.resetModel) {\n\t          field.resetModel();\n\t        }\n\t      });\n\t    }\n\n\t    function setupModels() {\n\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t      var watchedModels = [$scope.model];\n\n\t      if ($scope.options.formState) {\n\t        // $scope.options.formState will have its own watcher\n\t        watchedModels.push($scope.options.formState);\n\t      }\n\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        var isNewModel = initModel(field);\n\n\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1) {\n\t          $scope.$watch(function () {\n\t            return field.model;\n\t          }, onModelOrFormStateChange, true);\n\t          watchedModels.push(field.model);\n\t        }\n\t      });\n\t    }\n\n\t    function initModel(field) {\n\t      var isNewModel = true;\n\n\t      if (_angularFix2['default'].isString(field.model)) {\n\t        var expression = field.model;\n\t        var index = $scope.fields.indexOf(field);\n\n\t        isNewModel = !refrencesCurrentlyWatchedModel(expression);\n\n\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t        if (!field.model) {\n\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t        }\n\t      }\n\t      return isNewModel;\n\t    }\n\n\t    function refrencesCurrentlyWatchedModel(expression) {\n\t      return ['model', 'formState'].some(function (item) {\n\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t      });\n\t    }\n\n\t    function attachKey(field, index) {\n\t      if (!isFieldGroup(field)) {\n\t        field.key = field.key || index || 0;\n\t      }\n\t    }\n\n\t    function setupWatchers(field, index) {\n\t      if (isFieldGroup(field) || !_angularFix2['default'].isDefined(field.watcher)) {\n\t        return;\n\t      }\n\t      var watchers = field.watcher;\n\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t        watchers = [watchers];\n\t      }\n\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t        if (!_angularFix2['default'].isDefined(watcher.listener)) {\n\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t        }\n\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t        var watchListener = getWatchListener(watcher, field, index);\n\n\t        var type = watcher.type || '$watch';\n\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t      });\n\t    }\n\n\t    function getWatchExpression(watcher, field, index) {\n\t      var watchExpression = watcher.expression || 'model[\\'' + field.key + '\\']';\n\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t        (function () {\n\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalExpression = watchExpression;\n\t          watchExpression = function formlyWatchExpression() {\n\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t          };\n\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchExpression;\n\t    }\n\n\t    function getWatchListener(watcher, field, index) {\n\t      var watchListener = watcher.listener;\n\t      if (_angularFix2['default'].isFunction(watchListener)) {\n\t        (function () {\n\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalListener = watchListener;\n\t          watchListener = function formlyWatchListener() {\n\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t            return originalListener.apply(undefined, _toConsumableArray(args));\n\t          };\n\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchListener;\n\t    }\n\n\t    function modifyArgs(watcher, index) {\n\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t        originalArgs[_key - 2] = arguments[_key];\n\t      }\n\n\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t    }\n\n\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t    }\n\n\t    function getFormlyFieldLikeLocals(field, index) {\n\t      // this makes it closer to what a regular formlyExpression would be\n\t      return {\n\t        options: field,\n\t        index: index,\n\t        formState: $scope.options.formState,\n\t        formId: $scope.formId\n\t      };\n\t    }\n\t  }\n\n\t  function formlyFormLink(scope, el, attrs) {\n\t    setFormController();\n\t    fixChromeAutocomplete();\n\n\t    function setFormController() {\n\t      var formId = attrs.name;\n\t      scope.formId = formId;\n\t      scope.theFormlyForm = scope[formId];\n\t      if (attrs.form) {\n\t        var getter = $parse(attrs.form);\n\t        var setter = getter.assign;\n\t        var parentForm = getter(scope.$parent);\n\t        if (parentForm) {\n\t          scope.theFormlyForm = parentForm;\n\t          if (scope[formId]) {\n\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t          }\n\n\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t          // to children forms :-( This line was added to solve this issue:\n\t          // https://github.com/formly-js/angular-formly/issues/287\n\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t          // so I expect it will remain this way for the life of angular 1.x\n\t          el.removeData('$formController');\n\t        } else {\n\t          setter(scope.$parent, scope[formId]);\n\t        }\n\t      }\n\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t        /* eslint no-console:0 */\n\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t      }\n\t    }\n\n\t    /*\n\t     * chrome autocomplete lameness\n\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t     * ლ(ಠ益ಠლ)   (╯°□°)╯︵ ┻━┻    (◞‸◟；)\n\t     */\n\t    function fixChromeAutocomplete() {\n\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t      if (global && !offInstance || onInstance) {\n\t        var input = document.createElement('input');\n\t        input.setAttribute('autocomplete', 'address-level4');\n\t        input.setAttribute('hidden', 'true');\n\t        el[0].appendChild(input);\n\t      }\n\t    }\n\t  }\n\n\t  // stateless util functions\n\t  function toKebabCase(string) {\n\t    if (string) {\n\t      return string.replace(/([A-Z])/g, function ($1) {\n\t        return '-' + $1.toLowerCase();\n\t      });\n\t    } else {\n\t      return '';\n\t    }\n\t  }\n\n\t  function isFieldGroup(field) {\n\t    return field && !!field.fieldGroup;\n\t  }\n\t}\n\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\texports['default'] = addFormlyNgModelAttrsManipulator;\n\n\t// @ngInject\n\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t    return;\n\t  }\n\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\n\t  function ngModelAttrsManipulator(template, options, scope) {\n\t    var node = document.createElement('div');\n\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t    if (skip === true) {\n\t      return template;\n\t    }\n\t    node.innerHTML = template;\n\n\t    var modelNodes = getNgModelNodes(node, skip);\n\t    if (!modelNodes || !modelNodes.length) {\n\t      return template;\n\t    }\n\n\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\n\t    addValidation();\n\t    alterNgModelAttr();\n\t    addModelOptions();\n\t    addTemplateOptionsAttrs();\n\t    addNgModelElAttrs();\n\n\t    return node.innerHTML;\n\n\t    function addValidation() {\n\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t      }\n\t    }\n\n\t    function alterNgModelAttr() {\n\t      if (isPropertyAccessor(options.key)) {\n\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t      }\n\t    }\n\n\t    function addModelOptions() {\n\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t        if (options.modelOptions.getterSetter) {\n\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t        }\n\t      }\n\t    }\n\n\t    function addTemplateOptionsAttrs() {\n\t      if (!options.templateOptions && !options.expressionProperties) {\n\t        // no need to run these if there are no templateOptions or expressionProperties\n\t        return;\n\t      }\n\t      var to = options.templateOptions || {};\n\t      var ep = options.expressionProperties || {};\n\n\t      var ngModelAttributes = getBuiltInAttributes();\n\n\t      // extend with the user's specifications winning\n\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\n\t      // Feel free to make this more simple :-)\n\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t        /* eslint complexity:[2, 14] */\n\t        var attrVal = undefined,\n\t            attrName = undefined;\n\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t        var toVal = to[name];\n\t        var epVal = getEpValue(ep, name);\n\n\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t        if (val.value) {\n\t          // I realize this looks backwards, but it's right, trust me...\n\t          attrName = val.value;\n\t          attrVal = name;\n\t        } else if (val.statement && inTo) {\n\t          attrName = val.statement;\n\t          if (_angularFix2['default'].isString(to[name])) {\n\t            attrVal = '$eval(' + ref + ')';\n\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t          } else {\n\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t          }\n\t        } else if (val.bound && inEp) {\n\t          attrName = val.bound;\n\t          attrVal = ref;\n\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t          attrName = val.attribute || val.boolean;\n\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t        } else if (val.attribute && inTo) {\n\t          attrName = val.attribute;\n\t          attrVal = toVal;\n\t        } else if (val.boolean) {\n\t          if (inTo && !inEp && toVal) {\n\t            attrName = val.boolean;\n\t            attrVal = true;\n\t          } else {\n\t            /* eslint no-empty:0 */\n\t            // empty to illustrate that a boolean will not be added via val.bound\n\t            // if you want it added via val.bound, then put it in expressionProperties\n\t          }\n\t        } else if (val.bound && inTo) {\n\t            attrName = val.bound;\n\t            attrVal = ref;\n\t          }\n\n\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t        }\n\t      });\n\t    }\n\n\t    function addNgModelElAttrs() {\n\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t        addRegardlessOfPresence(modelNodes, name, val);\n\t      });\n\t    }\n\t  }\n\n\t  // Utility functions\n\t  function getNgModelNodes(node, skip) {\n\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t    try {\n\t      return node.querySelectorAll(query);\n\t    } catch (e) {\n\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t      //it should be removed when IE8 support is dropped\n\t      return getNgModelNodesFallback(node, skip);\n\t    }\n\t  }\n\n\t  function getNgModelNodesFallback(node, skip) {\n\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t    var matchingNgModelNodes = [];\n\n\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t    matchingNgModelNodes.item = function (i) {\n\t      return this[i];\n\t    };\n\n\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t      var ngModelNode = allNgModelNodes[i];\n\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t        matchingNgModelNodes.push(ngModelNode);\n\t      }\n\t    }\n\n\t    return matchingNgModelNodes;\n\t  }\n\n\t  function nodeMatches(node, selector) {\n\t    var div = document.createElement('div');\n\t    div.innerHTML = node.outerHTML;\n\t    return div.querySelector(selector);\n\t  }\n\n\t  function getBuiltInAttributes() {\n\t    var ngModelAttributes = {\n\t      focus: {\n\t        attribute: 'formly-focus'\n\t      }\n\t    };\n\t    var boundOnly = [];\n\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t    var attributeOnly = ['placeholder', 'min', 'max', 'tabindex', 'type'];\n\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t      bothAttributeAndBound.push('maxlength');\n\t    } else {\n\t      boundOnly.push('maxlength');\n\t    }\n\n\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t      ngModelAttributes[item] = { attribute: item };\n\t    });\n\t    return ngModelAttributes;\n\t  }\n\n\t  function getEpValue(ep, name) {\n\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t  }\n\n\t  function addIfNotPresent(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      if (!node.getAttribute(attr)) {\n\t        node.setAttribute(attr, val);\n\t      }\n\t    });\n\t  }\n\n\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      node.setAttribute(attr, val);\n\t    });\n\t  }\n\n\t  function isPropertyAccessor(key) {\n\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t  }\n\t}\n\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = addCustomTags;\n\n\t// @ngInject\n\tfunction addCustomTags($document) {\n\t  // IE8 check ->\n\t  // https://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx\n\t  if ($document && $document.documentMode < 9) {\n\t    (function () {\n\t      var document = $document.get(0);\n\t      // add the custom elements that we need for formly\n\t      var customElements = ['formly-field', 'formly-form'];\n\t      _angularFix2['default'].forEach(customElements, function (el) {\n\t        document.createElement(el);\n\t      });\n\t    })();\n\t  }\n\t}\n\taddCustomTags.$inject = [\"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly/dist/formly.js\n ** module id = 7\n ** module chunks = 2\n **/","//! angular-formly-templates-bootstrap version 6.1.7 built with ♥ by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> (ó ì_í)=óò=(ì_í ò)\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tmodule.exports = __webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar ngModuleName = 'formlyBootstrap';\n\tvar angular = __webpack_require__(2);\n\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t  output: {\n\t    prefix: 'angular-formly-bootstrap'\n\t  }\n\t}));\n\tngModule.constant('formlyBootstrapVersion', (\"6.1.7\"));\n\n\t__webpack_require__(6)(ngModule);\n\t__webpack_require__(9)(ngModule);\n\t__webpack_require__(19)(ngModule);\n\n\texports['default'] = ngModuleName;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tvar angular = __webpack_require__(3);\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\tmodule.exports = angular;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addWrappers);\n\n\t  function addWrappers(formlyConfigProvider) {\n\t    formlyConfigProvider.setWrapper([{\n\t      name: 'bootstrapLabel',\n\t      template: __webpack_require__(7),\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string,\n\t            required: check.bool.optional,\n\t            labelSrOnly: check.bool.optional\n\t          }\n\t        };\n\t      }\n\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t  }\n\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  __webpack_require__(10)(ngModule);\n\t  __webpack_require__(12)(ngModule);\n\t  __webpack_require__(14)(ngModule);\n\t  __webpack_require__(15)(ngModule);\n\t  __webpack_require__(17)(ngModule);\n\t  __webpack_require__(18)(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'checkbox',\n\t      template: __webpack_require__(11),\n\t      wrapper: ['bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'multiCheckbox',\n\t      template: __webpack_require__(13),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      },\n\t      defaultOptions: {\n\t        noFormControl: false,\n\t        ngModelAttrs: {\n\t          required: {\n\t            attribute: '',\n\t            bound: ''\n\t          }\n\t        }\n\t      },\n\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t        var to = $scope.to;\n\t        var opts = $scope.options;\n\t        $scope.multiCheckbox = {\n\t          checked: [],\n\t          change: setModel\n\t        };\n\n\t        // initialize the checkboxes check property\n\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t          var modelValue, valueProp;\n\n\t          if (Object.keys(newModelValue).length) {\n\t            modelValue = newModelValue[opts.key];\n\n\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t                valueProp = to.valueProp || 'value';\n\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t                }\n\t              }\n\t            });\n\t          }\n\t        }, true);\n\n\t        function checkValidity(expressionValue) {\n\t          var valid;\n\n\t          if ($scope.to.required) {\n\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\n\t            $scope.fc.$setValidity('required', valid);\n\t          }\n\t        }\n\n\t        function setModel() {\n\t          $scope.model[opts.key] = [];\n\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t            if (checkbox) {\n\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t            }\n\t          });\n\n\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t          $scope.fc.$setTouched();\n\t          checkValidity(true);\n\t        }\n\n\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t          $scope.$watch(function () {\n\t            return $scope.to.required;\n\t          }, function (newValue) {\n\t            checkValidity(newValue);\n\t          });\n\t        }\n\n\t        if ($scope.to.required) {\n\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t            if (!newValue) {\n\t              return;\n\t            }\n\t            checkValidity(true);\n\t            unwatchFormControl();\n\t          });\n\t        }\n\t      }]\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addInputType);\n\n\t  function addInputType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'input',\n\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t    });\n\t  }\n\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addRadioType);\n\n\t  function addRadioType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'radio',\n\t      template: __webpack_require__(16),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        noFormControl: false\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addSelectType);\n\n\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\n\t  function addSelectType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'select',\n\t      template: template,\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: function defaultOptions(options) {\n\t        /* jshint maxlen:195 */\n\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t        return {\n\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t          })\n\t        };\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            optionsAttr: check.string.optional,\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional,\n\t            groupProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addTextareaType);\n\n\t  function addTextareaType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'textarea',\n\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        ngModelAttrs: {\n\t          rows: { attribute: 'rows' },\n\t          cols: { attribute: 'cols' }\n\t        }\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            rows: check.number.optional,\n\t            cols: check.number.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _addons = __webpack_require__(20);\n\n\tvar _addons2 = _interopRequireDefault(_addons);\n\n\tvar _description = __webpack_require__(22);\n\n\tvar _description2 = _interopRequireDefault(_description);\n\n\texports['default'] = function (ngModule) {\n\t  (0, _addons2['default'])(ngModule);\n\t  (0, _description2['default'])(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addAddonsManipulator);\n\n\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t    var addonTemplate = __webpack_require__(21);\n\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t      'class': formlyBootstrapApiCheck.string.optional,\n\t      text: formlyBootstrapApiCheck.string.optional,\n\t      onClick: formlyBootstrapApiCheck.func.optional\n\t    }).strict.optional;\n\t    var api = formlyBootstrapApiCheck.shape({\n\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t        addonLeft: addonChecker,\n\t        addonRight: addonChecker\n\t      })\n\t    });\n\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t        return template;\n\t      }\n\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t    });\n\t  }\n\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addDescriptionManipulator);\n\n\t  function addDescriptionManipulator(formlyConfig) {\n\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t      if (angular.isDefined(options.templateOptions.description)) {\n\t        var el = document.createElement('div');\n\t        el.appendChild(angular.element(template)[0]);\n\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t        if (modelEls) {\n\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t        }\n\t        return el.innerHTML;\n\t      } else {\n\t        return template;\n\t      }\n\t    });\n\t  }\n\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js\n ** module id = 13\n ** module chunks = 2\n **/","/**\n * angular-permission\n * Route permission and access control as simple as it can get\n * @version v1.1.1 - 2015-11-09\n * @link http://www.rafaelvidaurre.com\n * @author Rafael Vidaurre <narzerus@gmail.com>\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n(function () {\n  'use strict';\n\n  angular.module('permission', ['ui.router'])\n    .run(['$rootScope', 'Permission', '$state', '$q',\n    function ($rootScope, Permission, $state, $q) {\n      $rootScope.$on('$stateChangeStart',\n      function (event, toState, toParams, fromState, fromParams) {\n        if (toState.$$finishAuthorize) {\n          return;\n        }\n\n        // If there are permissions set then prevent default and attempt to authorize\n        var permissions;\n        if (toState.data && toState.data.permissions) {\n          permissions = toState.data.permissions;\n        } else if (toState.permissions) {\n          /**\n          * This way of defining permissions will be depracated in v1. Should use\n          * `data` key instead\n          */\n          console.log('Deprecation Warning: permissions should be set inside the `data` key ');\n          console.log('Setting permissions for a state outside `data` will be depracated in' +\n            ' version 1');\n          permissions = toState.permissions;\n        }\n\n        if (permissions) {\n          event.preventDefault();\n          toState = angular.extend({'$$finishAuthorize': true}, toState);\n\n          if ($rootScope.$broadcast('$stateChangePermissionStart', toState, toParams).defaultPrevented) {\n            return;\n          }\n\n          Permission.authorize(permissions, toParams).then(function () {\n            // If authorized, use call state.go without triggering the event.\n            // Then trigger $stateChangeSuccess manually to resume the rest of the process\n            // Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n              $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams);\n\n              $state.go(toState.name, toParams, {notify: false}).then(function() {\n                $rootScope\n                  .$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams);\n              });\n            }\n          }, function () {\n            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n              $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams);\n\n              var redirectTo = permissions.redirectTo;\n              var result;\n\n              if (angular.isFunction(redirectTo)) {\n                redirectTo = redirectTo();\n\n                $q.when(redirectTo).then(function (newState) {\n                  if (newState) {\n                    $state.go(newState, toParams);\n                  }\n                });\n\n              } else {\n                if (redirectTo) {\n                  $state.go(redirectTo, toParams);\n                }\n              }\n            }\n          });\n        }\n      });\n    }]);\n}());\n\n(function () {\n  'use strict';\n\n  angular.module('permission')\n    .provider('Permission', function () {\n      var roleValidationConfig = {};\n      var validateRoleDefinitionParams = function (roleName, validationFunction) {\n        if (!angular.isString(roleName)) {\n          throw new Error('Role name must be a string');\n        }\n        if (!angular.isFunction(validationFunction)) {\n          throw new Error('Validation function not provided correctly');\n        }\n      };\n\n      var validateManyRolesDefinitionParams = function(roles, validationFunction) {\n        if (!angular.isArray(roles)) {\n          throw new Error('Roles must be an array');\n        } else {\n          for(var i = 0; i < roles.length; i++) {\n            validateRoleDefinitionParams(roles[i], validationFunction);\n          }\n        }\n      };\n\n      this.defineRole = function (roleName, validationFunction) {\n        /**\n          This method is only available in config-time, and cannot access services, as they are\n          not yet injected anywere which makes this kinda useless.\n          Should remove if we cannot find a use for it.\n        **/\n        validateRoleDefinitionParams(roleName, validationFunction);\n        roleValidationConfig[roleName] = validationFunction;\n\n        return this;\n      };\n\n      this.$get = ['$q', function ($q) {\n        var Permission = {\n          _promiseify: function (value) {\n            /**\n              Converts a value into a promise, if the value is truthy it resolves it, otherwise\n              it rejects it\n            **/\n            if (value && angular.isFunction(value.then)) {\n              return value;\n            }\n\n            var deferred = $q.defer();\n            if (value) {\n              deferred.resolve();\n            } else {\n              deferred.reject();\n            }\n            return deferred.promise;\n          },\n          _validateRoleMap: function (roleMap) {\n            if (typeof(roleMap) !== 'object' || roleMap instanceof Array) {\n              throw new Error('Role map has to be an object');\n            }\n            if (roleMap.only === undefined && roleMap.except === undefined) {\n              throw new Error('Either \"only\" or \"except\" keys must me defined');\n            }\n            if (roleMap.only) {\n              if (!(roleMap.only instanceof Array)) {\n                throw new Error('Array of roles expected');\n              }\n            } else if (roleMap.except) {\n              if (!(roleMap.except instanceof Array)) {\n                throw new Error('Array of roles expected');\n              }\n            }\n          },\n          _findMatchingRole: function (rolesArray, toParams) {\n            var roles = angular.copy(rolesArray);\n            var deferred = $q.defer();\n            var currentRole = roles.shift();\n\n            // If no roles left to validate reject promise\n            if (!currentRole) {\n              deferred.reject();\n              return deferred.promise;\n            }\n            // Validate role definition exists\n            if (!angular.isFunction(Permission.roleValidations[currentRole])) {\n              throw new Error('undefined role or invalid role validation');\n            }\n\n            var validatingRole = Permission.roleValidations[currentRole](toParams, currentRole);\n            validatingRole = Permission._promiseify(validatingRole);\n\n            validatingRole.then(function () {\n              deferred.resolve();\n            }, function () {\n              Permission._findMatchingRole(roles, toParams).then(function () {\n                deferred.resolve();\n              }, function () {\n                deferred.reject();\n              });\n            });\n\n            return deferred.promise;\n          },\n          defineRole: function (roleName, validationFunction) {\n            /**\n              Service-available version of defineRole, the callback passed here lives in the\n              scope where it is defined and therefore can interact with other modules\n            **/\n            validateRoleDefinitionParams(roleName, validationFunction);\n            Permission.roleValidations[roleName] = validationFunction;\n\n            return Permission;\n          },\n          defineManyRoles: function(roles, validationFunction) {\n            validateManyRolesDefinitionParams(roles, validationFunction);\n\n            var definedPermissions = Permission;\n            for(var i = 0; i < roles.length; i++) {\n               definedPermissions = definedPermissions.defineRole(roles[i], validationFunction);\n            }\n\n            return definedPermissions;\n          },\n          resolveIfMatch: function (rolesArray, toParams) {\n            var roles = angular.copy(rolesArray);\n            var deferred = $q.defer();\n            Permission._findMatchingRole(roles, toParams).then(function () {\n              // Found role match\n              deferred.resolve();\n            }, function () {\n              // No match\n              deferred.reject();\n            });\n            return deferred.promise;\n          },\n          rejectIfMatch: function (roles, toParams) {\n            var deferred = $q.defer();\n            Permission._findMatchingRole(roles, toParams).then(function () {\n              // Role found\n              deferred.reject();\n            }, function () {\n              // Role not found\n              deferred.resolve();\n            });\n            return deferred.promise;\n          },\n          roleValidations: roleValidationConfig,\n          authorize: function (roleMap, toParams) {\n            // Validate input\n            Permission._validateRoleMap(roleMap);\n\n            var authorizing;\n\n            if (roleMap.only) {\n              authorizing = Permission.resolveIfMatch(roleMap.only, toParams);\n            } else {\n              authorizing = Permission.rejectIfMatch(roleMap.except, toParams);\n            }\n\n            return authorizing;\n          }\n        };\n\n        return Permission;\n      }];\n    });\n\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-permission/dist/angular-permission.js\n ** module id = 14\n ** module chunks = 2\n **/","require('./ui-bootstrap-tpls');\nmodule.exports = 'ui.bootstrap';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/index.js\n ** module id = 15\n ** module chunks = 2\n **/","/**\r\n * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n * @author Mark Lagendijk <mark@lagendijk.info>\r\n * @license MIT\r\n */\r\nangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n        var self = this;\r\n\r\n        /**\r\n         * Recursively sets the states using $stateProvider.state.\r\n         * Child states are defined via a `children` property.\r\n         *\r\n         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n         * 3. Sets `parent` property of the descendant states.\r\n         *\r\n         * @param {Object} state - A regular ui.router state object.\r\n         * @param {Array} [state.children] - An optional array of child states.\r\n         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n         * @param {Object} [options] - An optional options object.\r\n         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n         *     prevents conversion of names to dot notation if true.\r\n         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n         */\r\n        this.state = function(state){\r\n            var args = Array.prototype.slice.apply(arguments);\r\n            var options = {\r\n                keepOriginalNames: false,\r\n                siblingTraversal: false\r\n            };  \r\n\r\n            if (typeof args[1] === 'boolean') {\r\n                options.keepOriginalNames = args[1];\r\n            } \r\n            else if (typeof args[1] === 'object') {\r\n                angular.extend(options, args[1]);\r\n            }\r\n\r\n            if (!options.keepOriginalNames) {\r\n                fixStateName(state);\r\n            }\r\n\r\n            $stateProvider.state(state);\r\n\r\n            if(state.children && state.children.length){\r\n                state.children.forEach(function(childState){\r\n                    childState.parent = state;\r\n                    self.state(childState, options);\r\n                });\r\n\r\n                if (options.siblingTraversal) {\r\n                    addSiblings(state);\r\n                }\r\n            }\r\n\r\n            return self;\r\n        };\r\n\r\n        this.setNestedState = this.state;\r\n\r\n        self.$get = angular.noop;\r\n\r\n        /**\r\n         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n         * @param state\r\n         */\r\n        function fixStateName(state){\r\n            if(state.parent){\r\n                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n            }\r\n        }\r\n\r\n        function addSiblings(state) {\r\n            state.children.forEach(function (childState, idx, array) {\r\n                if (array[idx + 1]) {\r\n                    childState.nextSibling = array[idx + 1].name;\r\n                }\r\n                if (array[idx - 1]) {\r\n                    childState.previousSibling = array[idx - 1].name;\r\n                }\r\n            });\r\n        }\r\n    }]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router.statehelper/statehelper.js\n ** module id = 16\n ** module chunks = 2\n **/","/**\n * State-based routing for AngularJS\n * @version v0.2.15\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\]-]+)|\\{([\\w\\[\\]-]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+(-+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:  surroundPattern = ['?(', ')?']; break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n    type        = $$UMFP.type(regexp || \"string\") || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    var param = this.params[paramName];\n    var paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validate\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  function valToString(val) { return val != null ? val.toString().replace(/\\//g, \"%2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/%2F/g, \"/\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    string: {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    int: {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    bool: {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    date: {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    json: {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    any: { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n      return config.type instanceof Type ? config.type : new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {object} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. if handle is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|object} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = extend({}, state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Re-add the saved hash before we start returning things\n        if (hash) toParams['#'] = hash;\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .value('$stateParams', {})\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        if (result && options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$viewContentLoading\n         * @eventOf ui.router.state.$view\n         * @eventType broadcast on root scope\n         * @description\n         *\n         * Fired once the view **begins loading**, *before* the DOM is rendered.\n         *\n         * @param {Object} event Event object.\n         * @param {Object} viewConfig The view config properties (template, controller, etc).\n         *\n         * @example\n         *\n         * <pre>\n         * $scope.$on('$viewContentLoading',\n         * function(event, viewConfig){\n         *     // Access to all the view config properties.\n         *     // and one special property 'targetView'\n         *     // viewConfig.targetView\n         * });\n         * </pre>\n         */\n          $rootScope.$broadcast('$viewContentLoading', options);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          var promise = $animate.enter(element, null, target, cb);\n          if (promise && promise.then) promise.then(cb);\n        },\n        leave: function(element, cb) {\n          var promise = $animate.leave(element, cb);\n          if (promise && promise.then) promise.then(cb);\n        }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n        scope.$on('$viewContentLoading', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description           *\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           */\n          currentScope.$emit('$viewContentLoaded');\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n * URL, the directive will automatically generate & update the `href` attribute via \n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n * the link will trigger a state transition with optional parameters. \n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative \n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the \n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n * \n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];\n\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n      var params = null, url = null, base = stateContext(element) || $state.$current;\n      // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n      var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?\n                 'xlink:href' : 'href';\n      var newHref = null, isAnchor = element.prop(\"tagName\").toUpperCase() === \"A\";\n      var isForm = element[0].nodeName === \"FORM\";\n      var attr = isForm ? \"action\" : hrefKind, nav = true;\n\n      var options = { relative: base, inherit: true };\n      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\n      angular.forEach(allowedOptions, function(option) {\n        if (option in optionsOverride) {\n          options[option] = optionsOverride[option];\n        }\n      });\n\n      var update = function(newVal) {\n        if (newVal) params = angular.copy(newVal);\n        if (!nav) return;\n\n        newHref = $state.href(ref.state, params, options);\n\n        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n        if (activeDirective) {\n          activeDirective.$$addStateInfo(ref.state, params);\n        }\n        if (newHref === null) {\n          nav = false;\n          return false;\n        }\n        attrs.$set(attr, newHref);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n          if (newVal !== params) update(newVal);\n        }, true);\n        params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (isForm) return;\n\n      element.bind(\"click\", function(e) {\n        var button = e.which || e.button;\n        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n          var transition = $timeout(function() {\n            $state.go(ref.state, params, options);\n          });\n          e.preventDefault();\n\n          // if the state has no URL, ignore one preventDefault from the <a> directive.\n          var ignorePreventDefaultCount = isAnchor && !newHref ? 1: 0;\n          e.preventDefault = function() {\n            if (ignorePreventDefaultCount-- <= 0)\n              $timeout.cancel(transition);\n          };\n        }\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n      var states = [], activeClass;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        var state = $state.get(newState, stateContext($element));\n\n        states.push({\n          state: state || { name: newState },\n          params: newParams\n        });\n\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      // Update route state\n      function update() {\n        if (anyMatch()) {\n          $element.addClass(activeClass);\n        } else {\n          $element.removeClass(activeClass);\n        }\n      }\n\n      function anyMatch() {\n        for (var i = 0; i < states.length; i++) {\n          if (isMatch(states[i].state, states[i].params)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      function isMatch(state, params) {\n        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n          return $state.is(state.name, params);\n        } else {\n          return $state.includes(state.name, params);\n        }\n      }\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state) {\n    return $state.is(state);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state) {\n    return $state.includes(state);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router/release/angular-ui-router.js\n ** module id = 17\n ** module chunks = 2\n **/","(function (root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(['angular'], factory);\n  } else if (root.hasOwnProperty('angular')) {\n    // Browser globals (root is window), we don't register it.\n    factory(root.angular);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('angular'));\n  }\n}(this , function (angular) {\n    'use strict';\n\n    // In cases where Angular does not get passed or angular is a truthy value\n    // but misses .module we can fall back to using window.\n    angular = (angular && angular.module ) ? angular : window.angular;\n\n    /**\n     * @ngdoc overview\n     * @name ngStorage\n     */\n\n    return angular.module('ngStorage', [])\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$localStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$localStorage', _storageProvider('localStorage'))\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$sessionStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\n    function _storageProvider(storageType) {\n        return function () {\n          var storageKeyPrefix = 'ngStorage-';\n\n          this.setKeyPrefix = function (prefix) {\n            if (typeof prefix !== 'string') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n            }\n            storageKeyPrefix = prefix;\n          };\n\n          var serializer = angular.toJson;\n          var deserializer = angular.fromJson;\n\n          this.setSerializer = function (s) {\n            if (typeof s !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n            }\n\n            serializer = s;\n          };\n\n          this.setDeserializer = function (d) {\n            if (typeof d !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n            }\n\n            deserializer = d;\n          };\n\n          // Note: This is not very elegant at all.\n          this.get = function (key) {\n            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n          };\n\n          // Note: This is not very elegant at all.\n          this.set = function (key, value) {\n            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n          };\n\n          this.$get = [\n              '$rootScope',\n              '$window',\n              '$log',\n              '$timeout',\n              '$document',\n\n              function(\n                  $rootScope,\n                  $window,\n                  $log,\n                  $timeout,\n                  $document\n              ){\n                function isStorageSupported(storageType) {\n\n                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n                    // that error and allow execution to continue.\n\n                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n                    // when \"Block cookies\": \"Always block\" is turned on\n                    var supported;\n                    try {\n                        supported = $window[storageType];\n                    }\n                    catch (err) {\n                        supported = false;\n                    }\n\n                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n                    // is available, but trying to call .setItem throws an exception below:\n                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n                    if (supported && storageType === 'localStorage') {\n                        var key = '__' + Math.round(Math.random() * 1e7);\n\n                        try {\n                            localStorage.setItem(key, key);\n                            localStorage.removeItem(key);\n                        }\n                        catch (err) {\n                            supported = false;\n                        }\n                    }\n\n                    return supported;\n                }\n\n                // The magic number 10 is used which only works for some keyPrefixes...\n                // See https://github.com/gsklee/ngStorage/issues/137\n                var prefixLength = storageKeyPrefix.length;\n\n                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n                    $storage = {\n                        $default: function(items) {\n                            for (var k in items) {\n                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n                            }\n\n                            $storage.$sync();\n                            return $storage;\n                        },\n                        $reset: function(items) {\n                            for (var k in $storage) {\n                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n                            }\n\n                            return $storage.$default(items);\n                        },\n                        $sync: function () {\n                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n                            }\n                        },\n                        $apply: function() {\n                            var temp$storage;\n\n                            _debounce = null;\n\n                            if (!angular.equals($storage, _last$storage)) {\n                                temp$storage = angular.copy(_last$storage);\n                                angular.forEach($storage, function(v, k) {\n                                    if (angular.isDefined(v) && '$' !== k[0]) {\n                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n                                        delete temp$storage[k];\n                                    }\n                                });\n\n                                for (var k in temp$storage) {\n                                    webStorage.removeItem(storageKeyPrefix + k);\n                                }\n\n                                _last$storage = angular.copy($storage);\n                            }\n                        }\n                    },\n                    _last$storage,\n                    _debounce;\n\n                $storage.$sync();\n\n                _last$storage = angular.copy($storage);\n\n                $rootScope.$watch(function() {\n                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n                });\n\n                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n                $window.addEventListener && $window.addEventListener('storage', function(event) {\n                    if (!event.key) {\n                      return;\n                    }\n\n                    // Reference doc.\n                    var doc = $document[0];\n\n                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\n                        _last$storage = angular.copy($storage);\n\n                        $rootScope.$apply();\n                    }\n                });\n\n                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n                    $storage.$apply();\n                });\n\n                return $storage;\n              }\n          ];\n      };\n    }\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngstorage/ngStorage.js\n ** module id = 24\n ** module chunks = 2\n **/","/**\n * oclazyload - Load modules on demand (lazy load) with angularJS\n * @version v1.0.9\n * @link https://github.com/ocombe/ocLazyLoad\n * @license MIT\n * @author Olivier Combe <olivier.combe@gmail.com>\n */\n(function (angular, window) {\n    'use strict';\n\n    var regModules = ['ng', 'oc.lazyLoad'],\n        regInvokes = {},\n        regConfigs = [],\n        modulesToLoad = [],\n        // modules to load from angular.module or other sources\n    realModules = [],\n        // real modules called from angular.module\n    recordDeclarations = [],\n        broadcast = angular.noop,\n        runBlocks = {},\n        justLoaded = [];\n\n    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\n    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n        var modules = {},\n            providers = {\n            $controllerProvider: $controllerProvider,\n            $compileProvider: $compileProvider,\n            $filterProvider: $filterProvider,\n            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n            $injector: $injector,\n            $animateProvider: $animateProvider\n        },\n            debug = false,\n            events = false,\n            moduleCache = [],\n            modulePromises = {};\n\n        moduleCache.push = function (value) {\n            if (this.indexOf(value) === -1) {\n                Array.prototype.push.apply(this, arguments);\n            }\n        };\n\n        this.config = function (config) {\n            // If we want to define modules configs\n            if (angular.isDefined(config.modules)) {\n                if (angular.isArray(config.modules)) {\n                    angular.forEach(config.modules, function (moduleConfig) {\n                        modules[moduleConfig.name] = moduleConfig;\n                    });\n                } else {\n                    modules[config.modules.name] = config.modules;\n                }\n            }\n\n            if (angular.isDefined(config.debug)) {\n                debug = config.debug;\n            }\n\n            if (angular.isDefined(config.events)) {\n                events = config.events;\n            }\n        };\n\n        /**\n         * Get the list of existing registered modules\n         * @param element\n         */\n        this._init = function _init(element) {\n            // this is probably useless now because we override angular.bootstrap\n            if (modulesToLoad.length === 0) {\n                var elements = [element],\n                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n                    append = function append(elm) {\n                    return elm && elements.push(elm);\n                };\n\n                angular.forEach(names, function (name) {\n                    names[name] = true;\n                    append(document.getElementById(name));\n                    name = name.replace(':', '\\\\:');\n                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n                    }\n                });\n\n                angular.forEach(elements, function (elm) {\n                    if (modulesToLoad.length === 0) {\n                        var className = ' ' + element.className + ' ';\n                        var match = NG_APP_CLASS_REGEXP.exec(className);\n                        if (match) {\n                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n                        } else {\n                            angular.forEach(elm.attributes, function (attr) {\n                                if (modulesToLoad.length === 0 && names[attr.name]) {\n                                    modulesToLoad.push(attr.value);\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n\n            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n            }\n\n            var addReg = function addReg(moduleName) {\n                if (regModules.indexOf(moduleName) === -1) {\n                    // register existing modules\n                    regModules.push(moduleName);\n                    var mainModule = angular.module(moduleName);\n\n                    // register existing components (directives, services, ...)\n                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\n                    angular.forEach(mainModule.requires, addReg);\n                }\n            };\n\n            angular.forEach(modulesToLoad, function (moduleName) {\n                addReg(moduleName);\n            });\n\n            modulesToLoad = []; // reset for next bootstrap\n            recordDeclarations.pop(); // wait for the next lazy load\n        };\n\n        /**\n         * Like JSON.stringify but that doesn't throw on circular references\n         * @param obj\n         */\n        var stringify = function stringify(obj) {\n            try {\n                return JSON.stringify(obj);\n            } catch (e) {\n                var cache = [];\n                return JSON.stringify(obj, function (key, value) {\n                    if (angular.isObject(value) && value !== null) {\n                        if (cache.indexOf(value) !== -1) {\n                            // Circular reference found, discard key\n                            return;\n                        }\n                        // Store value in our collection\n                        cache.push(value);\n                    }\n                    return value;\n                });\n            }\n        };\n\n        var hashCode = function hashCode(str) {\n            var hash = 0,\n                i,\n                chr,\n                len;\n            if (str.length == 0) {\n                return hash;\n            }\n            for (i = 0, len = str.length; i < len; i++) {\n                chr = str.charCodeAt(i);\n                hash = (hash << 5) - hash + chr;\n                hash |= 0; // Convert to 32bit integer\n            }\n            return hash;\n        };\n\n        function _register(providers, registerModules, params) {\n            if (registerModules) {\n                var k,\n                    moduleName,\n                    moduleFn,\n                    tempRunBlocks = [];\n                for (k = registerModules.length - 1; k >= 0; k--) {\n                    moduleName = registerModules[k];\n                    if (!angular.isString(moduleName)) {\n                        moduleName = getModuleName(moduleName);\n                    }\n                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n                        continue;\n                    }\n                    // new if not registered\n                    var newModule = regModules.indexOf(moduleName) === -1;\n                    moduleFn = ngModuleFct(moduleName);\n                    if (newModule) {\n                        regModules.push(moduleName);\n                        _register(providers, moduleFn.requires, params);\n                    }\n                    if (moduleFn._runBlocks.length > 0) {\n                        // new run blocks detected! Replace the old ones (if existing)\n                        runBlocks[moduleName] = [];\n                        while (moduleFn._runBlocks.length > 0) {\n                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n                        }\n                    }\n                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n                    }\n                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n                    registerModules.pop();\n                    justLoaded.push(moduleName);\n                }\n                // execute the run blocks at the end\n                var instanceInjector = providers.getInstanceInjector();\n                angular.forEach(tempRunBlocks, function (fn) {\n                    instanceInjector.invoke(fn);\n                });\n            }\n        }\n\n        function _registerInvokeList(args, moduleName) {\n            var invokeList = args[2][0],\n                type = args[1],\n                newInvoke = false;\n            if (angular.isUndefined(regInvokes[moduleName])) {\n                regInvokes[moduleName] = {};\n            }\n            if (angular.isUndefined(regInvokes[moduleName][type])) {\n                regInvokes[moduleName][type] = {};\n            }\n            var onInvoke = function onInvoke(invokeName, invoke) {\n                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n                    regInvokes[moduleName][type][invokeName] = [];\n                }\n                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n                    newInvoke = true;\n                    regInvokes[moduleName][type][invokeName].push(invoke);\n                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n                }\n            };\n\n            function checkHashes(potentialNew, invokes) {\n                var isNew = true,\n                    newHash;\n                if (invokes.length) {\n                    newHash = signature(potentialNew);\n                    angular.forEach(invokes, function (invoke) {\n                        isNew = isNew && signature(invoke) !== newHash;\n                    });\n                }\n                return isNew;\n            }\n\n            function signature(data) {\n                if (angular.isArray(data)) {\n                    // arrays are objects, we need to test for it first\n                    return hashCode(data.toString());\n                } else if (angular.isObject(data)) {\n                    // constants & values for example\n                    return hashCode(stringify(data));\n                } else {\n                    if (angular.isDefined(data) && data !== null) {\n                        return hashCode(data.toString());\n                    } else {\n                        // null & undefined constants\n                        return data;\n                    }\n                }\n            }\n\n            if (angular.isString(invokeList)) {\n                onInvoke(invokeList, args[2][1]);\n            } else if (angular.isObject(invokeList)) {\n                angular.forEach(invokeList, function (invoke, key) {\n                    if (angular.isString(invoke)) {\n                        // decorators for example\n                        onInvoke(invoke, invokeList[1]);\n                    } else {\n                        // components registered as object lists {\"componentName\": function() {}}\n                        onInvoke(key, invoke);\n                    }\n                });\n            } else {\n                return false;\n            }\n            return newInvoke;\n        }\n\n        function _invokeQueue(providers, queue, moduleName, reconfig) {\n            if (!queue) {\n                return;\n            }\n\n            var i, len, args, provider;\n            for (i = 0, len = queue.length; i < len; i++) {\n                args = queue[i];\n                if (angular.isArray(args)) {\n                    if (providers !== null) {\n                        if (providers.hasOwnProperty(args[0])) {\n                            provider = providers[args[0]];\n                        } else {\n                            throw new Error('unsupported provider ' + args[0]);\n                        }\n                    }\n                    var isNew = _registerInvokeList(args, moduleName);\n                    if (args[1] !== 'invoke') {\n                        if (isNew && angular.isDefined(provider)) {\n                            provider[args[1]].apply(provider, args[2]);\n                        }\n                    } else {\n                        // config block\n                        var callInvoke = function callInvoke(fct) {\n                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n                            if (invoked === -1 || reconfig) {\n                                if (invoked === -1) {\n                                    regConfigs.push(moduleName + '-' + fct);\n                                }\n                                if (angular.isDefined(provider)) {\n                                    provider[args[1]].apply(provider, args[2]);\n                                }\n                            }\n                        };\n                        if (angular.isFunction(args[2][0])) {\n                            callInvoke(args[2][0]);\n                        } else if (angular.isArray(args[2][0])) {\n                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n                                if (angular.isFunction(args[2][0][j])) {\n                                    callInvoke(args[2][0][j]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function getModuleName(module) {\n            var moduleName = null;\n            if (angular.isString(module)) {\n                moduleName = module;\n            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n                moduleName = module.name;\n            }\n            return moduleName;\n        }\n\n        function moduleExists(moduleName) {\n            if (!angular.isString(moduleName)) {\n                return false;\n            }\n            try {\n                return ngModuleFct(moduleName);\n            } catch (e) {\n                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                    return false;\n                }\n            }\n        }\n\n        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n            var instanceInjector,\n                filesCache = $cacheFactory('ocLazyLoad');\n\n            if (!debug) {\n                $log = {};\n                $log['error'] = angular.noop;\n                $log['warn'] = angular.noop;\n                $log['info'] = angular.noop;\n            }\n\n            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n            providers.getInstanceInjector = function () {\n                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n            };\n\n            broadcast = function broadcast(eventName, params) {\n                if (events) {\n                    $rootScope.$broadcast(eventName, params);\n                }\n                if (debug) {\n                    $log.info(eventName, params);\n                }\n            };\n\n            function reject(e) {\n                var deferred = $q.defer();\n                $log.error(e.message);\n                deferred.reject(e);\n                return deferred.promise;\n            }\n\n            return {\n                _broadcast: broadcast,\n\n                _$log: $log,\n\n                /**\n                 * Returns the files cache used by the loaders to store the files currently loading\n                 * @returns {*}\n                 */\n                _getFilesCache: function getFilesCache() {\n                    return filesCache;\n                },\n\n                /**\n                 * Let the service know that it should monitor angular.module because files are loading\n                 * @param watch boolean\n                 */\n                toggleWatch: function toggleWatch(watch) {\n                    if (watch) {\n                        recordDeclarations.push(true);\n                    } else {\n                        recordDeclarations.pop();\n                    }\n                },\n\n                /**\n                 * Let you get a module config object\n                 * @param moduleName String the name of the module\n                 * @returns {*}\n                 */\n                getModuleConfig: function getModuleConfig(moduleName) {\n                    if (!angular.isString(moduleName)) {\n                        throw new Error('You need to give the name of the module to get');\n                    }\n                    if (!modules[moduleName]) {\n                        return null;\n                    }\n                    return angular.copy(modules[moduleName]);\n                },\n\n                /**\n                 * Let you define a module config object\n                 * @param moduleConfig Object the module config object\n                 * @returns {*}\n                 */\n                setModuleConfig: function setModuleConfig(moduleConfig) {\n                    if (!angular.isObject(moduleConfig)) {\n                        throw new Error('You need to give the module config object to set');\n                    }\n                    modules[moduleConfig.name] = moduleConfig;\n                    return moduleConfig;\n                },\n\n                /**\n                 * Returns the list of loaded modules\n                 * @returns {string[]}\n                 */\n                getModules: function getModules() {\n                    return regModules;\n                },\n\n                /**\n                 * Let you check if a module has been loaded into Angular or not\n                 * @param modulesNames String/Object a module name, or a list of module names\n                 * @returns {boolean}\n                 */\n                isLoaded: function isLoaded(modulesNames) {\n                    var moduleLoaded = function moduleLoaded(module) {\n                        var isLoaded = regModules.indexOf(module) > -1;\n                        if (!isLoaded) {\n                            isLoaded = !!moduleExists(module);\n                        }\n                        return isLoaded;\n                    };\n                    if (angular.isString(modulesNames)) {\n                        modulesNames = [modulesNames];\n                    }\n                    if (angular.isArray(modulesNames)) {\n                        var i, len;\n                        for (i = 0, len = modulesNames.length; i < len; i++) {\n                            if (!moduleLoaded(modulesNames[i])) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    } else {\n                        throw new Error('You need to define the module(s) name(s)');\n                    }\n                },\n\n                /**\n                 * Given a module, return its name\n                 * @param module\n                 * @returns {String}\n                 */\n                _getModuleName: getModuleName,\n\n                /**\n                 * Returns a module if it exists\n                 * @param moduleName\n                 * @returns {module}\n                 */\n                _getModule: function getModule(moduleName) {\n                    try {\n                        return ngModuleFct(moduleName);\n                    } catch (e) {\n                        // this error message really suxx\n                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n                        }\n                        throw e;\n                    }\n                },\n\n                /**\n                 * Check if a module exists and returns it if it does\n                 * @param moduleName\n                 * @returns {boolean}\n                 */\n                moduleExists: moduleExists,\n\n                /**\n                 * Load the dependencies, and might try to load new files depending on the config\n                 * @param moduleName (String or Array of Strings)\n                 * @param localParams\n                 * @returns {*}\n                 * @private\n                 */\n                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n                    var loadedModule,\n                        requires,\n                        diff,\n                        promisesList = [],\n                        self = this;\n\n                    moduleName = self._getModuleName(moduleName);\n\n                    if (moduleName === null) {\n                        return $q.when();\n                    } else {\n                        try {\n                            loadedModule = self._getModule(moduleName);\n                        } catch (e) {\n                            return reject(e);\n                        }\n                        // get unloaded requires\n                        requires = self.getRequires(loadedModule);\n                    }\n\n                    angular.forEach(requires, function (requireEntry) {\n                        // If no configuration is provided, try and find one from a previous load.\n                        // If there isn't one, bail and let the normal flow run\n                        if (angular.isString(requireEntry)) {\n                            var config = self.getModuleConfig(requireEntry);\n                            if (config === null) {\n                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n                                return;\n                            }\n                            requireEntry = config;\n                            // ignore the name because it's probably not a real module name\n                            config.name = undefined;\n                        }\n\n                        // Check if this dependency has been loaded previously\n                        if (self.moduleExists(requireEntry.name)) {\n                            // compare against the already loaded module to see if the new definition adds any new files\n                            diff = requireEntry.files.filter(function (n) {\n                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n                            });\n\n                            // If the module was redefined, advise via the console\n                            if (diff.length !== 0) {\n                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n                            }\n\n                            // Push everything to the file loader, it will weed out the duplicates.\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                            return;\n                        } else if (angular.isArray(requireEntry)) {\n                            var files = [];\n                            angular.forEach(requireEntry, function (entry) {\n                                // let's check if the entry is a file name or a config name\n                                var config = self.getModuleConfig(entry);\n                                if (config === null) {\n                                    files.push(entry);\n                                } else if (config.files) {\n                                    files = files.concat(config.files);\n                                }\n                            });\n                            if (files.length > 0) {\n                                requireEntry = {\n                                    files: files\n                                };\n                            }\n                        } else if (angular.isObject(requireEntry)) {\n                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n                                self.setModuleConfig(requireEntry);\n                                moduleCache.push(requireEntry['name']);\n                            }\n                        }\n\n                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                        }\n                    });\n\n                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n                    return $q.all(promisesList);\n                },\n\n                /**\n                 * Inject new modules into Angular\n                 * @param moduleName\n                 * @param localParams\n                 * @param real\n                 */\n                inject: function inject(moduleName) {\n                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n                    var self = this,\n                        deferred = $q.defer();\n                    if (angular.isDefined(moduleName) && moduleName !== null) {\n                        if (angular.isArray(moduleName)) {\n                            var promisesList = [];\n                            angular.forEach(moduleName, function (module) {\n                                promisesList.push(self.inject(module, localParams, real));\n                            });\n                            return $q.all(promisesList);\n                        } else {\n                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n                        }\n                    }\n                    if (modulesToLoad.length > 0) {\n                        var res = modulesToLoad.slice(); // clean copy\n                        var loadNext = function loadNext(moduleName) {\n                            moduleCache.push(moduleName);\n                            modulePromises[moduleName] = deferred.promise;\n                            self._loadDependencies(moduleName, localParams).then(function success() {\n                                try {\n                                    justLoaded = [];\n                                    _register(providers, moduleCache, localParams);\n                                } catch (e) {\n                                    self._$log.error(e.message);\n                                    deferred.reject(e);\n                                    return;\n                                }\n\n                                if (modulesToLoad.length > 0) {\n                                    loadNext(modulesToLoad.shift()); // load the next in list\n                                } else {\n                                        deferred.resolve(res); // everything has been loaded, resolve\n                                    }\n                            }, function error(err) {\n                                deferred.reject(err);\n                            });\n                        };\n\n                        // load the first in list\n                        loadNext(modulesToLoad.shift());\n                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n                        return modulePromises[localParams.name];\n                    } else {\n                        deferred.resolve();\n                    }\n                    return deferred.promise;\n                },\n\n                /**\n                 * Get the list of required modules/services/... for this module\n                 * @param module\n                 * @returns {Array}\n                 */\n                getRequires: function getRequires(module) {\n                    var requires = [];\n                    angular.forEach(module.requires, function (requireModule) {\n                        if (regModules.indexOf(requireModule) === -1) {\n                            requires.push(requireModule);\n                        }\n                    });\n                    return requires;\n                },\n\n                /**\n                 * Invoke the new modules & component by their providers\n                 * @param providers\n                 * @param queue\n                 * @param moduleName\n                 * @param reconfig\n                 * @private\n                 */\n                _invokeQueue: _invokeQueue,\n\n                /**\n                 * Check if a module has been invoked and registers it if not\n                 * @param args\n                 * @param moduleName\n                 * @returns {boolean} is new\n                 */\n                _registerInvokeList: _registerInvokeList,\n\n                /**\n                 * Register a new module and loads it, executing the run/config blocks if needed\n                 * @param providers\n                 * @param registerModules\n                 * @param params\n                 * @private\n                 */\n                _register: _register,\n\n                /**\n                 * Add a module name to the list of modules that will be loaded in the next inject\n                 * @param name\n                 * @param force\n                 * @private\n                 */\n                _addToLoadList: _addToLoadList,\n\n                /**\n                 * Unregister modules (you shouldn't have to use this)\n                 * @param modules\n                 */\n                _unregister: function _unregister(modules) {\n                    if (angular.isDefined(modules)) {\n                        if (angular.isArray(modules)) {\n                            angular.forEach(modules, function (module) {\n                                regInvokes[module] = undefined;\n                            });\n                        }\n                    }\n                }\n            };\n        }];\n\n        // Let's get the list of loaded modules & components\n        this._init(angular.element(window.document));\n    }]);\n\n    var bootstrapFct = angular.bootstrap;\n    angular.bootstrap = function (element, modules, config) {\n        // we use slice to make a clean copy\n        angular.forEach(modules.slice(), function (module) {\n            _addToLoadList(module, true, true);\n        });\n        return bootstrapFct(element, modules, config);\n    };\n\n    var _addToLoadList = function _addToLoadList(name, force, real) {\n        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n            modulesToLoad.push(name);\n            if (real) {\n                realModules.push(name);\n            }\n        }\n    };\n\n    var ngModuleFct = angular.module;\n    angular.module = function (name, requires, configFn) {\n        _addToLoadList(name, false, true);\n        return ngModuleFct(name, requires, configFn);\n    };\n\n    // CommonJS package manager support:\n    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n        module.exports = 'oc.lazyLoad';\n    }\n})(angular, window);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\n        return {\n            restrict: 'A',\n            terminal: true,\n            priority: 1000,\n            compile: function compile(element, attrs) {\n                // we store the content and remove it before compilation\n                var content = element[0].innerHTML;\n                element.html('');\n\n                return function ($scope, $element, $attr) {\n                    var model = $parse($attr.ocLazyLoad);\n                    $scope.$watch(function () {\n                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n                    }, function (moduleName) {\n                        if (angular.isDefined(moduleName)) {\n                            $ocLazyLoad.load(moduleName).then(function () {\n                                // Attach element contents to DOM and then compile them.\n                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\n                                // of the compiled contents when attaching to the parent DOM.\n                                $animate.enter(content, $element);\n                                // get the new content & compile it\n                                $compile($element.contents())($scope);\n                            });\n                        }\n                    }, true);\n                };\n            }\n        };\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n            var uaCssChecked = false,\n                useCssLoadPatch = false,\n                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\n            /**\r\n             * Load a js/css file\r\n             * @param type\r\n             * @param path\r\n             * @param params\r\n             * @returns promise\r\n             */\n            $delegate.buildElement = function buildElement(type, path, params) {\n                var deferred = $q.defer(),\n                    el,\n                    loaded,\n                    filesCache = $delegate._getFilesCache(),\n                    cacheBuster = function cacheBuster(url) {\n                    var dc = new Date().getTime();\n                    if (url.indexOf('?') >= 0) {\n                        if (url.substring(0, url.length - 1) === '&') {\n                            return url + '_dc=' + dc;\n                        }\n                        return url + '&_dc=' + dc;\n                    } else {\n                        return url + '?_dc=' + dc;\n                    }\n                };\n\n                // Store the promise early so the file load can be detected by other parallel lazy loads\n                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n                // as it causes false positive load results.\n                if (angular.isUndefined(filesCache.get(path))) {\n                    filesCache.put(path, deferred.promise);\n                }\n\n                // Switch in case more content types are added later\n                switch (type) {\n                    case 'css':\n                        el = $window.document.createElement('link');\n                        el.type = 'text/css';\n                        el.rel = 'stylesheet';\n                        el.href = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    case 'js':\n                        el = $window.document.createElement('script');\n                        el.src = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    default:\n                        filesCache.remove(path);\n                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n                        break;\n                }\n                el.onload = el['onreadystatechange'] = function (e) {\n                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n                    el.onload = el['onreadystatechange'] = null;\n                    loaded = 1;\n                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n                    deferred.resolve();\n                };\n                el.onerror = function () {\n                    filesCache.remove(path);\n                    deferred.reject(new Error('Unable to load ' + path));\n                };\n                el.async = params.serie ? 0 : 1;\n\n                var insertBeforeElem = anchor.lastChild;\n                if (params.insertBefore) {\n                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n                    if (element && element.length > 0) {\n                        insertBeforeElem = element[0];\n                    }\n                }\n                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\n                /*\r\n                 The event load or readystatechange doesn't fire in:\r\n                 - iOS < 6       (default mobile browser)\r\n                 - Android < 4.4 (default mobile browser)\r\n                 - Safari < 6    (desktop browser)\r\n                 */\n                if (type == 'css') {\n                    if (!uaCssChecked) {\n                        var ua = $window.navigator.userAgent.toLowerCase();\n\n                        // iOS < 6\n                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n                            useCssLoadPatch = iOSVersion < 6;\n                        } else if (ua.indexOf(\"android\") > -1) {\n                            // Android < 4.4\n                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n                            useCssLoadPatch = androidVersion < 4.4;\n                        } else if (ua.indexOf('safari') > -1) {\n                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n                        }\n                    }\n\n                    if (useCssLoadPatch) {\n                        var tries = 1000; // * 20 = 20000 miliseconds\n                        var interval = $interval(function () {\n                            try {\n                                el.sheet.cssRules;\n                                $interval.cancel(interval);\n                                el.onload();\n                            } catch (e) {\n                                if (--tries <= 0) {\n                                    el.onerror();\n                                }\n                            }\n                        }, 20);\n                    }\n                }\n\n                return deferred.promise;\n            };\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\r\n             * The function that loads new files\r\n             * @param config\r\n             * @param params\r\n             * @returns {*}\r\n             */\n            $delegate.filesLoader = function filesLoader(config) {\n                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var cssFiles = [],\n                    templatesFiles = [],\n                    jsFiles = [],\n                    promises = [],\n                    cachePromise = null,\n                    filesCache = $delegate._getFilesCache();\n\n                $delegate.toggleWatch(true); // start watching angular.module calls\n\n                angular.extend(params, config);\n\n                var pushFile = function pushFile(path) {\n                    var file_type = null,\n                        m;\n                    if (angular.isObject(path)) {\n                        file_type = path.type;\n                        path = path.path;\n                    }\n                    cachePromise = filesCache.get(path);\n                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\n                        // always check for requirejs syntax just in case\n                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n                            // Detect file type using preceding type declaration (ala requireJS)\n                            file_type = m[1];\n                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n                        }\n\n                        if (!file_type) {\n                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n                                // Detect file type via file extension\n                                file_type = m[1];\n                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\n                                // requirejs\n                                file_type = 'js';\n                            } else {\n                                $delegate._$log.error('File type could not be determined. ' + path);\n                                return;\n                            }\n                        }\n\n                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n                            cssFiles.push(path);\n                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n                            templatesFiles.push(path);\n                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n                            jsFiles.push(path);\n                        } else {\n                            $delegate._$log.error('File type is not valid. ' + path);\n                        }\n                    } else if (cachePromise) {\n                        promises.push(cachePromise);\n                    }\n                };\n\n                if (params.serie) {\n                    pushFile(params.files.shift());\n                } else {\n                    angular.forEach(params.files, function (path) {\n                        pushFile(path);\n                    });\n                }\n\n                if (cssFiles.length > 0) {\n                    var cssDeferred = $q.defer();\n                    $delegate.cssLoader(cssFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            cssDeferred.reject(err);\n                        } else {\n                            cssDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(cssDeferred.promise);\n                }\n\n                if (templatesFiles.length > 0) {\n                    var templatesDeferred = $q.defer();\n                    $delegate.templatesLoader(templatesFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            templatesDeferred.reject(err);\n                        } else {\n                            templatesDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(templatesDeferred.promise);\n                }\n\n                if (jsFiles.length > 0) {\n                    var jsDeferred = $q.defer();\n                    $delegate.jsLoader(jsFiles, function (err) {\n                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\n                            $delegate._$log.error(err);\n                            jsDeferred.reject(err);\n                        } else {\n                            jsDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(jsDeferred.promise);\n                }\n\n                if (promises.length === 0) {\n                    var deferred = $q.defer(),\n                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n                    $delegate._$log.error(err);\n                    deferred.reject(err);\n                    return deferred.promise;\n                } else if (params.serie && params.files.length > 0) {\n                    return $q.all(promises).then(function () {\n                        return $delegate.filesLoader(config, params);\n                    });\n                } else {\n                    return $q.all(promises)['finally'](function (res) {\n                        $delegate.toggleWatch(false); // stop watching angular.module calls\n                        return res;\n                    });\n                }\n            };\n\n            /**\r\n             * Load a module or a list of modules into Angular\r\n             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n             * @param params Object optional parameters\r\n             * @returns promise\r\n             */\n            $delegate.load = function (originalModule) {\n                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var self = this,\n                    config = null,\n                    deferredList = [],\n                    deferred = $q.defer(),\n                    errText;\n\n                // clean copy\n                var module = angular.copy(originalModule);\n                var params = angular.copy(originalParams);\n\n                // If module is an array, break it down\n                if (angular.isArray(module)) {\n                    // Resubmit each entry as a single module\n                    angular.forEach(module, function (m) {\n                        deferredList.push(self.load(m, params));\n                    });\n\n                    // Resolve the promise once everything has loaded\n                    $q.all(deferredList).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n\n                    return deferred.promise;\n                }\n\n                // Get or Set a configuration depending on what was passed in\n                if (angular.isString(module)) {\n                    config = self.getModuleConfig(module);\n                    if (!config) {\n                        config = {\n                            files: [module]\n                        };\n                    }\n                } else if (angular.isObject(module)) {\n                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n                        config = {\n                            files: [module]\n                        };\n                    } else {\n                        config = self.setModuleConfig(module);\n                    }\n                }\n\n                if (config === null) {\n                    var moduleName = self._getModuleName(module);\n                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n                    $delegate._$log.error(errText);\n                    deferred.reject(new Error(errText));\n                    return deferred.promise;\n                } else {\n                    // deprecated\n                    if (angular.isDefined(config.template)) {\n                        if (angular.isUndefined(config.files)) {\n                            config.files = [];\n                        }\n                        if (angular.isString(config.template)) {\n                            config.files.push(config.template);\n                        } else if (angular.isArray(config.template)) {\n                            config.files.concat(config.template);\n                        }\n                    }\n                }\n\n                var localParams = angular.extend({}, params, config);\n\n                // if someone used an external loader and called the load function with just the module name\n                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n                    return $delegate.inject(config.name, localParams, true);\n                }\n\n                $delegate.filesLoader(config, localParams).then(function () {\n                    $delegate.inject(null, localParams).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n                }, function (err) {\n                    deferred.reject(err);\n                });\n\n                return deferred.promise;\n            };\n\n            // return the patched service\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * cssLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite cssLoader and it will probably not use promises :(\n             */\n            $delegate.cssLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('css', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.cssLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * jsLoader function\n             * @type Function\n             * @param paths array list of js files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite jsLoader and it will probably not use promises :(\n             */\n            $delegate.jsLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('js', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.jsLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n            /**\n             * templatesLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters for $http\n             * because the user can overwrite templatesLoader and it will probably not use promises :(\n             */\n            $delegate.templatesLoader = function (paths, callback, params) {\n                var promises = [],\n                    filesCache = $delegate._getFilesCache();\n\n                angular.forEach(paths, function (url) {\n                    var deferred = $q.defer();\n                    promises.push(deferred.promise);\n                    $http.get(url, params).success(function (data) {\n                        if (angular.isString(data) && data.length > 0) {\n                            angular.forEach(angular.element(data), function (node) {\n                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n                                    $templateCache.put(node.id, node.innerHTML);\n                                }\n                            });\n                        }\n                        if (angular.isUndefined(filesCache.get(url))) {\n                            filesCache.put(url, true);\n                        }\n                        deferred.resolve();\n                    }).error(function (err) {\n                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n                    });\n                });\n                return $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n// Array.indexOf polyfill for IE8\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement, fromIndex) {\n        var k;\n\n        // 1. Let O be the result of calling ToObject passing\n        //    the this value as the argument.\n        if (this == null) {\n            throw new TypeError('\"this\" is null or not defined');\n        }\n\n        var O = Object(this);\n\n        // 2. Let lenValue be the result of calling the Get\n        //    internal method of O with the argument \"length\".\n        // 3. Let len be ToUint32(lenValue).\n        var len = O.length >>> 0;\n\n        // 4. If len is 0, return -1.\n        if (len === 0) {\n            return -1;\n        }\n\n        // 5. If argument fromIndex was passed let n be\n        //    ToInteger(fromIndex); else let n be 0.\n        var n = +fromIndex || 0;\n\n        if (Math.abs(n) === Infinity) {\n            n = 0;\n        }\n\n        // 6. If n >= len, return -1.\n        if (n >= len) {\n            return -1;\n        }\n\n        // 7. If n >= 0, then Let k be n.\n        // 8. Else, n<0, Let k be len - abs(n).\n        //    If k is less than 0, then let k be 0.\n        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n        // 9. Repeat, while k < len\n        while (k < len) {\n            // a. Let Pk be ToString(k).\n            //   This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the\n            //    HasProperty internal method of O with argument Pk.\n            //   This step can be combined with c\n            // c. If kPresent is true, then\n            //    i.  Let elementK be the result of calling the Get\n            //        internal method of O with the argument ToString(k).\n            //   ii.  Let same be the result of applying the\n            //        Strict Equality Comparison Algorithm to\n            //        searchElement and elementK.\n            //  iii.  If same is true, return k.\n            if (k in O && O[k] === searchElement) {\n                return k;\n            }\n            k++;\n        }\n        return -1;\n    };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/oclazyload/dist/ocLazyLoad.js\n ** module id = 25\n ** module chunks = 2\n **/","/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 0.14.3 - 2015-10-23\n * License: MIT\n */\nangular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module(\"ui.bootstrap.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/carousel/carousel.html\",\"template/carousel/slide.html\",\"template/datepicker/datepicker.html\",\"template/datepicker/day.html\",\"template/datepicker/month.html\",\"template/datepicker/popup.html\",\"template/datepicker/year.html\",\"template/modal/backdrop.html\",\"template/modal/window.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/tooltip/tooltip-template-popup.html\",\"template/popover/popover-html.html\",\"template/popover/popover-template.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/progressbar/progressbar.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/timepicker/timepicker.html\",\"template/typeahead/typeahead-match.html\",\"template/typeahead/typeahead-popup.html\"]);\nangular.module('ui.bootstrap.collapse', [])\n\n  .directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        function expand() {\n          element.removeClass('collapse')\n            .addClass('collapsing')\n            .attr('aria-expanded', true)\n            .attr('aria-hidden', false);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              addClass: 'in',\n              easing: 'ease',\n              to: { height: element[0].scrollHeight + 'px' }\n            }).start().finally(expandDone);\n          } else {\n            $animate.addClass(element, 'in', {\n              to: { height: element[0].scrollHeight + 'px' }\n            }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse')\n            .css({height: 'auto'});\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          element\n            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n            // Otherwise, the browser attempts to animate from height 0 (in\n            // collapsing class) to the given height here.\n            .css({height: element[0].scrollHeight + 'px'})\n            // initially all panel collapse have the collapse class, this removal\n            // prevents the animation from jumping to collapsed state\n            .removeClass('collapse')\n            .addClass('collapsing')\n            .attr('aria-expanded', false)\n            .attr('aria-hidden', true);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              removeClass: 'in',\n              to: {height: '0'}\n            }).start().finally(collapseDone);\n          } else {\n            $animate.removeClass(element, 'in', {\n              to: {height: '0'}\n            }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n        }\n\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\n/* Deprecated collapse below */\n\nangular.module('ui.bootstrap.collapse')\n\n  .value('$collapseSuppressWarning', false)\n\n  .directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        if (!$collapseSuppressWarning) {\n          $log.warn('collapse is now deprecated. Use uib-collapse instead.');\n        }\n\n        function expand() {\n          element.removeClass('collapse')\n            .addClass('collapsing')\n            .attr('aria-expanded', true)\n            .attr('aria-hidden', false);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              easing: 'ease',\n              to: { height: element[0].scrollHeight + 'px' }\n            }).start().done(expandDone);\n          } else {\n            $animate.animate(element, {}, {\n              height: element[0].scrollHeight + 'px'\n            }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse in')\n            .css({height: 'auto'});\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          element\n            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n            // Otherwise, the browser attempts to animate from height 0 (in\n            // collapsing class) to the given height here.\n            .css({height: element[0].scrollHeight + 'px'})\n            // initially all panel collapse have the collapse class, this removal\n            // prevents the animation from jumping to collapsed state\n            .removeClass('collapse in')\n            .addClass('collapsing')\n            .attr('aria-expanded', false)\n            .attr('aria-hidden', true);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              to: {height: '0'}\n            }).start().done(collapseDone);\n          } else {\n            $animate.animate(element, {}, {\n              height: '0'\n            }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n        }\n\n        scope.$watch(attrs.collapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\n.constant('uibAccordionConfig', {\n  closeOthers: true\n})\n\n.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if (closeOthers) {\n      angular.forEach(this.groups, function(group) {\n        if (group !== openGroup) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function(event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if (index !== -1) {\n      this.groups.splice(index, 1);\n    }\n  };\n\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('uibAccordion', function() {\n  return {\n    controller: 'UibAccordionController',\n    controllerAs: 'accordion',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/accordion/accordion.html';\n    }\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('uibAccordionGroup', function() {\n  return {\n    require: '^uibAccordion',         // We need this directive to be inside an accordion\n    transclude: true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/accordion/accordion-group.html';\n    },\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      accordionCtrl.addGroup(scope);\n\n      scope.openClass = attrs.openClass || 'panel-open';\n      scope.panelClass = attrs.panelClass;\n      scope.$watch('isOpen', function(value) {\n        element.toggleClass(scope.openClass, !!value);\n        if (value) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function($event) {\n        if (!scope.isDisabled) {\n          if (!$event || $event.which === 32) {\n            scope.isOpen = !scope.isOpen;\n          }\n        }\n      };\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n.directive('uibAccordionHeading', function() {\n  return {\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n.directive('uibAccordionTransclude', function() {\n  return {\n    require: ['?^uibAccordionGroup', '?^accordionGroup'],\n    link: function(scope, element, attrs, controller) {\n      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n        if (heading) {\n          element.find('span').html('');\n          element.find('span').append(heading);\n        }\n      });\n    }\n  };\n});\n\n/* Deprecated accordion below */\n\nangular.module('ui.bootstrap.accordion')\n\n  .value('$accordionSuppressWarning', false)\n\n  .controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {\n    if (!$accordionSuppressWarning) {\n      $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');\n    }\n\n    angular.extend(this, $controller('UibAccordionController', {\n      $scope: $scope,\n      $attrs: $attrs\n    }));\n  }])\n\n  .directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      restrict: 'EA',\n      controller: 'AccordionController',\n      controllerAs: 'accordion',\n      transclude: true,\n      replace: false,\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || 'template/accordion/accordion.html';\n      },\n      link: function() {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion is now deprecated. Use uib-accordion instead.');\n        }\n      }\n    };\n  }])\n\n  .directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      require: '^accordion',         // We need this directive to be inside an accordion\n      restrict: 'EA',\n      transclude: true,              // It transcludes the contents of the directive into the template\n      replace: true,                // The element containing the directive will be replaced with the template\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || 'template/accordion/accordion-group.html';\n      },\n      scope: {\n        heading: '@',               // Interpolate the heading attribute onto this scope\n        isOpen: '=?',\n        isDisabled: '=?'\n      },\n      controller: function() {\n        this.setHeading = function(element) {\n          this.heading = element;\n        };\n      },\n      link: function(scope, element, attrs, accordionCtrl) {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');\n        }\n\n        accordionCtrl.addGroup(scope);\n\n        scope.openClass = attrs.openClass || 'panel-open';\n        scope.panelClass = attrs.panelClass;\n        scope.$watch('isOpen', function(value) {\n          element.toggleClass(scope.openClass, !!value);\n          if (value) {\n            accordionCtrl.closeOthers(scope);\n          }\n        });\n\n        scope.toggleOpen = function($event) {\n          if (!scope.isDisabled) {\n            if (!$event || $event.which === 32) {\n              scope.isOpen = !scope.isOpen;\n            }\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      restrict: 'EA',\n      transclude: true,   // Grab the contents to be used as the heading\n      template: '',       // In effect remove this element!\n      replace: true,\n      require: '^accordionGroup',\n      link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');\n        }\n        // Pass the heading to the accordion-group controller\n        // so that it can be transcluded into the right place in the template\n        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n      }\n    };\n  }])\n\n  .directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      require: '^accordionGroup',\n      link: function(scope, element, attr, controller) {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');\n        }\n\n        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n          if (heading) {\n            element.find('span').html('');\n            element.find('span').append(heading);\n          }\n        });\n      }\n    };\n  }]);\n\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n  $scope.closeable = !!$attrs.close;\n\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\n  if (dismissOnTimeout) {\n    $timeout(function() {\n      $scope.close();\n    }, parseInt(dismissOnTimeout, 10));\n  }\n}])\n\n.directive('uibAlert', function() {\n  return {\n    controller: 'UibAlertController',\n    controllerAs: 'alert',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/alert/alert.html';\n    },\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@',\n      close: '&'\n    }\n  };\n});\n\n/* Deprecated alert below */\n\nangular.module('ui.bootstrap.alert')\n\n  .value('$alertSuppressWarning', false)\n\n  .controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {\n    if (!$alertSuppressWarning) {\n      $log.warn('AlertController is now deprecated. Use UibAlertController instead.');\n    }\n\n    angular.extend(this, $controller('UibAlertController', {\n      $scope: $scope,\n      $attrs: $attrs\n    }));\n  }])\n\n  .directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {\n    return {\n      controller: 'AlertController',\n      controllerAs: 'alert',\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || 'template/alert/alert.html';\n      },\n      transclude: true,\n      replace: true,\n      scope: {\n        type: '@',\n        close: '&'\n      },\n      link: function() {\n        if (!$alertSuppressWarning) {\n          $log.warn('alert is now deprecated. Use uib-alert instead.');\n        }\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('uibButtonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('uibBtnRadio', function() {\n  return {\n    require: ['uibBtnRadio', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'buttons',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n    }\n  };\n})\n\n.directive('uibBtnCheckbox', function() {\n  return {\n    require: ['uibBtnCheckbox', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'button',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attribute, defaultValue) {\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        scope.$apply(function() {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\n/* Deprecated buttons below */\n\nangular.module('ui.bootstrap.buttons')\n\n  .value('$buttonsSuppressWarning', false)\n\n  .controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {\n    if (!$buttonsSuppressWarning) {\n      $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');\n    }\n\n    angular.extend(this, $controller('UibButtonsController'));\n  }])\n\n  .directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {\n    return {\n      require: ['btnRadio', 'ngModel'],\n      controller: 'ButtonsController',\n      controllerAs: 'buttons',\n      link: function(scope, element, attrs, ctrls) {\n        if (!$buttonsSuppressWarning) {\n          $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');\n        }\n\n        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        element.find('input').css({display: 'none'});\n\n        //model -> UI\n        ngModelCtrl.$render = function() {\n          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n        };\n\n        //ui->model\n        element.bind(buttonsCtrl.toggleEvent, function() {\n          if (attrs.disabled) {\n            return;\n          }\n\n          var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n          if (!isActive || angular.isDefined(attrs.uncheckable)) {\n            scope.$apply(function() {\n              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n              ngModelCtrl.$render();\n            });\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {\n    return {\n      require: ['btnCheckbox', 'ngModel'],\n      controller: 'ButtonsController',\n      controllerAs: 'button',\n      link: function(scope, element, attrs, ctrls) {\n        if (!$buttonsSuppressWarning) {\n          $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');\n        }\n\n        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        element.find('input').css({display: 'none'});\n\n        function getTrueValue() {\n          return getCheckboxValue(attrs.btnCheckboxTrue, true);\n        }\n\n        function getFalseValue() {\n          return getCheckboxValue(attrs.btnCheckboxFalse, false);\n        }\n\n        function getCheckboxValue(attributeValue, defaultValue) {\n          var val = scope.$eval(attributeValue);\n          return angular.isDefined(val) ? val : defaultValue;\n        }\n\n        //model -> UI\n        ngModelCtrl.$render = function() {\n          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n        };\n\n        //ui->model\n        element.bind(buttonsCtrl.toggleEvent, function() {\n          if (attrs.disabled) {\n            return;\n          }\n\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n            ngModelCtrl.$render();\n          });\n        });\n\n        //accessibility\n        element.on('keypress', function(e) {\n          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {\n            return;\n          }\n\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n            ngModelCtrl.$render();\n          });\n        });\n      }\n    };\n  }]);\n\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.carousel\n *\n * @description\n * AngularJS version of an image carousel.\n *\n */\nangular.module('ui.bootstrap.carousel', [])\n\n.controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    NEW_ANIMATE = angular.version.minor >= 4,\n    NO_TRANSITION = 'uib-noTransition',\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    currentIndex = -1,\n    currentInterval, isPlaying;\n  self.currentSlide = null;\n\n  var destroyed = false;\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = $scope.indexOfSlide(nextSlide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n    }\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {\n      goNext(nextSlide, nextIndex, direction);\n    }\n  };\n\n  function goNext(slide, index, direction) {\n    // Scope has been destroyed, stop here.\n    if (destroyed) { return; }\n\n    angular.extend(slide, {direction: direction, active: true});\n    angular.extend(self.currentSlide || {}, {direction: direction, active: false});\n    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&\n      slide.$element && self.slides.length > 1) {\n      slide.$element.data(SLIDE_DIRECTION, slide.direction);\n      if (self.currentSlide && self.currentSlide.$element) {\n        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);\n      }\n\n      $scope.$currentTransition = true;\n      if (NEW_ANIMATE) {\n        $animate.on('addClass', slide.$element, function(element, phase) {\n          if (phase === 'close') {\n            $scope.$currentTransition = null;\n            $animate.off('addClass', element);\n          }\n        });\n      } else {\n        slide.$element.one('$animate:close', function closeFn() {\n          $scope.$currentTransition = null;\n        });\n      }\n    }\n\n    self.currentSlide = slide;\n    currentIndex = index;\n\n    //every time you change slides, reset the timer\n    restartTimer();\n  }\n\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n\n  function getSlideByIndex(index) {\n    if (angular.isUndefined(slides[index].index)) {\n      return slides[index];\n    }\n    var i, len = slides.length;\n    for (i = 0; i < slides.length; ++i) {\n      if (slides[i].index == index) {\n        return slides[i];\n      }\n    }\n  }\n\n  self.getCurrentIndex = function() {\n    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {\n      return +self.currentSlide.index;\n    }\n    return currentIndex;\n  };\n\n  /* Allow outside people to call indexOf on slides array */\n  $scope.indexOfSlide = function(slide) {\n    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);\n  };\n\n  $scope.next = function() {\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\n    if (newIndex === 0 && $scope.noWrap()) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), 'next');\n  };\n\n  $scope.prev = function() {\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), 'prev');\n  };\n\n  $scope.isActive = function(slide) {\n     return self.currentSlide === slide;\n  };\n\n  $scope.$watch('interval', restartTimer);\n  $scope.$watchCollection('slides', resetTransition);\n  $scope.$on('$destroy', resetTimer);\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval > 0) {\n      currentInterval = $interval(timerFn, interval);\n    }\n  }\n\n  function resetTimer() {\n    if (currentInterval) {\n      $interval.cancel(currentInterval);\n      currentInterval = null;\n    }\n  }\n\n  function timerFn() {\n    var interval = +$scope.interval;\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n      $scope.next();\n    } else {\n      $scope.pause();\n    }\n  }\n\n  function resetTransition(slides) {\n    if (!slides.length) {\n      $scope.$currentTransition = null;\n    }\n  }\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  self.addSlide = function(slide, element) {\n    slide.$element = element;\n    slides.push(slide);\n    //if this is the first slide or the slide is set to active, select it\n    if (slides.length === 1 || slide.active) {\n      self.select(slides[slides.length - 1]);\n      if (slides.length === 1) {\n        $scope.play();\n      }\n    } else {\n      slide.active = false;\n    }\n  };\n\n  self.removeSlide = function(slide) {\n    if (angular.isDefined(slide.index)) {\n      slides.sort(function(a, b) {\n        return +a.index > +b.index;\n      });\n    }\n    //get the index of the slide inside the carousel\n    var index = slides.indexOf(slide);\n    slides.splice(index, 1);\n    if (slides.length > 0 && slide.active) {\n      if (index >= slides.length) {\n        self.select(slides[index - 1]);\n      } else {\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n    }\n\n    //clean the currentSlide when no more slide\n    if (slides.length === 0) {\n      self.currentSlide = null;\n    }\n  };\n\n  $scope.$watch('noTransition', function(noTransition) {\n    $element.data(NO_TRANSITION, noTransition);\n  });\n\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:carousel\n * @restrict EA\n *\n * @description\n * Carousel is the outer container for a set of image 'slides' to showcase.\n *\n * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <uib-carousel>\n      <uib-slide>\n        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>Beautiful!</p>\n        </div>\n      </uib-slide>\n      <uib-slide>\n        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>D'aww!</p>\n        </div>\n      </uib-slide>\n    </uib-carousel>\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n */\n.directive('uibCarousel', [function() {\n  return {\n    transclude: true,\n    replace: true,\n    controller: 'UibCarouselController',\n    controllerAs: 'carousel',\n    require: 'carousel',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/carousel.html';\n    },\n    scope: {\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    }\n  };\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:slide\n * @restrict EA\n *\n * @description\n * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n *\n * @param {boolean=} active Model binding, whether or not this slide is currently active.\n * @param {number=} index The index of the slide. The slides will be sorted by this parameter.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n<div ng-controller=\"CarouselDemoCtrl\">\n  <uib-carousel>\n    <uib-slide ng-repeat=\"slide in slides\" active=\"slide.active\" index=\"$index\">\n      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n      <div class=\"carousel-caption\">\n        <h4>Slide {{$index}}</h4>\n        <p>{{slide.text}}</p>\n      </div>\n    </uib-slide>\n  </uib-carousel>\n  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n  <br />Enter a negative number to stop the interval.\n</div>\n  </file>\n  <file name=\"script.js\">\nfunction CarouselDemoCtrl($scope) {\n  $scope.myInterval = 5000;\n}\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n*/\n\n.directive('uibSlide', function() {\n  return {\n    require: '^uibCarousel',\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/slide.html';\n    },\n    scope: {\n      active: '=?',\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n})\n\n.animation('.item', [\n         '$injector', '$animate',\nfunction ($injector, $animate) {\n  var NO_TRANSITION = 'uib-noTransition',\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    $animateCss = null;\n\n  if ($injector.has('$animateCss')) {\n    $animateCss = $injector.get('$animateCss');\n  }\n\n  function removeClass(element, className, callback) {\n    element.removeClass(className);\n    if (callback) {\n      callback();\n    }\n  }\n\n  return {\n    beforeAddClass: function(element, className, done) {\n      // Due to transclusion, noTransition property is on parent's scope\n      if (className == 'active' && element.parent() && element.parent().parent() &&\n          !element.parent().parent().data(NO_TRANSITION)) {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction == 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element,\n          directionClass + ' ' + direction, done);\n        element.addClass(direction);\n\n        if ($animateCss) {\n          $animateCss(element, {addClass: directionClass})\n            .start()\n            .done(removeClassFn);\n        } else {\n          $animate.addClass(element, directionClass).then(function () {\n            if (!stopped) {\n              removeClassFn();\n            }\n            done();\n          });\n        }\n\n        return function () {\n          stopped = true;\n        };\n      }\n      done();\n    },\n    beforeRemoveClass: function (element, className, done) {\n      // Due to transclusion, noTransition property is on parent's scope\n      if (className === 'active' && element.parent() && element.parent().parent() &&\n          !element.parent().parent().data(NO_TRANSITION)) {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction == 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\n        if ($animateCss) {\n          $animateCss(element, {addClass: directionClass})\n            .start()\n            .done(removeClassFn);\n        } else {\n          $animate.addClass(element, directionClass).then(function() {\n            if (!stopped) {\n              removeClassFn();\n            }\n            done();\n          });\n        }\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    }\n  };\n}]);\n\n/* deprecated carousel below */\n\nangular.module('ui.bootstrap.carousel')\n\n.value('$carouselSuppressWarning', false)\n\n.controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {\n  if (!$carouselSuppressWarning) {\n    $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');\n  }\n\n  angular.extend(this, $controller('UibCarouselController', {\n    $scope: $scope,\n    $element: $element\n  }));\n}])\n\n.directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n  return {\n    transclude: true,\n    replace: true,\n    controller: 'CarouselController',\n    controllerAs: 'carousel',\n    require: 'carousel',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/carousel.html';\n    },\n    scope: {\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    },\n    link: function() {\n      if (!$carouselSuppressWarning) {\n        $log.warn('carousel is now deprecated. Use uib-carousel instead.');\n      }\n    }\n  };\n}])\n\n.directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n  return {\n    require: '^carousel',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/slide.html';\n    },\n    scope: {\n      active: '=?',\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      if (!$carouselSuppressWarning) {\n        $log.warn('slide is now deprecated. Use uib-slide instead.');\n      }\n\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  var localeId;\n  var formatCodeToRegex;\n\n  this.init = function() {\n    localeId = $locale.id;\n\n    this.parsers = {};\n\n    formatCodeToRegex = {\n      'yyyy': {\n        regex: '\\\\d{4}',\n        apply: function(value) { this.year = +value; }\n      },\n      'yy': {\n        regex: '\\\\d{2}',\n        apply: function(value) { this.year = +value + 2000; }\n      },\n      'y': {\n        regex: '\\\\d{1,4}',\n        apply: function(value) { this.year = +value; }\n      },\n      'MMMM': {\n        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n      },\n      'MMM': {\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n      },\n      'MM': {\n        regex: '0[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; }\n      },\n      'M': {\n        regex: '[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; }\n      },\n      'dd': {\n        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; }\n      },\n      'd': {\n        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; }\n      },\n      'EEEE': {\n        regex: $locale.DATETIME_FORMATS.DAY.join('|')\n      },\n      'EEE': {\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n      },\n      'HH': {\n        regex: '(?:0|1)[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'hh': {\n        regex: '0[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'H': {\n        regex: '1?[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'h': {\n        regex: '[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'mm': {\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.minutes = +value; }\n      },\n      'm': {\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.minutes = +value; }\n      },\n      'sss': {\n        regex: '[0-9][0-9][0-9]',\n        apply: function(value) { this.milliseconds = +value; }\n      },\n      'ss': {\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.seconds = +value; }\n      },\n      's': {\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.seconds = +value; }\n      },\n      'a': {\n        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n        apply: function(value) {\n          if (this.hours === 12) {\n            this.hours = 0;\n          }\n\n          if (value === 'PM') {\n            this.hours += 12;\n          }\n        }\n      }\n    };\n  };\n\n  this.init();\n\n  function createParser(format) {\n    var map = [], regex = format.split('');\n\n    angular.forEach(formatCodeToRegex, function(data, code) {\n      var index = format.indexOf(code);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + code.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({ index: index, apply: data.apply });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  this.parse = function(input, format, baseDate) {\n    if (!angular.isString(input) || !format) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.parsers[format]) {\n      this.parsers[format] = createParser(format);\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex);\n\n    if (results && results.length) {\n      var fields, dt;\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n        fields = {\n          year: baseDate.getFullYear(),\n          month: baseDate.getMonth(),\n          date: baseDate.getDate(),\n          hours: baseDate.getHours(),\n          minutes: baseDate.getMinutes(),\n          seconds: baseDate.getSeconds(),\n          milliseconds: baseDate.getMilliseconds()\n        };\n      } else {\n        if (baseDate) {\n          $log.warn('dateparser:', 'baseDate is not a valid date');\n        }\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n      }\n\n      for (var i = 1, n = results.length; i < n; i++) {\n        var mapper = map[i-1];\n        if (mapper.apply) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      if (isValid(fields.year, fields.month, fields.date)) {\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n          dt = new Date(baseDate);\n          dt.setFullYear(fields.year, fields.month, fields.date,\n            fields.hours, fields.minutes, fields.seconds,\n            fields.milliseconds || 0);\n        } else {\n          dt = new Date(fields.year, fields.month, fields.date,\n            fields.hours, fields.minutes, fields.seconds,\n            fields.milliseconds || 0);\n        }\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if (date < 1) {\n      return false;\n    }\n\n    if (month === 1 && date > 28) {\n      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n    }\n\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\n      return date < 31;\n    }\n\n    return true;\n  }\n}]);\n\n/* Deprecated dateparser below */\n\nangular.module('ui.bootstrap.dateparser')\n\n.value('$dateParserSuppressWarning', false)\n\n.service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {\n  if (!$dateParserSuppressWarning) {\n    $log.warn('dateParser is now deprecated. Use uibDateParser instead.');\n  }\n\n  angular.extend(this, uibDateParser);\n}]);\n\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n    function getStyle(el, cssprop) {\n      if (el.currentStyle) { //IE\n        return el.currentStyle[cssprop];\n      } else if ($window.getComputedStyle) {\n        return $window.getComputedStyle(el)[cssprop];\n      }\n      // finally try and get inline style\n      return el.style[cssprop];\n    }\n\n    /**\n     * Checks if a given element is statically positioned\n     * @param element - raw DOM element\n     */\n    function isStaticPositioned(element) {\n      return (getStyle(element, 'position') || 'static' ) === 'static';\n    }\n\n    /**\n     * returns the closest, non-statically positioned parentOffset of a given element\n     * @param element\n     */\n    var parentOffsetEl = function(element) {\n      var docDomEl = $document[0];\n      var offsetParent = element.offsetParent || docDomEl;\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docDomEl;\n    };\n\n    return {\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/\n       */\n      position: function(element) {\n        var elBCR = this.offset(element);\n        var offsetParentBCR = { top: 0, left: 0 };\n        var offsetParentEl = parentOffsetEl(element[0]);\n        if (offsetParentEl != $document[0]) {\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n        }\n\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: elBCR.top - offsetParentBCR.top,\n          left: elBCR.left - offsetParentBCR.left\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/\n       */\n      offset: function(element) {\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n        };\n      },\n\n      /**\n       * Provides coordinates for the targetEl in relation to hostEl\n       */\n      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {\n        var positionStrParts = positionStr.split('-');\n        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\n        var hostElPos,\n          targetElWidth,\n          targetElHeight,\n          targetElPos;\n\n        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\n        targetElWidth = targetEl.prop('offsetWidth');\n        targetElHeight = targetEl.prop('offsetHeight');\n\n        var shiftWidth = {\n          center: function() {\n            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n          },\n          left: function() {\n            return hostElPos.left;\n          },\n          right: function() {\n            return hostElPos.left + hostElPos.width;\n          }\n        };\n\n        var shiftHeight = {\n          center: function() {\n            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n          },\n          top: function() {\n            return hostElPos.top;\n          },\n          bottom: function() {\n            return hostElPos.top + hostElPos.height;\n          }\n        };\n\n        switch (pos0) {\n          case 'right':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: shiftWidth[pos0]()\n            };\n            break;\n          case 'left':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: hostElPos.left - targetElWidth\n            };\n            break;\n          case 'bottom':\n            targetElPos = {\n              top: shiftHeight[pos0](),\n              left: shiftWidth[pos1]()\n            };\n            break;\n          default:\n            targetElPos = {\n              top: hostElPos.top - targetElHeight,\n              left: shiftWidth[pos1]()\n            };\n            break;\n        }\n\n        return targetElPos;\n      }\n    };\n  }]);\n\n/* Deprecated position below */\n\nangular.module('ui.bootstrap.position')\n\n.value('$positionSuppressWarning', false)\n\n.service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {\n  if (!$positionSuppressWarning) {\n    $log.warn('$position is now deprecated. Use $uibPosition instead.');\n  }\n\n  angular.extend(this, $uibPosition);\n}]);\n\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\n.value('$datepickerSuppressError', false)\n\n.constant('uibDatepickerConfig', {\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  datepickerMode: 'day',\n  minMode: 'day',\n  maxMode: 'year',\n  showWeeks: true,\n  startingDay: 0,\n  yearRange: 20,\n  minDate: null,\n  maxDate: null,\n  shortcutPropagation: false\n})\n\n.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  // Configuration attributes\n  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  // Watchable date attributes\n  angular.forEach(['minDate', 'maxDate'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  angular.forEach(['minMode', 'maxMode'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = angular.isDefined(value) ? value : $attrs[key];\n        $scope[key] = self[key];\n        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n          $scope.datepickerMode = self[key];\n        }\n      });\n    } else {\n      self[key] = datepickerConfig[key] || null;\n      $scope[key] = self[key];\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  if (angular.isDefined($attrs.initDate)) {\n    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n        self.activeDate = initDate;\n        self.refreshView();\n      }\n    });\n  } else {\n    this.activeDate = new Date();\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n          isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = date;\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date)\n    };\n  };\n\n  this.isDisabled = function(date) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  this.step = { months: 1 };\n  this.element = $element;\n  function getDaysInMonth(year, month) {\n    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n  }\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    scope.showWeeks = ctrl.showWeeks;\n    ctrl.refreshView();\n  };\n\n  this.getDates = function(startDate, n) {\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n    while (i < n) {\n      date = new Date(current);\n      dates[i++] = date;\n      current.setDate(current.getDate() + 1);\n    }\n    return dates;\n  };\n\n  this._refreshView = function() {\n    var year = this.activeDate.getFullYear(),\n      month = this.activeDate.getMonth(),\n      firstDayOfMonth = new Date(this.activeDate);\n\n    firstDayOfMonth.setFullYear(year, month, 1);\n\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\n      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n      firstDate = new Date(firstDayOfMonth);\n\n    if (numDisplayedFromPreviousMonth > 0) {\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n    }\n\n    // 42 is the number of days on a six-month calendar\n    var days = this.getDates(firstDate, 42);\n    for (var i = 0; i < 42; i ++) {\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n        secondary: days[i].getMonth() !== month,\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.labels = new Array(7);\n    for (var j = 0; j < 7; j++) {\n      scope.labels[j] = {\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\n        full: dateFilter(days[j].date, 'EEEE')\n      };\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n    scope.rows = this.split(days, 7);\n\n    if (scope.showWeeks) {\n      scope.weekNumbers = [];\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n          numWeeks = scope.rows.length;\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n        scope.weekNumbers.push(\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n      }\n    }\n  };\n\n  this.compare = function(date1, date2) {\n    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n  };\n\n  function getISO8601WeekNumber(date) {\n    var checkDate = new Date(date);\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  }\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getDate();\n\n    if (key === 'left') {\n      date = date - 1;   // up\n    } else if (key === 'up') {\n      date = date - 7;   // down\n    } else if (key === 'right') {\n      date = date + 1;   // down\n    } else if (key === 'down') {\n      date = date + 7;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setMonth(month, 1);\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n    } else if (key === 'home') {\n      date = 1;\n    } else if (key === 'end') {\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n    }\n    this.activeDate.setDate(date);\n  };\n}])\n\n.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  this.step = { years: 1 };\n  this.element = $element;\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    ctrl.refreshView();\n  };\n\n  this._refreshView = function() {\n    var months = new Array(12),\n        year = this.activeDate.getFullYear(),\n        date;\n\n    for (var i = 0; i < 12; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(year, i, 1);\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n    scope.rows = this.split(months, 3);\n  };\n\n  this.compare = function(date1, date2) {\n    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getMonth();\n\n    if (key === 'left') {\n      date = date - 1;   // up\n    } else if (key === 'up') {\n      date = date - 3;   // down\n    } else if (key === 'right') {\n      date = date + 1;   // down\n    } else if (key === 'down') {\n      date = date + 3;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setFullYear(year);\n    } else if (key === 'home') {\n      date = 0;\n    } else if (key === 'end') {\n      date = 11;\n    }\n    this.activeDate.setMonth(date);\n  };\n}])\n\n.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var range;\n  this.element = $element;\n\n  function getStartingYear(year) {\n    return parseInt((year - 1) / range, 10) * range + 1;\n  }\n\n  this.yearpickerInit = function() {\n    range = this.yearRange;\n    this.step = { years: range };\n  };\n\n  this._refreshView = function() {\n    var years = new Array(range), date;\n\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(start + i, 0, 1);\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n    scope.rows = this.split(years, 5);\n  };\n\n  this.compare = function(date1, date2) {\n    return date1.getFullYear() - date2.getFullYear();\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getFullYear();\n\n    if (key === 'left') {\n      date = date - 1;   // up\n    } else if (key === 'up') {\n      date = date - 5;   // down\n    } else if (key === 'right') {\n      date = date + 1;   // down\n    } else if (key === 'down') {\n      date = date + 5;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      date += (key === 'pageup' ? - 1 : 1) * this.step.years;\n    } else if (key === 'home') {\n      date = getStartingYear(this.activeDate.getFullYear());\n    } else if (key === 'end') {\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n    }\n    this.activeDate.setFullYear(date);\n  };\n}])\n\n.directive('uibDatepicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerMode: '=?',\n      dateDisabled: '&',\n      customClass: '&',\n      shortcutPropagation: '&?'\n    },\n    require: ['uibDatepicker', '^ngModel'],\n    controller: 'UibDatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n})\n\n.directive('uibDaypicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/day.html';\n    },\n    require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0] || ctrls[2],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibMonthpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/month.html';\n    },\n    require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0] || ctrls[2],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibYearpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/year.html';\n    },\n    require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var ctrl = ctrls[0] || ctrls[2];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n})\n\n.constant('uibDatepickerPopupConfig', {\n  datepickerPopup: 'yyyy-MM-dd',\n  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',\n  datepickerTemplateUrl: 'template/datepicker/datepicker.html',\n  html5Types: {\n    date: 'yyyy-MM-dd',\n    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n    'month': 'yyyy-MM'\n  },\n  currentText: 'Today',\n  clearText: 'Clear',\n  closeText: 'Done',\n  closeOnDateSelection: true,\n  appendToBody: false,\n  showButtonBar: true,\n  onOpenFocus: true\n})\n\n.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout',\nfunction(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {\n  var self = this;\n  var cache = {},\n    isHtml5DateInput = false;\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,\n    ngModel, $popup;\n\n  scope.watchData = {};\n\n  this.init = function(_ngModel_) {\n    ngModel = _ngModel_;\n    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;\n    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\n    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\n    if (datepickerPopupConfig.html5Types[attrs.type]) {\n      dateFormat = datepickerPopupConfig.html5Types[attrs.type];\n      isHtml5DateInput = true;\n    } else {\n      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n          // Invalidate the $modelValue to ensure that formatters re-run\n          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n          if (newDateFormat !== dateFormat) {\n            dateFormat = newDateFormat;\n            ngModel.$modelValue = null;\n\n            if (!dateFormat) {\n              throw new Error('uibDatepickerPopup must have a date format specified.');\n            }\n          }\n      });\n    }\n\n    if (!dateFormat) {\n      throw new Error('uibDatepickerPopup must have a date format specified.');\n    }\n\n    if (isHtml5DateInput && attrs.datepickerPopup) {\n      throw new Error('HTML5 date input types do not support custom formats.');\n    }\n\n    // popup element used to display calendar\n    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n    popupEl.attr({\n      'ng-model': 'date',\n      'ng-change': 'dateSelection(date)',\n      'template-url': datepickerPopupTemplateUrl\n    });\n\n    // datepicker element\n    datepickerEl = angular.element(popupEl.children()[0]);\n    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\n    if (isHtml5DateInput) {\n      if (attrs.type === 'month') {\n        datepickerEl.attr('datepicker-mode', '\"month\"');\n        datepickerEl.attr('min-mode', 'month');\n      }\n    }\n\n    if (attrs.datepickerOptions) {\n      var options = scope.$parent.$eval(attrs.datepickerOptions);\n      if (options && options.initDate) {\n        scope.initDate = options.initDate;\n        datepickerEl.attr('init-date', 'initDate');\n        delete options.initDate;\n      }\n      angular.forEach(options, function(value, option) {\n        datepickerEl.attr(cameltoDash(option), value);\n      });\n    }\n\n    angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {\n      if (attrs[key]) {\n        var getAttribute = $parse(attrs[key]);\n        scope.$parent.$watch(getAttribute, function(value) {\n          scope.watchData[key] = value;\n          if (key === 'minDate' || key === 'maxDate') {\n            cache[key] = new Date(value);\n          }\n        });\n        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\n        // Propagate changes from datepicker to outside\n        if (key === 'datepickerMode') {\n          var setAttribute = getAttribute.assign;\n          scope.$watch('watchData.' + key, function(value, oldvalue) {\n            if (angular.isFunction(setAttribute) && value !== oldvalue) {\n              setAttribute(scope.$parent, value);\n            }\n          });\n        }\n      }\n    });\n    if (attrs.dateDisabled) {\n      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n    }\n\n    if (attrs.showWeeks) {\n      datepickerEl.attr('show-weeks', attrs.showWeeks);\n    }\n\n    if (attrs.customClass) {\n      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n    }\n\n    if (!isHtml5DateInput) {\n      // Internal API to maintain the correct ng-invalid-[key] class\n      ngModel.$$parserName = 'date';\n      ngModel.$validators.date = validator;\n      ngModel.$parsers.unshift(parseDate);\n      ngModel.$formatters.push(function(value) {\n        scope.date = value;\n        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);\n      });\n    } else {\n      ngModel.$formatters.push(function(value) {\n        scope.date = value;\n        return value;\n      });\n    }\n\n    // Detect changes in the view from the text box\n    ngModel.$viewChangeListeners.push(function() {\n      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);\n    });\n\n    element.bind('keydown', inputKeydownBind);\n\n    $popup = $compile(popupEl)(scope);\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\n    popupEl.remove();\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    scope.$on('$destroy', function() {\n      if (scope.isOpen === true) {\n        if (!$rootScope.$$phase) {\n          scope.$apply(function() {\n            scope.isOpen = false;\n          });\n        }\n      }\n\n      $popup.remove();\n      element.unbind('keydown', inputKeydownBind);\n      $document.unbind('click', documentClickBind);\n    });\n  };\n\n  scope.getText = function(key) {\n    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n  };\n\n  scope.isDisabled = function(date) {\n    if (date === 'today') {\n      date = new Date();\n    }\n\n    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||\n      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));\n  };\n\n  scope.compare = function(date1, date2) {\n    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n  };\n\n  // Inner change\n  scope.dateSelection = function(dt) {\n    if (angular.isDefined(dt)) {\n      scope.date = dt;\n    }\n    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n    element.val(date);\n    ngModel.$setViewValue(date);\n\n    if (closeOnDateSelection) {\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.keydown = function(evt) {\n    if (evt.which === 27) {\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.select = function(date) {\n    if (date === 'today') {\n      var today = new Date();\n      if (angular.isDate(scope.date)) {\n        date = new Date(scope.date);\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n      } else {\n        date = new Date(today.setHours(0, 0, 0, 0));\n      }\n    }\n    scope.dateSelection(date);\n  };\n\n  scope.close = function() {\n    scope.isOpen = false;\n    element[0].focus();\n  };\n\n  scope.$watch('isOpen', function(value) {\n    if (value) {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n      $timeout(function() {\n        if (onOpenFocus) {\n          scope.$broadcast('uib:datepicker.focus');\n        }\n        $document.bind('click', documentClickBind);\n      }, 0, false);\n    } else {\n      $document.unbind('click', documentClickBind);\n    }\n  });\n\n  function cameltoDash(string) {\n    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n  }\n\n  function parseDate(viewValue) {\n    if (angular.isNumber(viewValue)) {\n      // presumably timestamp to date object\n      viewValue = new Date(viewValue);\n    }\n\n    if (!viewValue) {\n      return null;\n    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n      return viewValue;\n    } else if (angular.isString(viewValue)) {\n      var date = dateParser.parse(viewValue, dateFormat, scope.date);\n      if (isNaN(date)) {\n        return undefined;\n      } else {\n        return date;\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  function validator(modelValue, viewValue) {\n    var value = modelValue || viewValue;\n\n    if (!attrs.ngRequired && !value) {\n      return true;\n    }\n\n    if (angular.isNumber(value)) {\n      value = new Date(value);\n    }\n    if (!value) {\n      return true;\n    } else if (angular.isDate(value) && !isNaN(value)) {\n      return true;\n    } else if (angular.isString(value)) {\n      var date = dateParser.parse(value, dateFormat);\n      return !isNaN(date);\n    } else {\n      return false;\n    }\n  }\n\n  function documentClickBind(event) {\n    var popup = $popup[0];\n    var dpContainsTarget = element[0].contains(event.target);\n    // The popup node may not be an element node\n    // In some browsers (IE) only element nodes have the 'contains' function\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n    }\n  }\n\n  function inputKeydownBind(evt) {\n    if (evt.which === 27 && scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n      element[0].focus();\n    } else if (evt.which === 40 && !scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = true;\n      });\n    }\n  }\n}])\n\n.directive('uibDatepickerPopup', function() {\n  return {\n    require: ['ngModel', 'uibDatepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&',\n      customClass: '&'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n})\n\n.directive('uibDatepickerPopupWrap', function() {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/popup.html';\n    }\n  };\n});\n\n/* Deprecated datepicker below */\n\nangular.module('ui.bootstrap.datepicker')\n\n.value('$datepickerSuppressWarning', false)\n\n.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {\n  if (!$datepickerSuppressWarning) {\n    $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');\n  }\n\n  var self = this,\n    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  this.modes = ['day', 'month', 'year'];\n\n  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n    'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  angular.forEach(['minDate', 'maxDate'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  angular.forEach(['minMode', 'maxMode'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = angular.isDefined(value) ? value : $attrs[key];\n        $scope[key] = self[key];\n        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n          $scope.datepickerMode = self[key];\n        }\n      });\n    } else {\n      self[key] = datepickerConfig[key] || null;\n      $scope[key] = self[key];\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  if (angular.isDefined($attrs.initDate)) {\n    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n        self.activeDate = initDate;\n        self.refreshView();\n      }\n    });\n  } else {\n    this.activeDate = new Date();\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n        isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = date;\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date)\n    };\n  };\n\n  this.isDisabled = function(date) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  this.fixTimeZone = function(date) {\n    var hours = date.getHours();\n    date.setHours(hours === 23 ? hours + 2 : 0);\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n      month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerMode: '=?',\n      dateDisabled: '&',\n      customClass: '&',\n      shortcutPropagation: '&?'\n    },\n    require: ['datepicker', '^ngModel'],\n    controller: 'DatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');\n      }\n\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n}])\n\n.directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: 'template/datepicker/day.html',\n    require: ['^datepicker', 'daypicker'],\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');\n      }\n\n      var datepickerCtrl = ctrls[0],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n}])\n\n.directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: 'template/datepicker/month.html',\n    require: ['^datepicker', 'monthpicker'],\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');\n      }\n\n      var datepickerCtrl = ctrls[0],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n}])\n\n.directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: 'template/datepicker/year.html',\n    require: ['^datepicker', 'yearpicker'],\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');\n      }\n\n      var ctrl = ctrls[0];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    require: ['ngModel', 'datepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&',\n      customClass: '&'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');\n      }\n\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n}])\n\n.directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/popup.html';\n    },\n    link: function() {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\n.constant('uibDropdownConfig', {\n  openClass: 'open'\n})\n\n.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n  var openScope = null;\n\n  this.open = function(dropdownScope) {\n    if (!openScope) {\n      $document.bind('click', closeDropdown);\n      $document.bind('keydown', keybindFilter);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function(dropdownScope) {\n    if (openScope === dropdownScope) {\n      openScope = null;\n      $document.unbind('click', closeDropdown);\n      $document.unbind('keydown', keybindFilter);\n    }\n  };\n\n  var closeDropdown = function(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope) { return; }\n\n    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  var keybindFilter = function(evt) {\n    if (evt.which === 27) {\n      openScope.focusToggleElement();\n      closeDropdown();\n    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      openScope.focusDropdownEntry(evt.which);\n    }\n  };\n}])\n\n.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    keynavEnabled =false,\n    selectedOption = null;\n\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\n    if (appendToBody && self.dropdownMenu) {\n      $document.find('body').append(self.dropdownMenu);\n      $element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      (angular.element(self.dropdownMenu).find('a')) :\n      (angular.element($element).find('ul').eq(0).find('a'));\n\n    switch (keyCode) {\n      case (40): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = (self.selectedOption === elems.length - 1 ?\n            self.selectedOption :\n            self.selectedOption + 1);\n        }\n        break;\n      }\n      case (38): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    if (appendToBody && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n      var css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n        toggleInvoker($scope, { open: !!isOpen });\n      }\n    });\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    if (scope.getAutoClose() !== 'disabled') {\n      scope.isOpen = false;\n    }\n  });\n\n  var offDestroy = $scope.$on('$destroy', function() {\n    scope.$destroy();\n  });\n  scope.$on('$destroy', offDestroy);\n}])\n\n.directive('uibDropdown', function() {\n  return {\n    controller: 'UibDropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init();\n    }\n  };\n})\n\n.directive('uibDropdownMenu', function() {\n  return {\n    restrict: 'AC',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n})\n\n.directive('uibKeyboardNav', function() {\n  return {\n    restrict: 'A',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      element.bind('keydown', function(e) {\n        if ([38, 40].indexOf(e.which) !== -1) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          var elems = dropdownCtrl.dropdownMenu.find('a');\n\n          switch (e.which) {\n            case (40): { // Down\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = 0;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n              }\n              break;\n            }\n            case (38): { // Up\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = elems.length - 1;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n                  0 : dropdownCtrl.selectedOption - 1;\n              }\n              break;\n            }\n          }\n          elems[dropdownCtrl.selectedOption].focus();\n        }\n      });\n    }\n  };\n})\n\n.directive('uibDropdownToggle', function() {\n  return {\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n});\n\n/* Deprecated dropdown below */\n\nangular.module('ui.bootstrap.dropdown')\n\n.value('$dropdownSuppressWarning', false)\n\n.service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {\n  if (!$dropdownSuppressWarning) {\n    $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');\n  }\n\n  angular.extend(this, uibDropdownService);\n}])\n\n.controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {\n  if (!$dropdownSuppressWarning) {\n    $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');\n  }\n\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    keynavEnabled =false,\n    selectedOption = null;\n\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\n    if (appendToBody && self.dropdownMenu) {\n      $document.find('body').append(self.dropdownMenu);\n      $element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      (angular.element(self.dropdownMenu).find('a')) :\n      (angular.element($element).find('ul').eq(0).find('a'));\n\n    switch (keyCode) {\n      case (40): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = (self.selectedOption === elems.length -1 ?\n            self.selectedOption :\n          self.selectedOption + 1);\n        }\n        break;\n      }\n      case (38): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    if (appendToBody && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n      var css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n        toggleInvoker($scope, { open: !!isOpen });\n      }\n    });\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    if (scope.getAutoClose() !== 'disabled') {\n      scope.isOpen = false;\n    }\n  });\n\n  var offDestroy = $scope.$on('$destroy', function() {\n    scope.$destroy();\n  });\n  scope.$on('$destroy', offDestroy);\n}])\n\n.directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    controller: 'DropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');\n      }\n\n      dropdownCtrl.init();\n    }\n  };\n}])\n\n.directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    restrict: 'AC',\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      if (!$dropdownSuppressWarning) {\n        $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n}])\n\n.directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    restrict: 'A',\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');\n      }\n\n      element.bind('keydown', function(e) {\n        if ([38, 40].indexOf(e.which) !== -1) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          var elems = dropdownCtrl.dropdownMenu.find('a');\n\n          switch (e.which) {\n            case (40): { // Down\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = 0;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n              }\n              break;\n            }\n            case (38): { // Up\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = elems.length - 1;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n                  0 : dropdownCtrl.selectedOption - 1;\n              }\n              break;\n            }\n          }\n          elems[dropdownCtrl.selectedOption].focus();\n        }\n      });\n    }\n  };\n}])\n\n.directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');\n      }\n\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.stackedMap', [])\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function() {\n    return {\n      createNew: function() {\n        var stack = [];\n\n        return {\n          add: function(key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function(key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function() {\n            return stack[stack.length - 1];\n          },\n          remove: function(key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function() {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function() {\n            return stack.length;\n          }\n        };\n      }\n    };\n  });\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n/**\n * A helper, internal data structure that stores all references attached to key\n */\n  .factory('$$multiMap', function() {\n    return {\n      createNew: function() {\n        var map = {};\n\n        return {\n          entries: function() {\n            return Object.keys(map).map(function(key) {\n              return {\n                key: key,\n                value: map[key]\n              };\n            });\n          },\n          get: function(key) {\n            return map[key];\n          },\n          hasKey: function(key) {\n            return !!map[key];\n          },\n          keys: function() {\n            return Object.keys(map);\n          },\n          put: function(key, value) {\n            if (!map[key]) {\n              map[key] = [];\n            }\n\n            map[key].push(value);\n          },\n          remove: function(key, value) {\n            var values = map[key];\n\n            if (!values) {\n              return;\n            }\n\n            var idx = values.indexOf(value);\n\n            if (idx !== -1) {\n              values.splice(idx, 1);\n            }\n\n            if (!values.length) {\n              delete map[key];\n            }\n          }\n        };\n      }\n    };\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('uibModalBackdrop', [\n           '$animate', '$injector', '$uibModalStack',\n  function($animate ,  $injector,   $modalStack) {\n    var $animateCss = null;\n\n    if ($injector.has('$animateCss')) {\n      $animateCss = $injector.get('$animateCss');\n    }\n\n    return {\n      replace: true,\n      templateUrl: 'template/modal/backdrop.html',\n      compile: function(tElement, tAttrs) {\n        tElement.addClass(tAttrs.backdropClass);\n        return linkFn;\n      }\n    };\n\n    function linkFn(scope, element, attrs) {\n      // Temporary fix for prefixing\n      element.addClass('modal-backdrop');\n\n      if (attrs.modalInClass) {\n        if ($animateCss) {\n          $animateCss(element, {\n            addClass: attrs.modalInClass\n          }).start();\n        } else {\n          $animate.addClass(element, attrs.modalInClass);\n        }\n\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n          var done = setIsAsync();\n          if ($animateCss) {\n            $animateCss(element, {\n              removeClass: attrs.modalInClass\n            }).start().then(done);\n          } else {\n            $animate.removeClass(element, attrs.modalInClass).then(done);\n          }\n        });\n      }\n    }\n  }])\n\n  .directive('uibModalWindow', [\n           '$uibModalStack', '$q', '$animate', '$injector',\n  function($modalStack ,  $q ,  $animate,   $injector) {\n    var $animateCss = null;\n\n    if ($injector.has('$animateCss')) {\n      $animateCss = $injector.get('$animateCss');\n    }\n\n    return {\n      scope: {\n        index: '@'\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'template/modal/window.html';\n      },\n      link: function(scope, element, attrs) {\n        element.addClass(attrs.windowClass || '');\n        element.addClass(attrs.windowTopClass || '');\n        scope.size = attrs.size;\n\n        scope.close = function(evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n\n        // moved from template to fix issue #2280\n        element.on('click', scope.close);\n\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n        // We can detect that by using this property in the template associated with this directive and then use\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n        scope.$isRendered = true;\n\n        // Deferred object that will be resolved when this modal is render.\n        var modalRenderDeferObj = $q.defer();\n        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n        attrs.$observe('modalRender', function(value) {\n          if (value == 'true') {\n            modalRenderDeferObj.resolve();\n          }\n        });\n\n        modalRenderDeferObj.promise.then(function() {\n          var animationPromise = null;\n\n          if (attrs.modalInClass) {\n            if ($animateCss) {\n              animationPromise = $animateCss(element, {\n                addClass: attrs.modalInClass\n              }).start();\n            } else {\n              animationPromise = $animate.addClass(element, attrs.modalInClass);\n            }\n\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n              var done = setIsAsync();\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: attrs.modalInClass\n                }).start().then(done);\n              } else {\n                $animate.removeClass(element, attrs.modalInClass).then(done);\n              }\n            });\n          }\n\n\n          $q.when(animationPromise).then(function() {\n            var inputWithAutofocus = element[0].querySelector('[autofocus]');\n            /**\n             * Auto-focusing of a freshly-opened modal element causes any child elements\n             * with the autofocus attribute to lose focus. This is an issue on touch\n             * based devices which will show and then hide the onscreen keyboard.\n             * Attempts to refocus the autofocus element via JavaScript will not reopen\n             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n             * the modal element if the modal does not contain an autofocus element.\n             */\n            if (inputWithAutofocus) {\n              inputWithAutofocus.focus();\n            } else {\n              element[0].focus();\n            }\n          });\n\n          // Notify {@link $modalStack} that modal is rendered.\n          var modal = $modalStack.getTop();\n          if (modal) {\n            $modalStack.modalRendered(modal.key);\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('uibModalAnimationClass', function() {\n    return {\n      compile: function(tElement, tAttrs) {\n        if (tAttrs.modalAnimation) {\n          tElement.addClass(tAttrs.uibModalAnimationClass);\n        }\n      }\n    };\n  })\n\n  .directive('uibModalTransclude', function() {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  })\n\n  .factory('$uibModalStack', [\n             '$animate', '$timeout', '$document', '$compile', '$rootScope',\n             '$q',\n             '$injector',\n             '$$multiMap',\n             '$$stackedMap',\n    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n              $q,\n              $injector,\n              $$multiMap,\n              $$stackedMap) {\n      var $animateCss = null;\n\n      if ($injector.has('$animateCss')) {\n        $animateCss = $injector.get('$animateCss');\n      }\n\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var openedClasses = $$multiMap.createNew();\n      var $modalStack = {\n        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n      };\n\n      //Modal focus behavior\n      var focusableElementList;\n      var focusIndex = 0;\n      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n        var body = $document.find('body').eq(0);\n        var modalWindow = openedWindows.get(modalInstance).value;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n          openedClasses.remove(modalBodyClass, modalInstance);\n          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n          toggleTopWindowClass(true);\n        });\n        checkRemoveBackdrop();\n\n        //move focus to specified element if available, or else to body\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n          elementToReceiveFocus.focus();\n        } else {\n          body.focus();\n        }\n      }\n\n      // Add or remove \"windowTopClass\" from the top window in the stack\n      function toggleTopWindowClass(toggleSwitch) {\n        var modalWindow;\n\n        if (openedWindows.length() > 0) {\n          modalWindow = openedWindows.top().value;\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n        }\n      }\n\n      function checkRemoveBackdrop() {\n        //remove backdrop if no longer needed\n        if (backdropDomEl && backdropIndex() == -1) {\n          var backdropScopeRef = backdropScope;\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n            backdropScopeRef = null;\n          });\n          backdropDomEl = undefined;\n          backdropScope = undefined;\n        }\n      }\n\n      function removeAfterAnimate(domEl, scope, done) {\n        var asyncDeferred;\n        var asyncPromise = null;\n        var setIsAsync = function() {\n          if (!asyncDeferred) {\n            asyncDeferred = $q.defer();\n            asyncPromise = asyncDeferred.promise;\n          }\n\n          return function asyncDone() {\n            asyncDeferred.resolve();\n          };\n        };\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\n        // Note that it's intentional that asyncPromise might be null.\n        // That's when setIsAsync has not been called during the\n        // NOW_CLOSING_EVENT broadcast.\n        return $q.when(asyncPromise).then(afterAnimating);\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          if ($animateCss) {\n            $animateCss(domEl, {\n              event: 'leave'\n            }).start().then(function() {\n              domEl.remove();\n            });\n          } else {\n            $animate.leave(domEl);\n          }\n          scope.$destroy();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.bind('keydown', function(evt) {\n        if (evt.isDefaultPrevented()) {\n          return evt;\n        }\n\n        var modal = openedWindows.top();\n        if (modal && modal.value.keyboard) {\n          switch (evt.which) {\n            case 27: {\n              evt.preventDefault();\n              $rootScope.$apply(function() {\n                $modalStack.dismiss(modal.key, 'escape key press');\n              });\n              break;\n            }\n            case 9: {\n              $modalStack.loadFocusElementList(modal);\n              var focusChanged = false;\n              if (evt.shiftKey) {\n                if ($modalStack.isFocusInFirstItem(evt)) {\n                  focusChanged = $modalStack.focusLastFocusableElement();\n                }\n              } else {\n                if ($modalStack.isFocusInLastItem(evt)) {\n                  focusChanged = $modalStack.focusFirstFocusableElement();\n                }\n              }\n\n              if (focusChanged) {\n                evt.preventDefault();\n                evt.stopPropagation();\n              }\n              break;\n            }\n          }\n        }\n      });\n\n      $modalStack.open = function(modalInstance, modal) {\n        var modalOpener = $document[0].activeElement,\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\n        toggleTopWindowClass(false);\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          renderDeferred: modal.renderDeferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard,\n          openedClass: modal.openedClass,\n          windowTopClass: modal.windowTopClass\n        });\n\n        openedClasses.put(modalBodyClass, modalInstance);\n\n        var body = $document.find('body').eq(0),\n            currBackdropIndex = backdropIndex();\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.index = currBackdropIndex;\n          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n          if (modal.animation) {\n            angularBackgroundDomEl.attr('modal-animation', 'true');\n          }\n          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n          body.append(backdropDomEl);\n        }\n\n        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n        angularDomEl.attr({\n          'template-url': modal.windowTemplateUrl,\n          'window-class': modal.windowClass,\n          'window-top-class': modal.windowTopClass,\n          'size': modal.size,\n          'index': openedWindows.length() - 1,\n          'animate': 'animate'\n        }).html(modal.content);\n        if (modal.animation) {\n          angularDomEl.attr('modal-animation', 'true');\n        }\n\n        var modalDomEl = $compile(angularDomEl)(modal.scope);\n        openedWindows.top().value.modalDomEl = modalDomEl;\n        openedWindows.top().value.modalOpener = modalOpener;\n        body.append(modalDomEl);\n        body.addClass(modalBodyClass);\n\n        $modalStack.clearFocusListCache();\n      };\n\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\n        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n      }\n\n      $modalStack.close = function(modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismiss = function(modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismissAll = function(reason) {\n        var topModal = this.getTop();\n        while (topModal && this.dismiss(topModal.key, reason)) {\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function() {\n        return openedWindows.top();\n      };\n\n      $modalStack.modalRendered = function(modalInstance) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.renderDeferred.resolve();\n        }\n      };\n\n      $modalStack.focusFirstFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[0].focus();\n          return true;\n        }\n        return false;\n      };\n      $modalStack.focusLastFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[focusableElementList.length - 1].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInFirstItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) == focusableElementList[0];\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInLastItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];\n        }\n        return false;\n      };\n\n      $modalStack.clearFocusListCache = function() {\n        focusableElementList = [];\n        focusIndex = 0;\n      };\n\n      $modalStack.loadFocusElementList = function(modalWindow) {\n        if (focusableElementList === undefined || !focusableElementList.length) {\n          if (modalWindow) {\n            var modalDomE1 = modalWindow.value.modalDomEl;\n            if (modalDomE1 && modalDomE1.length) {\n              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n            }\n          }\n        }\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$uibModal', function() {\n    var $modalProvider = {\n      options: {\n        animation: true,\n        backdrop: true, //can also be false or 'static'\n        keyboard: true\n      },\n      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log',\n        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);\n          }\n\n          function getResolvePromises(resolves) {\n            var promisesArr = [];\n            angular.forEach(resolves, function(value) {\n              if (angular.isFunction(value) || angular.isArray(value)) {\n                promisesArr.push($q.when($injector.invoke(value)));\n              } else if (angular.isString(value)) {\n                promisesArr.push($q.when($injector.get(value)));\n              } else {\n                promisesArr.push($q.when(value));\n              }\n            });\n            return promisesArr;\n          }\n\n          var promiseChain = null;\n          $modal.getPromiseChain = function() {\n            return promiseChain;\n          };\n\n          $modal.open = function(modalOptions) {\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n            var modalRenderDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              rendered: modalRenderDeferred.promise,\n              close: function (result) {\n                return $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                return $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\n            function resolveWithTemplate() {\n              return templateAndResolvePromise;\n            }\n\n            // Wait for the resolution of the existing promise chain.\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n            // Then add to $modalStack and resolve opened.\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n            var samePromise;\n            samePromise = promiseChain = $q.all([promiseChain])\n              .then(resolveWithTemplate, resolveWithTemplate)\n              .then(function resolveSuccess(tplAndVars) {\n\n                var modalScope = (modalOptions.scope || $rootScope).$new();\n                modalScope.$close = modalInstance.close;\n                modalScope.$dismiss = modalInstance.dismiss;\n\n                modalScope.$on('$destroy', function() {\n                  if (!modalScope.$$uibDestructionScheduled) {\n                    modalScope.$dismiss('$uibUnscheduledDestruction');\n                  }\n                });\n\n                var ctrlInstance, ctrlLocals = {};\n                var resolveIter = 1;\n\n                //controllers\n                if (modalOptions.controller) {\n                  ctrlLocals.$scope = modalScope;\n                  ctrlLocals.$uibModalInstance = modalInstance;\n                  Object.defineProperty(ctrlLocals, '$modalInstance', {\n                    get: function() {\n                      if (!$modalSuppressWarning) {\n                        $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');\n                      }\n\n                      return modalInstance;\n                    }\n                  });\n                  angular.forEach(modalOptions.resolve, function(value, key) {\n                    ctrlLocals[key] = tplAndVars[resolveIter++];\n                  });\n\n                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n                  if (modalOptions.controllerAs) {\n                    if (modalOptions.bindToController) {\n                      angular.extend(ctrlInstance, modalScope);\n                    }\n\n                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n                  }\n                }\n\n                $modalStack.open(modalInstance, {\n                  scope: modalScope,\n                  deferred: modalResultDeferred,\n                  renderDeferred: modalRenderDeferred,\n                  content: tplAndVars[0],\n                  animation: modalOptions.animation,\n                  backdrop: modalOptions.backdrop,\n                  keyboard: modalOptions.keyboard,\n                  backdropClass: modalOptions.backdropClass,\n                  windowTopClass: modalOptions.windowTopClass,\n                  windowClass: modalOptions.windowClass,\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n                  size: modalOptions.size,\n                  openedClass: modalOptions.openedClass\n                });\n                modalOpenedDeferred.resolve(true);\n\n            }, function resolveError(reason) {\n              modalOpenedDeferred.reject(reason);\n              modalResultDeferred.reject(reason);\n            })\n            .finally(function() {\n              if (promiseChain === samePromise) {\n                promiseChain = null;\n              }\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }\n      ]\n    };\n\n    return $modalProvider;\n  });\n\n/* deprecated modal below */\n\nangular.module('ui.bootstrap.modal')\n\n  .value('$modalSuppressWarning', false)\n\n  /**\n   * A helper directive for the $modal service. It creates a backdrop element.\n   */\n  .directive('modalBackdrop', [\n    '$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning',\n    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {\n      var $animateCss = null;\n\n      if ($injector.has('$animateCss')) {\n        $animateCss = $injector.get('$animateCss');\n      }\n\n      return {\n        replace: true,\n        templateUrl: 'template/modal/backdrop.html',\n        compile: function(tElement, tAttrs) {\n          tElement.addClass(tAttrs.backdropClass);\n          return linkFn;\n        }\n      };\n\n      function linkFn(scope, element, attrs) {\n        if (!$modalSuppressWarning) {\n          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');\n        }\n        element.addClass('modal-backdrop');\n\n        if (attrs.modalInClass) {\n          if ($animateCss) {\n            $animateCss(element, {\n              addClass: attrs.modalInClass\n            }).start();\n          } else {\n            $animate.addClass(element, attrs.modalInClass);\n          }\n\n          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n            var done = setIsAsync();\n            if ($animateCss) {\n              $animateCss(element, {\n                removeClass: attrs.modalInClass\n              }).start().then(done);\n            } else {\n              $animate.removeClass(element, attrs.modalInClass).then(done);\n            }\n          });\n        }\n      }\n    }])\n\n  .directive('modalWindow', [\n    '$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning',\n    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {\n      var $animateCss = null;\n\n      if ($injector.has('$animateCss')) {\n        $animateCss = $injector.get('$animateCss');\n      }\n\n      return {\n        scope: {\n          index: '@'\n        },\n        replace: true,\n        transclude: true,\n        templateUrl: function(tElement, tAttrs) {\n          return tAttrs.templateUrl || 'template/modal/window.html';\n        },\n        link: function(scope, element, attrs) {\n          if (!$modalSuppressWarning) {\n            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');\n          }\n          element.addClass(attrs.windowClass || '');\n          element.addClass(attrs.windowTopClass || '');\n          scope.size = attrs.size;\n\n          scope.close = function(evt) {\n            var modal = $modalStack.getTop();\n            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n              evt.preventDefault();\n              evt.stopPropagation();\n              $modalStack.dismiss(modal.key, 'backdrop click');\n            }\n          };\n\n          // moved from template to fix issue #2280\n          element.on('click', scope.close);\n\n          // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n          // We can detect that by using this property in the template associated with this directive and then use\n          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n          scope.$isRendered = true;\n\n          // Deferred object that will be resolved when this modal is render.\n          var modalRenderDeferObj = $q.defer();\n          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n          attrs.$observe('modalRender', function(value) {\n            if (value == 'true') {\n              modalRenderDeferObj.resolve();\n            }\n          });\n\n          modalRenderDeferObj.promise.then(function() {\n            var animationPromise = null;\n\n            if (attrs.modalInClass) {\n              if ($animateCss) {\n                animationPromise = $animateCss(element, {\n                  addClass: attrs.modalInClass\n                }).start();\n              } else {\n                animationPromise = $animate.addClass(element, attrs.modalInClass);\n              }\n\n              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n                var done = setIsAsync();\n                if ($animateCss) {\n                  $animateCss(element, {\n                    removeClass: attrs.modalInClass\n                  }).start().then(done);\n                } else {\n                  $animate.removeClass(element, attrs.modalInClass).then(done);\n                }\n              });\n            }\n\n\n            $q.when(animationPromise).then(function() {\n              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n              /**\n               * Auto-focusing of a freshly-opened modal element causes any child elements\n               * with the autofocus attribute to lose focus. This is an issue on touch\n               * based devices which will show and then hide the onscreen keyboard.\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n               * the modal element if the modal does not contain an autofocus element.\n               */\n              if (inputWithAutofocus) {\n                inputWithAutofocus.focus();\n              } else {\n                element[0].focus();\n              }\n            });\n\n            // Notify {@link $modalStack} that modal is rendered.\n            var modal = $modalStack.getTop();\n            if (modal) {\n              $modalStack.modalRendered(modal.key);\n            }\n          });\n        }\n      };\n    }])\n\n  .directive('modalAnimationClass', [\n    '$log', '$modalSuppressWarning',\n    function ($log, $modalSuppressWarning) {\n      return {\n        compile: function(tElement, tAttrs) {\n          if (!$modalSuppressWarning) {\n            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');\n          }\n          if (tAttrs.modalAnimation) {\n            tElement.addClass(tAttrs.modalAnimationClass);\n          }\n        }\n      };\n    }])\n\n  .directive('modalTransclude', [\n    '$log', '$modalSuppressWarning',\n    function ($log, $modalSuppressWarning) {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        if (!$modalSuppressWarning) {\n          $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');\n        }\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  }])\n\n  .service('$modalStack', [\n    '$animate', '$timeout', '$document', '$compile', '$rootScope',\n    '$q',\n    '$injector',\n    '$$multiMap',\n    '$$stackedMap',\n    '$uibModalStack',\n    '$log',\n    '$modalSuppressWarning',\n    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n             $q,\n             $injector,\n             $$multiMap,\n             $$stackedMap,\n             $uibModalStack,\n             $log,\n             $modalSuppressWarning) {\n      if (!$modalSuppressWarning) {\n        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');\n      }\n\n      angular.extend(this, $uibModalStack);\n    }])\n\n  .provider('$modal', ['$uibModalProvider', function($uibModalProvider) {\n    angular.extend(this, $uibModalProvider);\n\n    this.$get = ['$injector', '$log', '$modalSuppressWarning',\n      function ($injector, $log, $modalSuppressWarning) {\n        if (!$modalSuppressWarning) {\n          $log.warn('$modal is now deprecated. Use $uibModal instead.');\n        }\n\n        return $injector.invoke($uibModalProvider.$get);\n      }];\n  }]);\n\nangular.module('ui.bootstrap.pagination', [])\n.controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n\n    $scope.$watch('totalItems', function() {\n      $scope.totalPages = self.calculateTotalPages();\n    });\n\n    $scope.$watch('totalPages', function(value) {\n      setNumPages($scope.$parent, value); // Readonly variable\n\n      if ( $scope.page > value ) {\n        $scope.selectPage(value);\n      } else {\n        ngModelCtrl.$render();\n      }\n    });\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page, evt) {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    var clickAllowed = !$scope.ngDisabled || !evt;\n    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      if (evt && evt.target) {\n        evt.target.blur();\n      }\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || self.config[key + 'Text'];\n  };\n\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n}])\n\n.constant('uibPaginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true\n})\n\n.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['uibPagination', '?ngModel'],\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pagination.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n        // recompute if maxSize\n        if (isMaxSized) {\n          if (rotate) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if (isMaxSized && ! rotate) {\n          if (startPage > 1) {\n            var previousPageSet = makePage(startPage - 1, '...', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if (endPage < totalPages) {\n            var nextPageSet = makePage(endPage + 1, '...', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.constant('uibPagerConfig', {\n  itemsPerPage: 10,\n  previousText: '« Previous',\n  nextText: 'Next »',\n  align: true\n})\n\n.directive('uibPager', ['uibPagerConfig', function(pagerConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['uibPager', '?ngModel'],\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pager.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/* Deprecated Pagination Below */\n\nangular.module('ui.bootstrap.pagination')\n.value('$paginationSuppressWarning', false)\n.controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {\n  if (!$paginationSuppressWarning) {\n    $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');\n  }\n\n  var self = this,\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n\n    $scope.$watch('totalItems', function() {\n      $scope.totalPages = self.calculateTotalPages();\n    });\n\n    $scope.$watch('totalPages', function(value) {\n      setNumPages($scope.$parent, value); // Readonly variable\n\n      if ( $scope.page > value ) {\n        $scope.selectPage(value);\n      } else {\n        ngModelCtrl.$render();\n      }\n    });\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page, evt) {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    var clickAllowed = !$scope.ngDisabled || !evt;\n    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      if (evt && evt.target) {\n        evt.target.blur();\n      }\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || self.config[key + 'Text'];\n  };\n\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n}])\n.directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['pagination', '?ngModel'],\n    controller: 'PaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pagination.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$paginationSuppressWarning) {\n        $log.warn('pagination is now deprecated. Use uib-pagination instead.');\n      }\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n        // recompute if maxSize\n        if (isMaxSized) {\n          if (rotate) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if (isMaxSized && ! rotate) {\n          if (startPage > 1) {\n            var previousPageSet = makePage(startPage - 1, '...', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if (endPage < totalPages) {\n            var nextPageSet = makePage(endPage + 1, '...', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['pager', '?ngModel'],\n    controller: 'PaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pager.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$paginationSuppressWarning) {\n        $log.warn('pager is now deprecated. Use uib-pager instead.');\n      }\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider('$uibTooltip', function() {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    animation: true,\n    popupDelay: 0,\n    popupCloseDelay: 0,\n    useContentExp: false\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'focus': 'blur',\n    'none': ''\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function(value) {\n\t\tangular.extend(globalOptions, value);\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n   */\n  this.setTriggers = function setTriggers(triggers) {\n    angular.extend(triggerMap, triggers);\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake-case.\n   */\n  function snake_case(name) {\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n    var openedTooltips = $$stackedMap.createNew();\n    $document.on('keypress', function(e) {\n      if (e.which === 27) {\n        var last = openedTooltips.top();\n        if (last) {\n          last.value.close();\n          openedTooltips.removeTop();\n          last = null;\n        }\n      }\n    });\n\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n      options = angular.extend({}, defaultOptions, globalOptions, options);\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers(trigger) {\n        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n        var hide = show.map(function(trigger) {\n          return triggerMap[trigger] || trigger;\n        });\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case(ttType);\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName + '-popup '+\n          'title=\"' + startSym + 'title' + endSym + '\" '+\n          (options.useContentExp ?\n            'content-exp=\"contentExp()\" ' :\n            'content=\"' + startSym + 'content' + endSym + '\" ') +\n          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n          'animation=\"animation\" ' +\n          'is-open=\"isOpen\"' +\n          'origin-scope=\"origScope\" ' +\n          'style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"' +\n          '>' +\n        '</div>';\n\n      return {\n        compile: function(tElem, tAttrs) {\n          var tooltipLinker = $compile(template);\n\n          return function link(scope, element, attrs, tooltipCtrl) {\n            var tooltip;\n            var tooltipLinkedScope;\n            var transitionTimeout;\n            var showTimeout;\n            var hideTimeout;\n            var positionTimeout;\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n            var triggers = getTriggers(undefined);\n            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n            var ttScope = scope.$new(true);\n            var repositionScheduled = false;\n            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n            var observers = [];\n\n            var positionTooltip = function() {\n              // check if tooltip exists and is not empty\n              if (!tooltip || !tooltip.html()) { return; }\n\n              if (!positionTimeout) {\n                positionTimeout = $timeout(function() {\n                  // Reset the positioning.\n                  tooltip.css({ top: 0, left: 0 });\n\n                  // Now set the calculated positioning.\n                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n                  ttCss.top += 'px';\n                  ttCss.left += 'px';\n                  ttCss.visibility = 'visible';\n                  tooltip.css(ttCss);\n\n                  positionTimeout = null;\n                }, 0, false);\n              }\n            };\n\n            // Set up the correct scope to allow transclusion later\n            ttScope.origScope = scope;\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            ttScope.isOpen = false;\n            openedTooltips.add(ttScope, {\n              close: hide\n            });\n\n            function toggleTooltipBind() {\n              if (!ttScope.isOpen) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n                return;\n              }\n\n              cancelHide();\n              prepareTooltip();\n\n              if (ttScope.popupDelay) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!showTimeout) {\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n                }\n              } else {\n                show();\n              }\n            }\n\n            function hideTooltipBind() {\n              cancelShow();\n\n              if (ttScope.popupCloseDelay) {\n                if (!hideTimeout) {\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n                }\n              } else {\n                hide();\n              }\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n              cancelShow();\n              cancelHide();\n\n              // Don't show empty tooltips.\n              if (!ttScope.content) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // And show the tooltip.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = true;\n                assignIsOpen(true);\n                positionTooltip();\n              });\n            }\n\n            function cancelShow() {\n              if (showTimeout) {\n                $timeout.cancel(showTimeout);\n                showTimeout = null;\n              }\n\n              if (positionTimeout) {\n                $timeout.cancel(positionTimeout);\n                positionTimeout = null;\n              }\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              cancelShow();\n              cancelHide();\n\n              if (!ttScope) {\n                return;\n              }\n\n              // First things first: we don't show it anymore.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = false;\n                assignIsOpen(false);\n                // And now we remove it from the DOM. However, if we have animation, we\n                // need to wait for it to expire beforehand.\n                // FIXME: this is a placeholder for a port of the transitions library.\n                // The fade transition in TWBS is 150ms.\n                if (ttScope.animation) {\n                  if (!transitionTimeout) {\n                    transitionTimeout = $timeout(removeTooltip, 150, false);\n                  }\n                } else {\n                  removeTooltip();\n                }\n              });\n            }\n\n            function cancelHide() {\n              if (hideTimeout) {\n                $timeout.cancel(hideTimeout);\n                hideTimeout = null;\n              }\n              if (transitionTimeout) {\n                $timeout.cancel(transitionTimeout);\n                transitionTimeout = null;\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                return;\n              }\n\n              tooltipLinkedScope = ttScope.$new();\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n                if (appendToBody) {\n                  $document.find('body').append(tooltip);\n                } else {\n                  element.after(tooltip);\n                }\n              });\n\n              prepObservers();\n            }\n\n            function removeTooltip() {\n              unregisterObservers();\n\n              transitionTimeout = null;\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n              if (tooltipLinkedScope) {\n                tooltipLinkedScope.$destroy();\n                tooltipLinkedScope = null;\n              }\n            }\n\n            /**\n             * Set the inital scope values. Once\n             * the tooltip is created, the observers\n             * will be added to keep things in synch.\n             */\n            function prepareTooltip() {\n              ttScope.title = attrs[prefix + 'Title'];\n              if (contentParse) {\n                ttScope.content = contentParse(scope);\n              } else {\n                ttScope.content = attrs[ttType];\n              }\n\n              ttScope.popupClass = attrs[prefix + 'Class'];\n              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\n              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n            }\n\n            function assignIsOpen(isOpen) {\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n                isOpenParse.assign(scope, isOpen);\n              }\n            }\n\n            ttScope.contentExp = function() {\n              return ttScope.content;\n            };\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe('disabled', function(val) {\n              if (val) {\n                cancelShow();\n              }\n\n              if (val && ttScope.isOpen) {\n                hide();\n              }\n            });\n\n            if (isOpenParse) {\n              scope.$watch(isOpenParse, function(val) {\n                /*jshint -W018 */\n                if (ttScope && !val === ttScope.isOpen) {\n                  toggleTooltipBind();\n                }\n                /*jshint +W018 */\n              });\n            }\n\n            function prepObservers() {\n              observers.length = 0;\n\n              if (contentParse) {\n                observers.push(\n                  scope.$watch(contentParse, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    }\n                  })\n                );\n\n                observers.push(\n                  tooltipLinkedScope.$watch(function() {\n                    if (!repositionScheduled) {\n                      repositionScheduled = true;\n                      tooltipLinkedScope.$$postDigest(function() {\n                        repositionScheduled = false;\n                        if (ttScope && ttScope.isOpen) {\n                          positionTooltip();\n                        }\n                      });\n                    }\n                  })\n                );\n              } else {\n                observers.push(\n                  attrs.$observe(ttType, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    } else {\n                      positionTooltip();\n                    }\n                  })\n                );\n              }\n\n              observers.push(\n                attrs.$observe(prefix + 'Title', function(val) {\n                  ttScope.title = val;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n\n              observers.push(\n                attrs.$observe(prefix + 'Placement', function(val) {\n                  ttScope.placement = val ? val : options.placement;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n            }\n\n            function unregisterObservers() {\n              if (observers.length) {\n                angular.forEach(observers, function(observer) {\n                  observer();\n                });\n                observers.length = 0;\n              }\n            }\n\n            var unregisterTriggers = function() {\n              triggers.show.forEach(function(trigger) {\n                element.unbind(trigger, showTooltipBind);\n              });\n              triggers.hide.forEach(function(trigger) {\n                trigger.split(' ').forEach(function(hideTrigger) {\n                  element[0].removeEventListener(hideTrigger, hideTooltipBind);\n                });\n              });\n            };\n\n            function prepTriggers() {\n              var val = attrs[prefix + 'Trigger'];\n              unregisterTriggers();\n\n              triggers = getTriggers(val);\n\n              if (triggers.show !== 'none') {\n                triggers.show.forEach(function(trigger, idx) {\n                  // Using raw addEventListener due to jqLite/jQuery bug - #4060\n                  if (trigger === triggers.hide[idx]) {\n                    element[0].addEventListener(trigger, toggleTooltipBind);\n                  } else if (trigger) {\n                    element[0].addEventListener(trigger, showTooltipBind);\n                    triggers.hide[idx].split(' ').forEach(function(trigger) {\n                      element[0].addEventListener(trigger, hideTooltipBind);\n                    });\n                  }\n\n                  element.on('keypress', function(e) {\n                    if (e.which === 27) {\n                      hideTooltipBind();\n                    }\n                  });\n                });\n              }\n            }\n\n            prepTriggers();\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\n            // if a tooltip is attached to <body> we need to remove it on\n            // location change as its parent scope will probably not be destroyed\n            // by the change.\n            if (appendToBody) {\n              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {\n                if (ttScope.isOpen) {\n                  hide();\n                }\n              });\n            }\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              cancelShow();\n              cancelHide();\n              unregisterTriggers();\n              removeTooltip();\n              openedTooltips.remove(ttScope);\n              ttScope = null;\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n// This is mostly ngInclude code but with a custom scope\n.directive('uibTooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest',\nfunction ($animate ,  $sce ,  $compile ,  $templateRequest) {\n  return {\n    link: function(scope, elem, attrs) {\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n/**\n * Note that it's intentional that these classes are *not* applied through $animate.\n * They must not be animated as they're expected to be present on the tooltip on\n * initialization.\n */\n.directive('uibTooltipClasses', function() {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      if (scope.placement) {\n        element.addClass(scope.placement);\n      }\n\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n})\n\n.directive('uibTooltipPopup', function() {\n  return {\n    replace: true,\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-popup.html',\n    link: function(scope, element) {\n      element.addClass('tooltip');\n    }\n  };\n})\n\n.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('uibTooltipTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n    link: function(scope, element) {\n      element.addClass('tooltip');\n    }\n  };\n})\n\n.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibTooltipHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n    link: function(scope, element) {\n      element.addClass('tooltip');\n    }\n  };\n})\n\n.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/* Deprecated tooltip below */\n\nangular.module('ui.bootstrap.tooltip')\n\n.value('$tooltipSuppressWarning', false)\n\n.provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {\n  angular.extend(this, $uibTooltipProvider);\n\n  this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {\n    if (!$tooltipSuppressWarning) {\n      $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');\n    }\n\n    return $injector.invoke($uibTooltipProvider.$get);\n  }];\n}])\n\n// This is mostly ngInclude code but with a custom scope\n.directive('tooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning',\nfunction ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {\n  return {\n    link: function(scope, elem, attrs) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');\n      }\n\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n.directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');\n      }\n\n      if (scope.placement) {\n        element.addClass(scope.placement);\n      }\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n}])\n\n.directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-popup.html',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');\n      }\n\n      element.addClass('tooltip');\n    }\n  };\n}])\n\n.directive('tooltip', ['$tooltip', function($tooltip) {\n  return $tooltip('tooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');\n      }\n\n      element.addClass('tooltip');\n    }\n  };\n}])\n\n.directive('tooltipTemplate', ['$tooltip', function($tooltip) {\n  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');\n      }\n\n      element.addClass('tooltip');\n    }\n  };\n}])\n\n.directive('tooltipHtml', ['$tooltip', function($tooltip) {\n  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, and selector delegatation.\n */\nangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\n.directive('uibPopoverTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/popover/popover-template.html',\n    link: function(scope, element) {\n      element.addClass('popover');\n    }\n  };\n})\n\n.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover-html.html',\n    link: function(scope, element) {\n      element.addClass('popover');\n    }\n  };\n})\n\n.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverPopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover.html',\n    link: function(scope, element) {\n      element.addClass('popover');\n    }\n  };\n})\n\n.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopover', 'popover', 'click');\n}]);\n\n/* Deprecated popover below */\n\nangular.module('ui.bootstrap.popover')\n\n.value('$popoverSuppressWarning', false)\n\n.directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/popover/popover-template.html',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');\n      }\n\n      element.addClass('popover');\n    }\n  };\n}])\n\n.directive('popoverTemplate', ['$tooltip', function($tooltip) {\n  return $tooltip('popoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover-html.html',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');\n      }\n\n      element.addClass('popover');\n    }\n  };\n}])\n\n.directive('popoverHtml', ['$tooltip', function($tooltip) {\n  return $tooltip('popoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover.html',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');\n      }\n\n      element.addClass('popover');\n    }\n  };\n}])\n\n.directive('popover', ['$tooltip', function($tooltip) {\n\n  return $tooltip('popover', 'popover', 'click');\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('uibProgressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n  var self = this,\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = $scope.max;\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n    this.bars.forEach(function (bar) {\n      bar.recalculatePercentage();\n    });\n  };\n\n  $scope.$watch('max', function(max) {\n    self.bars.forEach(function(bar) {\n      bar.max = $scope.max;\n      bar.recalculatePercentage();\n    });\n  });\n}])\n\n.directive('uibProgress', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    require: 'uibProgress',\n    scope: {\n      max: '=?'\n    },\n    templateUrl: 'template/progressbar/progress.html'\n  };\n})\n\n.directive('uibBar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^uibProgress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, element, attrs);\n    }\n  };\n})\n\n.directive('uibProgressbar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    scope: {\n      value: '=',\n      max: '=?',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n});\n\n/* Deprecated progressbar below */\n\nangular.module('ui.bootstrap.progressbar')\n\n.value('$progressSuppressWarning', false)\n\n.controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {\n  if (!$progressSuppressWarning) {\n    $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');\n  }\n\n  var self = this,\n    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = $scope.max;\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n  };\n\n  $scope.$watch('max', function(max) {\n    self.bars.forEach(function(bar) {\n      bar.max = $scope.max;\n      bar.recalculatePercentage();\n    });\n  });\n}])\n\n.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'ProgressController',\n    require: 'progress',\n    scope: {\n      max: '=?',\n      title: '@?'\n    },\n    templateUrl: 'template/progressbar/progress.html',\n    link: function() {\n      if (!$progressSuppressWarning) {\n        $log.warn('progress is now deprecated. Use uib-progress instead.');\n      }\n    }\n  };\n}])\n\n.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^progress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      if (!$progressSuppressWarning) {\n        $log.warn('bar is now deprecated. Use uib-bar instead.');\n      }\n      progressCtrl.addBar(scope, element);\n    }\n  };\n}])\n\n.directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'ProgressController',\n    scope: {\n      value: '=',\n      max: '=?',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      if (!$progressSuppressWarning) {\n        $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');\n      }\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.rating', [])\n\n.constant('uibRatingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null,\n  titles : ['one', 'two', 'three', 'four', 'five']\n})\n\n.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl  = { $setViewValue: angular.noop };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.push(function(value) {\n      if (angular.isNumber(value) && value << 0 !== value) {\n        value = Math.round(value);\n      }\n      return value;\n    });\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n      tmpTitles : ratingConfig.titles;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n      $scope.$parent.$eval($attrs.ratingStates) :\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n    }\n    return states;\n  };\n\n  this.getTitle = function(index) {\n    if (index >= this.titles.length) {\n      return index + 1;\n    } else {\n      return this.titles[index];\n    }\n  };\n\n  $scope.rate = function(value) {\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if (!$scope.readonly) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n  };\n}])\n\n.directive('uibRating', function() {\n  return {\n    require: ['uibRating', 'ngModel'],\n    scope: {\n      readonly: '=?',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'UibRatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n});\n\n/* Deprecated rating below */\n\nangular.module('ui.bootstrap.rating')\n\n.value('$ratingSuppressWarning', false)\n\n.controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {\n  if (!$ratingSuppressWarning) {\n    $log.warn('RatingController is now deprecated. Use UibRatingController instead.');\n  }\n\n  angular.extend(this, $controller('UibRatingController', {\n    $scope: $scope,\n    $attrs: $attrs\n  }));\n}])\n\n.directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {\n  return {\n    require: ['rating', 'ngModel'],\n    scope: {\n      readonly: '=?',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'RatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$ratingSuppressWarning) {\n        $log.warn('rating is now deprecated. Use uib-rating instead.');\n      }\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n}]);\n\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.tabs\n *\n * @description\n * AngularJS version of the tabs directive.\n */\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('UibTabsetController', ['$scope', function ($scope) {\n  var ctrl = this,\n      tabs = ctrl.tabs = $scope.tabs = [];\n\n  ctrl.select = function(selectedTab) {\n    angular.forEach(tabs, function(tab) {\n      if (tab.active && tab !== selectedTab) {\n        tab.active = false;\n        tab.onDeselect();\n        selectedTab.selectCalled = false;\n      }\n    });\n    selectedTab.active = true;\n    // only call select if it has not already been called\n    if (!selectedTab.selectCalled) {\n      selectedTab.onSelect();\n      selectedTab.selectCalled = true;\n    }\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    tabs.push(tab);\n    // we can't run the select function on the first tab\n    // since that would select it twice\n    if (tabs.length === 1 && tab.active !== false) {\n      tab.active = true;\n    } else if (tab.active) {\n      ctrl.select(tab);\n    } else {\n      tab.active = false;\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index = tabs.indexOf(tab);\n    //Select a new tab if the tab to be removed is selected and not destroyed\n    if (tab.active && tabs.length > 1 && !destroyed) {\n      //If this is the last tab, select the previous tab. else, the next tab.\n      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n      ctrl.select(tabs[newActiveIndex]);\n    }\n    tabs.splice(index, 1);\n  };\n\n  var destroyed;\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabset\n * @restrict EA\n *\n * @description\n * Tabset is the outer container for the tabs directive\n *\n * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <uib-tabset>\n      <uib-tab heading=\"Tab 1\"><b>First</b> Content!</uib-tab>\n      <uib-tab heading=\"Tab 2\"><i>Second</i> Content!</uib-tab>\n    </uib-tabset>\n    <hr />\n    <uib-tabset vertical=\"true\">\n      <uib-tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</uib-tab>\n      <uib-tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</uib-tab>\n    </uib-tabset>\n    <uib-tabset justified=\"true\">\n      <uib-tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</uib-tab>\n      <uib-tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</uib-tab>\n    </uib-tabset>\n  </file>\n</example>\n */\n.directive('uibTabset', function() {\n  return {\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@'\n    },\n    controller: 'UibTabsetController',\n    templateUrl: 'template/tabs/tabset.html',\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tab\n * @restrict EA\n *\n * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n * @param {string=} select An expression to evaluate when the tab is selected.\n * @param {boolean=} active A binding, telling whether or not this tab is selected.\n * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n *\n * @description\n * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <div ng-controller=\"TabsDemoCtrl\">\n      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n        Select item 1, using active binding\n      </button>\n      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n        Enable/disable item 2, using disabled binding\n      </button>\n      <br />\n      <uib-tabset>\n        <uib-tab heading=\"Tab 1\">First Tab</uib-tab>\n        <uib-tab select=\"alertMe()\">\n          <uib-tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n          Second Tab, with alert callback and html heading!\n        </uib-tab>\n        <uib-tab ng-repeat=\"item in items\"\n          heading=\"{{item.title}}\"\n          disabled=\"item.disabled\"\n          active=\"item.active\">\n          {{item.content}}\n        </uib-tab>\n      </uib-tabset>\n    </div>\n  </file>\n  <file name=\"script.js\">\n    function TabsDemoCtrl($scope) {\n      $scope.items = [\n        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n      ];\n\n      $scope.alertMe = function() {\n        setTimeout(function() {\n          alert(\"You've selected the alert tab!\");\n        });\n      };\n    };\n  </file>\n</example>\n */\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabHeading\n * @restrict EA\n *\n * @description\n * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <uib-tabset>\n      <uib-tab>\n        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>\n        And some content, too!\n      </uib-tab>\n      <uib-tab>\n        <uib-tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n        That's right.\n      </uib-tab>\n    </uib-tabset>\n  </file>\n</example>\n */\n.directive('uibTab', ['$parse', function($parse) {\n  return {\n    require: '^uibTabset',\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/tabs/tab.html',\n    transclude: true,\n    scope: {\n      active: '=?',\n      heading: '@',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n      scope.$watch('active', function(active) {\n        if (active) {\n          tabsetCtrl.select(scope);\n        }\n      });\n\n      scope.disabled = false;\n      if (attrs.disable) {\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\n          scope.disabled = !! value;\n        });\n      }\n\n      scope.select = function() {\n        if (!scope.disabled) {\n          scope.active = true;\n        }\n      };\n\n      tabsetCtrl.addTab(scope);\n      scope.$on('$destroy', function() {\n        tabsetCtrl.removeTab(scope);\n      });\n\n      //We need to transclude later, once the content container is ready.\n      //when this link happens, we're inside a tab heading.\n      scope.$transcludeFn = transclude;\n    }\n  };\n}])\n\n.directive('uibTabHeadingTransclude', function() {\n  return {\n    restrict: 'A',\n    require: ['?^uibTab', '?^tab'], // TODO: change to '^uibTab' after deprecation removal\n    link: function(scope, elm) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n})\n\n.directive('uibTabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: ['?^uibTabset', '?^tabset'], // TODO: change to '^uibTabset' after deprecation removal\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.uibTabContentTransclude);\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n\n  function isTabHeading(node) {\n    return node.tagName && (\n      node.hasAttribute('tab-heading') || // TODO: remove after deprecation removal\n      node.hasAttribute('data-tab-heading') || // TODO: remove after deprecation removal\n      node.hasAttribute('x-tab-heading') || // TODO: remove after deprecation removal\n      node.hasAttribute('uib-tab-heading') ||\n      node.hasAttribute('data-uib-tab-heading') ||\n      node.hasAttribute('x-uib-tab-heading') ||\n      node.tagName.toLowerCase() === 'tab-heading' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === 'data-tab-heading' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === 'x-tab-heading' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n    );\n  }\n});\n\n/* deprecated tabs below */\n\nangular.module('ui.bootstrap.tabs')\n\n  .value('$tabsSuppressWarning', false)\n\n  .controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {\n    if (!$tabsSuppressWarning) {\n      $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');\n    }\n\n    angular.extend(this, $controller('UibTabsetController', {\n      $scope: $scope\n    }));\n  }])\n\n  .directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: 'EA',\n      transclude: true,\n      replace: true,\n      scope: {\n        type: '@'\n      },\n      controller: 'TabsetController',\n      templateUrl: 'template/tabs/tabset.html',\n      link: function(scope, element, attrs) {\n\n        if (!$tabsSuppressWarning) {\n          $log.warn('tabset is now deprecated. Use uib-tabset instead.');\n        }\n        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n      }\n    };\n  }])\n\n  .directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {\n    return {\n      require: '^tabset',\n      restrict: 'EA',\n      replace: true,\n      templateUrl: 'template/tabs/tab.html',\n      transclude: true,\n      scope: {\n        active: '=?',\n        heading: '@',\n        onSelect: '&select', //This callback is called in contentHeadingTransclude\n        //once it inserts the tab's content into the dom\n        onDeselect: '&deselect'\n      },\n      controller: function() {\n        //Empty controller so other directives can require being 'under' a tab\n      },\n      link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n        if (!$tabsSuppressWarning) {\n          $log.warn('tab is now deprecated. Use uib-tab instead.');\n        }\n\n        scope.$watch('active', function(active) {\n          if (active) {\n            tabsetCtrl.select(scope);\n          }\n        });\n\n        scope.disabled = false;\n        if (attrs.disable) {\n          scope.$parent.$watch($parse(attrs.disable), function(value) {\n            scope.disabled = !!value;\n          });\n        }\n\n        scope.select = function() {\n          if (!scope.disabled) {\n            scope.active = true;\n          }\n        };\n\n        tabsetCtrl.addTab(scope);\n        scope.$on('$destroy', function() {\n          tabsetCtrl.removeTab(scope);\n        });\n\n        //We need to transclude later, once the content container is ready.\n        //when this link happens, we're inside a tab heading.\n        scope.$transcludeFn = transclude;\n      }\n    };\n  }])\n\n  .directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: 'A',\n      require: '^tab',\n      link: function(scope, elm) {\n        if (!$tabsSuppressWarning) {\n          $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');\n        }\n\n        scope.$watch('headingElement', function updateHeadingElement(heading) {\n          if (heading) {\n            elm.html('');\n            elm.append(heading);\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: 'A',\n      require: '^tabset',\n      link: function(scope, elm, attrs) {\n        if (!$tabsSuppressWarning) {\n          $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');\n        }\n\n        var tab = scope.$eval(attrs.tabContentTransclude);\n\n        //Now our tab is ready to be transcluded: both the tab heading area\n        //and the tab content area are loaded.  Transclude 'em both.\n        tab.$transcludeFn(tab.$parent, function(contents) {\n          angular.forEach(contents, function(node) {\n            if (isTabHeading(node)) {\n              //Let tabHeadingTransclude know.\n              tab.headingElement = node;\n            }\n            else {\n              elm.append(node);\n            }\n          });\n        });\n      }\n    };\n\n    function isTabHeading(node) {\n      return node.tagName && (\n          node.hasAttribute('tab-heading') ||\n          node.hasAttribute('data-tab-heading') ||\n          node.hasAttribute('x-tab-heading') ||\n          node.tagName.toLowerCase() === 'tab-heading' ||\n          node.tagName.toLowerCase() === 'data-tab-heading' ||\n          node.tagName.toLowerCase() === 'x-tab-heading'\n        );\n    }\n  }]);\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('uibTimepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  showMeridian: true,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true,\n  arrowkeys: true,\n  showSpinners: true\n})\n\n.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var selected = new Date(),\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n  $element.removeAttr('tabindex');\n\n  this.init = function(ngModelCtrl_, inputs) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\n      return modelValue ? new Date(modelValue) : null;\n    });\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1);\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n    if (mousewheel) {\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);\n    }\n\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n    if (arrowkeys) {\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents(hoursInputEl, minutesInputEl);\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = parseInt(value, 10);\n    });\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = parseInt(value, 10);\n    });\n  }\n\n  var min;\n  $scope.$parent.$watch($parse($attrs.min), function(value) {\n    var dt = new Date(value);\n    min = isNaN(dt) ? undefined : dt;\n  });\n\n  var max;\n  $scope.$parent.$watch($parse($attrs.max), function(value) {\n    var dt = new Date(value);\n    max = isNaN(dt) ? undefined : dt;\n  });\n\n  $scope.noIncrementHours = function() {\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\n    return incrementedSelected > max ||\n      (incrementedSelected < selected && incrementedSelected < min);\n  };\n\n  $scope.noDecrementHours = function() {\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n    return decrementedSelected < min ||\n      (decrementedSelected > selected && decrementedSelected > max);\n  };\n\n  $scope.noIncrementMinutes = function() {\n    var incrementedSelected = addMinutes(selected, minuteStep);\n    return incrementedSelected > max ||\n      (incrementedSelected < selected && incrementedSelected < min);\n  };\n\n  $scope.noDecrementMinutes = function() {\n    var decrementedSelected = addMinutes(selected, -minuteStep);\n    return decrementedSelected < min ||\n      (decrementedSelected > selected && decrementedSelected > max);\n  };\n\n  $scope.noToggleMeridian = function() {\n    if (selected.getHours() < 13) {\n      return addMinutes(selected, 12 * 60) > max;\n    } else {\n      return addMinutes(selected, -12 * 60) < min;\n    }\n  };\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if (ngModelCtrl.$error.time) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n          selected.setHours(hours);\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    });\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate() {\n    var hours = parseInt($scope.hours, 10);\n    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n    if (!valid) {\n      return undefined;\n    }\n\n    if ($scope.showMeridian) {\n      if (hours === 12) {\n        hours = 0;\n      }\n      if ($scope.meridian === meridians[1]) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = parseInt($scope.minutes, 10);\n    return (minutes >= 0 && minutes < 60) ? minutes : undefined;\n  }\n\n  function pad(value) {\n    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n      return (e.detail || delta > 0);\n    };\n\n    hoursInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n      e.preventDefault();\n    });\n\n    minutesInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n      e.preventDefault();\n    });\n\n  };\n\n  // Respond on up/down arrowkeys\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {\n    hoursInputEl.bind('keydown', function(e) {\n      if (e.which === 38) { // up\n        e.preventDefault();\n        $scope.incrementHours();\n        $scope.$apply();\n      } else if (e.which === 40) { // down\n        e.preventDefault();\n        $scope.decrementHours();\n        $scope.$apply();\n      }\n    });\n\n    minutesInputEl.bind('keydown', function(e) {\n      if (e.which === 38) { // up\n        e.preventDefault();\n        $scope.incrementMinutes();\n        $scope.$apply();\n      } else if (e.which === 40) { // down\n        e.preventDefault();\n        $scope.decrementMinutes();\n        $scope.$apply();\n      }\n    });\n  };\n\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {\n    if ($scope.readonlyInput) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes) {\n      ngModelCtrl.$setViewValue(null);\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n      }\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate(),\n        minutes = getMinutesFromTemplate();\n\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n        selected.setHours(hours);\n        if (selected < min || selected > max) {\n          invalidate(true);\n        } else {\n          refresh('h');\n        }\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.bind('blur', function(e) {\n      if (!$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply(function() {\n          $scope.hours = pad($scope.hours);\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(undefined, true);\n        } else {\n          refresh('m');\n        }\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.bind('blur', function(e) {\n      if (!$scope.invalidMinutes && $scope.minutes < 10) {\n        $scope.$apply(function() {\n          $scope.minutes = pad($scope.minutes);\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$viewValue;\n\n    if (isNaN(date)) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if (date) {\n        selected = date;\n      }\n\n      if (selected < min || selected > max) {\n        ngModelCtrl.$setValidity('time', false);\n        $scope.invalidHours = true;\n        $scope.invalidMinutes = true;\n      } else {\n        makeValid();\n      }\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh(keyboardChange) {\n    makeValid();\n    ngModelCtrl.$setViewValue(new Date(selected));\n    updateTemplate(keyboardChange);\n  }\n\n  function makeValid() {\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n  }\n\n  function updateTemplate(keyboardChange) {\n    var hours = selected.getHours(), minutes = selected.getMinutes();\n\n    if ($scope.showMeridian) {\n      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system\n    }\n\n    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n    if (keyboardChange !== 'm') {\n      $scope.minutes = pad(minutes);\n    }\n    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n  }\n\n  function addMinutes(date, minutes) {\n    var dt = new Date(date.getTime() + minutes * 60000);\n    var newDate = new Date(date);\n    newDate.setHours(dt.getHours(), dt.getMinutes());\n    return newDate;\n  }\n\n  function addMinutesToSelected(minutes) {\n    selected = addMinutes(selected, minutes);\n    refresh();\n  }\n\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\n  $scope.incrementHours = function() {\n    if (!$scope.noIncrementHours()) {\n      addMinutesToSelected(hourStep * 60);\n    }\n  };\n\n  $scope.decrementHours = function() {\n    if (!$scope.noDecrementHours()) {\n      addMinutesToSelected(-hourStep * 60);\n    }\n  };\n\n  $scope.incrementMinutes = function() {\n    if (!$scope.noIncrementMinutes()) {\n      addMinutesToSelected(minuteStep);\n    }\n  };\n\n  $scope.decrementMinutes = function() {\n    if (!$scope.noDecrementMinutes()) {\n      addMinutesToSelected(-minuteStep);\n    }\n  };\n\n  $scope.toggleMeridian = function() {\n    if (!$scope.noToggleMeridian()) {\n      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));\n    }\n  };\n}])\n\n.directive('uibTimepicker', function() {\n  return {\n    restrict: 'EA',\n    require: ['uibTimepicker', '?^ngModel'],\n    controller: 'UibTimepickerController',\n    controllerAs: 'timepicker',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n});\n\n/* Deprecated timepicker below */\n\nangular.module('ui.bootstrap.timepicker')\n\n.value('$timepickerSuppressWarning', false)\n\n.controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {\n  if (!$timepickerSuppressWarning) {\n    $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');\n  }\n\n  angular.extend(this, $controller('UibTimepickerController', {\n    $scope: $scope,\n    $element: $element,\n    $attrs: $attrs\n  }));\n}])\n\n.directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {\n  return {\n    restrict: 'EA',\n    require: ['timepicker', '?^ngModel'],\n    controller: 'TimepickerController',\n    controllerAs: 'timepicker',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      if (!$timepickerSuppressWarning) {\n        $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');\n      }\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n    return {\n      parse: function(input) {\n        var match = input.match(TYPEAHEAD_REGEXP);\n        if (!match) {\n          throw new Error(\n            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n              ' but got \"' + input + '\".');\n        }\n\n        return {\n          itemName: match[3],\n          source: $parse(match[4]),\n          viewMapper: $parse(match[2] || match[1]),\n          modelMapper: $parse(match[1])\n        };\n      }\n    };\n  }])\n\n  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser',\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    var modelCtrl, ngModelOptions;\n    //SUPPORTED ATTRIBUTES (OPTIONS)\n\n    //minimal no of characters that needs to be entered before typeahead kicks-in\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n    if (!minLength && minLength !== 0) {\n      minLength = 1;\n    }\n\n    //minimal wait time after last character typed before typeahead kicks-in\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n    //should it restrict model values to the ones selected from the popup only?\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n    //binding to a variable that indicates if matches are being retrieved asynchronously\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n    //a callback executed when a match is selected\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n    //should it select highlighted popup value when losing focus?\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n    //binding to a variable that indicates if there were no results after the query is completed\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n    var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n    //If input matches an item of the list exactly, select it automatically\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n    //INTERNAL VARIABLES\n\n    //model setter executed upon match selection\n    var parsedModel = $parse(attrs.ngModel);\n    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n    var $setModelValue = function(scope, newValue) {\n      if (angular.isFunction(parsedModel(originalScope)) &&\n        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n        return invokeModelSetter(scope, {$$$p: newValue});\n      } else {\n        return parsedModel.assign(scope, newValue);\n      }\n    };\n\n    //expressions used by typeahead\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\n    var hasFocus;\n\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n    //mousedown & mouseup events\n    //Issue #3699\n    var selected;\n\n    //create a child scope for the typeahead directive so we are not polluting original scope\n    //with typeahead-specific data (matches, query etc.)\n    var scope = originalScope.$new();\n    var offDestroy = originalScope.$on('$destroy', function() {\n      scope.$destroy();\n    });\n    scope.$on('$destroy', offDestroy);\n\n    // WAI-ARIA\n    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n    element.attr({\n      'aria-autocomplete': 'list',\n      'aria-expanded': false,\n      'aria-owns': popupId\n    });\n\n    //pop-up element used to display matches\n    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n    popUpEl.attr({\n      id: popupId,\n      matches: 'matches',\n      active: 'activeIdx',\n      select: 'select(activeIdx)',\n      'move-in-progress': 'moveInProgress',\n      query: 'query',\n      position: 'position'\n    });\n    //custom item template\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n    }\n\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n    }\n\n    var resetMatches = function() {\n      scope.matches = [];\n      scope.activeIdx = -1;\n      element.attr('aria-expanded', false);\n    };\n\n    var getMatchId = function(index) {\n      return popupId + '-option-' + index;\n    };\n\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n    // This attribute is added or removed automatically when the `activeIdx` changes.\n    scope.$watch('activeIdx', function(index) {\n      if (index < 0) {\n        element.removeAttr('aria-activedescendant');\n      } else {\n        element.attr('aria-activedescendant', getMatchId(index));\n      }\n    });\n\n    var inputIsExactMatch = function(inputValue, index) {\n      if (scope.matches.length > index && inputValue) {\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n      }\n\n      return false;\n    };\n\n    var getMatchesAsync = function(inputValue) {\n      var locals = {$viewValue: inputValue};\n      isLoadingSetter(originalScope, true);\n      isNoResultsSetter(originalScope, false);\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n        //it might happen that several async queries were in progress if a user were typing fast\n        //but we are interested only in responses that correspond to the current view value\n        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n        if (onCurrentRequest && hasFocus) {\n          if (matches && matches.length > 0) {\n            scope.activeIdx = focusFirst ? 0 : -1;\n            isNoResultsSetter(originalScope, false);\n            scope.matches.length = 0;\n\n            //transform labels\n            for (var i = 0; i < matches.length; i++) {\n              locals[parserResult.itemName] = matches[i];\n              scope.matches.push({\n                id: getMatchId(i),\n                label: parserResult.viewMapper(scope, locals),\n                model: matches[i]\n              });\n            }\n\n            scope.query = inputValue;\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n            //due to other elements being rendered\n            recalculatePosition();\n\n            element.attr('aria-expanded', true);\n\n            //Select the single remaining option if user input matches\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n              scope.select(0);\n            }\n          } else {\n            resetMatches();\n            isNoResultsSetter(originalScope, true);\n          }\n        }\n        if (onCurrentRequest) {\n          isLoadingSetter(originalScope, false);\n        }\n      }, function() {\n        resetMatches();\n        isLoadingSetter(originalScope, false);\n        isNoResultsSetter(originalScope, true);\n      });\n    };\n\n    // bind events only if appendToBody params exist - performance feature\n    if (appendToBody) {\n      angular.element($window).bind('resize', fireRecalculating);\n      $document.find('body').bind('scroll', fireRecalculating);\n    }\n\n    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutEventPromise;\n\n    // Default progress type\n    scope.moveInProgress = false;\n\n    function fireRecalculating() {\n      if (!scope.moveInProgress) {\n        scope.moveInProgress = true;\n        scope.$digest();\n      }\n\n      // Cancel previous timeout\n      if (timeoutEventPromise) {\n        $timeout.cancel(timeoutEventPromise);\n      }\n\n      // Debounced executing recalculate after events fired\n      timeoutEventPromise = $timeout(function() {\n        // if popup is visible\n        if (scope.matches.length) {\n          recalculatePosition();\n        }\n\n        scope.moveInProgress = false;\n      }, eventDebounceTime);\n    }\n\n    // recalculate actual position and set new values to scope\n    // after digest loop is popup in right position\n    function recalculatePosition() {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top += element.prop('offsetHeight');\n    }\n\n    //we need to propagate user's query so we can higlight matches\n    scope.query = undefined;\n\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutPromise;\n\n    var scheduleSearchWithTimeout = function(inputValue) {\n      timeoutPromise = $timeout(function() {\n        getMatchesAsync(inputValue);\n      }, waitTime);\n    };\n\n    var cancelPreviousTimeout = function() {\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n    };\n\n    resetMatches();\n\n    scope.select = function(activeIdx) {\n      //called from within the $digest() cycle\n      var locals = {};\n      var model, item;\n\n      selected = true;\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n      model = parserResult.modelMapper(originalScope, locals);\n      $setModelValue(originalScope, model);\n      modelCtrl.$setValidity('editable', true);\n      modelCtrl.$setValidity('parse', true);\n\n      onSelectCallback(originalScope, {\n        $item: item,\n        $model: model,\n        $label: parserResult.viewMapper(originalScope, locals)\n      });\n\n      resetMatches();\n\n      //return focus to the input element if a match was selected via a mouse click event\n      // use timeout to avoid $rootScope:inprog error\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n        $timeout(function() { element[0].focus(); }, 0, false);\n      }\n    };\n\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n    element.bind('keydown', function(evt) {\n      //typeahead is open and an \"interesting\" key was pressed\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n        return;\n      }\n\n      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n        resetMatches();\n        scope.$digest();\n        return;\n      }\n\n      evt.preventDefault();\n\n      if (evt.which === 40) {\n        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n        scope.$digest();\n      } else if (evt.which === 38) {\n        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n        scope.$digest();\n      } else if (evt.which === 13 || evt.which === 9) {\n        scope.$apply(function () {\n          scope.select(scope.activeIdx);\n        });\n      } else if (evt.which === 27) {\n        evt.stopPropagation();\n\n        resetMatches();\n        scope.$digest();\n      }\n    });\n\n    element.bind('blur', function() {\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n        selected = true;\n        scope.$apply(function() {\n          scope.select(scope.activeIdx);\n        });\n      }\n      hasFocus = false;\n      selected = false;\n    });\n\n    // Keep reference to click handler to unbind it.\n    var dismissClickHandler = function(evt) {\n      // Issue #3973\n      // Firefox treats right click as a click on document\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n        resetMatches();\n        if (!$rootScope.$$phase) {\n          scope.$digest();\n        }\n      }\n    };\n\n    $document.bind('click', dismissClickHandler);\n\n    originalScope.$on('$destroy', function() {\n      $document.unbind('click', dismissClickHandler);\n      if (appendToBody || appendToElementId) {\n        $popup.remove();\n      }\n\n      if (appendToBody) {\n        angular.element($window).unbind('resize', fireRecalculating);\n        $document.find('body').unbind('scroll', fireRecalculating);\n      }\n      // Prevent jQuery cache memory leak\n      popUpEl.remove();\n    });\n\n    var $popup = $compile(popUpEl)(scope);\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else if (appendToElementId !== false) {\n      angular.element($document[0].getElementById(appendToElementId)).append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    this.init = function(_modelCtrl, _ngModelOptions) {\n      modelCtrl = _modelCtrl;\n      ngModelOptions = _ngModelOptions;\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function(inputValue) {\n        hasFocus = true;\n\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        } else {\n          if (!inputValue) {\n            // Reset in case user had typed something previously.\n            modelCtrl.$setValidity('editable', true);\n            return null;\n          } else {\n            modelCtrl.$setValidity('editable', false);\n            return undefined;\n          }\n        }\n      });\n\n      modelCtrl.$formatters.push(function(modelValue) {\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        // The validity may be set to false via $parsers (see above) if\n        // the model is restricted to selected values. If the model\n        // is set manually it is considered to be valid.\n        if (!isEditable) {\n          modelCtrl.$setValidity('editable', true);\n        }\n\n        if (inputFormatter) {\n          locals.$model = modelValue;\n          return inputFormatter(originalScope, locals);\n        } else {\n          //it might happen that we don't have enough info to properly render input value\n          //we need to check for this situation and simply return model value if we can't apply custom formatting\n          locals[parserResult.itemName] = modelValue;\n          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n          locals[parserResult.itemName] = undefined;\n          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n        }\n      });\n    };\n  }])\n\n  .directive('uibTypeahead', function() {\n    return {\n      controller: 'UibTypeaheadController',\n      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n      link: function(originalScope, element, attrs, ctrls) {\n        ctrls[2].init(ctrls[0], ctrls[1]);\n      }\n    };\n  })\n\n  .directive('uibTypeaheadPopup', function() {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  })\n\n  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n    return {\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link:function(scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          $compile(tplContent.trim())(scope, function(clonedElement) {\n            element.replaceWith(clonedElement);\n          });\n        });\n      }\n    };\n  }])\n\n  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n      return matchItem;\n    };\n  }]);\n\n/* Deprecated typeahead below */\n  \nangular.module('ui.bootstrap.typeahead')\n  .value('$typeaheadSuppressWarning', false)\n  .service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {\n    if (!$typeaheadSuppressWarning) {\n      $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');\n    }\n\n    return uibTypeaheadParser;\n  }])\n\n  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning',\n    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    return {\n      require: ['ngModel', '^?ngModelOptions'],\n      link: function(originalScope, element, attrs, ctrls) {\n        if (!$typeaheadSuppressWarning) {\n          $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');\n        }\n        var modelCtrl = ctrls[0];\n        var ngModelOptions = ctrls[1];\n        //SUPPORTED ATTRIBUTES (OPTIONS)\n\n        //minimal no of characters that needs to be entered before typeahead kicks-in\n        var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n        if (!minLength && minLength !== 0) {\n          minLength = 1;\n        }\n\n        //minimal wait time after last character typed before typeahead kicks-in\n        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n        //should it restrict model values to the ones selected from the popup only?\n        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n        //binding to a variable that indicates if matches are being retrieved asynchronously\n        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n        //a callback executed when a match is selected\n        var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n        //should it select highlighted popup value when losing focus?\n        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n        //binding to a variable that indicates if there were no results after the query is completed\n        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n        var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\n        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n        //If input matches an item of the list exactly, select it automatically\n        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n        //INTERNAL VARIABLES\n\n        //model setter executed upon match selection\n        var parsedModel = $parse(attrs.ngModel);\n        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n        var $setModelValue = function(scope, newValue) {\n          if (angular.isFunction(parsedModel(originalScope)) &&\n            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n            return invokeModelSetter(scope, {$$$p: newValue});\n          } else {\n            return parsedModel.assign(scope, newValue);\n          }\n        };\n\n        //expressions used by typeahead\n        var parserResult = typeaheadParser.parse(attrs.typeahead);\n\n        var hasFocus;\n\n        //Used to avoid bug in iOS webview where iOS keyboard does not fire\n        //mousedown & mouseup events\n        //Issue #3699\n        var selected;\n\n        //create a child scope for the typeahead directive so we are not polluting original scope\n        //with typeahead-specific data (matches, query etc.)\n        var scope = originalScope.$new();\n        var offDestroy = originalScope.$on('$destroy', function() {\n\t\t\t    scope.$destroy();\n        });\n        scope.$on('$destroy', offDestroy);\n\n        // WAI-ARIA\n        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n        element.attr({\n          'aria-autocomplete': 'list',\n          'aria-expanded': false,\n          'aria-owns': popupId\n        });\n\n        //pop-up element used to display matches\n        var popUpEl = angular.element('<div typeahead-popup></div>');\n        popUpEl.attr({\n          id: popupId,\n          matches: 'matches',\n          active: 'activeIdx',\n          select: 'select(activeIdx)',\n          'move-in-progress': 'moveInProgress',\n          query: 'query',\n          position: 'position'\n        });\n        //custom item template\n        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n        }\n\n        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n        }\n\n        var resetMatches = function() {\n          scope.matches = [];\n          scope.activeIdx = -1;\n          element.attr('aria-expanded', false);\n        };\n\n        var getMatchId = function(index) {\n          return popupId + '-option-' + index;\n        };\n\n        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n        // This attribute is added or removed automatically when the `activeIdx` changes.\n        scope.$watch('activeIdx', function(index) {\n          if (index < 0) {\n            element.removeAttr('aria-activedescendant');\n          } else {\n            element.attr('aria-activedescendant', getMatchId(index));\n          }\n        });\n\n        var inputIsExactMatch = function(inputValue, index) {\n          if (scope.matches.length > index && inputValue) {\n            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n          }\n\n          return false;\n        };\n\n        var getMatchesAsync = function(inputValue) {\n          var locals = {$viewValue: inputValue};\n          isLoadingSetter(originalScope, true);\n          isNoResultsSetter(originalScope, false);\n          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n            //it might happen that several async queries were in progress if a user were typing fast\n            //but we are interested only in responses that correspond to the current view value\n            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n            if (onCurrentRequest && hasFocus) {\n              if (matches && matches.length > 0) {\n                scope.activeIdx = focusFirst ? 0 : -1;\n                isNoResultsSetter(originalScope, false);\n                scope.matches.length = 0;\n\n                //transform labels\n                for (var i = 0; i < matches.length; i++) {\n                  locals[parserResult.itemName] = matches[i];\n                  scope.matches.push({\n                    id: getMatchId(i),\n                    label: parserResult.viewMapper(scope, locals),\n                    model: matches[i]\n                  });\n                }\n\n                scope.query = inputValue;\n                //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n                //due to other elements being rendered\n                recalculatePosition();\n\n                element.attr('aria-expanded', true);\n\n                //Select the single remaining option if user input matches\n                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n                  scope.select(0);\n                }\n              } else {\n                resetMatches();\n                isNoResultsSetter(originalScope, true);\n              }\n            }\n            if (onCurrentRequest) {\n              isLoadingSetter(originalScope, false);\n            }\n          }, function() {\n            resetMatches();\n            isLoadingSetter(originalScope, false);\n            isNoResultsSetter(originalScope, true);\n          });\n        };\n\n        // bind events only if appendToBody params exist - performance feature\n        if (appendToBody) {\n          angular.element($window).bind('resize', fireRecalculating);\n          $document.find('body').bind('scroll', fireRecalculating);\n        }\n\n        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n        var timeoutEventPromise;\n\n        // Default progress type\n        scope.moveInProgress = false;\n\n        function fireRecalculating() {\n          if (!scope.moveInProgress) {\n            scope.moveInProgress = true;\n            scope.$digest();\n          }\n\n          // Cancel previous timeout\n          if (timeoutEventPromise) {\n            $timeout.cancel(timeoutEventPromise);\n          }\n\n          // Debounced executing recalculate after events fired\n          timeoutEventPromise = $timeout(function() {\n            // if popup is visible\n            if (scope.matches.length) {\n              recalculatePosition();\n            }\n\n            scope.moveInProgress = false;\n          }, eventDebounceTime);\n        }\n\n        // recalculate actual position and set new values to scope\n        // after digest loop is popup in right position\n        function recalculatePosition() {\n          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n          scope.position.top += element.prop('offsetHeight');\n        }\n\n        resetMatches();\n\n        //we need to propagate user's query so we can higlight matches\n        scope.query = undefined;\n\n        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n        var timeoutPromise;\n\n        var scheduleSearchWithTimeout = function(inputValue) {\n          timeoutPromise = $timeout(function() {\n            getMatchesAsync(inputValue);\n          }, waitTime);\n        };\n\n        var cancelPreviousTimeout = function() {\n          if (timeoutPromise) {\n            $timeout.cancel(timeoutPromise);\n          }\n        };\n\n        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n        modelCtrl.$parsers.unshift(function(inputValue) {\n          hasFocus = true;\n\n          if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n            if (waitTime > 0) {\n              cancelPreviousTimeout();\n              scheduleSearchWithTimeout(inputValue);\n            } else {\n              getMatchesAsync(inputValue);\n            }\n          } else {\n            isLoadingSetter(originalScope, false);\n            cancelPreviousTimeout();\n            resetMatches();\n          }\n\n          if (isEditable) {\n            return inputValue;\n          } else {\n            if (!inputValue) {\n              // Reset in case user had typed something previously.\n              modelCtrl.$setValidity('editable', true);\n              return null;\n            } else {\n              modelCtrl.$setValidity('editable', false);\n              return undefined;\n            }\n          }\n        });\n\n        modelCtrl.$formatters.push(function(modelValue) {\n          var candidateViewValue, emptyViewValue;\n          var locals = {};\n\n          // The validity may be set to false via $parsers (see above) if\n          // the model is restricted to selected values. If the model\n          // is set manually it is considered to be valid.\n          if (!isEditable) {\n            modelCtrl.$setValidity('editable', true);\n          }\n\n          if (inputFormatter) {\n            locals.$model = modelValue;\n            return inputFormatter(originalScope, locals);\n          } else {\n            //it might happen that we don't have enough info to properly render input value\n            //we need to check for this situation and simply return model value if we can't apply custom formatting\n            locals[parserResult.itemName] = modelValue;\n            candidateViewValue = parserResult.viewMapper(originalScope, locals);\n            locals[parserResult.itemName] = undefined;\n            emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n          }\n        });\n\n        scope.select = function(activeIdx) {\n          //called from within the $digest() cycle\n          var locals = {};\n          var model, item;\n\n          selected = true;\n          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n          model = parserResult.modelMapper(originalScope, locals);\n          $setModelValue(originalScope, model);\n          modelCtrl.$setValidity('editable', true);\n          modelCtrl.$setValidity('parse', true);\n\n          onSelectCallback(originalScope, {\n            $item: item,\n            $model: model,\n            $label: parserResult.viewMapper(originalScope, locals)\n          });\n\n          resetMatches();\n\n          //return focus to the input element if a match was selected via a mouse click event\n          // use timeout to avoid $rootScope:inprog error\n          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n            $timeout(function() { element[0].focus(); }, 0, false);\n          }\n        };\n\n        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n        element.bind('keydown', function(evt) {\n          //typeahead is open and an \"interesting\" key was pressed\n          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n            return;\n          }\n\n          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n            resetMatches();\n            scope.$digest();\n            return;\n          }\n\n          evt.preventDefault();\n\n          if (evt.which === 40) {\n            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n            scope.$digest();\n          } else if (evt.which === 38) {\n            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n            scope.$digest();\n          } else if (evt.which === 13 || evt.which === 9) {\n            scope.$apply(function () {\n              scope.select(scope.activeIdx);\n            });\n          } else if (evt.which === 27) {\n            evt.stopPropagation();\n\n            resetMatches();\n            scope.$digest();\n          }\n        });\n\n        element.bind('blur', function() {\n          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n            selected = true;\n            scope.$apply(function() {\n              scope.select(scope.activeIdx);\n            });\n          }\n          hasFocus = false;\n          selected = false;\n        });\n\n        // Keep reference to click handler to unbind it.\n        var dismissClickHandler = function(evt) {\n          // Issue #3973\n          // Firefox treats right click as a click on document\n          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n            resetMatches();\n            if (!$rootScope.$$phase) {\n              scope.$digest();\n            }\n          }\n        };\n\n        $document.bind('click', dismissClickHandler);\n\n        originalScope.$on('$destroy', function() {\n          $document.unbind('click', dismissClickHandler);\n          if (appendToBody || appendToElementId) {\n            $popup.remove();\n          }\n\n          if (appendToBody) {\n            angular.element($window).unbind('resize', fireRecalculating);\n            $document.find('body').unbind('scroll', fireRecalculating);\n          }\n          // Prevent jQuery cache memory leak\n          popUpEl.remove();\n        });\n\n        var $popup = $compile(popUpEl)(scope);\n\n        if (appendToBody) {\n          $document.find('body').append($popup);\n        } else if (appendToElementId !== false) {\n          angular.element($document[0].getElementById(appendToElementId)).append($popup);\n        } else {\n          element.after($popup);\n        }\n      }\n    };\n  }])\n  \n  .directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        \n        if (!$typeaheadSuppressWarning) {\n          $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');\n        }\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  }])\n  \n  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {\n    return {\n      restrict: 'EA',\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link:function(scope, element, attrs) {\n        if (!$typeaheadSuppressWarning) {\n          $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');\n        }\n\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          $compile(tplContent.trim())(scope, function(clonedElement) {\n            element.replaceWith(clonedElement);\n          });\n        });\n      }\n    };\n  }])\n  \n  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!$typeaheadSuppressWarning) {\n        $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');\n      }\n\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n\n      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n\n      return matchItem;\n    };\n  }]);\n\nangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion-group.html\",\n    \"<div class=\\\"panel {{panelClass || 'panel-default'}}\\\">\\n\" +\n    \"  <div class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n    \"      <a href tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n    \"    </h4>\\n\" +\n    \"  </div>\\n\" +\n    \"  <div class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n    \"\t  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion.html\",\n    \"<div class=\\\"panel-group\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/alert/alert.html\",\n    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n    \"    </button>\\n\" +\n    \"    <div ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/carousel/carousel.html\",\n    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ol>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/carousel/slide.html\",\n    \"<div ng-class=\\\"{\\n\" +\n    \"    'active': active\\n\" +\n    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/datepicker.html\",\n    \"<div ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/day.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default btn-sm\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/month.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" dropdown-nested ng-if=\\\"isOpen\\\" style=\\\"display: block\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"\t<li ng-transclude></li>\\n\" +\n    \"\t<li ng-if=\\\"showButtonBar\\\" style=\\\"padding:10px 9px 2px\\\">\\n\" +\n    \"\t\t<span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-info\\\" ng-click=\\\"select('today')\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"\t\t</span>\\n\" +\n    \"\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n    \"\t</li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/year.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"3\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/backdrop.html\",\n    \"<div uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"     modal-in-class=\\\"in\\\"\\n\" +\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n    \"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/window.html\",\n    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"    modal-in-class=\\\"in\\\"\\n\" +\n    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n    \"    <div class=\\\"modal-dialog\\\" ng-class=\\\"size ? 'modal-' + size : ''\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pagination.html\",\n    \"<ul class=\\\"pagination\\\">\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-html-popup.html\",\n    \"<div\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\n    \"<div\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-template-popup.html\",\n    \"<div\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover-html.html\",\n    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover-template.html\",\n    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\"\\n\" +\n    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover.html\",\n    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/bar.html\",\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n}]);\n\nangular.module(\"template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\">\\n\" +\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tab.html\",\n    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\">\\n\" +\n    \"  <a href ng-click=\\\"select()\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tabset.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n    \"  <div class=\\\"tab-content\\\">\\n\" +\n    \"    <div class=\\\"tab-pane\\\" \\n\" +\n    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/timepicker/timepicker.html\",\n    \"<table>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td>:</td>\\n\" +\n    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-match.html\",\n    \"<a href tabindex=\\\"-1\\\" ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"></a>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" style=\\\"display: block;\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n!angular.$$csp() && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/ui-bootstrap-tpls.js\n ** module id = 31\n ** module chunks = 2\n **/"],"sourceRoot":""}