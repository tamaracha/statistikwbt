{"version":3,"sources":["webpack:///vendors.js","webpack:///webpack/bootstrap af4f9cc29930c1488753","webpack:///external \"angular\"","webpack:///./~/api-check/dist/api-check.js","webpack:///./~/angular-formly/dist/formly.js","webpack:///./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js","webpack:///./~/angular-permission/dist/angular-permission.js","webpack:///./~/angular-ui-bootstrap/index.js","webpack:///./~/angular-ui-router.statehelper/statehelper.js","webpack:///./~/angular-ui-router/release/angular-ui-router.js","webpack:///./~/ngstorage/ngStorage.js","webpack:///./~/oclazyload/dist/ocLazyLoad.js","webpack:///./~/angular-ui-bootstrap/ui-bootstrap-tpls.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift",2,"e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","angular","root","factory","this","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_apiCheck","_apiCheck2","getApiCheckInstance","apiCheck","api","args","output","config","disabled","globalConfig","apiTypes","argTypes","passed","message","failed","checkApiCheckApi","arguments","Array","isArray","prototype","slice","messages","checkEnoughArgs","checkApiWithArgs","returnObject","getTypes","getErrorMessage","checkApiArgs","isArrayOrArgs","Error","prefix","errors","apiCheckApis","handleErrorMessage","getApiCheck","shouldThrow","result","console","warn","getPrefix","onlyPrefix","gOut","trim","getSuffix","s","onlySuffix","suffix","getUrl","u","url","docsBaseUrl","urlSuffix","join","passedAndShouldHavePassed","buildMessageFromApiAndArgs","replaceFunctionWithName","each","val","name","replacedItems","indexOf","displayName","getObjectString","types","stringify","generateMessage","n","useS","keys","newLine","passedArgs","_getTypes","copy","arrayify","map","checker","index","specified","hasOwnProperty","getCheckerDisplay","terse","verbose","addHelpers","arg","getArgDisplay","extraCheckers","apiCheckApiCheck","getApiCheckInstanceCheckers","additionalProperties","throw","utils","apiCheckUtil","wrapper","checkers","getCheckers","checkerIndex","argIndex","res","lastChecker","argName","argFailed","skipPreviousChecker","isOptional","isError","getCheckerErrorMessage","t","checkerTypeType","checkerType","location","apiCheckDataChecker","shape","string","optional","bool","asFunc","func","withProperties","__apiCheckData","asShape","wrongShape","oneOfType","getError","checkerHelp","getCheckerHelp","_ref","help","requiredArgs","filter","a","gottenArgs","hasKeys","getDisplayIfNotGotten","getDisplay","cName","constructor","typeOf","properties","argDisplay","v","k","getApiCheckApis","os","checkerFnChecker","shortType","notOptional","notRequired","strict","objectOf","typeOrArrayOf","any","VERSION","internalChecker","getSerialize","fn","decycle","seen","key","getPath","ret","path","unshift","spaces","JSON","_defineProperty","enumerable","configurable","writable","daCopy","RegExp","options","display","short","getCheckerType","typeTypes","iterator","context","eachArry","eachObj","hasOwn","list","arry","finalJoin","last","pop","stringType","nAtL","tName","tLocation","thing","undef","setupChecker","getNoop","isNoop","prop","getRequiredVersion","notNullable","addNullable","addOptional","requiredChecker","copyProps","originalChecker","optionalCheck","fixType","nullableCheck","isNullable","nullable","checkerCopy","dest","noop","checkerHelpers","typeOfCheckGetter","lType","toLowerCase","funcCheckGetter","functionChecker","apiError","shapeChecker","notFunction","objectCheckGetter","nullType","objectNullOkChecker","objectChecker","nullOk","instanceCheckGetter","classToCheck","oneOfCheckGetter","enums","enum","enm","some","oneOfTypeCheckGetter","typeCheckers","checkersDisplay","arrayOfCheckGetter","shortCheckerDisplay","array","every","item","objectOfCheckGetter","checkerDisplay","notObject","object","allTypesSuccess","typeOrArrayOfCheckGetter","arrayOf","getShapeCheckGetter","shapeCheckGetter","nonObject","modifyTypeDisplayToHelpOut","theRet","required","addHelper","property","objectMessage","stringMessage","error","toUpperCase","parentRequired","strictType","shapeTypes","isObject","shapePropError","shapeError","allowedProperties","extraProps","getRequiredIfNotChecker","all","otherProps","propChecker","props","ifProps","description","getTypeForShapeChild","propName","propExists","iteration","otherPropsExist","otherProp","ifNot","onlyIf","othersPresent","requiredIfNot","argumentsCheckerGetter","number","anyCheckGetter","nullCheckGetter","rangeCheckGetter","min","max","lessThanCheckGetter","greaterThanCheckGetter","emptyObjectCheckGetter","emptyObject","instanceOf","oneOf","range","lessThan","greaterThan","null","_require","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_5__","_indexCommon","_indexCommon2","_angularFix","_angularFix2","_providersFormlyApiCheck","_providersFormlyApiCheck2","_otherDocsBaseUrl","_otherDocsBaseUrl2","_providersFormlyUsability","_providersFormlyUsability2","_providersFormlyConfig","_providersFormlyConfig2","_providersFormlyValidationMessages","_providersFormlyValidationMessages2","_servicesFormlyUtil","_servicesFormlyUtil2","_servicesFormlyWarn","_servicesFormlyWarn2","_directivesFormlyCustomValidation","_directivesFormlyCustomValidation2","_directivesFormlyField","_directivesFormlyField2","_directivesFormlyFocus","_directivesFormlyFocus2","_directivesFormlyForm","_directivesFormlyForm2","_runFormlyNgModelAttrsManipulator","_runFormlyNgModelAttrsManipulator2","_runFormlyCustomTags","_runFormlyCustomTags2","ngModuleName","ngModule","constant","provider","directive","run","version","shapeRequiredIfNot","shapeRequiredIfNotDefinition","formlyExpression","specifyWrapperType","apiCheckProperty","apiCheckInstanceProperty","apiCheckFunctionProperty","formlyWrapperType","template","templateUrl","overwriteOk","apiCheckInstance","apiCheckFunction","apiCheckOptions","expressionProperties","expression","modelChecker","templateManipulators","preWrapper","postWrapper","validatorChecker","fieldOptionsApiShape","$$hashKey","model","originalModel","className","extras","validateOnModelChange","skipNgModelAttrsManipulator","data","templateOptions","modelOptions","updateOn","debounce","allowInvalid","getterSetter","timezone","watcher","listener","validators","asyncValidators","parsers","formatters","noFormControl","hide","hideExpression","ngModelElAttrs","ngModelAttrs","statement","attribute","bound","boolean","elementAttributes","optionsTypes","link","controller","validation","show","errorExistsAndShouldBeVisible","formControl","runExpressions","resetModel","updateInitialValue","initialValue","defaultValue","formlyFieldOptions","formOptionsApi","formState","removeChromeAutoComplete","fieldTransform","fieldGroup","form","typeOptionsDefaultOptions","formlyTypeOptions","defaultOptions","extends","extend","formlyUsability","formlyApiCheck","formlyErrorAndWarningsUrlPrefix","getFieldError","errorInfoSlug","field","toJson","getFormlyError","checkWrapper","checkWrapperTemplate","additionalInfo","formlyTransclude","_this","$get","$inject","_toConsumableArray","arr","arr2","from","formlyConfig","formlyUsabilityProvider","setType","checkType","extendTypeOptions","typeMap","_ret","allTypes","forEach","checkOverwrite","extendsType","getType","extendTypeControllerFunction","extendTypeLinkFunction","extendTypeDefaultOptions","_otherUtils2","reverseDeepMerge","extendTemplate","extendsCtrl","isDefined","optionsCtrl","$scope","$controller","extendsFn","optionsFn","extendsDO","optionsDO","optionsDOIsFn","isFunction","extendsDOIsFn","opts","scope","extendsDefaultOptions","mergedDefaultOptions","extenderOptionsDefaultOptions","newDefaultOptions","throwError","errorContext","getTypeHeritage","parent","heritage","isString","setWrapper","_x","_x2","_again","wrapperOptions","getOptionsTypes","getOptionsName","checkWrapperAPI","templateWrappersMap","defaultWrapperName","checkWrapperTypes","newValue","objectName","getWrapper","getWrapperByType","wrappers","_name","removeWrapperByName","removeWrappersForType","disableWarnings","warnInfoSlug","_this2","disableNgModelAttrsManipulator","ngModelAttrsManipulatorPreferUnbound","defaultHideDirective","getFieldId","_otherUtils","formlyEval","$modelValue","$viewValue","extraLocals","$eval","formId","objAndSameType","obj1","obj2","getPrototypeOf","findByNodeName","el","nodeName","element","children","node","extendFunction","_len","fns","_key","extendArray","primary","secondary","startsWith","str","search","substring","contains","formlyValidationMessages","addTemplateOptionValueMessage","alternate","validationMessages","templateOptionValue","addStringMessage","viewValue","modelValue","formlyUtil","formlyWarn","$log","formlyCustomValidation","restrict","require","attrs","ctrl","addValidatorToPipeline","isAsync","validator","setupMessage","useNewValidatorsApi","setupWithValidators","setupWithParsers","validatorCollection","inFlightValidator","$parsers","isValid","$pending","then","$setValidity","bind","formlyField","$http","$q","$compile","$templateCache","$interpolate","FormlyFieldController","$timeout","$parse","currentValue","valueGetterSetter","setter","assign","promise","when","newVal","parseSet","parseGet","isNumber","simplifyLife","to","formOptions","setFieldIdAndName","formName","$name","setDefaultValue","setInitialValue","mergeFieldOptionsWithTypeDefaults","mergeOptions","properOrder","reverse","typeName","extraOptions","extendOptionsWithDefaults","resetFormControl","isMultiNgModel","$setViewValue","$render","$setUntouched","$setPristine","$root","$$phase","$digest","addValidationMessages","invokeControllers","setupFieldGroup","fieldType","getFieldType","checkApi","fieldLink","formlyFormCtrl","setFieldGroupTemplate","checkFieldGroupApi","addClass","extraAttributes","getTemplate","transcludeInWrappers","setElementTemplate","addAttributes","attr","addClasses","templateString","html","asHtml","contents","watchFormControl","watchFieldNameOrExistence","nameExpressionRegex","nameExpression","exec","watchFieldExistence","$watch","fieldCount","fc","stopWatchingShowError","addShowMessagesWatcher","addParsers","addFormatters","customExpression","errorExistsAndShouldBeVisibleExpression","$invalid","noTouchedButDirty","isUndefined","$touched","$dirty","showError","setParsersOrFormatters","formWasPristine","$pristine","$formatters","formatter","which","getThingsFromType","theType","typeThings","getDefaultOptionsProperty","getThingsFromOptionsTypes","getDefaultOptionsOptionsTypes","optionsTypesThings","optionsTypeName","getFormlyExpressionThing","formlyExpressionParserOrFormatterFunction","originalThingProp","things","ngModelCtrls","ngModelCtrl","_ngModelCtrl","concat","templateEl","ngModelNodes","querySelectorAll","ngModelNode","getAttribute","callLinkFunctions","thusly","runManipulators","manipulators","templateToManipulate","chain","manipulator","newTemplate","fieldManipulators","getManipulators","getFieldTemplate","append","addManipulators","_ref$preWrapper","pre","_ref$postWrapper","post","fromOptionsOrType","isUrl","templatePromise","_ret2","httpOptions","cache","get","response","getWrapperOption","aWrapper","runApiCheck","promises","w","wrappersTemplates","wrapperTemplate","totalWrapper","doTransclusion","superWrapper","transcludeEl","find","replaceWith","typeWrappers","formWrappers","defaultWrapper","_ref2","forType","runApiCheckForType","instance","checkerObjects","checkOptions","transclude","fields","formlyFocus","$document","previousEl","doc","$observe","activeElement","focus","focusWait","blur","formlyForm","formlyFormGetTemplate","getRootEl","rootEl","getFieldRootEl","fieldRootEl","getHideDirective","hideDirective","getTrackBy","trackBy","getFormName","bindName","minor","startSymbol","endSymbol","getTranscludeClass","transcludeClass","copyAttributes","attributes","excluded","arrayAttrs","toKebabCase","currentFormId","parentFormAttributes","hasClass","FormlyFormController","onModelOrFormStateChange","evalCloseToFormlyExpression","validate","$validate","setupFields","checkDeprecatedOptions","fieldTransforms","setupModels","attachKey","setupWatchers","setupOptions","isFieldGroup","watchedModels","isNewModel","initModel","refrencesCurrentlyWatchedModel","watchers","watchExpression","getWatchExpression","watchListener","getWatchListener","stopWatching","watchDeep","originalExpression","modifyArgs","_slice","originalListener","originalArgs","getFormlyFieldLikeLocals","formlyFormLink","setFormController","theFormlyForm","getter","parentForm","$parent","$removeControl","removeData","fixChromeAutocomplete","global","offInstance","onInstance","input","setAttribute","replace","$1","addFormlyNgModelAttrsManipulator","ngModelAttrsManipulator","addValidation","addIfNotPresent","modelNodes","alterNgModelAttr","isPropertyAccessor","addRegardlessOfPresence","addModelOptions","addTemplateOptionsAttrs","ep","ngModelAttributes","getBuiltInAttributes","attrVal","attrName","ref","toVal","epVal","getEpValue","inTo","inEp","addNgModelElAttrs","skip","innerHTML","getNgModelNodes","selectorNot","skipNot","query","getNgModelNodesFallback","allNgModelNodes","matchingNgModelNodes","hasAttribute","nodeMatches","selector","div","outerHTML","querySelector","boundOnly","bothBooleanAndBound","bothAttributeAndBound","statementOnly","attributeOnly","substr","nodes","addCustomTags","isIeLessThan9","customElements","__WEBPACK_EXTERNAL_MODULE_4__","addWrappers","formlyConfigProvider","check","label","labelSrOnly","addCheckboxType","labelProp","valueProp","checkValidity","expressionValue","valid","setModel","multiCheckbox","checked","checkbox","$setTouched","change","newModelValue","newOptionsValues","unwatchFormControl","addInputType","addRadioType","addSelectType","ngOptions","optionsAttr","groupProp","addTextareaType","rows","cols","_addons","_addons2","_description","_description2","addAddonsManipulator","formlyBootstrapApiCheck","addonTemplate","addonChecker","class","text","onClick","addonLeft","addonRight","addDescriptionManipulator","modelEls","$rootScope","Permission","$state","$on","event","toState","toParams","fromState","fromParams","$$finishAuthorize","permissions","log","preventDefault","$broadcast","defaultPrevented","authorize","go","notify","redirectTo","newState","roleValidationConfig","validateRoleDefinitionParams","roleName","validationFunction","validateManyRolesDefinitionParams","roles","defineRole","_promiseify","deferred","defer","resolve","reject","_validateRoleMap","roleMap","only","except","_findMatchingRole","rolesArray","currentRole","roleValidations","validatingRole","defineManyRoles","definedPermissions","resolveIfMatch","rejectIfMatch","authorizing","$stateProvider","fixStateName","state","addSiblings","childState","idx","nextSibling","previousSibling","self","keepOriginalNames","siblingTraversal","setNestedState","inherit","extra","merge","dst","ancestors","first","second","objectKeys","Number","len","Math","ceil","floor","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","j","equalForKeys","b","filterByKeys","values","filtered","pick","omit","collection","$Resolve","$injector","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","$$promises","$$values","study","invocables","visit","visited","cycle","splice","plan","annotate","param","isResolve","invocableKeys","locals","done","wait","merged","$$inheritedValues","resolution","fail","reason","$$failure","invoke","invocable","onfailure","invocation","proceed","waitParams","dep","ii","$TemplateFactory","fromConfig","fromString","fromUrl","templateProvider","fromProvider","headers","Accept","UrlMatcher","pattern","parentMatcher","addParameter","paramNames","test","$$UMFP","Param","quoteRegExp","squash","surroundPattern","matchDetails","isSearch","regexp","segment","cfg","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","lastIndex","sourceSearch","sourcePath","$$paramNames","Type","$UrlMatcherFactory","valToString","toString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","parseInt","date","getFullYear","getMonth","getDate","match","capture","Date","isNaN","valueOf","equals","toISOString","json","fromJson","identity","$$getDefaultValue","strictMode","compile","isMatcher","o","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","ignore","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","handler","$match","$location","$browser","appendBasePath","isHtml5","absolute","baseHref","update","evt","rule","handled","lastPushedUrl","rules","otherwise","listen","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","href","validates","html5Mode","enabled","hashPrefix","slash","port","protocol","host","redirect","handlerIsString","strategies","matcher","regex","sticky","deferIntercept","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","split","pathLength","current","states","queueState","parentName","queue","flushQueuedChildren","queued","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","l","MAX_VALUE","decorator","$view","$resolve","$urlRouter","handleRedirect","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","resolveState","paramsAreFiltered","resolveViews","viewsPromises","views","view","injectables","$template","load","globals","controllerProvider","injectLocals","$$controller","$$state","$$controllerAs","controllerAs","TransitionPrevented","reload","relative","fromPath","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","resolved","entering","exiting","onExit","onEnter","includes","lossy","nav","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","charAt","","abstract","$ViewProvider","$templateFactory","defaults","$ViewScrollProvider","useAnchorScroll","$anchorScroll","$element","scrollIntoView","$ViewDirective","$uiViewScroll","getService","service","has","getRenderer","statics","enter","target","cb","after","leave","remove","$animate","$animator","animate","terminal","priority","tElement","tAttrs","$transclude","cleanupLastView","currentScope","$destroy","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","clone","$emit","autoScrollExp","onloadExp","onload","autoscroll","$ViewDirectiveFill","initial","uiView","inheritedData","parseStateRef","parsed","preparsed","paramExpr","stateContext","stateData","$StateRefDirective","allowedOptions","uiSrefActive","uiSref","hrefKind","newHref","isAnchor","isForm","optionsOverride","uiSrefOpts","option","activeDirective","$$addStateInfo","$set","oldVal","button","ctrlKey","metaKey","shiftKey","ignorePreventDefaultCount","cancel","$StateRefActiveDirective","$attrs","anyMatch","activeClass","removeClass","isMatch","uiSrefActiveEq","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","charCodeAt","isPathParam","isDefaultValue","nextSegment","$subPattern","sub","mode","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_storageProvider","storageType","storageKeyPrefix","setKeyPrefix","TypeError","serializer","deserializer","setSerializer","setDeserializer","d","getItem","set","setItem","$window","isStorageSupported","supported","err","round","random","localStorage","removeItem","_last$storage","_debounce","prefixLength","webStorage","$storage","$default","items","$sync","$reset","$apply","temp$storage","addEventListener","hasFocus","regModules","regInvokes","regConfigs","modulesToLoad","realModules","recordDeclarations","broadcast","runBlocks","justLoaded","ocLazyLoad","$controllerProvider","$provide","$compileProvider","$filterProvider","$animateProvider","_register","providers","registerModules","moduleName","moduleFn","tempRunBlocks","getModuleName","newModule","ngModuleFct","requires","_runBlocks","rerun","_invokeQueue","reconfig","_configBlocks","instanceInjector","getInstanceInjector","_registerInvokeList","checkHashes","potentialNew","invokes","newHash","isNew","signature","hashCode","invokeList","newInvoke","onInvoke","invokeName","callInvoke","fct","invoked","jlen","moduleExists","debug","events","moduleCache","modulePromises","moduleConfig","_init","elements","names","NG_APP_CLASS_REGEXP","elm","getElementById","jasmine","mocha","mock","addReg","mainModule","chr","$rootElement","$cacheFactory","filesCache","eventName","info","_broadcast","_$log","_getFilesCache","toggleWatch","watch","getModuleConfig","setModuleConfig","getModules","isLoaded","modulesNames","moduleLoaded","_getModuleName","_getModule","_loadDependencies","localParams","loadedModule","diff","promisesList","getRequires","requireEntry","files","filesLoader","entry","inject","real","_addToLoadList","loadNext","requireModule","bootstrapFct","bootstrap","force","configFn","$ocLazyLoad","content","$attr","$delegate","$interval","uaCssChecked","useCssLoadPatch","anchor","buildElement","cacheBuster","dc","getTime","put","onerror","serie","insertBeforeElem","lastChild","insertBefore","jQuery","parentNode","ua","navigator","userAgent","platform","appVersion","iOSVersion","parseFloat","androidVersion","versionMatch","tries","interval","sheet","cssRules","cssFiles","templatesFiles","jsFiles","cachePromise","pushFile","file_type","jsLoader","cssDeferred","cssLoader","templatesDeferred","templatesLoader","jsDeferred","originalModule","errText","originalParams","deferredList","paths","ocLazyLoadLoader","success","searchElement","fromIndex","O","abs","Infinity","$animateCss","expand","easing","height","scrollHeight","start","expandDone","css","collapse","collapseDone","uibCollapse","shouldCollapse","$collapseSuppressWarning","closeOthers","accordionConfig","groups","openGroup","group","isOpen","addGroup","groupScope","that","removeGroup","heading","isDisabled","setHeading","accordionCtrl","openClass","panelClass","toggleClass","toggleOpen","$event","accordionGroupCtrl","uibAccordionTransclude","$accordionSuppressWarning","accordionTransclude","closeable","close","dismissOnTimeout","$alertSuppressWarning","toggleEvent","buttonConfig","ctrls","buttonsCtrl","uibBtnRadio","on","isActive","uncheckable","getTrueValue","getCheckboxValue","btnCheckboxTrue","getFalseValue","btnCheckboxFalse","$buttonsSuppressWarning","btnRadio","attributeValue","goNext","slide","direction","destroyed","active","currentSlide","noTransition","$currentTransition","slides","SLIDE_DIRECTION","NEW_ANIMATE","phase","off","one","currentIndex","restartTimer","getSlideByIndex","resetTimer","currentInterval","timerFn","isPlaying","next","pause","resetTransition","NO_TRANSITION","select","nextSlide","nextIndex","indexOfSlide","getCurrentIndex","newIndex","noWrap","prev","$watchCollection","play","noPause","addSlide","removeSlide","sort","actual","carouselCtrl","animation","beforeAddClass","stopped","directionClass","removeClassFn","beforeRemoveClass","$carouselSuppressWarning","$locale","orderByFilter","createParser","formatCodeToRegex","code","year","month","localeId","SPECIAL_CHARACTERS_REGEXP","init","yyyy","yy","y","MMMM","DATETIME_FORMATS","MONTH","MMM","SHORTMONTH","MM","M","dd","EEEE","DAY","EEE","SHORTDAY","HH","hours","hh","H","h","mm","minutes","sss","milliseconds","ss","seconds","AMPMS","parse","baseDate","parser","results","dt","isDate","getHours","getMinutes","getSeconds","getMilliseconds","mapper","setFullYear","$dateParserSuppressWarning","uibDateParser","getStyle","cssprop","currentStyle","getComputedStyle","style","isStaticPositioned","parentOffsetEl","docDomEl","offsetParent","position","elBCR","offset","offsetParentBCR","top","offsetParentEl","clientTop","scrollTop","clientLeft","scrollLeft","boundingClientRect","getBoundingClientRect","width","pageYOffset","documentElement","pageXOffset","positionElements","hostEl","targetEl","positionStr","appendToBody","hostElPos","targetElWidth","targetElHeight","targetElPos","positionStrParts","pos0","pos1","shiftWidth","center","shiftHeight","bottom","$positionSuppressWarning","$uibPosition","formatDay","formatMonth","formatYear","formatDayHeader","formatDayTitle","formatMonthTitle","datepickerMode","minMode","maxMode","showWeeks","startingDay","yearRange","minDate","maxDate","shortcutPropagation","dateFilter","datepickerConfig","$datepickerSuppressError","modes","refreshView","uniqueId","$id","initDate","activeDate","$isEmpty","dateObject","compare","activeDateId","uid","ngModelCtrl_","render","_refreshView","createDateObject","selected","customClass","dateDisabled","size","arrays","move","step","years","months","toggleMode",13,32,33,34,35,36,37,38,39,40,"focusElement","keydown","altKey","stopPropagation","handleKeyDown","getDaysInMonth","DAYS_IN_MONTH","getISO8601WeekNumber","checkDate","setDate","getDay","time","setMonth","getDates","startDate","dates","firstDayOfMonth","difference","numDisplayedFromPreviousMonth","firstDate","days","labels","abbr","full","title","weekNumbers","thursdayIndex","numWeeks","curWeek","date1","date2","getStartingYear","yearpickerInit","datepickerCtrl","daypickerCtrl","monthpickerCtrl","datepickerPopup","datepickerPopupTemplateUrl","datepickerTemplateUrl","html5Types","datetime-local","currentText","clearText","closeText","closeOnDateSelection","showButtonBar","onOpenFocus","$position","dateParser","datepickerPopupConfig","cameltoDash","parseDate","dateFormat","ngRequired","documentClickBind","popup","$popup","dpContainsTarget","popupContainsTarget","inputKeydownBind","popupEl","datepickerEl","ngModel","isHtml5DateInput","watchData","_ngModel_","datepickerAppendToBody","uibDatepickerPopup","oldValue","newDateFormat","ng-model","ng-change","template-url","datepickerOptions","oldvalue","$$parserName","$validators","$viewChangeListeners","unbind","getText","dateSelection","today","setHours","$datepickerSuppressWarning","fixTimeZone","openScope","open","dropdownScope","closeDropdown","keybindFilter","getAutoClose","toggleElement","getToggleElement","dropdownElement","getDropdownElement","focusToggleElement","isKeynavEnabled","focusDropdownEntry","dropdownConfig","uibDropdownService","$templateRequest","templateScope","getIsOpen","setIsOpen","toggleInvoker","onToggle","keynavEnabled","dropdownAppendToBody","uibKeyboardNav","dropdownMenu","toggle","autoClose","getElement","keyCode","elems","eq","selectedOption","wasOpen","pos","rightalign","innerWidth","dropdownMenuTemplateUrl","tplContent","newEl","offDestroy","dropdownCtrl","dropdownNested","tplUrl","toggleDropdown","aria-haspopup","aria-expanded","$dropdownSuppressWarning","createNew","stack","add","removeTop","entries","hasKey","$modalStack","linkFn","modalInClass","NOW_CLOSING_EVENT","setIsAsync","backdropClass","windowClass","windowTopClass","modal","getTop","backdrop","currentTarget","dismiss","$isRendered","modalRenderDeferObj","animationPromise","inputWithAutofocus","modalRendered","modalAnimation","uibModalAnimationClass","empty","$$multiMap","$$stackedMap","backdropIndex","topBackdropIndex","opened","openedWindows","removeModalWindow","modalInstance","elementToReceiveFocus","body","modalWindow","removeAfterAnimate","modalDomEl","modalScope","modalBodyClass","openedClass","OPENED_MODAL_CLASS","openedClasses","toggleTopWindowClass","checkRemoveBackdrop","toggleSwitch","backdropDomEl","backdropScopeRef","backdropScope","domEl","afterAnimating","asyncDeferred","asyncPromise","broadcastClosing","resultOrReason","closing","focusableElementList","focusIndex","tababbleSelector","newBackdropIndex","isDefaultPrevented","keyboard","loadFocusElementList","focusChanged","isFocusInFirstItem","focusLastFocusableElement","isFocusInLastItem","focusFirstFocusableElement","modalOpener","renderDeferred","currBackdropIndex","angularBackgroundDomEl","angularDomEl","windowTemplateUrl","window-class","window-top-class","clearFocusListCache","$$uibDestructionScheduled","dismissAll","topModal","srcElement","modalDomE1","$modalProvider","$modalSuppressWarning","getTemplatePromise","getResolvePromises","resolves","promisesArr","$modal","promiseChain","getPromiseChain","modalOptions","resolveWithTemplate","templateAndResolvePromise","modalResultDeferred","modalOpenedDeferred","modalRenderDeferred","rendered","samePromise","tplAndVars","$close","$dismiss","ctrlInstance","ctrlLocals","resolveIter","$uibModalInstance","bindToController","modalAnimationClass","$uibModalStack","$uibModalProvider","setNumPages","numPages","itemsPerPage","totalPages","calculateTotalPages","page","selectPage","totalItems","clickAllowed","ngDisabled","noPrevious","noNext","boundaryLinks","directionLinks","firstText","previousText","nextText","lastText","rotate","paginationConfig","makePage","getPages","currentPage","pages","startPage","endPage","isMaxSized","maxSize","previousPageSet","nextPageSet","paginationCtrl","originalRender","align","pagerConfig","$paginationSuppressWarning","snake_case","separator","letter","placement","popupDelay","popupCloseDelay","useContentExp","triggerMap","mouseenter","click","none","globalOptions","setTriggers","triggers","openedTooltips","ttType","defaultTriggerShow","getTriggers","trigger","directiveName","startSym","endSym","tElem","tooltipLinker","tooltipCtrl","toggleTooltipBind","ttScope","hideTooltipBind","showTooltipBind","hasEnableExp","cancelHide","prepareTooltip","showTimeout","cancelShow","hideTimeout","createTooltip","$evalAsync","assignIsOpen","positionTooltip","positionTimeout","transitionTimeout","removeTooltip","tooltip","tooltipLinkedScope","prepObservers","unregisterObservers","contentParse","popupClass","delay","closeDelay","isOpenParse","observers","repositionScheduled","$$postDigest","observer","prepTriggers","unregisterTriggers","ttCss","visibility","origScope","contentExp","hideTrigger","removeEventListener","appendToBodyVal","$sce","elem","previousElement","currentElement","tooltipTemplateTranscludeScope","changeCounter","cleanupLastIncludeContent","parseAsResourceUrl","uibTooltipTemplateTransclude","thisChangeId","tooltipAnimationClass","$uibTooltip","originScope","$uibTooltipProvider","$tooltipSuppressWarning","tooltipTemplateTransclude","$tooltip","$popoverSuppressWarning","progressConfig","bars","addBar","bar","recalculatePercentage","totalPercentage","reduce","total","percent","toFixed","removeBar","progressCtrl","$progressSuppressWarning","stateOn","stateOff","titles","ratingConfig","tmpTitles","ratingStates","buildTemplateObjects","getTitle","rate","readonly","onHover","reset","onLeave","onKeydown","ratingCtrl","$ratingSuppressWarning","tabs","selectedTab","tab","onDeselect","selectCalled","onSelect","addTab","removeTab","newActiveIndex","vertical","justified","tabsetCtrl","disable","$transcludeFn","isTabHeading","tagName","uibTabContentTransclude","headingElement","$tabsSuppressWarning","tabContentTransclude","hourStep","minuteStep","showMeridian","meridians","readonlyInput","mousewheel","arrowkeys","showSpinners","timepickerConfig","getHoursFromTemplate","meridian","getMinutesFromTemplate","pad","refresh","keyboardChange","makeValid","updateTemplate","invalidHours","invalidMinutes","addMinutes","newDate","addMinutesToSelected","tabindex","removeAttr","inputs","hoursInputEl","minutesInputEl","setupMousewheelEvents","setupArrowkeyEvents","setupInputEvents","noIncrementHours","incrementedSelected","noDecrementHours","decrementedSelected","noIncrementMinutes","noDecrementMinutes","noToggleMeridian","$error","isScrollingUp","originalEvent","delta","wheelDelta","deltaY","detail","incrementHours","decrementHours","incrementMinutes","decrementMinutes","updateHours","updateMinutes","invalidate","setMinutes","toggleMeridian","timepickerCtrl","$timepickerSuppressWarning","TYPEAHEAD_REGEXP","itemName","viewMapper","modelMapper","originalScope","typeaheadParser","fireRecalculating","moveInProgress","timeoutEventPromise","matches","recalculatePosition","eventDebounceTime","modelCtrl","ngModelOptions","HOT_KEYS","minLength","typeaheadMinLength","waitTime","typeaheadWaitMs","isEditable","typeaheadEditable","isLoadingSetter","typeaheadLoading","onSelectCallback","typeaheadOnSelect","isSelectOnBlur","typeaheadSelectOnBlur","isNoResultsSetter","typeaheadNoResults","inputFormatter","typeaheadInputFormatter","typeaheadAppendToBody","appendToElementId","typeaheadAppendToElementId","focusFirst","typeaheadFocusFirst","selectOnExact","typeaheadSelectOnExact","parsedModel","invokeModelSetter","$setModelValue","$options","$$$p","parserResult","uibTypeahead","popupId","aria-autocomplete","aria-owns","popUpEl","move-in-progress","typeaheadTemplateUrl","typeaheadPopupTemplateUrl","resetMatches","activeIdx","getMatchId","inputIsExactMatch","inputValue","getMatchesAsync","onCurrentRequest","timeoutPromise","scheduleSearchWithTimeout","cancelPreviousTimeout","$item","$model","$label","typeaheadFocusOnSelect","dismissClickHandler","_modelCtrl","_ngModelOptions","candidateViewValue","emptyViewValue","popupTemplateUrl","matchIdx","selectActive","selectMatch","clonedElement","escapeRegexp","queryToEscape","containsHtml","matchItem","isSanitizePresent","trustAsHtml","uibTypeaheadParser","$typeaheadSuppressWarning","typeahead","$$csp","prepend"],"mappings":"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","file":"vendors.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t2:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".app.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(17);\n\t__webpack_require__(16);\n\t__webpack_require__(15);\n\t__webpack_require__(25);\n\t__webpack_require__(4);\n\t__webpack_require__(7);\n\t__webpack_require__(13);\n\t__webpack_require__(14);\n\tmodule.exports = __webpack_require__(24);\n\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = angular;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! api-check version 7.5.5 built with  by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) ( _)==(_ )\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"apiCheck\"] = factory();\n\t\telse\n\t\t\troot[\"apiCheck\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _apiCheck = __webpack_require__(1);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = _apiCheck2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar apiCheckUtil = __webpack_require__(3);\n\t\tvar each = apiCheckUtil.each;\n\t\tvar isError = apiCheckUtil.isError;\n\t\tvar t = apiCheckUtil.t;\n\t\tvar arrayify = apiCheckUtil.arrayify;\n\t\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\t\tvar typeOf = apiCheckUtil.typeOf;\n\t\tvar getError = apiCheckUtil.getError;\n\t\n\t\tvar checkers = __webpack_require__(4);\n\t\tvar apiCheckApis = getApiCheckApis();\n\t\n\t\tmodule.exports = getApiCheckInstance;\n\t\tmodule.exports.VERSION = (\"7.5.5\");\n\t\tmodule.exports.utils = apiCheckUtil;\n\t\tmodule.exports.globalConfig = {\n\t\t  verbose: false,\n\t\t  disabled: false\n\t\t};\n\t\n\t\tvar apiCheckApiCheck = getApiCheckInstance({\n\t\t  output: { prefix: 'apiCheck' }\n\t\t});\n\t\tmodule.exports.internalChecker = apiCheckApiCheck;\n\t\n\t\teach(checkers, function (checker, name) {\n\t\t  return module.exports[name] = checker;\n\t\t});\n\t\n\t\tfunction getApiCheckInstance() {\n\t\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t\t  /* eslint complexity:[2, 6] */\n\t\t  if (apiCheckApiCheck && arguments.length) {\n\t\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t\t      prefix: 'creating an apiCheck instance'\n\t\t    });\n\t\t  }\n\t\n\t\t  var additionalProperties = {\n\t\t    'throw': getApiCheck(true),\n\t\t    warn: getApiCheck(false),\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    handleErrorMessage: handleErrorMessage,\n\t\t    config: {\n\t\t      output: config.output || {\n\t\t        prefix: '',\n\t\t        suffix: '',\n\t\t        docsBaseUrl: ''\n\t\t      },\n\t\t      verbose: config.verbose || false,\n\t\t      disabled: config.disabled || false\n\t\t    },\n\t\t    utils: apiCheckUtil\n\t\t  };\n\t\n\t\t  each(additionalProperties, function (wrapper, name) {\n\t\t    return apiCheck[name] = wrapper;\n\t\t  });\n\t\n\t\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\t  each(extraCheckers, function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\n\t\t  return apiCheck;\n\t\n\t\t  /**\n\t\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t\t   * @param {Array} api - the checkers to check with\n\t\t   * @param {Array} args - the args to check\n\t\t   * @param {Object} output - output options\n\t\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t\t   */\n\t\t  function apiCheck(api, args, output) {\n\t\t    /* eslint complexity:[2, 8] */\n\t\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t\t      return {\n\t\t        apiTypes: {}, argTypes: {},\n\t\t        passed: true, message: '',\n\t\t        failed: false\n\t\t      }; // empty version of what is normally returned\n\t\t    }\n\t\t    checkApiCheckApi(arguments);\n\t\t    if (!Array.isArray(api)) {\n\t\t      api = [api];\n\t\t      args = [args];\n\t\t    } else {\n\t\t      // turn arguments into an array\n\t\t      args = Array.prototype.slice.call(args);\n\t\t    }\n\t\t    var messages = checkEnoughArgs(api, args);\n\t\t    if (!messages.length) {\n\t\t      // this is where we actually go perform the checks.\n\t\t      messages = checkApiWithArgs(api, args);\n\t\t    }\n\t\n\t\t    var returnObject = getTypes(api, args);\n\t\t    returnObject.args = args;\n\t\t    if (messages.length) {\n\t\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t\t      returnObject.failed = true;\n\t\t      returnObject.passed = false;\n\t\t    } else {\n\t\t      returnObject.message = '';\n\t\t      returnObject.failed = false;\n\t\t      returnObject.passed = true;\n\t\t    }\n\t\t    return returnObject;\n\t\t  }\n\t\n\t\t  /**\n\t\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t\t   */\n\t\t  function checkApiCheckApi(checkApiArgs) {\n\t\t    var api = checkApiArgs[0];\n\t\t    var args = checkApiArgs[1];\n\t\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\t\n\t\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t\t    }\n\t\t    // dog fooding here\n\t\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t\t    if (errors.length) {\n\t\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t\t        prefix: 'apiCheck'\n\t\t      });\n\t\t      apiCheck.handleErrorMessage(message, true);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getApiCheck(shouldThrow) {\n\t\t    return function apiCheckWrapper(api, args, output) {\n\t\t      var result = apiCheck(api, args, output);\n\t\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t\t      return result; // wont get here if an error is thrown\n\t\t    };\n\t\t  }\n\t\n\t\t  function handleErrorMessage(message, shouldThrow) {\n\t\t    if (shouldThrow && message) {\n\t\t      throw new Error(message);\n\t\t    } else if (message) {\n\t\t      /* eslint no-console:0 */\n\t\t      console.warn(message);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getErrorMessage(api, args) {\n\t\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t\n\t\t    var gOut = apiCheck.config.output || {};\n\t\t    var prefix = getPrefix();\n\t\t    var suffix = getSuffix();\n\t\t    var url = getUrl();\n\t\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\t\n\t\t    function getPrefix() {\n\t\t      var p = output.onlyPrefix;\n\t\t      if (!p) {\n\t\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t\t      }\n\t\t      return p;\n\t\t    }\n\t\n\t\t    function getSuffix() {\n\t\t      var s = output.onlySuffix;\n\t\t      if (!s) {\n\t\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t\t      }\n\t\t      return s;\n\t\t    }\n\t\n\t\t    function getUrl() {\n\t\t      var u = output.url;\n\t\t      if (!u) {\n\t\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t\t      }\n\t\t      return u;\n\t\t    }\n\t\t  }\n\t\n\t\t  function buildMessageFromApiAndArgs(api, args) {\n\t\t    var _getTypes = getTypes(api, args);\n\t\n\t\t    var apiTypes = _getTypes.apiTypes;\n\t\t    var argTypes = _getTypes.argTypes;\n\t\n\t\t    var copy = Array.prototype.slice.call(args || []);\n\t\t    var replacedItems = [];\n\t\t    replaceFunctionWithName(copy);\n\t\t    var passedArgs = getObjectString(copy);\n\t\t    argTypes = getObjectString(argTypes);\n\t\t    apiTypes = getObjectString(apiTypes);\n\t\n\t\t    return generateMessage();\n\t\n\t\t    // functions\n\t\n\t\t    function replaceFunctionWithName(obj) {\n\t\t      each(obj, function (val, name) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        if (replacedItems.indexOf(val) === -1) {\n\t\t          // avoid recursive problems\n\t\t          replacedItems.push(val);\n\t\t          if (typeof val === 'object') {\n\t\t            replaceFunctionWithName(obj);\n\t\t          } else if (typeof val === 'function') {\n\t\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function getObjectString(types) {\n\t\t      if (!types || !types.length) {\n\t\t        return 'nothing';\n\t\t      } else if (types && types.length === 1) {\n\t\t        types = types[0];\n\t\t      }\n\t\t      return stringify(types, null, 2);\n\t\t    }\n\t\n\t\t    function generateMessage() {\n\t\t      var n = '\\n';\n\t\t      var useS = true;\n\t\t      if (args && args.length === 1) {\n\t\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t\t          useS = !!Object.keys(args[0]).length;\n\t\t        } else {\n\t\t          useS = false;\n\t\t        }\n\t\t      }\n\t\t      var types = 'type' + (useS ? 's' : '');\n\t\t      var newLine = n + n;\n\t\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypes(api, args) {\n\t\t    api = arrayify(api);\n\t\t    args = arrayify(args);\n\t\t    var apiTypes = api.map(function (checker, index) {\n\t\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t\t      return getCheckerDisplay(checker, {\n\t\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t\t        obj: args[index],\n\t\t        addHelpers: true\n\t\t      });\n\t\t    });\n\t\t    var argTypes = args.map(function (arg) {\n\t\t      return getArgDisplay(arg, []);\n\t\t    });\n\t\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t\t  }\n\t\t}\n\t\n\t\t// STATELESS FUNCTIONS\n\t\n\t\t/**\n\t\t * This is where the magic happens for actually checking the arguments with the api.\n\t\t * @param {Array} api - checkers\n\t\t * @param  {Array} args - and arguments object\n\t\t * @returns {Array} - the error messages\n\t\t */\n\t\tfunction checkApiWithArgs(api, args) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var messages = [];\n\t\t  var failed = false;\n\t\t  var checkerIndex = 0;\n\t\t  var argIndex = 0;\n\t\t  var arg = undefined,\n\t\t      checker = undefined,\n\t\t      res = undefined,\n\t\t      lastChecker = undefined,\n\t\t      argName = undefined,\n\t\t      argFailed = undefined,\n\t\t      skipPreviousChecker = undefined;\n\t\t  /* jshint -W084 */\n\t\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t\t    arg = args[argIndex++];\n\t\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t\t    res = checker(arg, 'value', argName);\n\t\t    argFailed = isError(res);\n\t\t    lastChecker = checkerIndex >= api.length;\n\t\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t\t      failed = true;\n\t\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t\t    } else if (argFailed && checker.isOptional) {\n\t\t      argIndex--;\n\t\t    } else {\n\t\t      messages.push(t(argName) + ' passed');\n\t\t    }\n\t\t  }\n\t\t  return failed ? messages : [];\n\t\t}\n\t\n\t\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\t\tfunction checkerTypeType(checkerType, name, location) {\n\t\t  var apiCheckDataChecker = checkers.shape({\n\t\t    type: checkers.string,\n\t\t    optional: checkers.bool\n\t\t  });\n\t\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t\t  if (isError(wrongShape)) {\n\t\t    return wrongShape;\n\t\t  }\n\t\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t\t    return getError(name, location, checkerTypeType.type);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerErrorMessage(res, checker, val) {\n\t\t  var checkerHelp = getCheckerHelp(checker, val);\n\t\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t\t  return res.message + checkerHelp;\n\t\t}\n\t\n\t\tfunction getCheckerHelp(_ref, val) {\n\t\t  var help = _ref.help;\n\t\n\t\t  if (!help) {\n\t\t    return '';\n\t\t  }\n\t\t  if (typeof help === 'function') {\n\t\t    help = help(val);\n\t\t  }\n\t\t  return help;\n\t\t}\n\t\n\t\tfunction checkEnoughArgs(api, args) {\n\t\t  var requiredArgs = api.filter(function (a) {\n\t\t    return !a.isOptional;\n\t\t  });\n\t\t  if (args.length < requiredArgs.length) {\n\t\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t\t  } else {\n\t\t    return [];\n\t\t  }\n\t\t}\n\t\n\t\tfunction getArgDisplay(arg, gottenArgs) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t\t  var type = typeOf(arg);\n\t\t  if (type === 'function') {\n\t\t    if (hasKeys()) {\n\t\t      var properties = stringify(getDisplayIfNotGotten());\n\t\t      return cName + ' (with properties: ' + properties + ')';\n\t\t    }\n\t\t    return cName;\n\t\t  }\n\t\n\t\t  if (arg === null) {\n\t\t    return 'null';\n\t\t  }\n\t\n\t\t  if (type !== 'array' && type !== 'object') {\n\t\t    return type;\n\t\t  }\n\t\n\t\t  if (hasKeys()) {\n\t\t    return getDisplayIfNotGotten();\n\t\t  }\n\t\n\t\t  return cName;\n\t\n\t\t  // utility functions\n\t\t  function hasKeys() {\n\t\t    return arg && Object.keys(arg).length;\n\t\t  }\n\t\n\t\t  function getDisplayIfNotGotten() {\n\t\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t\t      return '[Circular]';\n\t\t    }\n\t\t    gottenArgs.push(arg);\n\t\t    return getDisplay(arg, gottenArgs);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getDisplay(obj, gottenArgs) {\n\t\t  var argDisplay = {};\n\t\t  each(obj, function (v, k) {\n\t\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t\t  });\n\t\t  return argDisplay;\n\t\t}\n\t\n\t\tfunction getApiCheckApis() {\n\t\t  var os = checkers.string.optional;\n\t\n\t\t  var checkerFnChecker = checkers.func.withProperties({\n\t\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t\t    displayName: checkers.string.optional,\n\t\t    shortType: checkers.string.optional,\n\t\t    notOptional: checkers.bool.optional,\n\t\t    notRequired: checkers.bool.optional\n\t\t  });\n\t\n\t\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t\t    output: checkers.shape({\n\t\t      prefix: checkers.string.optional,\n\t\t      suffix: checkers.string.optional,\n\t\t      docsBaseUrl: checkers.string.optional\n\t\t    }).strict.optional,\n\t\t    verbose: checkers.bool.optional,\n\t\t    disabled: checkers.bool.optional\n\t\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\t\n\t\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t\t  }).strict.optional];\n\t\n\t\t  return {\n\t\t    checkerFnChecker: checkerFnChecker,\n\t\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t\t    checkApiCheckApi: checkApiCheckApi\n\t\t  };\n\t\t}\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = stringify;\n\t\n\t\tfunction getSerialize (fn, decycle) {\n\t\t  var seen = [], keys = [];\n\t\t  decycle = decycle || function(key, value) {\n\t\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t\t  };\n\t\t  return function(key, value) {\n\t\t    var ret = value;\n\t\t    if (typeof value === 'object' && value) {\n\t\t      if (seen.indexOf(value) !== -1)\n\t\t        ret = decycle(key, value);\n\t\t      else {\n\t\t        seen.push(value);\n\t\t        keys.push(key);\n\t\t      }\n\t\t    }\n\t\t    if (fn) ret = fn(key, ret);\n\t\t    return ret;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getPath (value, seen, keys) {\n\t\t  var index = seen.indexOf(value);\n\t\t  var path = [ keys[index] ];\n\t\t  for (index--; index >= 0; index--) {\n\t\t    if (seen[index][ path[0] ] === value) {\n\t\t      value = seen[index];\n\t\t      path.unshift(keys[index]);\n\t\t    }\n\t\t  }\n\t\t  return '~' + path.join('.');\n\t\t}\n\t\n\t\tfunction stringify(obj, fn, spaces, decycle) {\n\t\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t\t}\n\t\n\t\tstringify.getSerialize = getSerialize;\n\t\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar checkerHelpers = {\n\t\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t\t};\n\t\n\t\tmodule.exports = {\n\t\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t\t  noop: noop\n\t\t};\n\t\n\t\tfunction copy(obj) {\n\t\t  var type = typeOf(obj);\n\t\t  var daCopy = undefined;\n\t\t  if (type === 'array') {\n\t\t    daCopy = [];\n\t\t  } else if (type === 'object') {\n\t\t    daCopy = {};\n\t\t  } else {\n\t\t    return obj;\n\t\t  }\n\t\t  each(obj, function (val, key) {\n\t\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t\t  });\n\t\t  return daCopy;\n\t\t}\n\t\n\t\tfunction typeOf(obj) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return 'array';\n\t\t  } else if (obj instanceof RegExp) {\n\t\t    return 'object';\n\t\t  } else {\n\t\t    return typeof obj;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerDisplay(checker, options) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var display = undefined;\n\t\t  var short = options && options.short;\n\t\t  if (short && checker.shortType) {\n\t\t    display = checker.shortType;\n\t\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t\t    display = getCheckerType(checker, options);\n\t\t  } else {\n\t\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t\t  }\n\t\t  return display;\n\t\t}\n\t\n\t\tfunction getCheckerType(_ref, options) {\n\t\t  var type = _ref.type;\n\t\n\t\t  if (typeof type === 'function') {\n\t\t    var __apiCheckData = type.__apiCheckData;\n\t\t    var typeTypes = type(options);\n\t\t    type = _defineProperty({\n\t\t      __apiCheckData: __apiCheckData\n\t\t    }, __apiCheckData.type, typeTypes);\n\t\t  }\n\t\t  return type;\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (!obj) {\n\t\t    return [];\n\t\t  } else if (Array.isArray(obj)) {\n\t\t    return obj;\n\t\t  } else {\n\t\t    return [obj];\n\t\t  }\n\t\t}\n\t\n\t\tfunction each(obj, iterator, context) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return eachArry(obj, iterator, context);\n\t\t  } else {\n\t\t    return eachObj(obj, iterator, context);\n\t\t  }\n\t\t}\n\t\n\t\tfunction eachObj(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t\t  for (var key in obj) {\n\t\t    if (hasOwn.call(obj, key)) {\n\t\t      ret = iterator.call(context, obj[key], key, obj);\n\t\t      if (ret === false) {\n\t\t        return ret;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction eachArry(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var length = obj.length;\n\t\t  for (var i = 0; i < length; i++) {\n\t\t    ret = iterator.call(context, obj[i], i, obj);\n\t\t    if (ret === false) {\n\t\t      return ret;\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction isError(obj) {\n\t\t  return obj instanceof Error;\n\t\t}\n\t\n\t\tfunction list(arry, join, finalJoin) {\n\t\t  arry = arrayify(arry);\n\t\t  var copy = arry.slice();\n\t\t  var last = copy.pop();\n\t\t  if (copy.length === 1) {\n\t\t    join = ' ';\n\t\t  }\n\t\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t\t}\n\t\n\t\tfunction getError(name, location, checkerType) {\n\t\t  if (typeof checkerType === 'function') {\n\t\t    checkerType = checkerType({ short: true });\n\t\t  }\n\t\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t\t}\n\t\n\t\tfunction nAtL(name, location) {\n\t\t  var tName = t(name || 'value');\n\t\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t\t  return '' + tName + tLocation;\n\t\t}\n\t\n\t\tfunction t(thing) {\n\t\t  return '`' + thing + '`';\n\t\t}\n\t\n\t\tfunction undef(thing) {\n\t\t  return typeof thing === 'undefined';\n\t\t}\n\t\n\t\t/**\n\t\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t\t * optional version\n\t\t *\n\t\t * @param {Function} checker - the checker to setup with properties\n\t\t * @param {Object} properties - properties to add to the checker\n\t\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t\t * @returns {Function} checker - the setup checker\n\t\t */\n\t\tfunction setupChecker(checker, properties, disabled) {\n\t\t  /* eslint complexity:[2, 9] */\n\t\t  if (disabled) {\n\t\t    // swap out the checker for its own copy of noop\n\t\t    checker = getNoop();\n\t\t    checker.isNoop = true;\n\t\t  }\n\t\n\t\t  if (typeof checker.type === 'string') {\n\t\t    checker.shortType = checker.type;\n\t\t  }\n\t\n\t\t  // assign all properties given\n\t\t  each(properties, function (prop, name) {\n\t\t    return checker[name] = prop;\n\t\t  });\n\t\n\t\t  if (!checker.displayName) {\n\t\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t\t  }\n\t\n\t\t  if (!checker.notRequired) {\n\t\t    checker = getRequiredVersion(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notNullable) {\n\t\t    addNullable(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker, disabled);\n\t\t  }\n\t\n\t\t  return checker;\n\t\t}\n\t\n\t\tfunction getRequiredVersion(checker, disabled) {\n\t\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t\t    if (undef(val) && !checker.isOptional) {\n\t\t      var tLocation = location ? ' in ' + t(location) : '';\n\t\t      var type = getCheckerDisplay(checker, { short: true });\n\t\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t\t    } else {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  copyProps(checker, requiredChecker);\n\t\t  requiredChecker.originalChecker = checker;\n\t\t  return requiredChecker;\n\t\t}\n\t\n\t\tfunction addOptional(checker, disabled) {\n\t\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t\t    if (!undef(val)) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, optionalCheck);\n\t\n\t\t  optionalCheck.isOptional = true;\n\t\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t\t  optionalCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .optional to the end of the checkers\n\t\t  checker.optional = optionalCheck;\n\t\n\t\t  fixType(checker, checker.optional);\n\t\t}\n\t\n\t\tfunction addNullable(checker, disabled) {\n\t\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t\t    if (val !== null) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, nullableCheck);\n\t\n\t\t  nullableCheck.isNullable = true;\n\t\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t\t  nullableCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t\t  checker.nullable = nullableCheck;\n\t\n\t\t  fixType(checker, checker.nullable);\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker.nullable, disabled);\n\t\t  }\n\t\t}\n\t\n\t\tfunction fixType(checker, checkerCopy) {\n\t\t  // fix type, because it's not a straight copy...\n\t\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t\t  // we also want to add \"(optional)\" to the types with a string\n\t\t  if (typeof checkerCopy.type === 'object') {\n\t\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t\t  } else if (typeof checkerCopy.type === 'function') {\n\t\t      checkerCopy.type = function () {\n\t\t        return checker.type.apply(checker, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      checkerCopy.type += ' (optional)';\n\t\t      return;\n\t\t    }\n\t\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t\t  checkerCopy.type.__apiCheckData.optional = true;\n\t\t}\n\t\n\t\t// UTILS\n\t\n\t\tfunction copyProps(src, dest) {\n\t\t  each(Object.keys(src), function (key) {\n\t\t    return dest[key] = src[key];\n\t\t  });\n\t\t}\n\t\n\t\tfunction noop() {}\n\t\n\t\tfunction getNoop() {\n\t\t  /* eslint no-shadow:0 */\n\t\t  /* istanbul ignore next */\n\t\t  return function noop() {};\n\t\t}\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\n\t\tvar _require = __webpack_require__(3);\n\t\n\t\tvar typeOf = _require.typeOf;\n\t\tvar each = _require.each;\n\t\tvar copy = _require.copy;\n\t\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\t\tvar isError = _require.isError;\n\t\tvar arrayify = _require.arrayify;\n\t\tvar list = _require.list;\n\t\tvar getError = _require.getError;\n\t\tvar nAtL = _require.nAtL;\n\t\tvar t = _require.t;\n\t\tvar checkerHelpers = _require.checkerHelpers;\n\t\tvar undef = _require.undef;\n\t\tvar setupChecker = checkerHelpers.setupChecker;\n\t\n\t\tvar checkers = module.exports = getCheckers();\n\t\tmodule.exports.getCheckers = getCheckers;\n\t\n\t\tfunction getCheckers(disabled) {\n\t\t  return {\n\t\t    array: typeOfCheckGetter('Array'),\n\t\t    bool: typeOfCheckGetter('Boolean'),\n\t\t    number: typeOfCheckGetter('Number'),\n\t\t    string: typeOfCheckGetter('String'),\n\t\t    func: funcCheckGetter(),\n\t\t    object: objectCheckGetter(),\n\t\n\t\t    emptyObject: emptyObjectCheckGetter(),\n\t\n\t\t    instanceOf: instanceCheckGetter,\n\t\t    oneOf: oneOfCheckGetter,\n\t\t    oneOfType: oneOfTypeCheckGetter,\n\t\n\t\t    arrayOf: arrayOfCheckGetter,\n\t\t    objectOf: objectOfCheckGetter,\n\t\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\t\n\t\t    range: rangeCheckGetter,\n\t\t    lessThan: lessThanCheckGetter,\n\t\t    greaterThan: greaterThanCheckGetter,\n\t\n\t\t    shape: getShapeCheckGetter(),\n\t\t    args: argumentsCheckerGetter(),\n\t\n\t\t    any: anyCheckGetter(),\n\t\t    'null': nullCheckGetter()\n\t\n\t\t  };\n\t\n\t\t  function typeOfCheckGetter(type) {\n\t\t    var lType = type.toLowerCase();\n\t\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== lType) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function funcCheckGetter() {\n\t\t    var type = 'Function';\n\t\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'function') {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\n\t\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t\t      if (isError(apiError)) {\n\t\t        throw apiError;\n\t\t      }\n\t\t      var shapeChecker = checkers.shape(properties, true);\n\t\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\t\n\t\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t\t        var notFunction = checkers.func(val, name, location);\n\t\t        if (isError(notFunction)) {\n\t\t          return notFunction;\n\t\t        }\n\t\t        return shapeChecker(val, name, location);\n\t\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t\t    };\n\t\t    return functionChecker;\n\t\t  }\n\t\n\t\t  function objectCheckGetter() {\n\t\t    var type = 'Object';\n\t\t    var nullType = 'Object (null ok)';\n\t\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'object') {\n\t\t        return getError(name, location, nullType);\n\t\t      }\n\t\t    }, { type: nullType }, disabled);\n\t\n\t\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t\t        return getError(name, location, objectChecker.type);\n\t\t      }\n\t\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\t\n\t\t    return objectChecker;\n\t\t  }\n\t\n\t\t  function instanceCheckGetter(classToCheck) {\n\t\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t\t      if (!(val instanceof classToCheck)) {\n\t\t        return getError(name, location, classToCheck.name);\n\t\t      }\n\t\t    }, { type: classToCheck.name }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfCheckGetter(enums) {\n\t\t    var type = {\n\t\t      __apiCheckData: { optional: false, type: 'enum' },\n\t\t      'enum': enums\n\t\t    };\n\t\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t\t      return stringify(enm);\n\t\t    }).join(', ') + ']';\n\t\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t\t      if (!enums.some(function (enm) {\n\t\t        return enm === val;\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t\t      return getCheckerDisplay(checker, { short: true });\n\t\t    });\n\t\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return typeCheckers.map(function (checker) {\n\t\t        return getCheckerDisplay(checker, options);\n\t\t      });\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t\t      if (!typeCheckers.some(function (checker) {\n\t\t        return !isError(checker(val, name, location));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function arrayOfCheckGetter(checker) {\n\t\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\t\n\t\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t\t        return !isError(checker(item));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function objectOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\t\n\t\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t\t      var notObject = checkers.object(val, name, location);\n\t\t      if (isError(notObject)) {\n\t\t        return notObject;\n\t\t      }\n\t\t      var allTypesSuccess = each(val, function (item, key) {\n\t\t        if (isError(checker(item, key, name))) {\n\t\t          return false;\n\t\t        }\n\t\t      });\n\t\t      if (!allTypesSuccess) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function typeOrArrayOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\n\t\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function getShapeCheckGetter() {\n\t\t    function shapeCheckGetter(shape, nonObject) {\n\t\t      var shapeTypes = {};\n\t\t      each(shape, function (checker, prop) {\n\t\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t\t      });\n\t\t      function type() {\n\t\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t\t        var ret = {};\n\t\t        var terse = options.terse;\n\t\t        var obj = options.obj;\n\t\t        var addHelpers = options.addHelpers;\n\t\n\t\t        var parentRequired = options.required;\n\t\t        each(shape, function (checker, prop) {\n\t\t          /* eslint complexity:[2, 6] */\n\t\t          var specified = obj && obj.hasOwnProperty(prop);\n\t\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t\t          if (!terse || (specified || !checker.isOptional)) {\n\t\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t\t          }\n\t\t          if (addHelpers) {\n\t\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t\t          }\n\t\t        });\n\t\t        return ret;\n\t\n\t\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t\t          if (!specified && required && !checker.isOptional) {\n\t\t            var item = 'ITEM';\n\t\t            if (checker.type && checker.type.__apiCheckData) {\n\t\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t\t            }\n\t\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t\t          } else if (specified) {\n\t\t            var error = checker(obj[prop], prop, null, obj);\n\t\t            if (isError(error)) {\n\t\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t\t            }\n\t\t          }\n\t\n\t\t          function addHelper(property, objectMessage, stringMessage) {\n\t\t            if (typeof theRet[prop] === 'string') {\n\t\t              theRet[prop] += stringMessage;\n\t\t            } else {\n\t\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\n\t\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t\t        if (isError(isObject)) {\n\t\t          return isObject;\n\t\t        }\n\t\t        var shapePropError = undefined;\n\t\t        location = location ? location + (name ? '/' : '') : '';\n\t\t        name = name || '';\n\t\t        each(shape, function (checker, prop) {\n\t\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t\t            return !isError(shapePropError);\n\t\t          }\n\t\t        });\n\t\t        if (isError(shapePropError)) {\n\t\t          return shapePropError;\n\t\t        }\n\t\t      }, { type: type, shortType: 'shape' }, disabled);\n\t\n\t\t      function strictType() {\n\t\t        return type.apply(undefined, arguments);\n\t\t      }\n\t\n\t\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t\t      strictType.__apiCheckData.strict = true;\n\t\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t\t        var shapeError = shapeChecker(val, name, location);\n\t\t        if (isError(shapeError)) {\n\t\t          return shapeError;\n\t\t        }\n\t\t        var allowedProperties = Object.keys(shape);\n\t\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t\t          return allowedProperties.indexOf(prop) === -1;\n\t\t        });\n\t\t        if (extraProps.length) {\n\t\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t\t        }\n\t\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\t\n\t\t      return shapeChecker;\n\t\t    }\n\t\n\t\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t\t      } else {\n\t\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (propExists === otherPropsExist) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t\t      otherProps = arrayify(otherProps);\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t\t      } else {\n\t\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t\t        var othersPresent = otherProps.every(function (property) {\n\t\t          return obj.hasOwnProperty(property);\n\t\t        });\n\t\t        if (!othersPresent) {\n\t\t          return getError(propName, location, type);\n\t\t        } else {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        throw new Error('requiredIfNot.all must be passed an array');\n\t\t      }\n\t\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t\t      var props = t(otherProps.join(', '));\n\t\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var iteration = all ? 'every' : 'some';\n\t\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (!otherPropsExist && !propExists) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, notRequired: true }, disabled);\n\t\t    }\n\t\n\t\t    return shapeCheckGetter;\n\t\n\t\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t\t      function type(options) {\n\t\t        if (options && options.short) {\n\t\t          return shortType;\n\t\t        }\n\t\t        return getCheckerDisplay(propChecker);\n\t\t      }\n\t\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function argumentsCheckerGetter() {\n\t\t    var type = 'function arguments';\n\t\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function anyCheckGetter() {\n\t\t    return setupChecker(function anyCheckerDefinition() {\n\t\t      // don't do anything\n\t\t    }, { type: 'any' }, disabled);\n\t\t  }\n\t\n\t\t  function nullCheckGetter() {\n\t\t    var type = 'null';\n\t\t    return setupChecker(function nullChecker(val, name, location) {\n\t\t      if (val !== null) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function rangeCheckGetter(min, max) {\n\t\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t\t    return setupChecker(function rangeChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < min || val > max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function lessThanCheckGetter(min) {\n\t\t    var type = 'lessThan[' + min + ']';\n\t\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val > min) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function greaterThanCheckGetter(max) {\n\t\t    var type = 'greaterThan[' + max + ']';\n\t\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function emptyObjectCheckGetter() {\n\t\t    var type = 'empty object';\n\t\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\t}\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 5 */,\n/* 6 */,\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t* angular-formly JavaScript Library v7.3.2\n\t*\n\t* @license MIT (http://license.angular-formly.com)\n\t*\n\t* built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n\t* ( _)==(_ )\n\t*/\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(3), __webpack_require__(4));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _indexCommon = __webpack_require__(1);\n\t\n\t\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\t\n\t\texports['default'] = _indexCommon2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\t\n\t\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\t\n\t\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\t\n\t\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\t\n\t\tvar _providersFormlyUsability = __webpack_require__(7);\n\t\n\t\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\t\n\t\tvar _providersFormlyConfig = __webpack_require__(8);\n\t\n\t\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\t\n\t\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\t\n\t\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\t\n\t\tvar _servicesFormlyUtil = __webpack_require__(11);\n\t\n\t\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\t\n\t\tvar _servicesFormlyWarn = __webpack_require__(12);\n\t\n\t\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\t\n\t\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\t\n\t\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\t\n\t\tvar _directivesFormlyField = __webpack_require__(14);\n\t\n\t\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\t\n\t\tvar _directivesFormlyFocus = __webpack_require__(15);\n\t\n\t\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\t\n\t\tvar _directivesFormlyForm = __webpack_require__(16);\n\t\n\t\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\t\n\t\tvar _runFormlyCustomTags = __webpack_require__(18);\n\t\n\t\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\t\n\t\tvar ngModuleName = 'formly';\n\t\n\t\texports['default'] = ngModuleName;\n\t\n\t\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\t\n\t\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\t\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\t\tngModule.constant('formlyVersion', (\"7.3.2\")); // <-- webpack variable\n\t\n\t\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\t\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\t\n\t\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\t\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\t\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\t\n\t\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\t\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\t\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\t\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\t\n\t\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\t\tngModule.run(_runFormlyCustomTags2['default']);\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar angular = __webpack_require__(3);\n\t\n\t\t/* istanbul ignore next */\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\texports['default'] = angular;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\tvar apiCheck = (0, _apiCheck2['default'])({\n\t\t  output: {\n\t\t    prefix: 'angular-formly:',\n\t\t    docsBaseUrl: __webpack_require__(6)\n\t\t  }\n\t\t});\n\t\n\t\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t\t    otherProps = [otherProps];\n\t\t  }\n\t\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\t\n\t\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t      return obj && obj.hasOwnProperty(otherProp);\n\t\t    });\n\t\t    if (!otherPropsExist && !propExists) {\n\t\t      return apiCheck.utils.getError(propName, location, type);\n\t\t    } else if (propExists) {\n\t\t      return propChecker(prop, propName, location, obj);\n\t\t    }\n\t\t  }\n\t\n\t\t  shapeRequiredIfNotDefinition.type = type;\n\t\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t\t}\n\t\n\t\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\t\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\t\n\t\tvar apiCheckProperty = apiCheck.func;\n\t\n\t\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t\t  warn: apiCheck.func,\n\t\t  'throw': apiCheck.func,\n\t\t  shape: apiCheck.func\n\t\t}));\n\t\n\t\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\t\n\t\tvar formlyWrapperType = apiCheck.shape({\n\t\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  overwriteOk: apiCheck.bool.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\t\n\t\tvar templateManipulators = apiCheck.shape({\n\t\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t\t}).strict.nullable;\n\t\n\t\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar fieldOptionsApiShape = {\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  model: modelChecker.optional,\n\t\t  originalModel: modelChecker.optional,\n\t\t  className: apiCheck.string.optional,\n\t\t  id: apiCheck.string.optional,\n\t\t  name: apiCheck.string.optional,\n\t\t  expressionProperties: expressionProperties.optional,\n\t\t  extras: apiCheck.shape({\n\t\t    validateOnModelChange: apiCheck.bool.optional,\n\t\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t\t  }).strict.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  templateOptions: apiCheck.object.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  modelOptions: apiCheck.shape({\n\t\t    updateOn: apiCheck.string.optional,\n\t\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t\t    allowInvalid: apiCheck.bool.optional,\n\t\t    getterSetter: apiCheck.bool.optional,\n\t\t    timezone: apiCheck.string.optional\n\t\t  }).optional,\n\t\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t\t    expression: formlyExpression.optional,\n\t\t    listener: formlyExpression\n\t\t  })).optional,\n\t\t  validators: validatorChecker.optional,\n\t\t  asyncValidators: validatorChecker.optional,\n\t\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  noFormControl: apiCheck.bool.optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t\t  }).strict).optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t\t  validation: apiCheck.shape({\n\t\t    show: apiCheck.bool.nullable.optional,\n\t\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t\t  }).optional,\n\t\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t\t  value: apiCheck.func.optional,\n\t\t  runExpressions: apiCheck.func.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  initialValue: apiCheck.any.optional,\n\t\t  defaultValue: apiCheck.any.optional\n\t\t};\n\t\n\t\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\t\n\t\tvar formOptionsApi = apiCheck.shape({\n\t\t  formState: apiCheck.object.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t\t  data: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar fieldGroup = apiCheck.shape({\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  // danger. Nested field groups wont get api-checked...\n\t\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t\t  className: apiCheck.string.optional,\n\t\t  options: formOptionsApi.optional,\n\t\t  templateOptions: apiCheck.object.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  model: modelChecker.optional,\n\t\t  form: apiCheck.object.optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t\t}).strict;\n\t\n\t\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\t\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\t\n\t\tvar formlyTypeOptions = apiCheck.shape({\n\t\t  name: apiCheck.string,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t\t  'extends': apiCheck.string.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional,\n\t\t  overwriteOk: apiCheck.bool.optional\n\t\t}).strict;\n\t\n\t\t_angularFix2['default'].extend(apiCheck, {\n\t\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t\t});\n\t\n\t\texports['default'] = apiCheck;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.3.2\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\t\tmodule.exports = exports[\"default\"];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyUsability;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t\t  var _this = this;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    getFormlyError: getFormlyError,\n\t\t    getFieldError: getFieldError,\n\t\t    checkWrapper: checkWrapper,\n\t\t    checkWrapperTemplate: checkWrapperTemplate,\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    $get: function $get() {\n\t\t      return _this;\n\t\t    }\n\t\t  });\n\t\n\t\t  function getFieldError(errorInfoSlug, message, field) {\n\t\t    if (arguments.length < 3) {\n\t\t      field = message;\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t\t  }\n\t\n\t\t  function getFormlyError(errorInfoSlug, message) {\n\t\t    if (!message) {\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t\t  }\n\t\n\t\t  function getErrorMessage(errorInfoSlug, message) {\n\t\t    var url = '';\n\t\t    if (errorInfoSlug !== null) {\n\t\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t\t    }\n\t\t    return 'Formly Error: ' + message + '. ' + url;\n\t\t  }\n\t\n\t\t  function checkWrapper(wrapper) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t\t      prefix: 'formlyConfig.setWrapper',\n\t\t      urlSuffix: 'setwrapper-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function checkWrapperTemplate(template, additionalInfo) {\n\t\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t\t    if (template.indexOf(formlyTransclude) === -1) {\n\t\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyConfig;\n\t\n\t\t// @ngInject\n\t\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t\t  var _this2 = this;\n\t\n\t\t  var typeMap = {};\n\t\t  var templateWrappersMap = {};\n\t\t  var defaultWrapperName = 'default';\n\t\t  var _this = this;\n\t\t  var getError = formlyUsabilityProvider.getFormlyError;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    setType: setType,\n\t\t    getType: getType,\n\t\t    getTypeHeritage: getTypeHeritage,\n\t\t    setWrapper: setWrapper,\n\t\t    getWrapper: getWrapper,\n\t\t    getWrapperByType: getWrapperByType,\n\t\t    removeWrapperByName: removeWrapperByName,\n\t\t    removeWrappersForType: removeWrappersForType,\n\t\t    disableWarnings: false,\n\t\t    extras: {\n\t\t      disableNgModelAttrsManipulator: false,\n\t\t      fieldTransform: [],\n\t\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t\t      removeChromeAutoComplete: false,\n\t\t      defaultHideDirective: 'ng-if',\n\t\t      getFieldId: null\n\t\t    },\n\t\t    templateManipulators: {\n\t\t      preWrapper: [],\n\t\t      postWrapper: []\n\t\t    },\n\t\t    $get: function $get() {\n\t\t      return _this2;\n\t\t    }\n\t\t  });\n\t\n\t\t  function setType(options) {\n\t\t    if (_angularFix2['default'].isArray(options)) {\n\t\t      var _ret = (function () {\n\t\t        var allTypes = [];\n\t\t        _angularFix2['default'].forEach(options, function (item) {\n\t\t          allTypes.push(setType(item));\n\t\t        });\n\t\t        return {\n\t\t          v: allTypes\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret === 'object') return _ret.v;\n\t\t    } else if (_angularFix2['default'].isObject(options)) {\n\t\t      checkType(options);\n\t\t      if (options['extends']) {\n\t\t        extendTypeOptions(options);\n\t\t      }\n\t\t      typeMap[options.name] = options;\n\t\t      return typeMap[options.name];\n\t\t    } else {\n\t\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkType(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t\t      prefix: 'formlyConfig.setType',\n\t\t      url: 'settype-validation-failed'\n\t\t    });\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t\t    } else {\n\t\t      options.overwriteOk = undefined;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeOptions(options) {\n\t\t    var extendsType = getType(options['extends'], true, options);\n\t\t    extendTypeControllerFunction(options, extendsType);\n\t\t    extendTypeLinkFunction(options, extendsType);\n\t\t    extendTypeDefaultOptions(options, extendsType);\n\t\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t\t    extendTemplate(options, extendsType);\n\t\t  }\n\t\n\t\t  function extendTemplate(options, extendsType) {\n\t\t    if (options.template && extendsType.templateUrl) {\n\t\t      delete options.templateUrl;\n\t\t    } else if (options.templateUrl && extendsType.template) {\n\t\t      delete options.template;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeControllerFunction(options, extendsType) {\n\t\t    var extendsCtrl = extendsType.controller;\n\t\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsCtrl = options.controller;\n\t\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t\t      options.controller = function ($scope, $controller) {\n\t\t        $controller(extendsCtrl, { $scope: $scope });\n\t\t        $controller(optionsCtrl, { $scope: $scope });\n\t\t      };\n\t\t      options.controller.$inject = ['$scope', '$controller'];\n\t\t    } else {\n\t\t      options.controller = extendsCtrl;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeLinkFunction(options, extendsType) {\n\t\t    var extendsFn = extendsType.link;\n\t\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsFn = options.link;\n\t\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t\t      options.link = function () {\n\t\t        extendsFn.apply(undefined, arguments);\n\t\t        optionsFn.apply(undefined, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      options.link = extendsFn;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeDefaultOptions(options, extendsType) {\n\t\t    var extendsDO = extendsType.defaultOptions;\n\t\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsDO = options.defaultOptions;\n\t\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t\t    if (extendsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t\t        var mergedDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t\t        var extenderOptionsDefaultOptions = optionsDO;\n\t\t        if (optionsDOIsFn) {\n\t\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t\t        }\n\t\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t\t        return extendsDefaultOptions;\n\t\t      };\n\t\t    } else if (optionsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var newDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t\t        return optionsDO(newDefaultOptions, scope);\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function getType(name, throwError, errorContext) {\n\t\t    if (!name) {\n\t\t      return undefined;\n\t\t    }\n\t\t    var type = typeMap[name];\n\t\t    if (!type && throwError === true) {\n\t\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t\t    } else {\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypeHeritage(parent) {\n\t\t    var heritage = [];\n\t\t    var type = parent;\n\t\t    if (_angularFix2['default'].isString(type)) {\n\t\t      type = getType(parent);\n\t\t    }\n\t\t    parent = type['extends'];\n\t\t    while (parent) {\n\t\t      type = getType(parent);\n\t\t      heritage.push(type);\n\t\t      parent = type['extends'];\n\t\t    }\n\t\t    return heritage;\n\t\t  }\n\t\n\t\t  function setWrapper(_x, _x2) {\n\t\t    var _again = true;\n\t\n\t\t    _function: while (_again) {\n\t\t      var options = _x,\n\t\t          name = _x2;\n\t\t      _again = false;\n\t\n\t\t      if (_angularFix2['default'].isArray(options)) {\n\t\t        return options.map(function (wrapperOptions) {\n\t\t          return setWrapper(wrapperOptions);\n\t\t        });\n\t\t      } else if (_angularFix2['default'].isObject(options)) {\n\t\t        options.types = getOptionsTypes(options);\n\t\t        options.name = getOptionsName(options, name);\n\t\t        checkWrapperAPI(options);\n\t\t        templateWrappersMap[options.name] = options;\n\t\t        return options;\n\t\t      } else if (_angularFix2['default'].isString(options)) {\n\t\t        _x = {\n\t\t          template: options,\n\t\t          name: name\n\t\t        };\n\t\t        _x2 = undefined;\n\t\t        _again = true;\n\t\t        continue _function;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsTypes(options) {\n\t\t    if (_angularFix2['default'].isString(options.types)) {\n\t\t      return [options.types];\n\t\t    }\n\t\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t\t      return [];\n\t\t    } else {\n\t\t      return options.types;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsName(options, name) {\n\t\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t\t  }\n\t\n\t\t  function checkWrapperAPI(options) {\n\t\t    formlyUsabilityProvider.checkWrapper(options);\n\t\t    if (options.template) {\n\t\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t\t    }\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t\t    } else {\n\t\t      delete options.overwriteOk;\n\t\t    }\n\t\t    checkWrapperTypes(options);\n\t\t  }\n\t\n\t\t  function checkWrapperTypes(options) {\n\t\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t\t    if (shouldThrow) {\n\t\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkOverwrite(property, object, newValue, objectName) {\n\t\t    if (object.hasOwnProperty(property)) {\n\t\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t\t    }\n\t\t  }\n\t\n\t\t  function getWrapper(name) {\n\t\t    return templateWrappersMap[name || defaultWrapperName];\n\t\t  }\n\t\n\t\t  function getWrapperByType(type) {\n\t\t    /* eslint prefer-const:0 */\n\t\t    var wrappers = [];\n\t\t    for (var _name in templateWrappersMap) {\n\t\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t\t          wrappers.push(templateWrappersMap[_name]);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return wrappers;\n\t\t  }\n\t\n\t\t  function removeWrapperByName(name) {\n\t\t    var wrapper = templateWrappersMap[name];\n\t\t    delete templateWrappersMap[name];\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function removeWrappersForType(type) {\n\t\t    var wrappers = getWrapperByType(type);\n\t\t    if (!wrappers) {\n\t\t      return undefined;\n\t\t    }\n\t\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t\t      return removeWrapperByName(wrappers.name);\n\t\t    } else {\n\t\t      wrappers.forEach(function (wrapper) {\n\t\t        return removeWrapperByName(wrapper.name);\n\t\t      });\n\t\t      return wrappers;\n\t\t    }\n\t\t  }\n\t\n\t\t  function warn() {\n\t\t    if (!_this.disableWarnings && console.warn) {\n\t\t      /* eslint no-console:0 */\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      console.warn.apply(console, _toConsumableArray(args));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = {\n\t\t  formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName, arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t\t};\n\t\n\t\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t\t  if (_angularFix2['default'].isFunction(expression)) {\n\t\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t\t  } else {\n\t\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t\t  }\n\t\t}\n\t\n\t\tfunction getFieldId(formId, options, index) {\n\t\t  if (options.id) {\n\t\t    return options.id;\n\t\t  }\n\t\t  var type = options.type;\n\t\t  if (!type && options.template) {\n\t\t    type = 'template';\n\t\t  } else if (!type && options.templateUrl) {\n\t\t    type = 'templateUrl';\n\t\t  }\n\t\n\t\t  return [formId, type, options.key, index].join('_');\n\t\t}\n\t\n\t\tfunction reverseDeepMerge(dest) {\n\t\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t\t    if (!index) {\n\t\t      return;\n\t\t    }\n\t\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t\t        dest[prop] = _angularFix2['default'].copy(val);\n\t\t      } else if (objAndSameType(dest[prop], val)) {\n\t\t        reverseDeepMerge(dest[prop], val);\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t  return dest;\n\t\t}\n\t\n\t\tfunction objAndSameType(obj1, obj2) {\n\t\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t\t}\n\t\n\t\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\t\tfunction findByNodeName(el, nodeName) {\n\t\t  if (!el.prop) {\n\t\t    // not a jQuery or jqLite object -> wrap it\n\t\t    el = _angularFix2['default'].element(el);\n\t\t  }\n\t\n\t\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t\t    return el;\n\t\t  }\n\t\n\t\t  var c = el.children();\n\t\t  for (var i = 0; c && i < c.length; i++) {\n\t\t    var node = findByNodeName(c[i], nodeName);\n\t\t    if (node) {\n\t\t      return node;\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t\t    obj = [obj];\n\t\t  } else if (!obj) {\n\t\t    obj = [];\n\t\t  }\n\t\t  return obj;\n\t\t}\n\t\n\t\tfunction extendFunction() {\n\t\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t    fns[_key] = arguments[_key];\n\t\t  }\n\t\n\t\t  return function extendedFunction() {\n\t\t    var args = arguments;\n\t\t    fns.forEach(function (fn) {\n\t\t      return fn.apply(null, args);\n\t\t    });\n\t\t  };\n\t\t}\n\t\n\t\tfunction extendArray(primary, secondary, property) {\n\t\t  if (property) {\n\t\t    primary = primary[property];\n\t\t    secondary = secondary[property];\n\t\t  }\n\t\t  if (secondary && primary) {\n\t\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t\t      if (primary.indexOf(item) === -1) {\n\t\t        primary.push(item);\n\t\t      }\n\t\t    });\n\t\t    return primary;\n\t\t  } else if (secondary) {\n\t\t    return secondary;\n\t\t  } else {\n\t\t    return primary;\n\t\t  }\n\t\t}\n\t\n\t\tfunction startsWith(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\n\t\tfunction contains(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\texports[\"default\"] = formlyValidationMessages;\n\t\n\t\t// @ngInject\n\t\tfunction formlyValidationMessages() {\n\t\n\t\t  var validationMessages = {\n\t\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t\t    addStringMessage: addStringMessage,\n\t\t    messages: {}\n\t\t  };\n\t\n\t\t  return validationMessages;\n\t\n\t\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t\t  }\n\t\n\t\t  function addStringMessage(name, string) {\n\t\t    validationMessages.messages[name] = function () {\n\t\t      return string;\n\t\t    };\n\t\t  }\n\t\n\t\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t\t      if (scope.options.templateOptions[prop]) {\n\t\t        return prefix + \" \" + scope.options.templateOptions[prop] + \" \" + suffix;\n\t\t      } else {\n\t\t        return alternate;\n\t\t      }\n\t\t    };\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports[\"default\"];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyUtil;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUtil() {\n\t\t  return _otherUtils2['default'];\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\texports['default'] = formlyWarn;\n\t\n\t\t// @ngInject\n\t\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t\t  return function warn() {\n\t\t    if (!formlyConfig.disableWarnings) {\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      $log.warn.apply($log, _toConsumableArray(args));\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyCustomValidation;\n\t\n\t\t// @ngInject\n\t\tfunction formlyCustomValidation(formlyUtil) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    require: 'ngModel',\n\t\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t\t      var opts = scope.options;\n\t\t      opts.validation.messages = opts.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t\t        opts.validation.messages[key] = function () {\n\t\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t        };\n\t\t      });\n\t\n\t\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\t\n\t\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t\t        setupMessage(validator, name);\n\t\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t\t        if (useNewValidatorsApi) {\n\t\t          setupWithValidators(validator, name, isAsync);\n\t\t        } else {\n\t\t          setupWithParsers(validator, name, isAsync);\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupMessage(validator, name) {\n\t\t        var message = validator.message;\n\t\t        if (message) {\n\t\t          opts.validation.messages[name] = function () {\n\t\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t          };\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupWithValidators(validator, name, isAsync) {\n\t\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\t\n\t\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t\t        };\n\t\t      }\n\t\n\t\t      function setupWithParsers(validator, name, isAsync) {\n\t\t        var inFlightValidator = undefined;\n\t\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t\t          if (isAsync) {\n\t\t            ctrl.$pending = ctrl.$pending || {};\n\t\t            ctrl.$pending[name] = true;\n\t\t            inFlightValidator = isValid;\n\t\t            isValid.then(function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, true);\n\t\t              }\n\t\t            })['catch'](function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, false);\n\t\t              }\n\t\t            })['finally'](function () {\n\t\t              var $pending = ctrl.$pending || {};\n\t\t              if (Object.keys($pending).length === 1) {\n\t\t                delete ctrl.$pending;\n\t\t              } else {\n\t\t                delete ctrl.$pending[name];\n\t\t              }\n\t\t            });\n\t\t          } else {\n\t\t            ctrl.$setValidity(name, isValid);\n\t\t          }\n\t\t          return viewValue;\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = formlyField;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyField\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t\t  var arrayify = formlyUtil.arrayify;\n\t\n\t\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    transclude: true,\n\t\t    require: '?^formlyForm',\n\t\t    scope: {\n\t\t      options: '=',\n\t\t      model: '=',\n\t\t      originalModel: '=?',\n\t\t      formId: '@', // TODO remove formId in a breaking release\n\t\t      index: '=?',\n\t\t      fields: '=?',\n\t\t      formState: '=?',\n\t\t      formOptions: '=?',\n\t\t      form: '=?' },\n\t\t    // TODO require form in a breaking release\n\t\t    controller: FormlyFieldController,\n\t\t    link: fieldLink\n\t\t  };\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t\t    /* eslint max-statements:[2, 31] */\n\t\t    if ($scope.options.fieldGroup) {\n\t\t      setupFieldGroup();\n\t\t      return;\n\t\t    }\n\t\n\t\t    var fieldType = getFieldType($scope.options);\n\t\t    simplifyLife($scope.options);\n\t\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t\t    checkApi($scope.options);\n\t\t    // set field id to link labels and fields\n\t\n\t\t    // initalization\n\t\t    setFieldIdAndName();\n\t\t    setDefaultValue();\n\t\t    setInitialValue();\n\t\t    runExpressions();\n\t\t    addValidationMessages($scope.options);\n\t\t    invokeControllers($scope, $scope.options, fieldType);\n\t\n\t\t    // function definitions\n\t\t    function runExpressions() {\n\t\t      // must run on next tick to make sure that the current value is correct.\n\t\t      return $timeout(function runExpressionsOnNextTick() {\n\t\t        var field = $scope.options;\n\t\t        var currentValue = valueGetterSetter();\n\t\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t\t          var setter = $parse(prop).assign;\n\t\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t\t          promise.then(function setFieldValue(value) {\n\t\t            setter(field, value);\n\t\t          });\n\t\t        });\n\t\t      }, 0, false);\n\t\t    }\n\t\n\t\t    function valueGetterSetter(newVal) {\n\t\t      if (!$scope.model || !$scope.options.key) {\n\t\t        return undefined;\n\t\t      }\n\t\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t\t        parseSet($scope.options.key, $scope.model, newVal);\n\t\t      }\n\t\t      return parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function parseSet(key, model, newVal) {\n\t\t      // If either of these are null/undefined then just return undefined\n\t\t      if (!key || !model) {\n\t\t        return;\n\t\t      }\n\t\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t\t      if (_angularFix2['default'].isNumber(key)) {\n\t\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t\t        model[key] = newVal;\n\t\t      } else {\n\t\t        var setter = $parse($scope.options.key).assign;\n\t\t        if (setter) {\n\t\t          setter($scope.model, newVal);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function parseGet(key, model) {\n\t\t      // If either of these are null/undefined then just return undefined\n\t\t      if (!key || !model) {\n\t\t        return undefined;\n\t\t      }\n\t\n\t\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t\t      if (_angularFix2['default'].isNumber(key)) {\n\t\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t\t        return model[key];\n\t\t      } else {\n\t\t        return $parse(key)(model);\n\t\t      }\n\t\t    }\n\t\n\t\t    function simplifyLife(options) {\n\t\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t\t      formlyUtil.reverseDeepMerge(options, {\n\t\t        originalModel: options.model,\n\t\t        extras: {},\n\t\t        data: {},\n\t\t        templateOptions: {},\n\t\t        validation: {}\n\t\t      });\n\t\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t\t      $scope.to = $scope.options.templateOptions;\n\t\t      $scope.formOptions = $scope.formOptions || {};\n\t\t    }\n\t\n\t\t    function setFieldIdAndName() {\n\t\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t\t      } else {\n\t\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t\t      }\n\t\t      $scope.options.id = $scope.id;\n\t\t      $scope.name = $scope.options.name || $scope.options.id;\n\t\t      $scope.options.name = $scope.name;\n\t\t    }\n\t\n\t\t    function setDefaultValue() {\n\t\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined(parseGet($scope.options.key, $scope.model))) {\n\t\t        parseSet($scope.options.key, $scope.model, $scope.options.defaultValue);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setInitialValue() {\n\t\t      $scope.options.initialValue = $scope.model && parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t\t      if (type) {\n\t\t        mergeOptions(options, type.defaultOptions);\n\t\t      }\n\t\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t\t      });\n\t\t    }\n\t\n\t\t    function mergeOptions(options, extraOptions) {\n\t\t      if (extraOptions) {\n\t\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t\t          extraOptions = extraOptions(options, $scope);\n\t\t        }\n\t\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t\t      }\n\t\t    }\n\t\n\t\t    function extendOptionsWithDefaults(options, index) {\n\t\t      var key = options.key || index || 0;\n\t\t      _angularFix2['default'].extend(options, {\n\t\t        // attach the key in case the formly-field directive is used directly\n\t\t        key: key,\n\t\t        value: options.value || valueGetterSetter,\n\t\t        runExpressions: runExpressions,\n\t\t        resetModel: resetModel,\n\t\t        updateInitialValue: updateInitialValue\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      parseSet($scope.options.key, $scope.model, $scope.options.initialValue);\n\t\t      if ($scope.options.formControl) {\n\t\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t\t            resetFormControl(formControl, true);\n\t\t          });\n\t\t        } else {\n\t\t          resetFormControl($scope.options.formControl);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function resetFormControl(formControl, isMultiNgModel) {\n\t\t      if (!isMultiNgModel) {\n\t\t        formControl.$setViewValue(parseGet($scope.options.key, $scope.model));\n\t\t      }\n\t\n\t\t      formControl.$render();\n\t\t      formControl.$setUntouched && formControl.$setUntouched();\n\t\t      formControl.$setPristine();\n\t\n\t\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t\t      if (!$scope.$root.$$phase) {\n\t\t        $scope.$digest();\n\t\t      }\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      $scope.options.initialValue = parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function addValidationMessages(options) {\n\t\t      options.validation.messages = options.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t\t        if (!options.validation.messages[name]) {\n\t\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t\t          };\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function invokeControllers(scope) {\n\t\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t\t        if (controller) {\n\t\t          $controller(controller, { $scope: scope });\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupFieldGroup() {\n\t\t      $scope.options.options = $scope.options.options || {};\n\t\t      $scope.options.options.formState = $scope.formState;\n\t\t      $scope.to = $scope.options.templateOptions;\n\t\t    }\n\t\t  }\n\t\n\t\t  // link function\n\t\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t\t    if (scope.options.fieldGroup) {\n\t\t      setFieldGroupTemplate();\n\t\t      return;\n\t\t    }\n\t\n\t\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t\t    if (!formlyFormCtrl && scope.options.model) {\n\t\t      scope.$watch('options.model', function () {\n\t\t        return scope.options.runExpressions();\n\t\t      }, true);\n\t\t    }\n\t\n\t\t    addAttributes();\n\t\t    addClasses();\n\t\n\t\t    var type = getFieldType(scope.options);\n\t\t    var args = arguments;\n\t\t    var thusly = this;\n\t\t    var fieldCount = 0;\n\t\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t\t    });\n\t\n\t\t    function setFieldGroupTemplate() {\n\t\t      checkFieldGroupApi(scope.options);\n\t\t      el.addClass('formly-field-group');\n\t\t      var extraAttributes = '';\n\t\t      if (scope.options.elementAttributes) {\n\t\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t\t        }).join(' ');\n\t\t      }\n\t\t      var modelValue = 'model';\n\t\t      scope.options.form = scope.form;\n\t\t      if (scope.options.key) {\n\t\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t\t      }\n\t\t      getTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ').then(transcludeInWrappers(scope.options, scope.formOptions)).then(setElementTemplate);\n\t\t    }\n\t\n\t\t    function addAttributes() {\n\t\t      if (scope.options.elementAttributes) {\n\t\t        el.attr(scope.options.elementAttributes);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addClasses() {\n\t\t      if (scope.options.className) {\n\t\t        el.addClass(scope.options.className);\n\t\t      }\n\t\t      if (scope.options.type) {\n\t\t        el.addClass('formly-field-' + scope.options.type);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setElementTemplate(templateString) {\n\t\t      el.html(asHtml(templateString));\n\t\t      $compile(el.contents())(scope);\n\t\t      return templateString;\n\t\t    }\n\t\n\t\t    function watchFormControl(templateString) {\n\t\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t\t      if (scope.options.noFormControl) {\n\t\t        return;\n\t\t      }\n\t\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\t\n\t\t      if (ngModelNodes.length) {\n\t\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t\t          fieldCount++;\n\t\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t\t        });\n\t\t      }\n\t\n\t\t      function watchFieldNameOrExistence(name) {\n\t\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t\t        var nameExpression = nameExpressionRegex.exec(name);\n\t\t        if (nameExpression) {\n\t\t          name = $interpolate(name)(scope);\n\t\t        }\n\t\t        watchFieldExistence(name);\n\t\t      }\n\t\n\t\t      function watchFieldExistence(name) {\n\t\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t\t          if (formControl) {\n\t\t            if (fieldCount > 1) {\n\t\t              if (!scope.options.formControl) {\n\t\t                scope.options.formControl = [];\n\t\t              }\n\t\t              scope.options.formControl.push(formControl);\n\t\t            } else {\n\t\t              scope.options.formControl = formControl;\n\t\t            }\n\t\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t\t            stopWatchingShowError();\n\t\t            addShowMessagesWatcher();\n\t\t            addParsers();\n\t\t            addFormatters();\n\t\t          }\n\t\t        });\n\t\t      }\n\t\n\t\t      function addShowMessagesWatcher() {\n\t\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t\t          var options = scope.options;\n\t\t          var fc = scope.fc;\n\t\n\t\t          if (!fc.$invalid) {\n\t\t            return false;\n\t\t          } else if (typeof options.validation.show === 'boolean') {\n\t\t            return options.validation.show;\n\t\t          } else if (customExpression) {\n\t\t            return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t\t          } else {\n\t\t            var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t\t            return scope.fc.$touched || noTouchedButDirty;\n\t\t          }\n\t\t        }, function onShowValidationChange(show) {\n\t\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t\t          scope.showError = show; // shortcut for template authors\n\t\t        });\n\t\t      }\n\t\n\t\t      function addParsers() {\n\t\t        setParsersOrFormatters('parsers');\n\t\t      }\n\t\n\t\t      function addFormatters() {\n\t\t        setParsersOrFormatters('formatters');\n\t\t        var ctrl = scope.fc;\n\t\t        var formWasPristine = scope.form.$pristine;\n\t\t        if (scope.options.formatters) {\n\t\t          (function () {\n\t\t            var value = ctrl.$modelValue;\n\t\t            ctrl.$formatters.forEach(function (formatter) {\n\t\t              value = formatter(value);\n\t\t            });\n\t\n\t\t            ctrl.$setViewValue(value);\n\t\t            ctrl.$render();\n\t\t            ctrl.$setPristine();\n\t\t            if (formWasPristine) {\n\t\t              scope.form.$setPristine();\n\t\t            }\n\t\t          })();\n\t\t        }\n\t\t      }\n\t\n\t\t      function setParsersOrFormatters(which) {\n\t\t        var originalThingProp = 'originalParser';\n\t\t        if (which === 'formatters') {\n\t\t          originalThingProp = 'originalFormatter';\n\t\t        }\n\t\n\t\t        // init with type's parsers\n\t\t        var things = getThingsFromType(type);\n\t\n\t\t        // get optionsTypes things\n\t\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\t\n\t\t        // get field's things\n\t\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\t\n\t\t        // convert things into formlyExpression things\n\t\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t\t          things[index] = getFormlyExpressionThing(thing);\n\t\t        });\n\t\n\t\t        var ngModelCtrls = scope.fc;\n\t\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t\t          ngModelCtrls = [ngModelCtrls];\n\t\t        }\n\t\n\t\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t\t          var _ngModelCtrl;\n\t\n\t\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t\t        });\n\t\n\t\t        function getThingsFromType(theType) {\n\t\t          if (!theType) {\n\t\t            return [];\n\t\t          }\n\t\t          if (_angularFix2['default'].isString(theType)) {\n\t\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t\t          }\n\t\t          var typeThings = [];\n\t\n\t\t          // get things from parent\n\t\t          if (theType['extends']) {\n\t\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t\t          }\n\t\n\t\t          // get own type's things\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\t\n\t\t          // get things from optionsTypes\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\t\n\t\t          return typeThings;\n\t\t        }\n\t\n\t\t        function getThingsFromOptionsTypes() {\n\t\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t\t          var optionsTypesThings = [];\n\t\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t\t          });\n\t\t          return optionsTypesThings;\n\t\t        }\n\t\n\t\t        function getFormlyExpressionThing(thing) {\n\t\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t\t          return formlyExpressionParserOrFormatterFunction;\n\t\n\t\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t\t            var $modelValue = scope.options.value();\n\t\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function callLinkFunctions() {\n\t\t      if (type && type.link) {\n\t\t        type.link.apply(thusly, args);\n\t\t      }\n\t\t      if (scope.options.link) {\n\t\t        scope.options.link.apply(thusly, args);\n\t\t      }\n\t\t    }\n\t\n\t\t    function runManipulators(manipulators) {\n\t\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t\t        var chain = $q.when(templateToManipulate);\n\t\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t\t          chain = chain.then(function (template) {\n\t\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t\t            });\n\t\t          });\n\t\t        });\n\t\t        return chain;\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  // sort-of stateless util functions\n\t\t  function asHtml(el) {\n\t\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t\t    return wrapper.append(el).html();\n\t\t  }\n\t\n\t\t  function getFieldType(options) {\n\t\t    return options.type && formlyConfig.getType(options.type);\n\t\t  }\n\t\n\t\t  function getManipulators(options, formOptions) {\n\t\t    var preWrapper = [];\n\t\t    var postWrapper = [];\n\t\t    addManipulators(options.templateManipulators);\n\t\t    addManipulators(formOptions.templateManipulators);\n\t\t    addManipulators(formlyConfig.templateManipulators);\n\t\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\t\n\t\t    function addManipulators(manipulators) {\n\t\t      /* eslint-disable */ // it doesn't understand this :-(\n\t\n\t\t      var _ref = manipulators || {};\n\t\n\t\t      var _ref$preWrapper = _ref.preWrapper;\n\t\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t\t      var _ref$postWrapper = _ref.postWrapper;\n\t\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\t\n\t\t      preWrapper = preWrapper.concat(pre);\n\t\t      postWrapper = postWrapper.concat(post);\n\t\t      /* eslint-enable */\n\t\t    }\n\t\t  }\n\t\n\t\t  function getFieldTemplate(options) {\n\t\t    function fromOptionsOrType(key, fieldType) {\n\t\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t\t        return options[key];\n\t\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t\t        return fieldType[key];\n\t\t      }\n\t\t    }\n\t\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    var template = fromOptionsOrType('template', type);\n\t\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t\t    }\n\t\n\t\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t\t  }\n\t\n\t\t  function getTemplate(template, isUrl, options) {\n\t\t    var templatePromise = undefined;\n\t\t    if (_angularFix2['default'].isFunction(template)) {\n\t\t      templatePromise = $q.when(template(options));\n\t\t    } else {\n\t\t      templatePromise = $q.when(template);\n\t\t    }\n\t\n\t\t    if (!isUrl) {\n\t\t      return templatePromise;\n\t\t    } else {\n\t\t      var _ret2 = (function () {\n\t\t        var httpOptions = { cache: $templateCache };\n\t\t        return {\n\t\t          v: templatePromise.then(function (url) {\n\t\t            return $http.get(url, httpOptions);\n\t\t          }).then(function (response) {\n\t\t            return response.data;\n\t\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t\t          })\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret2 === 'object') return _ret2.v;\n\t\t    }\n\t\t  }\n\t\n\t\t  function transcludeInWrappers(options, formOptions) {\n\t\t    var wrapper = getWrapperOption(options, formOptions);\n\t\n\t\t    return function transcludeTemplate(template) {\n\t\t      if (!wrapper.length) {\n\t\t        return $q.when(template);\n\t\t      }\n\t\n\t\t      wrapper.forEach(function (aWrapper) {\n\t\t        formlyUsability.checkWrapper(aWrapper, options);\n\t\t        runApiCheck(aWrapper, options);\n\t\t      });\n\t\t      var promises = wrapper.map(function (w) {\n\t\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t\t      });\n\t\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t\t        });\n\t\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t\t        var totalWrapper = wrappersTemplates.shift();\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t\t        });\n\t\t        return doTransclusion(totalWrapper, template);\n\t\t      });\n\t\t    };\n\t\t  }\n\t\n\t\t  function doTransclusion(wrapper, template) {\n\t\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t\t    superWrapper.append(wrapper);\n\t\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t\t    if (!transcludeEl.length) {\n\t\t      // try it using our custom find function\n\t\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t\t    }\n\t\t    transcludeEl.replaceWith(template);\n\t\t    return superWrapper.html();\n\t\t  }\n\t\n\t\t  function getWrapperOption(options, formOptions) {\n\t\t    /* eslint complexity:[2, 6] */\n\t\t    var wrapper = options.wrapper;\n\t\t    // explicit null means no wrapper\n\t\t    if (wrapper === null) {\n\t\t      return [];\n\t\t    }\n\t\n\t\t    // nothing specified means use the default wrapper for the type\n\t\t    if (!wrapper) {\n\t\t      // get all wrappers that specify they apply to this type\n\t\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t\t    } else {\n\t\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t\t    }\n\t\n\t\t    // get all wrappers for that the type specified that it uses.\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    if (type && type.wrapper) {\n\t\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(typeWrappers);\n\t\t    }\n\t\n\t\t    // add form wrappers\n\t\t    if (formOptions.wrapper) {\n\t\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(formWrappers);\n\t\t    }\n\t\n\t\t    // add the default wrapper last\n\t\t    var defaultWrapper = formlyConfig.getWrapper();\n\t\t    if (defaultWrapper) {\n\t\t      wrapper.push(defaultWrapper);\n\t\t    }\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function checkApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t    // validate with the type\n\t\t    var type = options.type && formlyConfig.getType(options.type);\n\t\t    if (type) {\n\t\t      runApiCheck(type, options, true);\n\t\t    }\n\t\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkFieldGroupApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function runApiCheck(_ref2, options, forType) {\n\t\t    var apiCheck = _ref2.apiCheck;\n\t\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\t\n\t\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t\t    if (forType && options.type) {\n\t\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t\t    /* eslint complexity:[2, 9] */\n\t\t    if (!apiCheck) {\n\t\t      return;\n\t\t    }\n\t\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t\t      return;\n\t\t    }\n\t\t    var fn = apiCheckFunction || 'warn';\n\t\t    // this is the new API\n\t\t    var checkerObjects = apiCheck(instance);\n\t\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t\t      var checker = instance.shape(shape);\n\t\t      var checkOptions = _angularFix2['default'].extend({\n\t\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t\t      }, apiCheckOptions);\n\t\t      instance[fn](checker, options[name], checkOptions);\n\t\t    });\n\t\t  }\n\t\t}\n\t\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\t\n\t\t// Stateless util functions\n\t\tfunction getDefaultOptionsOptionsTypes(type) {\n\t\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t\t}\n\t\n\t\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\texports['default'] = formlyFocus;\n\t\n\t\t// @ngInject\n\t\tfunction formlyFocus($timeout, $document) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    link: function formlyFocusLink(scope, element, attrs) {\n\t\t      var previousEl = null;\n\t\t      var el = element[0];\n\t\t      var doc = $document[0];\n\t\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t\t        if (value === 'true') {\n\t\t          $timeout(function setElementFocus() {\n\t\t            previousEl = doc.activeElement;\n\t\t            el.focus();\n\t\t          }, ~ ~attrs.focusWait);\n\t\t        } else if (value === 'false') {\n\t\t          if (doc.activeElement === el) {\n\t\t            el.blur();\n\t\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t\t              previousEl.focus();\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar _slice = Array.prototype.slice;\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyForm;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyForm\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t\t  var currentFormId = 1;\n\t\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    template: formlyFormGetTemplate,\n\t\t    replace: true,\n\t\t    transclude: true,\n\t\t    scope: {\n\t\t      fields: '=',\n\t\t      model: '=',\n\t\t      form: '=?',\n\t\t      options: '=?'\n\t\t    },\n\t\t    controller: FormlyFormController,\n\t\t    link: formlyFormLink\n\t\t  };\n\t\n\t\t  function formlyFormGetTemplate(el, attrs) {\n\t\t    var rootEl = getRootEl();\n\t\t    var fieldRootEl = getFieldRootEl();\n\t\t    var formId = 'formly_' + currentFormId++;\n\t\t    var parentFormAttributes = '';\n\t\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t\t    }\n\t\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\t\n\t\t    function getRootEl() {\n\t\t      return attrs.rootEl || 'ng-form';\n\t\t    }\n\t\n\t\t    function getFieldRootEl() {\n\t\t      return attrs.fieldRootEl || 'div';\n\t\t    }\n\t\n\t\t    function getHideDirective() {\n\t\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t\t    }\n\t\n\t\t    function getTrackBy() {\n\t\t      if (!attrs.trackBy) {\n\t\t        return '';\n\t\t      } else {\n\t\t        return 'track by ' + attrs.trackBy;\n\t\t      }\n\t\t    }\n\t\n\t\t    function getFormName() {\n\t\t      var formName = formId;\n\t\t      var bindName = attrs.bindName;\n\t\t      if (bindName) {\n\t\t        if (_angularFix2['default'].version.minor < 3) {\n\t\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t\t        }\n\t\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t\t      }\n\t\t      return formName;\n\t\t    }\n\t\n\t\t    function getTranscludeClass() {\n\t\t      return attrs.transcludeClass || '';\n\t\t    }\n\t\n\t\t    function copyAttributes(attributes) {\n\t\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t\t      var arrayAttrs = [];\n\t\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t\t        var nodeName = _ref.nodeName;\n\t\t        var value = _ref.value;\n\t\n\t\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t\t        }\n\t\t      });\n\t\t      return arrayAttrs.join(' ');\n\t\t    }\n\t\t  }\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t\t    setupOptions();\n\t\t    $scope.model = $scope.model || {};\n\t\t    setupFields();\n\t\n\t\t    // watch the model and evaluate watch expressions that depend on it.\n\t\t    $scope.$watch('model', onModelOrFormStateChange, true);\n\t\t    if ($scope.options.formState) {\n\t\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t\t    }\n\t\n\t\t    function onModelOrFormStateChange() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function runFieldExpressionProperties(field, index) {\n\t\t        var model = field.model || $scope.model;\n\t\t        var promise = field.runExpressions && field.runExpressions();\n\t\t        if (field.hideExpression) {\n\t\t          // can't use hide with expressionProperties reliably\n\t\t          var val = model[field.key];\n\t\t          field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t\t        }\n\t\t        if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t\t          var validate = field.formControl.$validate;\n\t\t          if (promise) {\n\t\t            promise.then(validate);\n\t\t          } else {\n\t\t            validate();\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupFields() {\n\t\t      $scope.fields = $scope.fields || [];\n\t\n\t\t      checkDeprecatedOptions($scope.options);\n\t\n\t\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\t\n\t\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t\t        fieldTransforms = [fieldTransforms];\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t\t        if (fieldTransform) {\n\t\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t\t          if (!$scope.fields) {\n\t\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t\t          }\n\t\t        }\n\t\t      });\n\t\n\t\t      setupModels();\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t\t    }\n\t\n\t\t    function checkDeprecatedOptions(options) {\n\t\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupOptions() {\n\t\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t\t      $scope.options = $scope.options || {};\n\t\t      $scope.options.formState = $scope.options.formState || {};\n\t\n\t\t      _angularFix2['default'].extend($scope.options, {\n\t\t        updateInitialValue: updateInitialValue,\n\t\t        resetModel: resetModel\n\t\t      });\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.updateInitialValue();\n\t\t        } else {\n\t\t          field.updateInitialValue();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.resetModel();\n\t\t        } else if (field.resetModel) {\n\t\t          field.resetModel();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupModels() {\n\t\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t\t      var watchedModels = [$scope.model];\n\t\n\t\t      if ($scope.options.formState) {\n\t\t        // $scope.options.formState will have its own watcher\n\t\t        watchedModels.push($scope.options.formState);\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        var isNewModel = initModel(field);\n\t\n\t\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1) {\n\t\t          $scope.$watch(function () {\n\t\t            return field.model;\n\t\t          }, onModelOrFormStateChange, true);\n\t\t          watchedModels.push(field.model);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function initModel(field) {\n\t\t      var isNewModel = true;\n\t\n\t\t      if (_angularFix2['default'].isString(field.model)) {\n\t\t        var expression = field.model;\n\t\t        var index = $scope.fields.indexOf(field);\n\t\n\t\t        isNewModel = !refrencesCurrentlyWatchedModel(expression);\n\t\n\t\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t\t        if (!field.model) {\n\t\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t\t        }\n\t\t      }\n\t\t      return isNewModel;\n\t\t    }\n\t\n\t\t    function refrencesCurrentlyWatchedModel(expression) {\n\t\t      return ['model', 'formState'].some(function (item) {\n\t\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t\t      });\n\t\t    }\n\t\n\t\t    function attachKey(field, index) {\n\t\t      if (!isFieldGroup(field)) {\n\t\t        field.key = field.key || index || 0;\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupWatchers(field, index) {\n\t\t      if (isFieldGroup(field) || !_angularFix2['default'].isDefined(field.watcher)) {\n\t\t        return;\n\t\t      }\n\t\t      var watchers = field.watcher;\n\t\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t\t        watchers = [watchers];\n\t\t      }\n\t\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t\t        if (!_angularFix2['default'].isDefined(watcher.listener)) {\n\t\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t\t        }\n\t\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t\t        var watchListener = getWatchListener(watcher, field, index);\n\t\n\t\t        var type = watcher.type || '$watch';\n\t\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t\t      });\n\t\t    }\n\t\n\t\t    function getWatchExpression(watcher, field, index) {\n\t\t      var watchExpression = watcher.expression || 'model[\\'' + field.key + '\\']';\n\t\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t\t        (function () {\n\t\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalExpression = watchExpression;\n\t\t          watchExpression = function formlyWatchExpression() {\n\t\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t\t          };\n\t\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchExpression;\n\t\t    }\n\t\n\t\t    function getWatchListener(watcher, field, index) {\n\t\t      var watchListener = watcher.listener;\n\t\t      if (_angularFix2['default'].isFunction(watchListener)) {\n\t\t        (function () {\n\t\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalListener = watchListener;\n\t\t          watchListener = function formlyWatchListener() {\n\t\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t            return originalListener.apply(undefined, _toConsumableArray(args));\n\t\t          };\n\t\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchListener;\n\t\t    }\n\t\n\t\t    function modifyArgs(watcher, index) {\n\t\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\t        originalArgs[_key - 2] = arguments[_key];\n\t\t      }\n\t\n\t\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t\t    }\n\t\n\t\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t\t    }\n\t\n\t\t    function getFormlyFieldLikeLocals(field, index) {\n\t\t      // this makes it closer to what a regular formlyExpression would be\n\t\t      return {\n\t\t        options: field,\n\t\t        index: index,\n\t\t        formState: $scope.options.formState,\n\t\t        formId: $scope.formId\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function formlyFormLink(scope, el, attrs) {\n\t\t    setFormController();\n\t\t    fixChromeAutocomplete();\n\t\n\t\t    function setFormController() {\n\t\t      var formId = attrs.name;\n\t\t      scope.formId = formId;\n\t\t      scope.theFormlyForm = scope[formId];\n\t\t      if (attrs.form) {\n\t\t        var getter = $parse(attrs.form);\n\t\t        var setter = getter.assign;\n\t\t        var parentForm = getter(scope.$parent);\n\t\t        if (parentForm) {\n\t\t          scope.theFormlyForm = parentForm;\n\t\t          if (scope[formId]) {\n\t\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t\t          }\n\t\n\t\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t\t          // to children forms :-( This line was added to solve this issue:\n\t\t          // https://github.com/formly-js/angular-formly/issues/287\n\t\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t\t          // so I expect it will remain this way for the life of angular 1.x\n\t\t          el.removeData('$formController');\n\t\t        } else {\n\t\t          setter(scope.$parent, scope[formId]);\n\t\t        }\n\t\t      }\n\t\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t\t        /* eslint no-console:0 */\n\t\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t\t      }\n\t\t    }\n\t\n\t\t    /*\n\t\t     * chrome autocomplete lameness\n\t\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t\t     * ()   ()     ()\n\t\t     */\n\t\t    function fixChromeAutocomplete() {\n\t\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t\t      if (global && !offInstance || onInstance) {\n\t\t        var input = document.createElement('input');\n\t\t        input.setAttribute('autocomplete', 'address-level4');\n\t\t        input.setAttribute('hidden', 'true');\n\t\t        el[0].appendChild(input);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  // stateless util functions\n\t\t  function toKebabCase(string) {\n\t\t    if (string) {\n\t\t      return string.replace(/([A-Z])/g, function ($1) {\n\t\t        return '-' + $1.toLowerCase();\n\t\t      });\n\t\t    } else {\n\t\t      return '';\n\t\t    }\n\t\t  }\n\t\n\t\t  function isFieldGroup(field) {\n\t\t    return field && !!field.fieldGroup;\n\t\t  }\n\t\t}\n\t\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\texports['default'] = addFormlyNgModelAttrsManipulator;\n\t\n\t\t// @ngInject\n\t\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t\t    return;\n\t\t  }\n\t\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\t\n\t\t  function ngModelAttrsManipulator(template, options, scope) {\n\t\t    var node = document.createElement('div');\n\t\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t\t    if (skip === true) {\n\t\t      return template;\n\t\t    }\n\t\t    node.innerHTML = template;\n\t\n\t\t    var modelNodes = getNgModelNodes(node, skip);\n\t\t    if (!modelNodes || !modelNodes.length) {\n\t\t      return template;\n\t\t    }\n\t\n\t\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\t\n\t\t    addValidation();\n\t\t    alterNgModelAttr();\n\t\t    addModelOptions();\n\t\t    addTemplateOptionsAttrs();\n\t\t    addNgModelElAttrs();\n\t\n\t\t    return node.innerHTML;\n\t\n\t\t    function addValidation() {\n\t\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t\t      }\n\t\t    }\n\t\n\t\t    function alterNgModelAttr() {\n\t\t      if (isPropertyAccessor(options.key)) {\n\t\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addModelOptions() {\n\t\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t\t        if (options.modelOptions.getterSetter) {\n\t\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function addTemplateOptionsAttrs() {\n\t\t      if (!options.templateOptions && !options.expressionProperties) {\n\t\t        // no need to run these if there are no templateOptions or expressionProperties\n\t\t        return;\n\t\t      }\n\t\t      var to = options.templateOptions || {};\n\t\t      var ep = options.expressionProperties || {};\n\t\n\t\t      var ngModelAttributes = getBuiltInAttributes();\n\t\n\t\t      // extend with the user's specifications winning\n\t\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\t\n\t\t      // Feel free to make this more simple :-)\n\t\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t\t        /* eslint complexity:[2, 14] */\n\t\t        var attrVal = undefined,\n\t\t            attrName = undefined;\n\t\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t\t        var toVal = to[name];\n\t\t        var epVal = getEpValue(ep, name);\n\t\n\t\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t\t        if (val.value) {\n\t\t          // I realize this looks backwards, but it's right, trust me...\n\t\t          attrName = val.value;\n\t\t          attrVal = name;\n\t\t        } else if (val.statement && inTo) {\n\t\t          attrName = val.statement;\n\t\t          if (_angularFix2['default'].isString(to[name])) {\n\t\t            attrVal = '$eval(' + ref + ')';\n\t\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t\t          } else {\n\t\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t\t          }\n\t\t        } else if (val.bound && inEp) {\n\t\t          attrName = val.bound;\n\t\t          attrVal = ref;\n\t\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t\t          attrName = val.attribute || val.boolean;\n\t\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t\t        } else if (val.attribute && inTo) {\n\t\t          attrName = val.attribute;\n\t\t          attrVal = toVal;\n\t\t        } else if (val.boolean) {\n\t\t          if (inTo && !inEp && toVal) {\n\t\t            attrName = val.boolean;\n\t\t            attrVal = true;\n\t\t          } else {\n\t\t            /* eslint no-empty:0 */\n\t\t            // empty to illustrate that a boolean will not be added via val.bound\n\t\t            // if you want it added via val.bound, then put it in expressionProperties\n\t\t          }\n\t\t        } else if (val.bound && inTo) {\n\t\t            attrName = val.bound;\n\t\t            attrVal = ref;\n\t\t          }\n\t\n\t\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function addNgModelElAttrs() {\n\t\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t\t        addRegardlessOfPresence(modelNodes, name, val);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  // Utility functions\n\t\t  function getNgModelNodes(node, skip) {\n\t\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t\t    try {\n\t\t      return node.querySelectorAll(query);\n\t\t    } catch (e) {\n\t\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t\t      //it should be removed when IE8 support is dropped\n\t\t      return getNgModelNodesFallback(node, skip);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getNgModelNodesFallback(node, skip) {\n\t\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t\t    var matchingNgModelNodes = [];\n\t\n\t\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t\t    matchingNgModelNodes.item = function (i) {\n\t\t      return this[i];\n\t\t    };\n\t\n\t\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t\t      var ngModelNode = allNgModelNodes[i];\n\t\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t\t        matchingNgModelNodes.push(ngModelNode);\n\t\t      }\n\t\t    }\n\t\n\t\t    return matchingNgModelNodes;\n\t\t  }\n\t\n\t\t  function nodeMatches(node, selector) {\n\t\t    var div = document.createElement('div');\n\t\t    div.innerHTML = node.outerHTML;\n\t\t    return div.querySelector(selector);\n\t\t  }\n\t\n\t\t  function getBuiltInAttributes() {\n\t\t    var ngModelAttributes = {\n\t\t      focus: {\n\t\t        attribute: 'formly-focus'\n\t\t      }\n\t\t    };\n\t\t    var boundOnly = [];\n\t\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t\t    var attributeOnly = ['placeholder', 'min', 'max', 'tabindex', 'type'];\n\t\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t\t      bothAttributeAndBound.push('maxlength');\n\t\t    } else {\n\t\t      boundOnly.push('maxlength');\n\t\t    }\n\t\n\t\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item };\n\t\t    });\n\t\t    return ngModelAttributes;\n\t\t  }\n\t\n\t\t  function getEpValue(ep, name) {\n\t\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t\t  }\n\t\n\t\t  function addIfNotPresent(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      if (!node.getAttribute(attr)) {\n\t\t        node.setAttribute(attr, val);\n\t\t      }\n\t\t    });\n\t\t  }\n\t\n\t\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      node.setAttribute(attr, val);\n\t\t    });\n\t\t  }\n\t\n\t\t  function isPropertyAccessor(key) {\n\t\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t\t  }\n\t\t}\n\t\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = addCustomTags;\n\t\n\t\t// @ngInject\n\t\tfunction addCustomTags($document) {\n\t\t  if ($document && $document.get) {\n\t\t    (function () {\n\t\t      // IE8 check ->\n\t\t      // http://stackoverflow.com/questions/10964966/detect-ie-version-prior-to-v9-in-javascript/10965203#10965203\n\t\t      var document = $document.get(0);\n\t\t      var div = document.createElement('div');\n\t\t      div.innerHTML = '<!--[if lt IE 9]><i></i><![endif]-->';\n\t\t      var isIeLessThan9 = div.getElementsByTagName('i').length === 1;\n\t\n\t\t      if (isIeLessThan9) {\n\t\t        // add the custom elements that we need for formly\n\t\t        var customElements = ['formly-field', 'formly-form', 'formly-custom-validation', 'formly-focus', 'formly-transpose'];\n\t\t        _angularFix2['default'].forEach(customElements, function (el) {\n\t\t          document.createElement(el);\n\t\t        });\n\t\t      }\n\t\t    })();\n\t\t  }\n\t\t}\n\t\taddCustomTags.$inject = [\"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! angular-formly-templates-bootstrap version 6.1.5 built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> ( _)==(_ )\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(3), __webpack_require__(7), __webpack_require__(4));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar ngModuleName = 'formlyBootstrap';\n\t\tvar angular = __webpack_require__(2);\n\t\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\t\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t\t  output: {\n\t\t    prefix: 'angular-formly-bootstrap'\n\t\t  }\n\t\t}));\n\t\tngModule.constant('formlyBootstrapVersion', (\"6.1.5\"));\n\t\n\t\t__webpack_require__(6)(ngModule);\n\t\t__webpack_require__(9)(ngModule);\n\t\t__webpack_require__(19)(ngModule);\n\t\n\t\texports['default'] = ngModuleName;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tvar angular = __webpack_require__(3);\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\tmodule.exports = angular;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addWrappers);\n\t\n\t\t  function addWrappers(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setWrapper([{\n\t\t      name: 'bootstrapLabel',\n\t\t      template: __webpack_require__(7),\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string,\n\t\t            required: check.bool.optional,\n\t\t            labelSrOnly: check.bool.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t\t  }\n\t\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  __webpack_require__(10)(ngModule);\n\t\t  __webpack_require__(12)(ngModule);\n\t\t  __webpack_require__(14)(ngModule);\n\t\t  __webpack_require__(15)(ngModule);\n\t\t  __webpack_require__(17)(ngModule);\n\t\t  __webpack_require__(18)(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'checkbox',\n\t\t      template: __webpack_require__(11),\n\t\t      wrapper: ['bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'multiCheckbox',\n\t\t      template: __webpack_require__(13),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      },\n\t\t      defaultOptions: {\n\t\t        noFormControl: false,\n\t\t        ngModelAttrs: {\n\t\t          required: {\n\t\t            attribute: '',\n\t\t            bound: ''\n\t\t          }\n\t\t        }\n\t\t      },\n\t\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t\t        var to = $scope.to;\n\t\t        var opts = $scope.options;\n\t\t        $scope.multiCheckbox = {\n\t\t          checked: [],\n\t\t          change: setModel\n\t\t        };\n\t\n\t\t        // initialize the checkboxes check property\n\t\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t\t          var modelValue, valueProp;\n\t\n\t\t          if (Object.keys(newModelValue).length) {\n\t\t            modelValue = newModelValue[opts.key];\n\t\n\t\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t\t                valueProp = to.valueProp || 'value';\n\t\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t\t                }\n\t\t              }\n\t\t            });\n\t\t          }\n\t\t        }, true);\n\t\n\t\t        function checkValidity(expressionValue) {\n\t\t          var valid;\n\t\n\t\t          if ($scope.to.required) {\n\t\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\t\n\t\t            $scope.fc.$setValidity('required', valid);\n\t\t          }\n\t\t        }\n\t\n\t\t        function setModel() {\n\t\t          $scope.model[opts.key] = [];\n\t\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t\t            if (checkbox) {\n\t\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t\t            }\n\t\t          });\n\t\n\t\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t\t          $scope.fc.$setTouched();\n\t\t          checkValidity(true);\n\t\t        }\n\t\n\t\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t\t          $scope.$watch(function () {\n\t\t            return $scope.to.required;\n\t\t          }, function (newValue) {\n\t\t            checkValidity(newValue);\n\t\t          });\n\t\t        }\n\t\n\t\t        if ($scope.to.required) {\n\t\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t\t            if (!newValue) {\n\t\t              return;\n\t\t            }\n\t\t            checkValidity(true);\n\t\t            unwatchFormControl();\n\t\t          });\n\t\t        }\n\t\t      }]\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addInputType);\n\t\n\t\t  function addInputType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'input',\n\t\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t\t    });\n\t\t  }\n\t\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addRadioType);\n\t\n\t\t  function addRadioType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'radio',\n\t\t      template: __webpack_require__(16),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        noFormControl: false\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addSelectType);\n\t\n\t\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\t\n\t\t  function addSelectType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'select',\n\t\t      template: template,\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: function defaultOptions(options) {\n\t\t        /* jshint maxlen:195 */\n\t\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t\t        return {\n\t\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t\t          })\n\t\t        };\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            optionsAttr: check.string.optional,\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional,\n\t\t            groupProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addTextareaType);\n\t\n\t\t  function addTextareaType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'textarea',\n\t\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        ngModelAttrs: {\n\t\t          rows: { attribute: 'rows' },\n\t\t          cols: { attribute: 'cols' }\n\t\t        }\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            rows: check.number.optional,\n\t\t            cols: check.number.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 19 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _addons = __webpack_require__(20);\n\t\n\t\tvar _addons2 = _interopRequireDefault(_addons);\n\t\n\t\tvar _description = __webpack_require__(22);\n\t\n\t\tvar _description2 = _interopRequireDefault(_description);\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  (0, _addons2['default'])(ngModule);\n\t\t  (0, _description2['default'])(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 20 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addAddonsManipulator);\n\t\n\t\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t\t    var addonTemplate = __webpack_require__(21);\n\t\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t\t      'class': formlyBootstrapApiCheck.string.optional,\n\t\t      text: formlyBootstrapApiCheck.string.optional,\n\t\t      onClick: formlyBootstrapApiCheck.func.optional\n\t\t    }).strict.optional;\n\t\t    var api = formlyBootstrapApiCheck.shape({\n\t\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t\t        addonLeft: addonChecker,\n\t\t        addonRight: addonChecker\n\t\t      })\n\t\t    });\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t\t        return template;\n\t\t      }\n\t\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t\t    });\n\t\t  }\n\t\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 21 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 22 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addDescriptionManipulator);\n\t\n\t\t  function addDescriptionManipulator(formlyConfig) {\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t\t      if (angular.isDefined(options.templateOptions.description)) {\n\t\t        var el = document.createElement('div');\n\t\t        el.appendChild(angular.element(template)[0]);\n\t\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t\t        if (modelEls) {\n\t\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t\t        }\n\t\t        return el.innerHTML;\n\t\t      } else {\n\t\t        return template;\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/**\n\t * angular-permission\n\t * Route permission and access control as simple as it can get\n\t * @version v1.1.1 - 2015-11-09\n\t * @link http://www.rafaelvidaurre.com\n\t * @author Rafael Vidaurre <narzerus@gmail.com>\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular.module('permission', ['ui.router'])\n\t    .run(['$rootScope', 'Permission', '$state', '$q',\n\t    function ($rootScope, Permission, $state, $q) {\n\t      $rootScope.$on('$stateChangeStart',\n\t      function (event, toState, toParams, fromState, fromParams) {\n\t        if (toState.$$finishAuthorize) {\n\t          return;\n\t        }\n\t\n\t        // If there are permissions set then prevent default and attempt to authorize\n\t        var permissions;\n\t        if (toState.data && toState.data.permissions) {\n\t          permissions = toState.data.permissions;\n\t        } else if (toState.permissions) {\n\t          /**\n\t          * This way of defining permissions will be depracated in v1. Should use\n\t          * `data` key instead\n\t          */\n\t          console.log('Deprecation Warning: permissions should be set inside the `data` key ');\n\t          console.log('Setting permissions for a state outside `data` will be depracated in' +\n\t            ' version 1');\n\t          permissions = toState.permissions;\n\t        }\n\t\n\t        if (permissions) {\n\t          event.preventDefault();\n\t          toState = angular.extend({'$$finishAuthorize': true}, toState);\n\t\n\t          if ($rootScope.$broadcast('$stateChangePermissionStart', toState, toParams).defaultPrevented) {\n\t            return;\n\t          }\n\t\n\t          Permission.authorize(permissions, toParams).then(function () {\n\t            // If authorized, use call state.go without triggering the event.\n\t            // Then trigger $stateChangeSuccess manually to resume the rest of the process\n\t            // Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n\t            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n\t              $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams);\n\t\n\t              $state.go(toState.name, toParams, {notify: false}).then(function() {\n\t                $rootScope\n\t                  .$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams);\n\t              });\n\t            }\n\t          }, function () {\n\t            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n\t              $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams);\n\t\n\t              var redirectTo = permissions.redirectTo;\n\t              var result;\n\t\n\t              if (angular.isFunction(redirectTo)) {\n\t                redirectTo = redirectTo();\n\t\n\t                $q.when(redirectTo).then(function (newState) {\n\t                  if (newState) {\n\t                    $state.go(newState, toParams);\n\t                  }\n\t                });\n\t\n\t              } else {\n\t                if (redirectTo) {\n\t                  $state.go(redirectTo, toParams);\n\t                }\n\t              }\n\t            }\n\t          });\n\t        }\n\t      });\n\t    }]);\n\t}());\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular.module('permission')\n\t    .provider('Permission', function () {\n\t      var roleValidationConfig = {};\n\t      var validateRoleDefinitionParams = function (roleName, validationFunction) {\n\t        if (!angular.isString(roleName)) {\n\t          throw new Error('Role name must be a string');\n\t        }\n\t        if (!angular.isFunction(validationFunction)) {\n\t          throw new Error('Validation function not provided correctly');\n\t        }\n\t      };\n\t\n\t      var validateManyRolesDefinitionParams = function(roles, validationFunction) {\n\t        if (!angular.isArray(roles)) {\n\t          throw new Error('Roles must be an array');\n\t        } else {\n\t          for(var i = 0; i < roles.length; i++) {\n\t            validateRoleDefinitionParams(roles[i], validationFunction);\n\t          }\n\t        }\n\t      };\n\t\n\t      this.defineRole = function (roleName, validationFunction) {\n\t        /**\n\t          This method is only available in config-time, and cannot access services, as they are\n\t          not yet injected anywere which makes this kinda useless.\n\t          Should remove if we cannot find a use for it.\n\t        **/\n\t        validateRoleDefinitionParams(roleName, validationFunction);\n\t        roleValidationConfig[roleName] = validationFunction;\n\t\n\t        return this;\n\t      };\n\t\n\t      this.$get = ['$q', function ($q) {\n\t        var Permission = {\n\t          _promiseify: function (value) {\n\t            /**\n\t              Converts a value into a promise, if the value is truthy it resolves it, otherwise\n\t              it rejects it\n\t            **/\n\t            if (value && angular.isFunction(value.then)) {\n\t              return value;\n\t            }\n\t\n\t            var deferred = $q.defer();\n\t            if (value) {\n\t              deferred.resolve();\n\t            } else {\n\t              deferred.reject();\n\t            }\n\t            return deferred.promise;\n\t          },\n\t          _validateRoleMap: function (roleMap) {\n\t            if (typeof(roleMap) !== 'object' || roleMap instanceof Array) {\n\t              throw new Error('Role map has to be an object');\n\t            }\n\t            if (roleMap.only === undefined && roleMap.except === undefined) {\n\t              throw new Error('Either \"only\" or \"except\" keys must me defined');\n\t            }\n\t            if (roleMap.only) {\n\t              if (!(roleMap.only instanceof Array)) {\n\t                throw new Error('Array of roles expected');\n\t              }\n\t            } else if (roleMap.except) {\n\t              if (!(roleMap.except instanceof Array)) {\n\t                throw new Error('Array of roles expected');\n\t              }\n\t            }\n\t          },\n\t          _findMatchingRole: function (rolesArray, toParams) {\n\t            var roles = angular.copy(rolesArray);\n\t            var deferred = $q.defer();\n\t            var currentRole = roles.shift();\n\t\n\t            // If no roles left to validate reject promise\n\t            if (!currentRole) {\n\t              deferred.reject();\n\t              return deferred.promise;\n\t            }\n\t            // Validate role definition exists\n\t            if (!angular.isFunction(Permission.roleValidations[currentRole])) {\n\t              throw new Error('undefined role or invalid role validation');\n\t            }\n\t\n\t            var validatingRole = Permission.roleValidations[currentRole](toParams, currentRole);\n\t            validatingRole = Permission._promiseify(validatingRole);\n\t\n\t            validatingRole.then(function () {\n\t              deferred.resolve();\n\t            }, function () {\n\t              Permission._findMatchingRole(roles, toParams).then(function () {\n\t                deferred.resolve();\n\t              }, function () {\n\t                deferred.reject();\n\t              });\n\t            });\n\t\n\t            return deferred.promise;\n\t          },\n\t          defineRole: function (roleName, validationFunction) {\n\t            /**\n\t              Service-available version of defineRole, the callback passed here lives in the\n\t              scope where it is defined and therefore can interact with other modules\n\t            **/\n\t            validateRoleDefinitionParams(roleName, validationFunction);\n\t            Permission.roleValidations[roleName] = validationFunction;\n\t\n\t            return Permission;\n\t          },\n\t          defineManyRoles: function(roles, validationFunction) {\n\t            validateManyRolesDefinitionParams(roles, validationFunction);\n\t\n\t            var definedPermissions = Permission;\n\t            for(var i = 0; i < roles.length; i++) {\n\t               definedPermissions = definedPermissions.defineRole(roles[i], validationFunction);\n\t            }\n\t\n\t            return definedPermissions;\n\t          },\n\t          resolveIfMatch: function (rolesArray, toParams) {\n\t            var roles = angular.copy(rolesArray);\n\t            var deferred = $q.defer();\n\t            Permission._findMatchingRole(roles, toParams).then(function () {\n\t              // Found role match\n\t              deferred.resolve();\n\t            }, function () {\n\t              // No match\n\t              deferred.reject();\n\t            });\n\t            return deferred.promise;\n\t          },\n\t          rejectIfMatch: function (roles, toParams) {\n\t            var deferred = $q.defer();\n\t            Permission._findMatchingRole(roles, toParams).then(function () {\n\t              // Role found\n\t              deferred.reject();\n\t            }, function () {\n\t              // Role not found\n\t              deferred.resolve();\n\t            });\n\t            return deferred.promise;\n\t          },\n\t          roleValidations: roleValidationConfig,\n\t          authorize: function (roleMap, toParams) {\n\t            // Validate input\n\t            Permission._validateRoleMap(roleMap);\n\t\n\t            var authorizing;\n\t\n\t            if (roleMap.only) {\n\t              authorizing = Permission.resolveIfMatch(roleMap.only, toParams);\n\t            } else {\n\t              authorizing = Permission.rejectIfMatch(roleMap.except, toParams);\n\t            }\n\t\n\t            return authorizing;\n\t          }\n\t        };\n\t\n\t        return Permission;\n\t      }];\n\t    });\n\t\n\t}());\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(31);\n\tmodule.exports = 'ui.bootstrap';\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n\t * @author Mark Lagendijk <mark@lagendijk.info>\r\n\t * @license MIT\r\n\t */\r\n\tangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n\t    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n\t        var self = this;\r\n\t\r\n\t        /**\r\n\t         * Recursively sets the states using $stateProvider.state.\r\n\t         * Child states are defined via a `children` property.\r\n\t         *\r\n\t         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n\t         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n\t         * 3. Sets `parent` property of the descendant states.\r\n\t         *\r\n\t         * @param {Object} state - A regular ui.router state object.\r\n\t         * @param {Array} [state.children] - An optional array of child states.\r\n\t         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n\t         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n\t         * @param {Object} [options] - An optional options object.\r\n\t         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n\t         *     prevents conversion of names to dot notation if true.\r\n\t         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n\t         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n\t         */\r\n\t        this.state = function(state){\r\n\t            var args = Array.prototype.slice.apply(arguments);\r\n\t            var options = {\r\n\t                keepOriginalNames: false,\r\n\t                siblingTraversal: false\r\n\t            };  \r\n\t\r\n\t            if (typeof args[1] === 'boolean') {\r\n\t                options.keepOriginalNames = args[1];\r\n\t            } \r\n\t            else if (typeof args[1] === 'object') {\r\n\t                angular.extend(options, args[1]);\r\n\t            }\r\n\t\r\n\t            if (!options.keepOriginalNames) {\r\n\t                fixStateName(state);\r\n\t            }\r\n\t\r\n\t            $stateProvider.state(state);\r\n\t\r\n\t            if(state.children && state.children.length){\r\n\t                state.children.forEach(function(childState){\r\n\t                    childState.parent = state;\r\n\t                    self.state(childState, options);\r\n\t                });\r\n\t\r\n\t                if (options.siblingTraversal) {\r\n\t                    addSiblings(state);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return self;\r\n\t        };\r\n\t\r\n\t        this.setNestedState = this.state;\r\n\t\r\n\t        self.$get = angular.noop;\r\n\t\r\n\t        /**\r\n\t         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n\t         * @param state\r\n\t         */\r\n\t        function fixStateName(state){\r\n\t            if(state.parent){\r\n\t                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        function addSiblings(state) {\r\n\t            state.children.forEach(function (childState, idx, array) {\r\n\t                if (array[idx + 1]) {\r\n\t                    childState.nextSibling = array[idx + 1].name;\r\n\t                }\r\n\t                if (array[idx - 1]) {\r\n\t                    childState.previousSibling = array[idx - 1].name;\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t    }]);\r\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t/**\n\t * State-based routing for AngularJS\n\t * @version v0.2.15\n\t * @link http://angular-ui.github.com/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n\t  module.exports = 'ui.router';\n\t}\n\t\n\t(function (window, angular, undefined) {\n\t/*jshint globalstrict:true*/\n\t/*global angular:false*/\n\t'use strict';\n\t\n\tvar isDefined = angular.isDefined,\n\t    isFunction = angular.isFunction,\n\t    isString = angular.isString,\n\t    isObject = angular.isObject,\n\t    isArray = angular.isArray,\n\t    forEach = angular.forEach,\n\t    extend = angular.extend,\n\t    copy = angular.copy;\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n\t}\n\t\n\tfunction merge(dst) {\n\t  forEach(arguments, function(obj) {\n\t    if (obj !== dst) {\n\t      forEach(obj, function(value, key) {\n\t        if (!dst.hasOwnProperty(key)) dst[key] = value;\n\t      });\n\t    }\n\t  });\n\t  return dst;\n\t}\n\t\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Object.keys()`.\n\t *\n\t * @param {Object} object A JavaScript object.\n\t * @return {Array} Returns the keys of the object as an array.\n\t */\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  forEach(object, function(val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Array.prototype.indexOf()`.\n\t *\n\t * @param {Array} array A JavaScript array.\n\t * @param {*} value A value to search the array for.\n\t * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n\t */\n\tfunction indexOf(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Merges a set of parameters with all parameters inherited between the common parents of the\n\t * current state and a given destination state.\n\t *\n\t * @param {Object} currentParams The value of the current state parameters ($stateParams).\n\t * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t * @param {Object} $current Internal definition of object representing the current state.\n\t * @param {Object} $to Internal definition of object representing state to transition to.\n\t */\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i].params) continue;\n\t    parentParams = objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t  if (!keys) {\n\t    keys = [];\n\t    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t  }\n\t\n\t  for (var i=0; i<keys.length; i++) {\n\t    var k = keys[i];\n\t    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Returns the subset of an object, based on a list of keys.\n\t *\n\t * @param {Array} keys\n\t * @param {Object} values\n\t * @return {Boolean} Returns a subset of `values`.\n\t */\n\tfunction filterByKeys(keys, values) {\n\t  var filtered = {};\n\t\n\t  forEach(keys, function (name) {\n\t    filtered[name] = values[name];\n\t  });\n\t  return filtered;\n\t}\n\t\n\t// like _.indexBy\n\t// when you know that your index values will be unique, or you want last-one-in to win\n\tfunction indexBy(array, propName) {\n\t  var result = {};\n\t  forEach(array, function(item) {\n\t    result[item[propName]] = item;\n\t  });\n\t  return result;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object only containing the whitelisted properties.\n\tfunction pick(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  forEach(keys, function(key) {\n\t    if (key in obj) copy[key] = obj[key];\n\t  });\n\t  return copy;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object omitting the blacklisted properties.\n\tfunction omit(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  for (var key in obj) {\n\t    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n\t  }\n\t  return copy;\n\t}\n\t\n\tfunction pluck(collection, key) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = isFunction(key) ? key(val) : val[key];\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction filter(collection, callback) {\n\t  var array = isArray(collection);\n\t  var result = array ? [] : {};\n\t  forEach(collection, function(val, i) {\n\t    if (callback(val, i)) {\n\t      result[array ? result.length : i] = val;\n\t    }\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction map(collection, callback) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = callback(val, i);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t * \n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t * \n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t * \n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t * \n\t * ## The main module for ui.router \n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes. \n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router - \n\t * \n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t * \n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.state']);\n\t\n\tangular.module('ui.router.compat', ['ui.router']);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$resolve\n\t *\n\t * @requires $q\n\t * @requires $injector\n\t *\n\t * @description\n\t * Manages resolution of (acyclic) graphs of promises.\n\t */\n\t$Resolve.$inject = ['$q', '$injector'];\n\tfunction $Resolve(  $q,    $injector) {\n\t  \n\t  var VISIT_IN_PROGRESS = 1,\n\t      VISIT_DONE = 2,\n\t      NOTHING = {},\n\t      NO_DEPENDENCIES = [],\n\t      NO_LOCALS = NOTHING,\n\t      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\t  \n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#study\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Studies a set of invocables that are likely to be used multiple times.\n\t   * <pre>\n\t   * $resolve.study(invocables)(locals, parent, self)\n\t   * </pre>\n\t   * is equivalent to\n\t   * <pre>\n\t   * $resolve.resolve(invocables, locals, parent, self)\n\t   * </pre>\n\t   * but the former is more efficient (in fact `resolve` just calls `study` \n\t   * internally).\n\t   *\n\t   * @param {object} invocables Invocable objects\n\t   * @return {function} a function to pass in locals, parent and self\n\t   */\n\t  this.study = function (invocables) {\n\t    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\t    var invocableKeys = objectKeys(invocables || {});\n\t    \n\t    // Perform a topological sort of invocables to build an ordered plan\n\t    var plan = [], cycle = [], visited = {};\n\t    function visit(value, key) {\n\t      if (visited[key] === VISIT_DONE) return;\n\t      \n\t      cycle.push(key);\n\t      if (visited[key] === VISIT_IN_PROGRESS) {\n\t        cycle.splice(0, indexOf(cycle, key));\n\t        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n\t      }\n\t      visited[key] = VISIT_IN_PROGRESS;\n\t      \n\t      if (isString(value)) {\n\t        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n\t      } else {\n\t        var params = $injector.annotate(value);\n\t        forEach(params, function (param) {\n\t          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n\t        });\n\t        plan.push(key, value, params);\n\t      }\n\t      \n\t      cycle.pop();\n\t      visited[key] = VISIT_DONE;\n\t    }\n\t    forEach(invocables, visit);\n\t    invocables = cycle = visited = null; // plan is all that's required\n\t    \n\t    function isResolve(value) {\n\t      return isObject(value) && value.then && value.$$promises;\n\t    }\n\t    \n\t    return function (locals, parent, self) {\n\t      if (isResolve(locals) && self === undefined) {\n\t        self = parent; parent = locals; locals = null;\n\t      }\n\t      if (!locals) locals = NO_LOCALS;\n\t      else if (!isObject(locals)) {\n\t        throw new Error(\"'locals' must be an object\");\n\t      }       \n\t      if (!parent) parent = NO_PARENT;\n\t      else if (!isResolve(parent)) {\n\t        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n\t      }\n\t      \n\t      // To complete the overall resolution, we have to wait for the parent\n\t      // promise and for the promise for each invokable in our plan.\n\t      var resolution = $q.defer(),\n\t          result = resolution.promise,\n\t          promises = result.$$promises = {},\n\t          values = extend({}, locals),\n\t          wait = 1 + plan.length/3,\n\t          merged = false;\n\t          \n\t      function done() {\n\t        // Merge parent values we haven't got yet and publish our own $$values\n\t        if (!--wait) {\n\t          if (!merged) merge(values, parent.$$values); \n\t          result.$$values = values;\n\t          result.$$promises = result.$$promises || true; // keep for isResolve()\n\t          delete result.$$inheritedValues;\n\t          resolution.resolve(values);\n\t        }\n\t      }\n\t      \n\t      function fail(reason) {\n\t        result.$$failure = reason;\n\t        resolution.reject(reason);\n\t      }\n\t\n\t      // Short-circuit if parent has already failed\n\t      if (isDefined(parent.$$failure)) {\n\t        fail(parent.$$failure);\n\t        return result;\n\t      }\n\t      \n\t      if (parent.$$inheritedValues) {\n\t        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n\t      }\n\t\n\t      // Merge parent values if the parent has already resolved, or merge\n\t      // parent promises and wait if the parent resolve is still in progress.\n\t      extend(promises, parent.$$promises);\n\t      if (parent.$$values) {\n\t        merged = merge(values, omit(parent.$$values, invocableKeys));\n\t        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n\t        done();\n\t      } else {\n\t        if (parent.$$inheritedValues) {\n\t          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n\t        }        \n\t        parent.then(done, fail);\n\t      }\n\t      \n\t      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n\t      for (var i=0, ii=plan.length; i<ii; i+=3) {\n\t        if (locals.hasOwnProperty(plan[i])) done();\n\t        else invoke(plan[i], plan[i+1], plan[i+2]);\n\t      }\n\t      \n\t      function invoke(key, invocable, params) {\n\t        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n\t        var invocation = $q.defer(), waitParams = 0;\n\t        function onfailure(reason) {\n\t          invocation.reject(reason);\n\t          fail(reason);\n\t        }\n\t        // Wait for any parameter that we have a promise for (either from parent or from this\n\t        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n\t        forEach(params, function (dep) {\n\t          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n\t            waitParams++;\n\t            promises[dep].then(function (result) {\n\t              values[dep] = result;\n\t              if (!(--waitParams)) proceed();\n\t            }, onfailure);\n\t          }\n\t        });\n\t        if (!waitParams) proceed();\n\t        function proceed() {\n\t          if (isDefined(result.$$failure)) return;\n\t          try {\n\t            invocation.resolve($injector.invoke(invocable, self, values));\n\t            invocation.promise.then(function (result) {\n\t              values[key] = result;\n\t              done();\n\t            }, onfailure);\n\t          } catch (e) {\n\t            onfailure(e);\n\t          }\n\t        }\n\t        // Publish promise synchronously; invocations further down in the plan may depend on it.\n\t        promises[key] = invocation.promise;\n\t      }\n\t      \n\t      return result;\n\t    };\n\t  };\n\t  \n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#resolve\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Resolves a set of invocables. An invocable is a function to be invoked via \n\t   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n\t   * An invocable can either return a value directly,\n\t   * or a `$q` promise. If a promise is returned it will be resolved and the \n\t   * resulting value will be used instead. Dependencies of invocables are resolved \n\t   * (in this order of precedence)\n\t   *\n\t   * - from the specified `locals`\n\t   * - from another invocable that is part of this `$resolve` call\n\t   * - from an invocable that is inherited from a `parent` call to `$resolve` \n\t   *   (or recursively\n\t   * - from any ancestor `$resolve` of that parent).\n\t   *\n\t   * The return value of `$resolve` is a promise for an object that contains \n\t   * (in this order of precedence)\n\t   *\n\t   * - any `locals` (if specified)\n\t   * - the resolved return values of all injectables\n\t   * - any values inherited from a `parent` call to `$resolve` (if specified)\n\t   *\n\t   * The promise will resolve after the `parent` promise (if any) and all promises \n\t   * returned by injectables have been resolved. If any invocable \n\t   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n\t   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n\t   * same error. A rejection of a `parent` promise (if specified) will likewise be \n\t   * propagated immediately. Once the `$resolve` promise has been rejected, no \n\t   * further invocables will be called.\n\t   * \n\t   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n\t   * to throw an error. As a special case, an injectable can depend on a parameter \n\t   * with the same name as the injectable, which will be fulfilled from the `parent` \n\t   * injectable of the same name. This allows inherited values to be decorated. \n\t   * Note that in this case any other injectable in the same `$resolve` with the same\n\t   * dependency would see the decorated value, not the inherited value.\n\t   *\n\t   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n\t   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n\t   * exception.\n\t   *\n\t   * Invocables are invoked eagerly as soon as all dependencies are available. \n\t   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n\t   *\n\t   * As a special case, an invocable can be a string, in which case it is taken to \n\t   * be a service name to be passed to `$injector.get()`. This is supported primarily \n\t   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n\t   * routes.\n\t   *\n\t   * @param {object} invocables functions to invoke or \n\t   * `$injector` services to fetch.\n\t   * @param {object} locals  values to make available to the injectables\n\t   * @param {object} parent  a promise returned by another call to `$resolve`.\n\t   * @param {object} self  the `this` for the invoked methods\n\t   * @return {object} Promise for an object that contains the resolved return value\n\t   * of all invocables, as well as any inherited and local values.\n\t   */\n\t  this.resolve = function (invocables, locals, parent, self) {\n\t    return this.study(invocables)(locals, parent, self);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$resolve', $Resolve);\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$templateFactory\n\t *\n\t * @requires $http\n\t * @requires $templateCache\n\t * @requires $injector\n\t *\n\t * @description\n\t * Service. Manages loading of templates.\n\t */\n\t$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n\tfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromConfig\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a configuration object. \n\t   *\n\t   * @param {object} config Configuration object for which to load a template. \n\t   * The following properties are search in the specified order, and the first one \n\t   * that is defined is used to create the template:\n\t   *\n\t   * @param {string|object} config.template html string template or function to \n\t   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n\t   * @param {string|object} config.templateUrl url to load or a function returning \n\t   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n\t   * @param {Function} config.templateProvider function to invoke via \n\t   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n\t   * @param {object} params  Parameters to pass to the template function.\n\t   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n\t   * via a `templateProvider`. Defaults to `{ params: params }`.\n\t   *\n\t   * @return {string|object}  The template html as a string, or a promise for \n\t   * that string,or `null` if no template is configured.\n\t   */\n\t  this.fromConfig = function (config, params, locals) {\n\t    return (\n\t      isDefined(config.template) ? this.fromString(config.template, params) :\n\t      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n\t      null\n\t    );\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromString\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a string or a function returning a string.\n\t   *\n\t   * @param {string|object} template html template as a string or function that \n\t   * returns an html template as a string.\n\t   * @param {object} params Parameters to pass to the template function.\n\t   *\n\t   * @return {string|object} The template html as a string, or a promise for that \n\t   * string.\n\t   */\n\t  this.fromString = function (template, params) {\n\t    return isFunction(template) ? template(params) : template;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromUrl\n\t   * @methodOf ui.router.util.$templateFactory\n\t   * \n\t   * @description\n\t   * Loads a template from the a URL via `$http` and `$templateCache`.\n\t   *\n\t   * @param {string|Function} url url of the template to load, or a function \n\t   * that returns a url.\n\t   * @param {Object} params Parameters to pass to the url function.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromUrl = function (url, params) {\n\t    if (isFunction(url)) url = url(params);\n\t    if (url == null) return null;\n\t    else return $http\n\t        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n\t        .then(function(response) { return response.data; });\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromProvider\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template by invoking an injectable provider function.\n\t   *\n\t   * @param {Function} provider Function to invoke via `$injector.invoke`\n\t   * @param {Object} params Parameters for the template.\n\t   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n\t   * `{ params: params }`.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromProvider = function (provider, params, locals) {\n\t    return $injector.invoke(provider, null, locals || { params: params });\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\t\n\tvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t *\n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon\n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash:\n\t * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n\t *   an existing UrlMatcher\n\t *\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} source  The pattern that was passed into the constructor\n\t *\n\t * @property {string} sourcePath  The path portion of the source property\n\t *\n\t * @property {string} sourceSearch  The search portion of the source property\n\t *\n\t * @property {string} regex  The constructed regex that will be used to match against the url when\n\t *   it is time to determine which url will match.\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tfunction UrlMatcher(pattern, config, parentMatcher) {\n\t  config = extend({ params: {} }, isObject(config) ? config : {});\n\t\n\t  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t  //   '*' name\n\t  //   ':' name\n\t  //   '{' name '}'\n\t  //   '{' name ':' regexp '}'\n\t  // The regular expression is somewhat complicated due to the need to allow curly braces\n\t  // inside the regular expression. The placeholder regexp breaks down as follows:\n\t  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t  //    \\{([\\w\\[\\]]+)(?:\\:( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t  //    \\\\.                            - a backslash escape\n\t  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      searchPlaceholder = /([:]?)([\\w\\[\\]-]+)|\\{([\\w\\[\\]-]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      compiled = '^', last = 0, m,\n\t      segments = this.segments = [],\n\t      parentParams = parentMatcher ? parentMatcher.params : {},\n\t      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n\t      paramNames = [];\n\t\n\t  function addParameter(id, type, config, location) {\n\t    paramNames.push(id);\n\t    if (parentParams[id]) return parentParams[id];\n\t    if (!/^\\w+(-+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    params[id] = new $$UMFP.Param(id, type, config, location);\n\t    return params[id];\n\t  }\n\t\n\t  function quoteRegExp(string, pattern, squash, optional) {\n\t    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!pattern) return result;\n\t    switch(squash) {\n\t      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n\t      case true:  surroundPattern = ['?(', ')?']; break;\n\t      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n\t    }\n\t    return result + surroundPattern[0] + pattern + surroundPattern[1];\n\t  }\n\t\n\t  this.source = pattern;\n\t\n\t  // Split into static segments separated by path parameter placeholders.\n\t  // The number of segments is always 1 more than the number of parameters.\n\t  function matchDetails(m, isSearch) {\n\t    var id, regexp, segment, type, cfg, arrayMode;\n\t    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n\t    cfg         = config.params[id];\n\t    segment     = pattern.substring(last, m.index);\n\t    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\t    type        = $$UMFP.type(regexp || \"string\") || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n\t    return {\n\t      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n\t    };\n\t  }\n\t\n\t  var p, param, segment;\n\t  while ((m = placeholder.exec(pattern))) {\n\t    p = matchDetails(m, false);\n\t    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\t\n\t    param = addParameter(p.id, p.type, p.cfg, \"path\");\n\t    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n\t    segments.push(p.segment);\n\t    last = placeholder.lastIndex;\n\t  }\n\t  segment = pattern.substring(last);\n\t\n\t  // Find any search parameter names and remove them from the last segment\n\t  var i = segment.indexOf('?');\n\t\n\t  if (i >= 0) {\n\t    var search = this.sourceSearch = segment.substring(i);\n\t    segment = segment.substring(0, i);\n\t    this.sourcePath = pattern.substring(0, last + i);\n\t\n\t    if (search.length > 0) {\n\t      last = 0;\n\t      while ((m = searchPlaceholder.exec(search))) {\n\t        p = matchDetails(m, true);\n\t        param = addParameter(p.id, p.type, p.cfg, \"search\");\n\t        last = placeholder.lastIndex;\n\t        // check if ?&\n\t      }\n\t    }\n\t  } else {\n\t    this.sourcePath = pattern;\n\t    this.sourceSearch = '';\n\t  }\n\t\n\t  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n\t  segments.push(segment);\n\t\n\t  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n\t  this.prefix = segments[0];\n\t  this.$$paramNames = paramNames;\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#concat\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns a new matcher for a pattern constructed by appending the path part and adding the\n\t * search parameters of the specified pattern to this pattern. The current pattern is not\n\t * modified. This can be understood as creating a pattern for URLs that are relative to (or\n\t * suffixes of) the current pattern.\n\t *\n\t * @example\n\t * The following two matchers are equivalent:\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').concat('/details?date');\n\t * new UrlMatcher('/user/{id}/details?q&date');\n\t * </pre>\n\t *\n\t * @param {string} pattern  The pattern to append.\n\t * @param {Object} config  An object hash of the configuration for the matcher.\n\t * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n\t */\n\tUrlMatcher.prototype.concat = function (pattern, config) {\n\t  // Because order of search parameters is irrelevant, we can add our own search\n\t  // parameters to the end of the new pattern. Parse the new pattern by itself\n\t  // and then join the bits together, but it's much easier to do this on a string level.\n\t  var defaultConfig = {\n\t    caseInsensitive: $$UMFP.caseInsensitive(),\n\t    strict: $$UMFP.strictMode(),\n\t    squash: $$UMFP.defaultSquashPolicy()\n\t  };\n\t  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n\t};\n\t\n\tUrlMatcher.prototype.toString = function () {\n\t  return this.source;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#exec\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Tests the specified path against this matcher, and returns an object containing the captured\n\t * parameter values, or null if the path does not match. The returned object contains the values\n\t * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t * they are not present in `searchParams`. This means that search parameters are always treated\n\t * as optional.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t *   x: '1', q: 'hello'\n\t * });\n\t * // returns { id: 'bob', q: 'hello', r: null }\n\t * </pre>\n\t *\n\t * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n\t * @returns {Object}  The captured parameter values.\n\t */\n\tUrlMatcher.prototype.exec = function (path, searchParams) {\n\t  var m = this.regexp.exec(path);\n\t  if (!m) return null;\n\t  searchParams = searchParams || {};\n\t\n\t  var paramNames = this.parameters(), nTotal = paramNames.length,\n\t    nPath = this.segments.length - 1,\n\t    values = {}, i, j, cfg, paramName;\n\t\n\t  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\t\n\t  function decodePathArray(string) {\n\t    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n\t    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\t\n\t    var split = reverseString(string).split(/-(?!\\\\)/);\n\t    var allReversed = map(split, reverseString);\n\t    return map(allReversed, unquoteDashes).reverse();\n\t  }\n\t\n\t  for (i = 0; i < nPath; i++) {\n\t    paramName = paramNames[i];\n\t    var param = this.params[paramName];\n\t    var paramVal = m[i+1];\n\t    // if the param value matches a pre-replace pair, replace the value before decoding.\n\t    for (j = 0; j < param.replace; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t  for (/**/; i < nTotal; i++) {\n\t    paramName = paramNames[i];\n\t    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n\t  }\n\t\n\t  return values;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#parameters\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns the names of all path and search parameters of this pattern in an unspecified order.\n\t *\n\t * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n\t *    pattern has no parameters, an empty array is returned.\n\t */\n\tUrlMatcher.prototype.parameters = function (param) {\n\t  if (!isDefined(param)) return this.$$paramNames;\n\t  return this.params[param] || null;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#validate\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Checks an object hash of parameters to validate their correctness according to the parameter\n\t * types of this `UrlMatcher`.\n\t *\n\t * @param {Object} params The object hash of parameters to validate.\n\t * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t */\n\tUrlMatcher.prototype.validates = function (params) {\n\t  return this.params.$$validates(params);\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#format\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Creates a URL that matches this pattern by substituting the specified values\n\t * for the path and search parameters. Null values for path parameters are\n\t * treated as empty strings.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t * // returns '/user/bob?q=yes'\n\t * </pre>\n\t *\n\t * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t * @returns {string}  the formatted URL (path and optionally search part).\n\t */\n\tUrlMatcher.prototype.format = function (values) {\n\t  values = values || {};\n\t  var segments = this.segments, params = this.parameters(), paramset = this.params;\n\t  if (!this.validates(values)) return null;\n\t\n\t  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\t\n\t  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n\t    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t  }\n\t\n\t  for (i = 0; i < nTotal; i++) {\n\t    var isPathParam = i < nPath;\n\t    var name = params[i], param = paramset[name], value = param.value(values[name]);\n\t    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n\t    var squash = isDefaultValue ? param.squash : false;\n\t    var encoded = param.type.encode(value);\n\t\n\t    if (isPathParam) {\n\t      var nextSegment = segments[i + 1];\n\t      if (squash === false) {\n\t        if (encoded != null) {\n\t          if (isArray(encoded)) {\n\t            result += map(encoded, encodeDashes).join(\"-\");\n\t          } else {\n\t            result += encodeURIComponent(encoded);\n\t          }\n\t        }\n\t        result += nextSegment;\n\t      } else if (squash === true) {\n\t        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n\t        result += nextSegment.match(capture)[1];\n\t      } else if (isString(squash)) {\n\t        result += squash + nextSegment;\n\t      }\n\t    } else {\n\t      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n\t      if (!isArray(encoded)) encoded = [ encoded ];\n\t      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n\t      result += (search ? '&' : '?') + (name + '=' + encoded);\n\t      search = true;\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:Type\n\t *\n\t * @description\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n\t * information on registering custom types.\n\t *\n\t * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n\t *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t * @example\n\t * <pre>\n\t * {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t * </pre>\n\t *\n\t * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n\t *           coming from a substring of a URL.\n\t *\n\t * @returns {Object}  Returns a new `Type` object.\n\t */\n\tfunction Type(config) {\n\t  extend(this, config);\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#is\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Detects whether a value is of a particular type. Accepts a native (decoded) value\n\t * and determines whether it matches the current `Type` object.\n\t *\n\t * @param {*} val  The value to check.\n\t * @param {string} key  Optional. If the type check is happening in the context of a specific\n\t *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n\t *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n\t * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n\t */\n\tType.prototype.is = function(val, key) {\n\t  return true;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#encode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n\t * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n\t * only needs to be a representation of `val` that has been coerced to a string.\n\t *\n\t * @param {*} val  The value to encode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n\t */\n\tType.prototype.encode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#decode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Converts a parameter value (from URL string or transition param) to a custom/native value.\n\t *\n\t * @param {string} val  The URL parameter value to decode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {*}  Returns a custom representation of the URL parameter value.\n\t */\n\tType.prototype.decode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#equals\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Determines whether two decoded values are equivalent.\n\t *\n\t * @param {*} a  A value to compare against.\n\t * @param {*} b  A value to compare against.\n\t * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n\t */\n\tType.prototype.equals = function(a, b) {\n\t  return a == b;\n\t};\n\t\n\tType.prototype.$subPattern = function() {\n\t  var sub = this.pattern.toString();\n\t  return sub.substr(1, sub.length - 2);\n\t};\n\t\n\tType.prototype.pattern = /.*/;\n\t\n\tType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\t\n\t/** Given an encoded string, or a decoded object, returns a decoded object */\n\tType.prototype.$normalize = function(val) {\n\t  return this.is(val) ? val : this.decode(val);\n\t};\n\t\n\t/*\n\t * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t * e.g.:\n\t * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t * - url: \"/path?queryParam=1&queryParam=2\n\t * - $stateParams.queryParam will be [1, 2]\n\t * if `mode` is \"auto\", then\n\t * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t */\n\tType.prototype.$asArray = function(mode, isSearch) {\n\t  if (!mode) return this;\n\t  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\t\n\t  function ArrayType(type, mode) {\n\t    function bindTo(type, callbackName) {\n\t      return function() {\n\t        return type[callbackName].apply(type, arguments);\n\t      };\n\t    }\n\t\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t      switch(val.length) {\n\t        case 0: return undefined;\n\t        case 1: return mode === \"auto\" ? val[0] : val;\n\t        default: return val;\n\t      }\n\t    }\n\t    function falsey(val) { return !val; }\n\t\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t      return function handleArray(val) {\n\t        val = arrayWrap(val);\n\t        var result = map(val, callback);\n\t        if (allTruthyMode === true)\n\t          return filter(result, falsey).length === 0;\n\t        return arrayUnwrap(result);\n\t      };\n\t    }\n\t\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t      return function handleArray(val1, val2) {\n\t        var left = arrayWrap(val1), right = arrayWrap(val2);\n\t        if (left.length !== right.length) return false;\n\t        for (var i = 0; i < left.length; i++) {\n\t          if (!callback(left[i], right[i])) return false;\n\t        }\n\t        return true;\n\t      };\n\t    }\n\t\n\t    this.encode = arrayHandler(bindTo(type, 'encode'));\n\t    this.decode = arrayHandler(bindTo(type, 'decode'));\n\t    this.is     = arrayHandler(bindTo(type, 'is'), true);\n\t    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n\t    this.pattern = type.pattern;\n\t    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n\t    this.name = type.name;\n\t    this.$arrayMode = mode;\n\t  }\n\t\n\t  return new ArrayType(this, mode);\n\t};\n\t\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$urlMatcherFactory\n\t *\n\t * @description\n\t * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n\t * is also available to providers under the name `$urlMatcherFactoryProvider`.\n\t */\n\tfunction $UrlMatcherFactory() {\n\t  $$UMFP = this;\n\t\n\t  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\t\n\t  function valToString(val) { return val != null ? val.toString().replace(/\\//g, \"%2F\") : val; }\n\t  function valFromString(val) { return val != null ? val.toString().replace(/%2F/g, \"/\") : val; }\n\t\n\t  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n\t    string: {\n\t      encode: valToString,\n\t      decode: valFromString,\n\t      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n\t      // In 0.2.x, string params are optional by default for backwards compat\n\t      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n\t      pattern: /[^/]*/\n\t    },\n\t    int: {\n\t      encode: valToString,\n\t      decode: function(val) { return parseInt(val, 10); },\n\t      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n\t      pattern: /\\d+/\n\t    },\n\t    bool: {\n\t      encode: function(val) { return val ? 1 : 0; },\n\t      decode: function(val) { return parseInt(val, 10) !== 0; },\n\t      is: function(val) { return val === true || val === false; },\n\t      pattern: /0|1/\n\t    },\n\t    date: {\n\t      encode: function (val) {\n\t        if (!this.is(val))\n\t          return undefined;\n\t        return [ val.getFullYear(),\n\t          ('0' + (val.getMonth() + 1)).slice(-2),\n\t          ('0' + val.getDate()).slice(-2)\n\t        ].join(\"-\");\n\t      },\n\t      decode: function (val) {\n\t        if (this.is(val)) return val;\n\t        var match = this.capture.exec(val);\n\t        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t      },\n\t      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n\t      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t    },\n\t    json: {\n\t      encode: angular.toJson,\n\t      decode: angular.fromJson,\n\t      is: angular.isObject,\n\t      equals: angular.equals,\n\t      pattern: /[^/]*/\n\t    },\n\t    any: { // does not encode/decode\n\t      encode: angular.identity,\n\t      decode: angular.identity,\n\t      equals: angular.equals,\n\t      pattern: /.*/\n\t    }\n\t  };\n\t\n\t  function getDefaultConfig() {\n\t    return {\n\t      strict: isStrictMode,\n\t      caseInsensitive: isCaseInsensitive\n\t    };\n\t  }\n\t\n\t  function isInjectable(value) {\n\t    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n\t  }\n\t\n\t  /**\n\t   * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t   */\n\t  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n\t    if (!isInjectable(config.value)) return config.value;\n\t    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t    return injector.invoke(config.value);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t   *\n\t   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t   * @returns {boolean} the current value of caseInsensitive\n\t   */\n\t  this.caseInsensitive = function(value) {\n\t    if (isDefined(value))\n\t      isCaseInsensitive = value;\n\t    return isCaseInsensitive;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#strictMode\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t   *\n\t   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n\t   * @returns {boolean} the current value of strictMode\n\t   */\n\t  this.strictMode = function(value) {\n\t    if (isDefined(value))\n\t      isStrictMode = value;\n\t    return isStrictMode;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Sets the default behavior when generating or matching URLs with default parameter values.\n\t   *\n\t   * @param {string} value A string that defines the default parameter URL squashing behavior.\n\t   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t   *             the parameter value from the URL and replace it with this string.\n\t   */\n\t  this.defaultSquashPolicy = function(value) {\n\t    if (!isDefined(value)) return defaultSquashPolicy;\n\t    if (value !== true && value !== false && !isString(value))\n\t      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t    defaultSquashPolicy = value;\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#compile\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n\t   *\n\t   * @param {string} pattern  The URL pattern.\n\t   * @param {Object} config  The config object hash.\n\t   * @returns {UrlMatcher}  The UrlMatcher.\n\t   */\n\t  this.compile = function (pattern, config) {\n\t    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#isMatcher\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n\t   *\n\t   * @param {Object} object  The object to perform the type check against.\n\t   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n\t   *          implementing all the same methods.\n\t   */\n\t  this.isMatcher = function (o) {\n\t    if (!isObject(o)) return false;\n\t    var result = true;\n\t\n\t    forEach(UrlMatcher.prototype, function(val, name) {\n\t      if (isFunction(val)) {\n\t        result = result && (isDefined(o[name]) && isFunction(o[name]));\n\t      }\n\t    });\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#type\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n\t   * generate URLs with typed parameters.\n\t   *\n\t   * @param {string} name  The type name.\n\t   * @param {Object|Function} definition   The type definition. See\n\t   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n\t   *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   *\n\t   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n\t   *\n\t   * @example\n\t   * This is a simple example of a custom type that encodes and decodes items from an\n\t   * array, using the array index as the URL-encoded value:\n\t   *\n\t   * <pre>\n\t   * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t   *\n\t   * $urlMatcherFactoryProvider.type('listItem', {\n\t   *   encode: function(item) {\n\t   *     // Represent the list item in the URL using its corresponding index\n\t   *     return list.indexOf(item);\n\t   *   },\n\t   *   decode: function(item) {\n\t   *     // Look up the list item by index\n\t   *     return list[parseInt(item, 10)];\n\t   *   },\n\t   *   is: function(item) {\n\t   *     // Ensure the item is valid by checking to see that it appears\n\t   *     // in the list\n\t   *     return list.indexOf(item) > -1;\n\t   *   }\n\t   * });\n\t   *\n\t   * $stateProvider.state('list', {\n\t   *   url: \"/list/{item:listItem}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     console.log($stateParams.item);\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t   * $state.go('list', { item: \"Ringo\" });\n\t   * </pre>\n\t   *\n\t   * This is a more complex example of a type that relies on dependency injection to\n\t   * interact with services, and uses the parameter name from the URL to infer how to\n\t   * handle encoding and decoding parameter values:\n\t   *\n\t   * <pre>\n\t   * // Defines a custom type that gets a value from a service,\n\t   * // where each service gets different types of values from\n\t   * // a backend API:\n\t   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n\t   *\n\t   *   // Matches up services to URL parameter names\n\t   *   var services = {\n\t   *     user: Users,\n\t   *     post: Posts\n\t   *   };\n\t   *\n\t   *   return {\n\t   *     encode: function(object) {\n\t   *       // Represent the object in the URL using its unique ID\n\t   *       return object.id;\n\t   *     },\n\t   *     decode: function(value, key) {\n\t   *       // Look up the object by ID, using the parameter\n\t   *       // name (key) to call the correct service\n\t   *       return services[key].findById(value);\n\t   *     },\n\t   *     is: function(object, key) {\n\t   *       // Check that object is a valid dbObject\n\t   *       return angular.isObject(object) && object.id && services[key];\n\t   *     }\n\t   *     equals: function(a, b) {\n\t   *       // Check the equality of decoded objects by comparing\n\t   *       // their unique IDs\n\t   *       return a.id === b.id;\n\t   *     }\n\t   *   };\n\t   * });\n\t   *\n\t   * // In a config() block, you can then attach URLs with\n\t   * // type-annotated parameters:\n\t   * $stateProvider.state('users', {\n\t   *   url: \"/users\",\n\t   *   // ...\n\t   * }).state('users.item', {\n\t   *   url: \"/{user:dbObject}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     // $stateParams.user will now be an object returned from\n\t   *     // the Users service\n\t   *   },\n\t   *   // ...\n\t   * });\n\t   * </pre>\n\t   */\n\t  this.type = function (name, definition, definitionFn) {\n\t    if (!isDefined(definition)) return $types[name];\n\t    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t\n\t    $types[name] = new Type(extend({ name: name }, definition));\n\t    if (definitionFn) {\n\t      typeQueue.push({ name: name, def: definitionFn });\n\t      if (!enqueue) flushTypeQueue();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n\t  function flushTypeQueue() {\n\t    while(typeQueue.length) {\n\t      var type = typeQueue.shift();\n\t      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t      angular.extend($types[type.name], injector.invoke(type.def));\n\t    }\n\t  }\n\t\n\t  // Register default types. Store them in the prototype of $types.\n\t  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n\t  $types = inherit($types, {});\n\t\n\t  /* No need to document $get, since it returns this */\n\t  this.$get = ['$injector', function ($injector) {\n\t    injector = $injector;\n\t    enqueue = false;\n\t    flushTypeQueue();\n\t\n\t    forEach(defaultTypes, function(type, name) {\n\t      if (!$types[name]) $types[name] = new Type(type);\n\t    });\n\t    return this;\n\t  }];\n\t\n\t  this.Param = function Param(id, type, config, location) {\n\t    var self = this;\n\t    config = unwrapShorthand(config);\n\t    type = getType(config, type, location);\n\t    var arrayMode = getArrayMode();\n\t    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n\t    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n\t      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n\t    var isOptional = config.value !== undefined;\n\t    var squash = getSquashPolicy(config, isOptional);\n\t    var replace = getReplace(config, arrayMode, isOptional, squash);\n\t\n\t    function unwrapShorthand(config) {\n\t      var keys = isObject(config) ? objectKeys(config) : [];\n\t      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n\t                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n\t      if (isShorthand) config = { value: config };\n\t      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n\t      return config;\n\t    }\n\t\n\t    function getType(config, urlType, location) {\n\t      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n\t      if (urlType) return urlType;\n\t      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\t      return config.type instanceof Type ? config.type : new Type(config.type);\n\t    }\n\t\n\t    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t    function getArrayMode() {\n\t      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n\t      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t    }\n\t\n\t    /**\n\t     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t     */\n\t    function getSquashPolicy(config, isOptional) {\n\t      var squash = config.squash;\n\t      if (!isOptional || squash === false) return false;\n\t      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n\t      if (squash === true || isString(squash)) return squash;\n\t      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t    }\n\t\n\t    function getReplace(config, arrayMode, isOptional, squash) {\n\t      var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t      ];\n\t      replace = isArray(config.replace) ? config.replace : [];\n\t      if (isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t      configuredKeys = map(replace, function(item) { return item.from; } );\n\t      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n\t    }\n\t\n\t    /**\n\t     * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t     */\n\t    function $$getDefaultValue() {\n\t      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t      var defaultValue = injector.invoke(config.$$fn);\n\t      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n\t        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n\t      return defaultValue;\n\t    }\n\t\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    function $value(value) {\n\t      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n\t      function $replace(value) {\n\t        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n\t        return replacement.length ? replacement[0] : value;\n\t      }\n\t      value = $replace(value);\n\t      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n\t    }\n\t\n\t    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\t\n\t    extend(this, {\n\t      id: id,\n\t      type: type,\n\t      location: location,\n\t      array: arrayMode,\n\t      squash: squash,\n\t      replace: replace,\n\t      isOptional: isOptional,\n\t      value: $value,\n\t      dynamic: undefined,\n\t      config: config,\n\t      toString: toString\n\t    });\n\t  };\n\t\n\t  function ParamSet(params) {\n\t    extend(this, params || {});\n\t  }\n\t\n\t  ParamSet.prototype = {\n\t    $$new: function() {\n\t      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n\t    },\n\t    $$keys: function () {\n\t      var keys = [], chain = [], parent = this,\n\t        ignore = objectKeys(ParamSet.prototype);\n\t      while (parent) { chain.push(parent); parent = parent.$$parent; }\n\t      chain.reverse();\n\t      forEach(chain, function(paramset) {\n\t        forEach(objectKeys(paramset), function(key) {\n\t            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n\t        });\n\t      });\n\t      return keys;\n\t    },\n\t    $$values: function(paramValues) {\n\t      var values = {}, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        values[key] = self[key].value(paramValues && paramValues[key]);\n\t      });\n\t      return values;\n\t    },\n\t    $$equals: function(paramValues1, paramValues2) {\n\t      var equal = true, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n\t        if (!self[key].type.equals(left, right)) equal = false;\n\t      });\n\t      return equal;\n\t    },\n\t    $$validates: function $$validate(paramValues) {\n\t      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n\t      for (i = 0; i < keys.length; i++) {\n\t        param = this[keys[i]];\n\t        rawVal = paramValues[keys[i]];\n\t        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n\t          break; // There was no parameter value, but the param is optional\n\t        normalized = param.type.$normalize(rawVal);\n\t        if (!param.type.is(normalized))\n\t          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n\t        encoded = param.type.encode(normalized);\n\t        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n\t          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t      }\n\t      return true;\n\t    },\n\t    $$parent: undefined\n\t  };\n\t\n\t  this.ParamSet = ParamSet;\n\t}\n\t\n\t// Register as a provider so it's available to other providers\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\tangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`. \n\t * When `$location` changes it runs through a list of rules one by one until a \n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\t$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n\tfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n\t  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\t\n\t  // Returns a string that is a prefix of all strings matching the RegExp\n\t  function regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t  }\n\t\n\t  // Interpolates matched values into a String.replace()-style pattern\n\t  function interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t      return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#rule\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t   * specific URLs.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // Here's an example of how you might allow case insensitive urls\n\t   *   $urlRouterProvider.rule(function ($injector, $location) {\n\t   *     var path = $location.path(),\n\t   *         normalized = path.toLowerCase();\n\t   *\n\t   *     if (path !== normalized) {\n\t   *       return normalized;\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {object} rule Handler function that takes `$injector` and `$location`\n\t   * services as arguments. You can use them to return a valid path as a string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.rule = function (rule) {\n\t    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    rules.push(rule);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouterProvider#otherwise\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines a path that is used when an invalid route is requested.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // if the path doesn't match any of the urls you configured\n\t   *   // otherwise will take care of routing the user to the\n\t   *   // specified url\n\t   *   $urlRouterProvider.otherwise('/index');\n\t   *\n\t   *   // Example of using function rule as param\n\t   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t   *     return '/a/valid/url';\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} rule The url path you want to redirect to or a function \n\t   * rule that returns the url path. The function version is passed two params: \n\t   * `$injector` and `$location` services, and must return a url string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.otherwise = function (rule) {\n\t    if (isString(rule)) {\n\t      var redirect = rule;\n\t      rule = function () { return redirect; };\n\t    }\n\t    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    otherwise = rule;\n\t    return this;\n\t  };\n\t\n\t\n\t  function handleIfMatch($injector, handler, match) {\n\t    if (!match) return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match });\n\t    return isDefined(result) ? result : true;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#when\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Registers a handler for a given url matching. if handle is a string, it is\n\t   * treated as a redirect, and is interpolated according to the syntax of match\n\t   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t   *\n\t   * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t   * matches. You have the option of inject the match object as `$match`.\n\t   *\n\t   * The handler can return\n\t   *\n\t   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t   *   will continue trying to find another one that matches.\n\t   * - **string** which is treated as a redirect and passed to `$location.url()`\n\t   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t   *     if ($state.$current.navigable !== state ||\n\t   *         !equalForKeys($match, $stateParams) {\n\t   *      $state.transitionTo(state, $match, false);\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} what The incoming path that you want to redirect.\n\t   * @param {string|object} handler The path you want to redirect your user to.\n\t   */\n\t  this.when = function (what, handler) {\n\t    var redirect, handlerIsString = isString(handler);\n\t    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\t\n\t    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n\t      throw new Error(\"invalid 'handler' in when()\");\n\t\n\t    var strategies = {\n\t      matcher: function (what, handler) {\n\t        if (handlerIsString) {\n\t          redirect = $urlMatcherFactory.compile(handler);\n\t          handler = ['$match', function ($match) { return redirect.format($match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n\t        }, {\n\t          prefix: isString(what.prefix) ? what.prefix : ''\n\t        });\n\t      },\n\t      regex: function (what, handler) {\n\t        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\t\n\t        if (handlerIsString) {\n\t          redirect = handler;\n\t          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path()));\n\t        }, {\n\t          prefix: regExpPrefix(what)\n\t        });\n\t      }\n\t    };\n\t\n\t    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\t\n\t    for (var n in check) {\n\t      if (check[n]) return this.rule(strategies[n](what, handler));\n\t    }\n\t\n\t    throw new Error(\"invalid 'what' in when()\");\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Disables (or enables) deferring location change interception.\n\t   *\n\t   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t   * defer a transition but maintain the current URL), call this method at configuration time.\n\t   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t   * `$locationChangeSuccess` event handler.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *\n\t   *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t   *   // this allows you to configure custom behavior in between\n\t   *   // location changes and route synchronization:\n\t   *   $urlRouterProvider.deferIntercept();\n\t   *\n\t   * }).run(function ($rootScope, $urlRouter, UserService) {\n\t   *\n\t   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t   *     // UserService is an example service for managing user state\n\t   *     if (UserService.isLoggedIn()) return;\n\t   *\n\t   *     // Prevent $urlRouter's default handler from firing\n\t   *     e.preventDefault();\n\t   *\n\t   *     UserService.handleLogin().then(function() {\n\t   *       // Once the user has logged in, sync the current URL\n\t   *       // to the router:\n\t   *       $urlRouter.sync();\n\t   *     });\n\t   *   });\n\t   *\n\t   *   // Configures $urlRouter's listener *after* your custom listener\n\t   *   $urlRouter.listen();\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t            no parameter is equivalent to `true`.\n\t   */\n\t  this.deferIntercept = function (defer) {\n\t    if (defer === undefined) defer = true;\n\t    interceptDeferred = defer;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouter\n\t   *\n\t   * @requires $location\n\t   * @requires $rootScope\n\t   * @requires $injector\n\t   * @requires $browser\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n\t  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\t\n\t    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\t\n\t    function appendBasePath(url, isHtml5, absolute) {\n\t      if (baseHref === '/') return url;\n\t      if (isHtml5) return baseHref.slice(0, -1) + url;\n\t      if (absolute) return baseHref.slice(1) + url;\n\t      return url;\n\t    }\n\t\n\t    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t    function update(evt) {\n\t      if (evt && evt.defaultPrevented) return;\n\t      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n\t      lastPushedUrl = undefined;\n\t      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n\t      //if (ignoreUpdate) return true;\n\t\n\t      function check(rule) {\n\t        var handled = rule($injector, $location);\n\t\n\t        if (!handled) return false;\n\t        if (isString(handled)) $location.replace().url(handled);\n\t        return true;\n\t      }\n\t      var n = rules.length, i;\n\t\n\t      for (i = 0; i < n; i++) {\n\t        if (check(rules[i])) return;\n\t      }\n\t      // always check otherwise last to allow dynamic updates to the set of rules\n\t      if (otherwise) check(otherwise);\n\t    }\n\t\n\t    function listen() {\n\t      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n\t      return listener;\n\t    }\n\t\n\t    if (!interceptDeferred) listen();\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#sync\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t       * with the transition by calling `$urlRouter.sync()`.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * angular.module('app', ['ui.router'])\n\t       *   .run(function($rootScope, $urlRouter) {\n\t       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t       *       // Halt state change from even starting\n\t       *       evt.preventDefault();\n\t       *       // Perform custom logic\n\t       *       var meetsRequirement = ...\n\t       *       // Continue with the update and state transition if logic allows\n\t       *       if (meetsRequirement) $urlRouter.sync();\n\t       *     });\n\t       * });\n\t       * </pre>\n\t       */\n\t      sync: function() {\n\t        update();\n\t      },\n\t\n\t      listen: function() {\n\t        return listen();\n\t      },\n\t\n\t      update: function(read) {\n\t        if (read) {\n\t          location = $location.url();\n\t          return;\n\t        }\n\t        if ($location.url() === location) return;\n\t\n\t        $location.url(location);\n\t        $location.replace();\n\t      },\n\t\n\t      push: function(urlMatcher, params, options) {\n\t         var url = urlMatcher.format(params || {});\n\t\n\t        // Handle the special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t            url += '#' + params['#'];\n\t        }\n\t\n\t        $location.url(url);\n\t        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n\t        if (options && options.replace) $location.replace();\n\t      },\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#href\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * A URL generation method that returns the compiled URL for a given\n\t       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t       *   person: \"bob\"\n\t       * });\n\t       * // $bob == \"/about/bob\";\n\t       * </pre>\n\t       *\n\t       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t       * @param {object=} options Options object. The options are:\n\t       *\n\t       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t       *\n\t       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t       */\n\t      href: function(urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params)) return null;\n\t\n\t        var isHtml5 = $locationProvider.html5Mode();\n\t        if (angular.isObject(isHtml5)) {\n\t          isHtml5 = isHtml5.enabled;\n\t        }\n\t        \n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t\n\t        if (!isHtml5 && url !== null) {\n\t          url = \"#\" + $locationProvider.hashPrefix() + url;\n\t        }\n\t\n\t        // Handle special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t          url += '#' + params['#'];\n\t        }\n\t\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\n\t        if (!options.absolute || !url) {\n\t          return url;\n\t        }\n\t\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\n\t        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\t$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n\tfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\t\n\t  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\t\n\t  // Builds state properties from definition passed to registerState()\n\t  var stateBuilder = {\n\t\n\t    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n\t    // state.children = [];\n\t    // if (parent) parent.children.push(state);\n\t    parent: function(state) {\n\t      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n\t      // regex matches any valid composite state name\n\t      // would match \"contact.list\" but not \"contacts\"\n\t      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n\t      return compositeName ? findState(compositeName[1]) : root;\n\t    },\n\t\n\t    // inherit 'data' from parent and override by own values (if any)\n\t    data: function(state) {\n\t      if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = extend({}, state.parent.data, state.data);\n\t      }\n\t      return state.data;\n\t    },\n\t\n\t    // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t    url: function(state) {\n\t      var url = state.url, config = { params: state.params || {} };\n\t\n\t      if (isString(url)) {\n\t        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n\t        return (state.parent.navigable || root).url.concat(url, config);\n\t      }\n\t\n\t      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n\t      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t    },\n\t\n\t    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t    navigable: function(state) {\n\t      return state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    },\n\t\n\t    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n\t    ownParams: function(state) {\n\t      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n\t      forEach(state.params || {}, function(config, id) {\n\t        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n\t      });\n\t      return params;\n\t    },\n\t\n\t    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n\t    params: function(state) {\n\t      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();\n\t    },\n\t\n\t    // If there is no explicit multi-view configuration, make one up so we don't have\n\t    // to handle both cases in the view directive later. Note that having an explicit\n\t    // 'views' property will mean the default unnamed view properties are ignored. This\n\t    // is also a good time to resolve view names to absolute names, so everything is a\n\t    // straight lookup at link time.\n\t    views: function(state) {\n\t      var views = {};\n\t\n\t      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n\t        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n\t        views[name] = view;\n\t      });\n\t      return views;\n\t    },\n\t\n\t    // Keep a full path from the root down to this state as this is needed for state activation.\n\t    path: function(state) {\n\t      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n\t    },\n\t\n\t    // Speed up $state.contains() as it's used a lot\n\t    includes: function(state) {\n\t      var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t      includes[state.name] = true;\n\t      return includes;\n\t    },\n\t\n\t    $delegates: {}\n\t  };\n\t\n\t  function isRelative(stateName) {\n\t    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t  }\n\t\n\t  function findState(stateOrName, base) {\n\t    if (!stateOrName) return undefined;\n\t\n\t    var isStr = isString(stateOrName),\n\t        name  = isStr ? stateOrName : stateOrName.name,\n\t        path  = isRelative(name);\n\t\n\t    if (path) {\n\t      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n\t      base = findState(base);\n\t      \n\t      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\t\n\t      for (; i < pathLength; i++) {\n\t        if (rel[i] === \"\" && i === 0) {\n\t          current = base;\n\t          continue;\n\t        }\n\t        if (rel[i] === \"^\") {\n\t          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n\t          current = current.parent;\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t      rel = rel.slice(i).join(\".\");\n\t      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n\t    }\n\t    var state = states[name];\n\t\n\t    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t      return state;\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function queueState(parentName, state) {\n\t    if (!queue[parentName]) {\n\t      queue[parentName] = [];\n\t    }\n\t    queue[parentName].push(state);\n\t  }\n\t\n\t  function flushQueuedChildren(parentName) {\n\t    var queued = queue[parentName] || [];\n\t    while(queued.length) {\n\t      registerState(queued.shift());\n\t    }\n\t  }\n\t\n\t  function registerState(state) {\n\t    // Wrap a new object around the state so we can store our private details easily.\n\t    state = inherit(state, {\n\t      self: state,\n\t      resolve: state.resolve || {},\n\t      toString: function() { return this.name; }\n\t    });\n\t\n\t    var name = state.name;\n\t    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n\t    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\t\n\t    // Get parent name\n\t    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n\t        : (isString(state.parent)) ? state.parent\n\t        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n\t        : '';\n\t\n\t    // If parent is not registered yet, add state to queue and register later\n\t    if (parentName && !states[parentName]) {\n\t      return queueState(parentName, state.self);\n\t    }\n\t\n\t    for (var key in stateBuilder) {\n\t      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n\t    }\n\t    states[name] = state;\n\t\n\t    // Register the state in the global state list and with $urlRouter if necessary.\n\t    if (!state[abstractKey] && state.url) {\n\t      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n\t          $state.transitionTo(state, $match, { inherit: true, location: false });\n\t        }\n\t      }]);\n\t    }\n\t\n\t    // Register any queued children\n\t    flushQueuedChildren(name);\n\t\n\t    return state;\n\t  }\n\t\n\t  // Checks text to see if it looks like a glob.\n\t  function isGlob (text) {\n\t    return text.indexOf('*') > -1;\n\t  }\n\t\n\t  // Returns true if glob matches current $state name.\n\t  function doesStateMatchGlob (glob) {\n\t    var globSegments = glob.split('.'),\n\t        segments = $state.$current.name.split('.');\n\t\n\t    //match single stars\n\t    for (var i = 0, l = globSegments.length; i < l; i++) {\n\t      if (globSegments[i] === '*') {\n\t        segments[i] = '*';\n\t      }\n\t    }\n\t\n\t    //match greedy starts\n\t    if (globSegments[0] === '**') {\n\t       segments = segments.slice(indexOf(segments, globSegments[1]));\n\t       segments.unshift('**');\n\t    }\n\t    //match greedy ends\n\t    if (globSegments[globSegments.length - 1] === '**') {\n\t       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n\t       segments.push('**');\n\t    }\n\t\n\t    if (globSegments.length != segments.length) {\n\t      return false;\n\t    }\n\t\n\t    return segments.join('') === globSegments.join('');\n\t  }\n\t\n\t\n\t  // Implicit root state that is always active\n\t  root = registerState({\n\t    name: '',\n\t    url: '^',\n\t    views: null,\n\t    'abstract': true\n\t  });\n\t  root.navigable = null;\n\t\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#decorator\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Allows you to extend (carefully) or override (at your own peril) the \n\t   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n\t   * to add custom functionality to ui-router, for example inferring templateUrl \n\t   * based on the state name.\n\t   *\n\t   * When passing only a name, it returns the current (original or decorated) builder\n\t   * function that matches `name`.\n\t   *\n\t   * The builder functions that can be decorated are listed below. Though not all\n\t   * necessarily have a good use case for decoration, that is up to you to decide.\n\t   *\n\t   * In addition, users can attach custom decorators, which will generate new \n\t   * properties within the state's internal definition. There is currently no clear \n\t   * use-case for this beyond accessing internal states (i.e. $state.$current), \n\t   * however, expect this to become increasingly relevant as we introduce additional \n\t   * meta-programming features.\n\t   *\n\t   * **Warning**: Decorators should not be interdependent because the order of \n\t   * execution of the builder functions in non-deterministic. Builder functions \n\t   * should only be dependent on the state definition object and super function.\n\t   *\n\t   *\n\t   * Existing builder functions and current return values:\n\t   *\n\t   * - **parent** `{object}` - returns the parent state object.\n\t   * - **data** `{object}` - returns state data, including any inherited data that is not\n\t   *   overridden by own values (if any).\n\t   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t   *   or `null`.\n\t   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n\t   *   navigable).\n\t   * - **params** `{object}` - returns an array of state params that are ensured to \n\t   *   be a super-set of parent's params.\n\t   * - **views** `{object}` - returns a views object where each key is an absolute view \n\t   *   name (i.e. \"viewName@stateName\") and each value is the config object \n\t   *   (template, controller) for the view. Even when you don't use the views object \n\t   *   explicitly on a state config, one is still created for you internally.\n\t   *   So by decorating this builder function you have access to decorating template \n\t   *   and controller properties.\n\t   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n\t   *   not including any params defined by ancestor states.\n\t   * - **path** `{string}` - returns the full path from the root down to this state. \n\t   *   Needed for state activation.\n\t   * - **includes** `{object}` - returns an object that includes every state that \n\t   *   would pass a `$state.includes()` test.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Override the internal 'views' builder with a function that takes the state\n\t   * // definition, and a reference to the internal function being overridden:\n\t   * $stateProvider.decorator('views', function (state, parent) {\n\t   *   var result = {},\n\t   *       views = parent(state);\n\t   *\n\t   *   angular.forEach(views, function (config, name) {\n\t   *     var autoName = (state.name + '.' + name).replace('.', '/');\n\t   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t   *     result[name] = config;\n\t   *   });\n\t   *   return result;\n\t   * });\n\t   *\n\t   * $stateProvider.state('home', {\n\t   *   views: {\n\t   *     'contact.list': { controller: 'ListController' },\n\t   *     'contact.item': { controller: 'ItemController' }\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * $state.go('home');\n\t   * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t   * // and /partials/home/contact/item.html, respectively.\n\t   * </pre>\n\t   *\n\t   * @param {string} name The name of the builder function to decorate. \n\t   * @param {object} func A function that is responsible for decorating the original \n\t   * builder function. The function receives two parameters:\n\t   *\n\t   *   - `{object}` - state - The state config object.\n\t   *   - `{object}` - super - The original builder function.\n\t   *\n\t   * @return {object} $stateProvider - $stateProvider instance\n\t   */\n\t  this.decorator = decorator;\n\t  function decorator(name, func) {\n\t    /*jshint validthis: true */\n\t    if (isString(name) && !isDefined(func)) {\n\t      return stateBuilder[name];\n\t    }\n\t    if (!isFunction(func) || !isString(name)) {\n\t      return this;\n\t    }\n\t    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n\t      stateBuilder.$delegates[name] = stateBuilder[name];\n\t    }\n\t    stateBuilder[name] = func;\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#state\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Registers a state configuration under a given state name. The stateConfig object\n\t   * has the following acceptable properties.\n\t   *\n\t   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t   * @param {object} stateConfig State configuration object.\n\t   * @param {string|function=} stateConfig.template\n\t   * <a id='template'></a>\n\t   *   html template as a string or a function that returns\n\t   *   an html template as a string which should be used by the uiView directives. This property \n\t   *   takes precedence over templateUrl.\n\t   *   \n\t   *   If `template` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t   *     applying the current state\n\t   *\n\t   * <pre>template:\n\t   *   \"<h1>inline template definition</h1>\" +\n\t   *   \"<div ui-view></div>\"</pre>\n\t   * <pre>template: function(params) {\n\t   *       return \"<h1>generated template</h1>\"; }</pre>\n\t   * </div>\n\t   *\n\t   * @param {string|function=} stateConfig.templateUrl\n\t   * <a id='templateUrl'></a>\n\t   *\n\t   *   path or function that returns a path to an html\n\t   *   template that should be used by uiView.\n\t   *   \n\t   *   If `templateUrl` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n\t   *     applying the current state\n\t   *\n\t   * <pre>templateUrl: \"home.html\"</pre>\n\t   * <pre>templateUrl: function(params) {\n\t   *     return myTemplates[params.pageId]; }</pre>\n\t   *\n\t   * @param {function=} stateConfig.templateProvider\n\t   * <a id='templateProvider'></a>\n\t   *    Provider function that returns HTML content string.\n\t   * <pre> templateProvider:\n\t   *       function(MyTemplateService, params) {\n\t   *         return MyTemplateService.getTemplate(params.pageId);\n\t   *       }</pre>\n\t   *\n\t   * @param {string|function=} stateConfig.controller\n\t   * <a id='controller'></a>\n\t   *\n\t   *  Controller fn that should be associated with newly\n\t   *   related scope or the name of a registered controller if passed as a string.\n\t   *   Optionally, the ControllerAs may be declared here.\n\t   * <pre>controller: \"MyRegisteredController\"</pre>\n\t   * <pre>controller:\n\t   *     \"MyRegisteredController as fooCtrl\"}</pre>\n\t   * <pre>controller: function($scope, MyService) {\n\t   *     $scope.data = MyService.getData(); }</pre>\n\t   *\n\t   * @param {function=} stateConfig.controllerProvider\n\t   * <a id='controllerProvider'></a>\n\t   *\n\t   * Injectable provider function that returns the actual controller or string.\n\t   * <pre>controllerProvider:\n\t   *   function(MyResolveData) {\n\t   *     if (MyResolveData.foo)\n\t   *       return \"FooCtrl\"\n\t   *     else if (MyResolveData.bar)\n\t   *       return \"BarCtrl\";\n\t   *     else return function($scope) {\n\t   *       $scope.baz = \"Qux\";\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {string=} stateConfig.controllerAs\n\t   * <a id='controllerAs'></a>\n\t   * \n\t   * A controller alias name. If present the controller will be\n\t   *   published to scope under the controllerAs name.\n\t   * <pre>controllerAs: \"myCtrl\"</pre>\n\t   *\n\t   * @param {string|object=} stateConfig.parent\n\t   * <a id='parent'></a>\n\t   * Optionally specifies the parent state of this state.\n\t   *\n\t   * <pre>parent: 'parentState'</pre>\n\t   * <pre>parent: parentState // JS variable</pre>\n\t   *\n\t   * @param {object=} stateConfig.resolve\n\t   * <a id='resolve'></a>\n\t   *\n\t   * An optional map&lt;string, function&gt; of dependencies which\n\t   *   should be injected into the controller. If any of these dependencies are promises, \n\t   *   the router will wait for them all to be resolved before the controller is instantiated.\n\t   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n\t   *   and the values of the resolved promises are injected into any controllers that reference them.\n\t   *   If any  of the promises are rejected the $stateChangeError event is fired.\n\t   *\n\t   *   The map object is:\n\t   *   \n\t   *   - key - {string}: name of dependency to be injected into controller\n\t   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n\t   *     it is injected and return value it treated as dependency. If result is a promise, it is \n\t   *     resolved before its value is injected into controller.\n\t   *\n\t   * <pre>resolve: {\n\t   *     myResolve1:\n\t   *       function($http, $stateParams) {\n\t   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n\t   *       }\n\t   *     }</pre>\n\t   *\n\t   * @param {string=} stateConfig.url\n\t   * <a id='url'></a>\n\t   *\n\t   *   A url fragment with optional parameters. When a state is navigated or\n\t   *   transitioned to, the `$stateParams` service will be populated with any \n\t   *   parameters that were passed.\n\t   *\n\t   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n\t   *   more details on acceptable patterns )\n\t   *\n\t   * examples:\n\t   * <pre>url: \"/home\"\n\t   * url: \"/users/:userid\"\n\t   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n\t   * url: \"/books/{categoryid:int}\"\n\t   * url: \"/books/{publishername:string}/{categoryid:int}\"\n\t   * url: \"/messages?before&after\"\n\t   * url: \"/messages?{before:date}&{after:date}\"\n\t   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n\t   * </pre>\n\t   *\n\t   * @param {object=} stateConfig.views\n\t   * <a id='views'></a>\n\t   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n\t   * manually/explicitly.\n\t   *\n\t   * Examples:\n\t   *\n\t   * Targets three named `ui-view`s in the parent state's template\n\t   * <pre>views: {\n\t   *     header: {\n\t   *       controller: \"headerCtrl\",\n\t   *       templateUrl: \"header.html\"\n\t   *     }, body: {\n\t   *       controller: \"bodyCtrl\",\n\t   *       templateUrl: \"body.html\"\n\t   *     }, footer: {\n\t   *       controller: \"footCtrl\",\n\t   *       templateUrl: \"footer.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n\t   * <pre>views: {\n\t   *     'header@top': {\n\t   *       controller: \"msgHeaderCtrl\",\n\t   *       templateUrl: \"msgHeader.html\"\n\t   *     }, 'body': {\n\t   *       controller: \"messagesCtrl\",\n\t   *       templateUrl: \"messages.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.abstract=false]\n\t   * <a id='abstract'></a>\n\t   * An abstract state will never be directly activated,\n\t   *   but can provide inherited properties to its common children states.\n\t   * <pre>abstract: true</pre>\n\t   *\n\t   * @param {function=} stateConfig.onEnter\n\t   * <a id='onEnter'></a>\n\t   *\n\t   * Callback function for when a state is entered. Good way\n\t   *   to trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explictly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onEnter: function(MyService, $stateParams) {\n\t   *     MyService.foo($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {function=} stateConfig.onExit\n\t   * <a id='onExit'></a>\n\t   *\n\t   * Callback function for when a state is exited. Good way to\n\t   *   trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explictly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onExit: function(MyService, $stateParams) {\n\t   *     MyService.cleanup($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n\t   * <a id='reloadOnSearch'></a>\n\t   *\n\t   * If `false`, will not retrigger the same state\n\t   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n\t   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t   * <pre>reloadOnSearch: false</pre>\n\t   *\n\t   * @param {object=} stateConfig.data\n\t   * <a id='data'></a>\n\t   *\n\t   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n\t   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n\t   *   the entire subtree via prototypal inheritance.\n\t   *\n\t   * <pre>data: {\n\t   *     requiredRole: 'foo'\n\t   * } </pre>\n\t   *\n\t   * @param {object=} stateConfig.params\n\t   * <a id='params'></a>\n\t   *\n\t   * A map which optionally configures parameters declared in the `url`, or\n\t   *   defines additional non-url parameters.  For each parameter being\n\t   *   configured, add a configuration object keyed to the name of the parameter.\n\t   *\n\t   *   Each parameter configuration object may contain the following properties:\n\t   *\n\t   *   - ** value ** - {object|function=}: specifies the default value for this\n\t   *     parameter.  This implicitly sets this parameter as optional.\n\t   *\n\t   *     When UI-Router routes to a state and no value is\n\t   *     specified for this parameter in the URL or transition, the\n\t   *     default value will be used instead.  If `value` is a function,\n\t   *     it will be injected and invoked, and the return value used.\n\t   *\n\t   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n\t   *     is treated as \"the default value is `null`\".\n\t   *\n\t   *     *Shorthand*: If you only need to configure the default value of the\n\t   *     parameter, you may use a shorthand syntax.   In the **`params`**\n\t   *     map, instead mapping the param name to a full parameter configuration\n\t   *     object, simply set map it to the default parameter value, e.g.:\n\t   *\n\t   * <pre>// define a parameter's default value\n\t   * params: {\n\t   *     param1: { value: \"defaultValue\" }\n\t   * }\n\t   * // shorthand default values\n\t   * params: {\n\t   *     param1: \"defaultValue\",\n\t   *     param2: \"param2Default\"\n\t   * }</pre>\n\t   *\n\t   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n\t   *     treated as an array of values.  If you specified a Type, the value will be\n\t   *     treated as an array of the specified Type.  Note: query parameter values\n\t   *     default to a special `\"auto\"` mode.\n\t   *\n\t   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n\t   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n\t   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n\t   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n\t   *     value (e.g.: `{ foo: '1' }`).\n\t   *\n\t   * <pre>params: {\n\t   *     param1: { array: true }\n\t   * }</pre>\n\t   *\n\t   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n\t   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n\t   *     configured default squash policy.\n\t   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n\t   *\n\t   *   There are three squash settings:\n\t   *\n\t   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n\t   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n\t   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n\t   *       This can allow for cleaner looking URLs.\n\t   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n\t   *\n\t   * <pre>params: {\n\t   *     param1: {\n\t   *       value: \"defaultId\",\n\t   *       squash: true\n\t   * } }\n\t   * // squash \"defaultValue\" to \"~\"\n\t   * params: {\n\t   *     param1: {\n\t   *       value: \"defaultValue\",\n\t   *       squash: \"~\"\n\t   * } }\n\t   * </pre>\n\t   *\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Some state name examples\n\t   *\n\t   * // stateName can be a single top-level name (must be unique).\n\t   * $stateProvider.state(\"home\", {});\n\t   *\n\t   * // Or it can be a nested state name. This state is a child of the\n\t   * // above \"home\" state.\n\t   * $stateProvider.state(\"home.newest\", {});\n\t   *\n\t   * // Nest states as deeply as needed.\n\t   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t   *\n\t   * // state() returns $stateProvider, so you can chain state declarations.\n\t   * $stateProvider\n\t   *   .state(\"home\", {})\n\t   *   .state(\"about\", {})\n\t   *   .state(\"contacts\", {});\n\t   * </pre>\n\t   *\n\t   */\n\t  this.state = state;\n\t  function state(name, definition) {\n\t    /*jshint validthis: true */\n\t    if (isObject(name)) definition = name;\n\t    else definition.name = name;\n\t    registerState(definition);\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$state\n\t   *\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires ui.router.state.$view\n\t   * @requires $injector\n\t   * @requires ui.router.util.$resolve\n\t   * @requires ui.router.state.$stateParams\n\t   * @requires ui.router.router.$urlRouter\n\t   *\n\t   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n\t   * you'd like to test against the current active state.\n\t   * @property {object} current A reference to the state's config object. However \n\t   * you passed it in. Useful for accessing custom data.\n\t   * @property {object} transition Currently pending transition. A promise that'll \n\t   * resolve or reject.\n\t   *\n\t   * @description\n\t   * `$state` service is responsible for representing states as well as transitioning\n\t   * between them. It also provides interfaces to ask for current state or even states\n\t   * you're coming from.\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n\t  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\t\n\t    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n\t    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n\t    var TransitionAborted = $q.reject(new Error('transition aborted'));\n\t    var TransitionFailed = $q.reject(new Error('transition failed'));\n\t\n\t    // Handles the case where a state which is the target of a transition is not found, and the user\n\t    // can optionally retry or defer the transition\n\t    function handleRedirect(redirect, state, params, options) {\n\t      /**\n\t       * @ngdoc event\n\t       * @name ui.router.state.$state#$stateNotFound\n\t       * @eventOf ui.router.state.$state\n\t       * @eventType broadcast on root scope\n\t       * @description\n\t       * Fired when a requested state **cannot be found** using the provided state name during transition.\n\t       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n\t       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n\t       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n\t       *\n\t       * @param {Object} event Event object.\n\t       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n\t       * @param {State} fromState Current state object.\n\t       * @param {Object} fromParams Current state params.\n\t       *\n\t       * @example\n\t       *\n\t       * <pre>\n\t       * // somewhere, assume lazy.state has not been defined\n\t       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n\t       *\n\t       * // somewhere else\n\t       * $scope.$on('$stateNotFound',\n\t       * function(event, unfoundState, fromState, fromParams){\n\t       *     console.log(unfoundState.to); // \"lazy.state\"\n\t       *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t       *     console.log(unfoundState.options); // {inherit:false} + default options\n\t       * })\n\t       * </pre>\n\t       */\n\t      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\t\n\t      if (evt.defaultPrevented) {\n\t        $urlRouter.update();\n\t        return TransitionAborted;\n\t      }\n\t\n\t      if (!evt.retry) {\n\t        return null;\n\t      }\n\t\n\t      // Allow the handler to return a promise to defer state lookup retry\n\t      if (options.$retry) {\n\t        $urlRouter.update();\n\t        return TransitionFailed;\n\t      }\n\t      var retryTransition = $state.transition = $q.when(evt.retry);\n\t\n\t      retryTransition.then(function() {\n\t        if (retryTransition !== $state.transition) return TransitionSuperseded;\n\t        redirect.options.$retry = true;\n\t        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n\t      }, function() {\n\t        return TransitionAborted;\n\t      });\n\t      $urlRouter.update();\n\t\n\t      return retryTransition;\n\t    }\n\t\n\t    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\t\n\t    $state = {\n\t      params: {},\n\t      current: root.self,\n\t      $current: root,\n\t      transition: null\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state. All resolves are re-resolved,\n\t     * controllers reinstantiated, and events re-fired.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t     * @example\n\t     * <pre>\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n\t     * //and current state is 'contacts.detail.item'\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.reload = function reload(state) {\n\t      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls \n\t     * `$state.transitionTo` internally but automatically sets options to \n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n\t     * This allows you to easily use an absolute or relative to path and specify \n\t     * only the parameters you'd like to update (while letting unspecified parameters \n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state, \n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n\t     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    $state.go = function go(to, params, options) {\n\t      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *    if String, then will reload the state with the name given in reload, and any children.\n\t     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.transitionTo = function transitionTo(to, toParams, options) {\n\t      toParams = toParams || {};\n\t      options = extend({\n\t        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n\t      }, options || {});\n\t\n\t      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n\t      var evt, toState = findState(to, options.relative);\n\t\n\t      // Store the hash param for later (since it will be stripped out by various methods)\n\t      var hash = toParams['#'];\n\t\n\t      if (!isDefined(toState)) {\n\t        var redirect = { to: to, toParams: toParams, options: options };\n\t        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\t\n\t        if (redirectResult) {\n\t          return redirectResult;\n\t        }\n\t\n\t        // Always retry once if the $stateNotFound was not prevented\n\t        // (handles either redirect changed or state lazy-definition)\n\t        to = redirect.to;\n\t        toParams = redirect.toParams;\n\t        options = redirect.options;\n\t        toState = findState(to, options.relative);\n\t\n\t        if (!isDefined(toState)) {\n\t          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n\t          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n\t        }\n\t      }\n\t      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n\t      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n\t      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\t\n\t      toParams = toState.params.$$values(toParams);\n\t      to = toState;\n\t\n\t      var toPath = to.path;\n\t\n\t      // Starting from the root of the path, keep all levels that haven't changed\n\t      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\t\n\t      if (!options.reload) {\n\t        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      } else if (isString(options.reload) || isObject(options.reload)) {\n\t        if (isObject(options.reload) && !options.reload.name) {\n\t          throw new Error('Invalid reload state object');\n\t        }\n\t        \n\t        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n\t        if (options.reload && !reloadState) {\n\t          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        }\n\t\n\t        while (state && state === fromPath[keep] && state !== reloadState) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      }\n\t\n\t      // If we're going to the same state and all locals are kept, we've got nothing to do.\n\t      // But clear 'transition', as we still want to cancel any other pending transitions.\n\t      // TODO: We may not want to bump 'transition' if we're called from a location change\n\t      // that we've initiated ourselves, because we might accidentally abort a legitimate\n\t      // transition initiated from code?\n\t      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n\t        if (hash) toParams['#'] = hash;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        if (options.location && to.navigable && to.navigable.url) {\n\t          $urlRouter.push(to.navigable.url, toParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t          $urlRouter.update(true);\n\t        }\n\t        $state.transition = null;\n\t        return $q.when($state.current);\n\t      }\n\t\n\t      // Filter parameters before we pass them to event handlers etc.\n\t      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\t\n\t      // Broadcast start event and cancel the transition if requested\n\t      if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeStart\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n\t         * to prevent the transition from happening and then the transition promise will be\n\t         * rejected with a `'transition prevented'` value.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $rootScope.$on('$stateChangeStart',\n\t         * function(event, toState, toParams, fromState, fromParams){\n\t         *     event.preventDefault();\n\t         *     // transitionTo() promise will be rejected with\n\t         *     // a 'transition prevented' error\n\t         * })\n\t         * </pre>\n\t         */\n\t        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n\t          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n\t          $urlRouter.update();\n\t          return TransitionPrevented;\n\t        }\n\t      }\n\t\n\t      // Resolve locals for the remaining states, but don't update any global state just\n\t      // yet -- if anything fails to resolve the current state needs to remain untouched.\n\t      // We also set up an inheritance chain for the locals here. This allows the view directive\n\t      // to quickly look up the correct definition for each view in the current state. Even\n\t      // though we create the locals object itself outside resolveState(), it is initially\n\t      // empty and gets filled asynchronously. We need to keep track of the promise for the\n\t      // (fully resolved) current locals, and pass this down the chain.\n\t      var resolved = $q.when(locals);\n\t\n\t      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n\t        locals = toLocals[l] = inherit(locals);\n\t        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n\t      }\n\t\n\t      // Once everything is resolved, we are ready to perform the actual transition\n\t      // and return a promise for the new state. We also keep track of what the\n\t      // current promise is, so that we can detect overlapping transitions and\n\t      // keep only the outcome of the last transition.\n\t      var transition = $state.transition = resolved.then(function () {\n\t        var l, entering, exiting;\n\t\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Exit 'from' states not kept\n\t        for (l = fromPath.length - 1; l >= keep; l--) {\n\t          exiting = fromPath[l];\n\t          if (exiting.self.onExit) {\n\t            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n\t          }\n\t          exiting.locals = null;\n\t        }\n\t\n\t        // Enter 'to' states not kept\n\t        for (l = keep; l < toPath.length; l++) {\n\t          entering = toPath[l];\n\t          entering.locals = toLocals[l];\n\t          if (entering.self.onEnter) {\n\t            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n\t          }\n\t        }\n\t\n\t        // Re-add the saved hash before we start returning things\n\t        if (hash) toParams['#'] = hash;\n\t\n\t        // Run it again, to catch any transitions in callbacks\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Update globals in $state\n\t        $state.$current = to;\n\t        $state.current = to.self;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        $state.transition = null;\n\t\n\t        if (options.location && to.navigable) {\n\t          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t        }\n\t\n\t        if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeSuccess\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired once the state transition is **complete**.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         */\n\t          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n\t        }\n\t        $urlRouter.update(true);\n\t\n\t        return $state.current;\n\t      }, function (error) {\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        $state.transition = null;\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeError\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when an **error occurs** during transition. It's important to note that if you\n\t         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t         * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t         * catch **ALL** errors.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         * @param {Error} error The resolve error object.\n\t         */\n\t        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\t\n\t        if (!evt.defaultPrevented) {\n\t            $urlRouter.update();\n\t        }\n\t\n\t        return $q.reject(error);\n\t      });\n\t\n\t      return transition;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be\n\t     * tested for strict equality against the current active params object, so all params\n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     * test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    $state.is = function is(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) { return undefined; }\n\t      if ($state.$current !== state) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t     * .includes will test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    $state.includes = function includes(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      if (isString(stateOrName) && isGlob(stateOrName)) {\n\t        if (!doesStateMatchGlob(stateOrName)) {\n\t          return false;\n\t        }\n\t        stateOrName = $state.$current.name;\n\t      }\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t      if (!isDefined(state)) { return undefined; }\n\t      if (!isDefined($state.$current.includes[state.name])) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n\t    };\n\t\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     * \n\t     * @returns {string} compiled state url\n\t     */\n\t    $state.href = function href(stateOrName, params, options) {\n\t      options = extend({\n\t        lossy:    true,\n\t        inherit:  true,\n\t        absolute: false,\n\t        relative: $state.$current\n\t      }, options || {});\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) return null;\n\t      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\t      \n\t      var nav = (state && options.lossy) ? state.navigable : state;\n\t\n\t      if (!nav || nav.url === undefined || nav.url === null) {\n\t        return null;\n\t      }\n\t      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n\t        absolute: options.absolute\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#get\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Returns the state configuration object for any specific state or all states.\n\t     *\n\t     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n\t     * the requested state. If not provided, returns an array of ALL state configs.\n\t     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n\t     * @returns {Object|Array} State configuration object or array of all objects.\n\t     */\n\t    $state.get = function (stateOrName, context) {\n\t      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n\t      var state = findState(stateOrName, context || $state.$current);\n\t      return (state && state.self) ? state.self : null;\n\t    };\n\t\n\t    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n\t      // Make a restricted $stateParams with only the parameters that apply to this state if\n\t      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n\t      // we also need $stateParams to be available for any $injector calls we make during the\n\t      // dependency resolution process.\n\t      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n\t      var locals = { $stateParams: $stateParams };\n\t\n\t      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n\t      // We're also including $stateParams in this; that way the parameters are restricted\n\t      // to the set that should be visible to the state, and are independent of when we update\n\t      // the global $state and $stateParams values.\n\t      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n\t      var promises = [dst.resolve.then(function (globals) {\n\t        dst.globals = globals;\n\t      })];\n\t      if (inherited) promises.push(inherited);\n\t\n\t      function resolveViews() {\n\t        var viewsPromises = [];\n\t\n\t        // Resolve template and dependencies for all views.\n\t        forEach(state.views, function (view, name) {\n\t          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n\t          injectables.$template = [ function () {\n\t            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n\t          }];\n\t\n\t          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n\t            // References to the controller (only instantiated at link time)\n\t            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n\t              var injectLocals = angular.extend({}, injectables, dst.globals);\n\t              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n\t            } else {\n\t              result.$$controller = view.controller;\n\t            }\n\t            // Provide access to the state itself for internal use\n\t            result.$$state = state;\n\t            result.$$controllerAs = view.controllerAs;\n\t            dst[name] = result;\n\t          }));\n\t        });\n\t\n\t        return $q.all(viewsPromises).then(function(){\n\t          return dst.globals;\n\t        });\n\t      }\n\t\n\t      // Wait for all the promises and then return the activation object\n\t      return $q.all(promises).then(resolveViews).then(function (values) {\n\t        return dst;\n\t      });\n\t    }\n\t\n\t    return $state;\n\t  }\n\t\n\t  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n\t    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n\t    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n\t      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n\t      function notSearchParam(key) {\n\t        return fromAndToState.params[key].location != \"search\";\n\t      }\n\t      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n\t      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n\t      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n\t      return nonQueryParamSet.$$equals(fromParams, toParams);\n\t    }\n\t\n\t    // If reload was not explicitly requested\n\t    // and we're transitioning to the same state we're already in\n\t    // and    the locals didn't change\n\t    //     or they changed in a way that doesn't merit reloading\n\t    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n\t    // Then return true.\n\t    if (!options.reload && to === from &&\n\t      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .value('$stateParams', {})\n\t  .provider('$state', $StateProvider);\n\t\n\t\n\t$ViewProvider.$inject = [];\n\tfunction $ViewProvider() {\n\t\n\t  this.$get = $get;\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$view\n\t   *\n\t   * @requires ui.router.util.$templateFactory\n\t   * @requires $rootScope\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  $get.$inject = ['$rootScope', '$templateFactory'];\n\t  function $get(   $rootScope,   $templateFactory) {\n\t    return {\n\t      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.state.$view#load\n\t       * @methodOf ui.router.state.$view\n\t       *\n\t       * @description\n\t       *\n\t       * @param {string} name name\n\t       * @param {object} options option object.\n\t       */\n\t      load: function load(name, options) {\n\t        var result, defaults = {\n\t          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n\t        };\n\t        options = extend(defaults, options);\n\t\n\t        if (options.view) {\n\t          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n\t        }\n\t        if (result && options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$viewContentLoading\n\t         * @eventOf ui.router.state.$view\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         *\n\t         * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {Object} viewConfig The view config properties (template, controller, etc).\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $scope.$on('$viewContentLoading',\n\t         * function(event, viewConfig){\n\t         *     // Access to all the view config properties.\n\t         *     // and one special property 'targetView'\n\t         *     // viewConfig.targetView\n\t         * });\n\t         * </pre>\n\t         */\n\t          $rootScope.$broadcast('$viewContentLoading', options);\n\t        }\n\t        return result;\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state').provider('$view', $ViewProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t\n\t  var useAnchorScroll = false;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t   * @methodOf ui.router.state.$uiViewScrollProvider\n\t   *\n\t   * @description\n\t   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t   * scrolling based on the url anchor.\n\t   */\n\t  this.useAnchorScroll = function () {\n\t    useAnchorScroll = true;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$uiViewScroll\n\t   *\n\t   * @requires $anchorScroll\n\t   * @requires $timeout\n\t   *\n\t   * @description\n\t   * When called with a jqLite element, it scrolls the element into view (after a\n\t   * `$timeout` so the DOM has time to refresh).\n\t   *\n\t   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t   */\n\t  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t    if (useAnchorScroll) {\n\t      return $anchorScroll;\n\t    }\n\t\n\t    return function ($element) {\n\t      return $timeout(function () {\n\t        $element[0].scrollIntoView();\n\t      }, 0, false);\n\t    };\n\t  }];\n\t}\n\t\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-view\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $compile\n\t * @requires $controller\n\t * @requires $injector\n\t * @requires ui.router.state.$uiViewScroll\n\t * @requires $document\n\t *\n\t * @restrict ECA\n\t *\n\t * @description\n\t * The ui-view directive tells $state where to place your templates.\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t * \n\t * @example\n\t * A view can be unnamed or named. \n\t * <pre>\n\t * <!-- Unnamed -->\n\t * <div ui-view></div> \n\t * \n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * </pre>\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a \n\t * single view and it is unnamed then you can populate it like so:\n\t * <pre>\n\t * <div ui-view></div> \n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * </pre>\n\t * \n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n\t * config property, by name, in this case an empty name:\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * But typically you'll only use the views property if you name your view or have more than one view \n\t * in the same template. There's not really a compelling reason to name a view if its the only one, \n\t * but you could if you wanted, like so:\n\t * <pre>\n\t * <div ui-view=\"main\"></div>\n\t * </pre> \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * Really though, you'll use views to set up multiple views:\n\t * <pre>\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div> \n\t * <div ui-view=\"data\"></div> \n\t * </pre>\n\t * \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * <pre>\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * </pre>\n\t */\n\t$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\n\tfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\t\n\t  function getService() {\n\t    return ($injector.has) ? function(service) {\n\t      return $injector.has(service) ? $injector.get(service) : null;\n\t    } : function(service) {\n\t      try {\n\t        return $injector.get(service);\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var service = getService(),\n\t      $animator = service('$animator'),\n\t      $animate = service('$animate');\n\t\n\t  // Returns a set of DOM manipulation functions based on which Angular version\n\t  // it should use\n\t  function getRenderer(attrs, scope) {\n\t    var statics = function() {\n\t      return {\n\t        enter: function (element, target, cb) { target.after(element); cb(); },\n\t        leave: function (element, cb) { element.remove(); cb(); }\n\t      };\n\t    };\n\t\n\t    if ($animate) {\n\t      return {\n\t        enter: function(element, target, cb) {\n\t          var promise = $animate.enter(element, null, target, cb);\n\t          if (promise && promise.then) promise.then(cb);\n\t        },\n\t        leave: function(element, cb) {\n\t          var promise = $animate.leave(element, cb);\n\t          if (promise && promise.then) promise.then(cb);\n\t        }\n\t      };\n\t    }\n\t\n\t    if ($animator) {\n\t      var animate = $animator && $animator(scope, attrs);\n\t\n\t      return {\n\t        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n\t        leave: function(element, cb) { animate.leave(element); cb(); }\n\t      };\n\t    }\n\t\n\t    return statics();\n\t  }\n\t\n\t  var directive = {\n\t    restrict: 'ECA',\n\t    terminal: true,\n\t    priority: 400,\n\t    transclude: 'element',\n\t    compile: function (tElement, tAttrs, $transclude) {\n\t      return function (scope, $element, attrs) {\n\t        var previousEl, currentEl, currentScope, latestLocals,\n\t            onloadExp     = attrs.onload || '',\n\t            autoScrollExp = attrs.autoscroll,\n\t            renderer      = getRenderer(attrs, scope);\n\t\n\t        scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t        scope.$on('$viewContentLoading', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        updateView(true);\n\t\n\t        function cleanupLastView() {\n\t          if (previousEl) {\n\t            previousEl.remove();\n\t            previousEl = null;\n\t          }\n\t\n\t          if (currentScope) {\n\t            currentScope.$destroy();\n\t            currentScope = null;\n\t          }\n\t\n\t          if (currentEl) {\n\t            renderer.leave(currentEl, function() {\n\t              previousEl = null;\n\t            });\n\t\n\t            previousEl = currentEl;\n\t            currentEl = null;\n\t          }\n\t        }\n\t\n\t        function updateView(firstTime) {\n\t          var newScope,\n\t              name            = getUiViewName(scope, attrs, $element, $interpolate),\n\t              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\t\n\t          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n\t          newScope = scope.$new();\n\t          latestLocals = $state.$current.locals[name];\n\t\n\t          var clone = $transclude(newScope, function(clone) {\n\t            renderer.enter(clone, $element, function onUiViewEnter() {\n\t              if(currentScope) {\n\t                currentScope.$emit('$viewContentAnimationEnded');\n\t              }\n\t\n\t              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                $uiViewScroll(clone);\n\t              }\n\t            });\n\t            cleanupLastView();\n\t          });\n\t\n\t          currentEl = clone;\n\t          currentScope = newScope;\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description           *\n\t           * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           */\n\t          currentScope.$emit('$viewContentLoaded');\n\t          currentScope.$eval(onloadExp);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  return directive;\n\t}\n\t\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\n\tfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n\t  return {\n\t    restrict: 'ECA',\n\t    priority: -400,\n\t    compile: function (tElement) {\n\t      var initial = tElement.html();\n\t      return function (scope, $element, attrs) {\n\t        var current = $state.$current,\n\t            name = getUiViewName(scope, attrs, $element, $interpolate),\n\t            locals  = current && current.locals[name];\n\t\n\t        if (! locals) {\n\t          return;\n\t        }\n\t\n\t        $element.data('$uiView', { name: name, state: locals.$$state });\n\t        $element.html(locals.$template ? locals.$template : initial);\n\t\n\t        var link = $compile($element.contents());\n\t\n\t        if (locals.$$controller) {\n\t          locals.$scope = scope;\n\t          locals.$element = $element;\n\t          var controller = $controller(locals.$$controller, locals);\n\t          if (locals.$$controllerAs) {\n\t            scope[locals.$$controllerAs] = controller;\n\t          }\n\t          $element.data('$ngControllerController', controller);\n\t          $element.children().data('$ngControllerController', controller);\n\t        }\n\t\n\t        link(scope);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Shared ui-view code for both directives:\n\t * Given scope, element, and its attributes, return the view's name\n\t */\n\tfunction getUiViewName(scope, attrs, element, $interpolate) {\n\t  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n\t  var inherited = element.inheritedData('$uiView');\n\t  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n\t}\n\t\n\tangular.module('ui.router.state').directive('uiView', $ViewDirective);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\tfunction parseStateRef(ref, current) {\n\t  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n\t  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t  return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t\n\tfunction stateContext(el) {\n\t  var stateData = el.parent().inheritedData('$uiView');\n\t\n\t  if (stateData && stateData.state && stateData.state.name) {\n\t    return stateData.state;\n\t  }\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $timeout\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n\t * URL, the directive will automatically generate & update the `href` attribute via \n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n\t * the link will trigger a state transition with optional parameters. \n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative \n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the \n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * @example\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n\t * following template:\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t * \n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t * \n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t * \n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n\t */\n\t$StateRefDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDirective($state, $timeout) {\n\t  var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];\n\t\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n\t      var params = null, url = null, base = stateContext(element) || $state.$current;\n\t      // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t      var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?\n\t                 'xlink:href' : 'href';\n\t      var newHref = null, isAnchor = element.prop(\"tagName\").toUpperCase() === \"A\";\n\t      var isForm = element[0].nodeName === \"FORM\";\n\t      var attr = isForm ? \"action\" : hrefKind, nav = true;\n\t\n\t      var options = { relative: base, inherit: true };\n\t      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\t\n\t      angular.forEach(allowedOptions, function(option) {\n\t        if (option in optionsOverride) {\n\t          options[option] = optionsOverride[option];\n\t        }\n\t      });\n\t\n\t      var update = function(newVal) {\n\t        if (newVal) params = angular.copy(newVal);\n\t        if (!nav) return;\n\t\n\t        newHref = $state.href(ref.state, params, options);\n\t\n\t        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n\t        if (activeDirective) {\n\t          activeDirective.$$addStateInfo(ref.state, params);\n\t        }\n\t        if (newHref === null) {\n\t          nav = false;\n\t          return false;\n\t        }\n\t        attrs.$set(attr, newHref);\n\t      };\n\t\n\t      if (ref.paramExpr) {\n\t        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n\t          if (newVal !== params) update(newVal);\n\t        }, true);\n\t        params = angular.copy(scope.$eval(ref.paramExpr));\n\t      }\n\t      update();\n\t\n\t      if (isForm) return;\n\t\n\t      element.bind(\"click\", function(e) {\n\t        var button = e.which || e.button;\n\t        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n\t          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t          var transition = $timeout(function() {\n\t            $state.go(ref.state, params, options);\n\t          });\n\t          e.preventDefault();\n\t\n\t          // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t          var ignorePreventDefaultCount = isAnchor && !newHref ? 1: 0;\n\t          e.preventDefault = function() {\n\t            if (ignorePreventDefaultCount-- <= 0)\n\t              $timeout.cancel(transition);\n\t          };\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use\n\t * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n\t *\n\t * @example\n\t * Given the following template:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active-eq\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n\t * when the exact target state used in the `ui-sref` is active; no child states.\n\t *\n\t */\n\t$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n\tfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n\t  return  {\n\t    restrict: \"A\",\n\t    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n\t      var states = [], activeClass;\n\t\n\t      // There probably isn't much point in $observing this\n\t      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t      // slight difference in logic routing\n\t      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\t\n\t      // Allow uiSref to communicate with uiSrefActive[Equals]\n\t      this.$$addStateInfo = function (newState, newParams) {\n\t        var state = $state.get(newState, stateContext($element));\n\t\n\t        states.push({\n\t          state: state || { name: newState },\n\t          params: newParams\n\t        });\n\t\n\t        update();\n\t      };\n\t\n\t      $scope.$on('$stateChangeSuccess', update);\n\t\n\t      // Update route state\n\t      function update() {\n\t        if (anyMatch()) {\n\t          $element.addClass(activeClass);\n\t        } else {\n\t          $element.removeClass(activeClass);\n\t        }\n\t      }\n\t\n\t      function anyMatch() {\n\t        for (var i = 0; i < states.length; i++) {\n\t          if (isMatch(states[i].state, states[i].params)) {\n\t            return true;\n\t          }\n\t        }\n\t        return false;\n\t      }\n\t\n\t      function isMatch(state, params) {\n\t        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n\t          return $state.is(state.name, params);\n\t        } else {\n\t          return $state.includes(state.name, params);\n\t        }\n\t      }\n\t    }]\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .directive('uiSref', $StateRefDirective)\n\t  .directive('uiSrefActive', $StateRefActiveDirective)\n\t  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t  var isFilter = function (state) {\n\t    return $state.is(state);\n\t  };\n\t  isFilter.$stateful = true;\n\t  return isFilter;\n\t}\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t  var includesFilter = function (state) {\n\t    return $state.includes(state);\n\t  };\n\t  includesFilter.$stateful = true;\n\t  return  includesFilter;\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .filter('isState', $IsStateFilter)\n\t  .filter('includedByState', $IncludedByStateFilter);\n\t})(window, window.angular);\n\n/***/ },\n/* 18 */,\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t  'use strict';\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (root.hasOwnProperty('angular')) {\n\t    // Browser globals (root is window), we don't register it.\n\t    factory(root.angular);\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = factory(require('angular'));\n\t  }\n\t}(this , function (angular) {\n\t    'use strict';\n\t\n\t    // In cases where Angular does not get passed or angular is a truthy value\n\t    // but misses .module we can fall back to using window.\n\t    angular = (angular && angular.module ) ? angular : window.angular;\n\t\n\t    /**\n\t     * @ngdoc overview\n\t     * @name ngStorage\n\t     */\n\t\n\t    return angular.module('ngStorage', [])\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$localStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$localStorage', _storageProvider('localStorage'))\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$sessionStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\t\n\t    function _storageProvider(storageType) {\n\t        return function () {\n\t          var storageKeyPrefix = 'ngStorage-';\n\t\n\t          this.setKeyPrefix = function (prefix) {\n\t            if (typeof prefix !== 'string') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n\t            }\n\t            storageKeyPrefix = prefix;\n\t          };\n\t\n\t          var serializer = angular.toJson;\n\t          var deserializer = angular.fromJson;\n\t\n\t          this.setSerializer = function (s) {\n\t            if (typeof s !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n\t            }\n\t\n\t            serializer = s;\n\t          };\n\t\n\t          this.setDeserializer = function (d) {\n\t            if (typeof d !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n\t            }\n\t\n\t            deserializer = d;\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.get = function (key) {\n\t            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.set = function (key, value) {\n\t            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n\t          };\n\t\n\t          this.$get = [\n\t              '$rootScope',\n\t              '$window',\n\t              '$log',\n\t              '$timeout',\n\t              '$document',\n\t\n\t              function(\n\t                  $rootScope,\n\t                  $window,\n\t                  $log,\n\t                  $timeout,\n\t                  $document\n\t              ){\n\t                function isStorageSupported(storageType) {\n\t\n\t                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n\t                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n\t                    // that error and allow execution to continue.\n\t\n\t                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n\t                    // when \"Block cookies\": \"Always block\" is turned on\n\t                    var supported;\n\t                    try {\n\t                        supported = $window[storageType];\n\t                    }\n\t                    catch (err) {\n\t                        supported = false;\n\t                    }\n\t\n\t                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n\t                    // is available, but trying to call .setItem throws an exception below:\n\t                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n\t                    if (supported && storageType === 'localStorage') {\n\t                        var key = '__' + Math.round(Math.random() * 1e7);\n\t\n\t                        try {\n\t                            localStorage.setItem(key, key);\n\t                            localStorage.removeItem(key);\n\t                        }\n\t                        catch (err) {\n\t                            supported = false;\n\t                        }\n\t                    }\n\t\n\t                    return supported;\n\t                }\n\t\n\t                // The magic number 10 is used which only works for some keyPrefixes...\n\t                // See https://github.com/gsklee/ngStorage/issues/137\n\t                var prefixLength = storageKeyPrefix.length;\n\t\n\t                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n\t                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n\t                    $storage = {\n\t                        $default: function(items) {\n\t                            for (var k in items) {\n\t                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n\t                            }\n\t\n\t                            $storage.$sync();\n\t                            return $storage;\n\t                        },\n\t                        $reset: function(items) {\n\t                            for (var k in $storage) {\n\t                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n\t                            }\n\t\n\t                            return $storage.$default(items);\n\t                        },\n\t                        $sync: function () {\n\t                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n\t                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n\t                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n\t                            }\n\t                        },\n\t                        $apply: function() {\n\t                            var temp$storage;\n\t\n\t                            _debounce = null;\n\t\n\t                            if (!angular.equals($storage, _last$storage)) {\n\t                                temp$storage = angular.copy(_last$storage);\n\t                                angular.forEach($storage, function(v, k) {\n\t                                    if (angular.isDefined(v) && '$' !== k[0]) {\n\t                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n\t                                        delete temp$storage[k];\n\t                                    }\n\t                                });\n\t\n\t                                for (var k in temp$storage) {\n\t                                    webStorage.removeItem(storageKeyPrefix + k);\n\t                                }\n\t\n\t                                _last$storage = angular.copy($storage);\n\t                            }\n\t                        }\n\t                    },\n\t                    _last$storage,\n\t                    _debounce;\n\t\n\t                $storage.$sync();\n\t\n\t                _last$storage = angular.copy($storage);\n\t\n\t                $rootScope.$watch(function() {\n\t                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n\t                });\n\t\n\t                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n\t                $window.addEventListener && $window.addEventListener('storage', function(event) {\n\t                    if (!event.key) {\n\t                      return;\n\t                    }\n\t\n\t                    // Reference doc.\n\t                    var doc = $document[0];\n\t\n\t                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n\t                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\t\n\t                        _last$storage = angular.copy($storage);\n\t\n\t                        $rootScope.$apply();\n\t                    }\n\t                });\n\t\n\t                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n\t                    $storage.$apply();\n\t                });\n\t\n\t                return $storage;\n\t              }\n\t          ];\n\t      };\n\t    }\n\t\n\t}));\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * oclazyload - Load modules on demand (lazy load) with angularJS\r\n\t * @version v1.0.8\r\n\t * @link https://github.com/ocombe/ocLazyLoad\r\n\t * @license MIT\r\n\t * @author Olivier Combe <olivier.combe@gmail.com>\r\n\t */\r\n\t(function (angular, window) {\r\n\t    'use strict';\r\n\t\r\n\t    var regModules = ['ng', 'oc.lazyLoad'],\r\n\t        regInvokes = {},\r\n\t        regConfigs = [],\r\n\t        modulesToLoad = [],\r\n\t        // modules to load from angular.module or other sources\r\n\t    realModules = [],\r\n\t        // real modules called from angular.module\r\n\t    recordDeclarations = [],\r\n\t        broadcast = angular.noop,\r\n\t        runBlocks = {},\r\n\t        justLoaded = [];\r\n\t\r\n\t    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\r\n\t\r\n\t    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\r\n\t        var modules = {},\r\n\t            providers = {\r\n\t            $controllerProvider: $controllerProvider,\r\n\t            $compileProvider: $compileProvider,\r\n\t            $filterProvider: $filterProvider,\r\n\t            $provide: $provide, // other things (constant, decorator, provider, factory, service)\r\n\t            $injector: $injector,\r\n\t            $animateProvider: $animateProvider\r\n\t        },\r\n\t            debug = false,\r\n\t            events = false,\r\n\t            moduleCache = [],\r\n\t            modulePromises = {};\r\n\t\r\n\t        moduleCache.push = function (value) {\r\n\t            if (this.indexOf(value) === -1) {\r\n\t                Array.prototype.push.apply(this, arguments);\r\n\t            }\r\n\t        };\r\n\t\r\n\t        this.config = function (config) {\r\n\t            // If we want to define modules configs\r\n\t            if (angular.isDefined(config.modules)) {\r\n\t                if (angular.isArray(config.modules)) {\r\n\t                    angular.forEach(config.modules, function (moduleConfig) {\r\n\t                        modules[moduleConfig.name] = moduleConfig;\r\n\t                    });\r\n\t                } else {\r\n\t                    modules[config.modules.name] = config.modules;\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (angular.isDefined(config.debug)) {\r\n\t                debug = config.debug;\r\n\t            }\r\n\t\r\n\t            if (angular.isDefined(config.events)) {\r\n\t                events = config.events;\r\n\t            }\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * Get the list of existing registered modules\r\n\t         * @param element\r\n\t         */\r\n\t        this._init = function _init(element) {\r\n\t            // this is probably useless now because we override angular.bootstrap\r\n\t            if (modulesToLoad.length === 0) {\r\n\t                var elements = [element],\r\n\t                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\r\n\t                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\r\n\t                    append = function append(elm) {\r\n\t                    return elm && elements.push(elm);\r\n\t                };\r\n\t\r\n\t                angular.forEach(names, function (name) {\r\n\t                    names[name] = true;\r\n\t                    append(document.getElementById(name));\r\n\t                    name = name.replace(':', '\\\\:');\r\n\t                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\r\n\t                        angular.forEach(element[0].querySelectorAll('.' + name), append);\r\n\t                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\r\n\t                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\r\n\t                    }\r\n\t                });\r\n\t\r\n\t                angular.forEach(elements, function (elm) {\r\n\t                    if (modulesToLoad.length === 0) {\r\n\t                        var className = ' ' + element.className + ' ';\r\n\t                        var match = NG_APP_CLASS_REGEXP.exec(className);\r\n\t                        if (match) {\r\n\t                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\r\n\t                        } else {\r\n\t                            angular.forEach(elm.attributes, function (attr) {\r\n\t                                if (modulesToLoad.length === 0 && names[attr.name]) {\r\n\t                                    modulesToLoad.push(attr.value);\r\n\t                                }\r\n\t                            });\r\n\t                        }\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t\r\n\t            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\r\n\t                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\r\n\t            }\r\n\t\r\n\t            var addReg = function addReg(moduleName) {\r\n\t                if (regModules.indexOf(moduleName) === -1) {\r\n\t                    // register existing modules\r\n\t                    regModules.push(moduleName);\r\n\t                    var mainModule = angular.module(moduleName);\r\n\t\r\n\t                    // register existing components (directives, services, ...)\r\n\t                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\r\n\t                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\r\n\t\r\n\t                    angular.forEach(mainModule.requires, addReg);\r\n\t                }\r\n\t            };\r\n\t\r\n\t            angular.forEach(modulesToLoad, function (moduleName) {\r\n\t                addReg(moduleName);\r\n\t            });\r\n\t\r\n\t            modulesToLoad = []; // reset for next bootstrap\r\n\t            recordDeclarations.pop(); // wait for the next lazy load\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * Like JSON.stringify but that doesn't throw on circular references\r\n\t         * @param obj\r\n\t         */\r\n\t        var stringify = function stringify(obj) {\r\n\t            try {\r\n\t                return JSON.stringify(obj);\r\n\t            } catch (e) {\r\n\t                var cache = [];\r\n\t                return JSON.stringify(obj, function (key, value) {\r\n\t                    if (angular.isObject(value) && value !== null) {\r\n\t                        if (cache.indexOf(value) !== -1) {\r\n\t                            // Circular reference found, discard key\r\n\t                            return;\r\n\t                        }\r\n\t                        // Store value in our collection\r\n\t                        cache.push(value);\r\n\t                    }\r\n\t                    return value;\r\n\t                });\r\n\t            }\r\n\t        };\r\n\t\r\n\t        var hashCode = function hashCode(str) {\r\n\t            var hash = 0,\r\n\t                i,\r\n\t                chr,\r\n\t                len;\r\n\t            if (str.length == 0) {\r\n\t                return hash;\r\n\t            }\r\n\t            for (i = 0, len = str.length; i < len; i++) {\r\n\t                chr = str.charCodeAt(i);\r\n\t                hash = (hash << 5) - hash + chr;\r\n\t                hash |= 0; // Convert to 32bit integer\r\n\t            }\r\n\t            return hash;\r\n\t        };\r\n\t\r\n\t        function _register(providers, registerModules, params) {\r\n\t            if (registerModules) {\r\n\t                var k,\r\n\t                    moduleName,\r\n\t                    moduleFn,\r\n\t                    tempRunBlocks = [];\r\n\t                for (k = registerModules.length - 1; k >= 0; k--) {\r\n\t                    moduleName = registerModules[k];\r\n\t                    if (!angular.isString(moduleName)) {\r\n\t                        moduleName = getModuleName(moduleName);\r\n\t                    }\r\n\t                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\r\n\t                        continue;\r\n\t                    }\r\n\t                    // new if not registered\r\n\t                    var newModule = regModules.indexOf(moduleName) === -1;\r\n\t                    moduleFn = ngModuleFct(moduleName);\r\n\t                    if (newModule) {\r\n\t                        regModules.push(moduleName);\r\n\t                        _register(providers, moduleFn.requires, params);\r\n\t                    }\r\n\t                    if (moduleFn._runBlocks.length > 0) {\r\n\t                        // new run blocks detected! Replace the old ones (if existing)\r\n\t                        runBlocks[moduleName] = [];\r\n\t                        while (moduleFn._runBlocks.length > 0) {\r\n\t                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\r\n\t                        }\r\n\t                    }\r\n\t                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\r\n\t                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\r\n\t                    }\r\n\t                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\r\n\t                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\r\n\t                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\r\n\t                    registerModules.pop();\r\n\t                    justLoaded.push(moduleName);\r\n\t                }\r\n\t                // execute the run blocks at the end\r\n\t                var instanceInjector = providers.getInstanceInjector();\r\n\t                angular.forEach(tempRunBlocks, function (fn) {\r\n\t                    instanceInjector.invoke(fn);\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t\r\n\t        function _registerInvokeList(args, moduleName) {\r\n\t            var invokeList = args[2][0],\r\n\t                type = args[1],\r\n\t                newInvoke = false;\r\n\t            if (angular.isUndefined(regInvokes[moduleName])) {\r\n\t                regInvokes[moduleName] = {};\r\n\t            }\r\n\t            if (angular.isUndefined(regInvokes[moduleName][type])) {\r\n\t                regInvokes[moduleName][type] = {};\r\n\t            }\r\n\t            var onInvoke = function onInvoke(invokeName, invoke) {\r\n\t                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\r\n\t                    regInvokes[moduleName][type][invokeName] = [];\r\n\t                }\r\n\t                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\r\n\t                    newInvoke = true;\r\n\t                    regInvokes[moduleName][type][invokeName].push(invoke);\r\n\t                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\r\n\t                }\r\n\t            };\r\n\t\r\n\t            function checkHashes(potentialNew, invokes) {\r\n\t                var isNew = true,\r\n\t                    newHash;\r\n\t                if (invokes.length) {\r\n\t                    newHash = signature(potentialNew);\r\n\t                    angular.forEach(invokes, function (invoke) {\r\n\t                        isNew = isNew && signature(invoke) !== newHash;\r\n\t                    });\r\n\t                }\r\n\t                return isNew;\r\n\t            }\r\n\t\r\n\t            function signature(data) {\r\n\t                if (angular.isArray(data)) {\r\n\t                    // arrays are objects, we need to test for it first\r\n\t                    return hashCode(data.toString());\r\n\t                } else if (angular.isObject(data)) {\r\n\t                    // constants & values for example\r\n\t                    return hashCode(stringify(data));\r\n\t                } else {\r\n\t                    if (angular.isDefined(data) && data !== null) {\r\n\t                        return hashCode(data.toString());\r\n\t                    } else {\r\n\t                        // null & undefined constants\r\n\t                        return data;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (angular.isString(invokeList)) {\r\n\t                onInvoke(invokeList, args[2][1]);\r\n\t            } else if (angular.isObject(invokeList)) {\r\n\t                angular.forEach(invokeList, function (invoke, key) {\r\n\t                    if (angular.isString(invoke)) {\r\n\t                        // decorators for example\r\n\t                        onInvoke(invoke, invokeList[1]);\r\n\t                    } else {\r\n\t                        // components registered as object lists {\"componentName\": function() {}}\r\n\t                        onInvoke(key, invoke);\r\n\t                    }\r\n\t                });\r\n\t            } else {\r\n\t                return false;\r\n\t            }\r\n\t            return newInvoke;\r\n\t        }\r\n\t\r\n\t        function _invokeQueue(providers, queue, moduleName, reconfig) {\r\n\t            if (!queue) {\r\n\t                return;\r\n\t            }\r\n\t\r\n\t            var i, len, args, provider;\r\n\t            for (i = 0, len = queue.length; i < len; i++) {\r\n\t                args = queue[i];\r\n\t                if (angular.isArray(args)) {\r\n\t                    if (providers !== null) {\r\n\t                        if (providers.hasOwnProperty(args[0])) {\r\n\t                            provider = providers[args[0]];\r\n\t                        } else {\r\n\t                            throw new Error('unsupported provider ' + args[0]);\r\n\t                        }\r\n\t                    }\r\n\t                    var isNew = _registerInvokeList(args, moduleName);\r\n\t                    if (args[1] !== 'invoke') {\r\n\t                        if (isNew && angular.isDefined(provider)) {\r\n\t                            provider[args[1]].apply(provider, args[2]);\r\n\t                        }\r\n\t                    } else {\r\n\t                        // config block\r\n\t                        var callInvoke = function callInvoke(fct) {\r\n\t                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\r\n\t                            if (invoked === -1 || reconfig) {\r\n\t                                if (invoked === -1) {\r\n\t                                    regConfigs.push(moduleName + '-' + fct);\r\n\t                                }\r\n\t                                if (angular.isDefined(provider)) {\r\n\t                                    provider[args[1]].apply(provider, args[2]);\r\n\t                                }\r\n\t                            }\r\n\t                        };\r\n\t                        if (angular.isFunction(args[2][0])) {\r\n\t                            callInvoke(args[2][0]);\r\n\t                        } else if (angular.isArray(args[2][0])) {\r\n\t                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\r\n\t                                if (angular.isFunction(args[2][0][j])) {\r\n\t                                    callInvoke(args[2][0][j]);\r\n\t                                }\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        function getModuleName(module) {\r\n\t            var moduleName = null;\r\n\t            if (angular.isString(module)) {\r\n\t                moduleName = module;\r\n\t            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\r\n\t                moduleName = module.name;\r\n\t            }\r\n\t            return moduleName;\r\n\t        }\r\n\t\r\n\t        function moduleExists(moduleName) {\r\n\t            if (!angular.isString(moduleName)) {\r\n\t                return false;\r\n\t            }\r\n\t            try {\r\n\t                return ngModuleFct(moduleName);\r\n\t            } catch (e) {\r\n\t                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\r\n\t                    return false;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\r\n\t            var instanceInjector,\r\n\t                filesCache = $cacheFactory('ocLazyLoad');\r\n\t\r\n\t            if (!debug) {\r\n\t                $log = {};\r\n\t                $log['error'] = angular.noop;\r\n\t                $log['warn'] = angular.noop;\r\n\t                $log['info'] = angular.noop;\r\n\t            }\r\n\t\r\n\t            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\r\n\t            providers.getInstanceInjector = function () {\r\n\t                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\r\n\t            };\r\n\t\r\n\t            broadcast = function broadcast(eventName, params) {\r\n\t                if (events) {\r\n\t                    $rootScope.$broadcast(eventName, params);\r\n\t                }\r\n\t                if (debug) {\r\n\t                    $log.info(eventName, params);\r\n\t                }\r\n\t            };\r\n\t\r\n\t            function reject(e) {\r\n\t                var deferred = $q.defer();\r\n\t                $log.error(e.message);\r\n\t                deferred.reject(e);\r\n\t                return deferred.promise;\r\n\t            }\r\n\t\r\n\t            return {\r\n\t                _broadcast: broadcast,\r\n\t\r\n\t                _$log: $log,\r\n\t\r\n\t                /**\r\n\t                 * Returns the files cache used by the loaders to store the files currently loading\r\n\t                 * @returns {*}\r\n\t                 */\r\n\t                _getFilesCache: function getFilesCache() {\r\n\t                    return filesCache;\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Let the service know that it should monitor angular.module because files are loading\r\n\t                 * @param watch boolean\r\n\t                 */\r\n\t                toggleWatch: function toggleWatch(watch) {\r\n\t                    if (watch) {\r\n\t                        recordDeclarations.push(true);\r\n\t                    } else {\r\n\t                        recordDeclarations.pop();\r\n\t                    }\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Let you get a module config object\r\n\t                 * @param moduleName String the name of the module\r\n\t                 * @returns {*}\r\n\t                 */\r\n\t                getModuleConfig: function getModuleConfig(moduleName) {\r\n\t                    if (!angular.isString(moduleName)) {\r\n\t                        throw new Error('You need to give the name of the module to get');\r\n\t                    }\r\n\t                    if (!modules[moduleName]) {\r\n\t                        return null;\r\n\t                    }\r\n\t                    return angular.copy(modules[moduleName]);\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Let you define a module config object\r\n\t                 * @param moduleConfig Object the module config object\r\n\t                 * @returns {*}\r\n\t                 */\r\n\t                setModuleConfig: function setModuleConfig(moduleConfig) {\r\n\t                    if (!angular.isObject(moduleConfig)) {\r\n\t                        throw new Error('You need to give the module config object to set');\r\n\t                    }\r\n\t                    modules[moduleConfig.name] = moduleConfig;\r\n\t                    return moduleConfig;\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Returns the list of loaded modules\r\n\t                 * @returns {string[]}\r\n\t                 */\r\n\t                getModules: function getModules() {\r\n\t                    return regModules;\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Let you check if a module has been loaded into Angular or not\r\n\t                 * @param modulesNames String/Object a module name, or a list of module names\r\n\t                 * @returns {boolean}\r\n\t                 */\r\n\t                isLoaded: function isLoaded(modulesNames) {\r\n\t                    var moduleLoaded = function moduleLoaded(module) {\r\n\t                        var isLoaded = regModules.indexOf(module) > -1;\r\n\t                        if (!isLoaded) {\r\n\t                            isLoaded = !!moduleExists(module);\r\n\t                        }\r\n\t                        return isLoaded;\r\n\t                    };\r\n\t                    if (angular.isString(modulesNames)) {\r\n\t                        modulesNames = [modulesNames];\r\n\t                    }\r\n\t                    if (angular.isArray(modulesNames)) {\r\n\t                        var i, len;\r\n\t                        for (i = 0, len = modulesNames.length; i < len; i++) {\r\n\t                            if (!moduleLoaded(modulesNames[i])) {\r\n\t                                return false;\r\n\t                            }\r\n\t                        }\r\n\t                        return true;\r\n\t                    } else {\r\n\t                        throw new Error('You need to define the module(s) name(s)');\r\n\t                    }\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Given a module, return its name\r\n\t                 * @param module\r\n\t                 * @returns {String}\r\n\t                 */\r\n\t                _getModuleName: getModuleName,\r\n\t\r\n\t                /**\r\n\t                 * Returns a module if it exists\r\n\t                 * @param moduleName\r\n\t                 * @returns {module}\r\n\t                 */\r\n\t                _getModule: function getModule(moduleName) {\r\n\t                    try {\r\n\t                        return ngModuleFct(moduleName);\r\n\t                    } catch (e) {\r\n\t                        // this error message really suxx\r\n\t                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\r\n\t                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\r\n\t                        }\r\n\t                        throw e;\r\n\t                    }\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Check if a module exists and returns it if it does\r\n\t                 * @param moduleName\r\n\t                 * @returns {boolean}\r\n\t                 */\r\n\t                moduleExists: moduleExists,\r\n\t\r\n\t                /**\r\n\t                 * Load the dependencies, and might try to load new files depending on the config\r\n\t                 * @param moduleName (String or Array of Strings)\r\n\t                 * @param localParams\r\n\t                 * @returns {*}\r\n\t                 * @private\r\n\t                 */\r\n\t                _loadDependencies: function _loadDependencies(moduleName, localParams) {\r\n\t                    var loadedModule,\r\n\t                        requires,\r\n\t                        diff,\r\n\t                        promisesList = [],\r\n\t                        self = this;\r\n\t\r\n\t                    moduleName = self._getModuleName(moduleName);\r\n\t\r\n\t                    if (moduleName === null) {\r\n\t                        return $q.when();\r\n\t                    } else {\r\n\t                        try {\r\n\t                            loadedModule = self._getModule(moduleName);\r\n\t                        } catch (e) {\r\n\t                            return reject(e);\r\n\t                        }\r\n\t                        // get unloaded requires\r\n\t                        requires = self.getRequires(loadedModule);\r\n\t                    }\r\n\t\r\n\t                    angular.forEach(requires, function (requireEntry) {\r\n\t                        // If no configuration is provided, try and find one from a previous load.\r\n\t                        // If there isn't one, bail and let the normal flow run\r\n\t                        if (angular.isString(requireEntry)) {\r\n\t                            var config = self.getModuleConfig(requireEntry);\r\n\t                            if (config === null) {\r\n\t                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\r\n\t                                return;\r\n\t                            }\r\n\t                            requireEntry = config;\r\n\t                            // ignore the name because it's probably not a real module name\r\n\t                            config.name = undefined;\r\n\t                        }\r\n\t\r\n\t                        // Check if this dependency has been loaded previously\r\n\t                        if (self.moduleExists(requireEntry.name)) {\r\n\t                            // compare against the already loaded module to see if the new definition adds any new files\r\n\t                            diff = requireEntry.files.filter(function (n) {\r\n\t                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\r\n\t                            });\r\n\t\r\n\t                            // If the module was redefined, advise via the console\r\n\t                            if (diff.length !== 0) {\r\n\t                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\r\n\t                            }\r\n\t\r\n\t                            // Push everything to the file loader, it will weed out the duplicates.\r\n\t                            if (angular.isDefined(self.filesLoader)) {\r\n\t                                // if a files loader is defined\r\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\r\n\t                                    return self._loadDependencies(requireEntry);\r\n\t                                }));\r\n\t                            } else {\r\n\t                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\r\n\t                            }\r\n\t                            return;\r\n\t                        } else if (angular.isArray(requireEntry)) {\r\n\t                            var files = [];\r\n\t                            angular.forEach(requireEntry, function (entry) {\r\n\t                                // let's check if the entry is a file name or a config name\r\n\t                                var config = self.getModuleConfig(entry);\r\n\t                                if (config === null) {\r\n\t                                    files.push(entry);\r\n\t                                } else if (config.files) {\r\n\t                                    files = files.concat(config.files);\r\n\t                                }\r\n\t                            });\r\n\t                            if (files.length > 0) {\r\n\t                                requireEntry = {\r\n\t                                    files: files\r\n\t                                };\r\n\t                            }\r\n\t                        } else if (angular.isObject(requireEntry)) {\r\n\t                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\r\n\t                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\r\n\t                                self.setModuleConfig(requireEntry);\r\n\t                                moduleCache.push(requireEntry['name']);\r\n\t                            }\r\n\t                        }\r\n\t\r\n\t                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\r\n\t                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\r\n\t                            if (angular.isDefined(self.filesLoader)) {\r\n\t                                // if a files loader is defined\r\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\r\n\t                                    return self._loadDependencies(requireEntry);\r\n\t                                }));\r\n\t                            } else {\r\n\t                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\r\n\t                            }\r\n\t                        }\r\n\t                    });\r\n\t\r\n\t                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\r\n\t                    return $q.all(promisesList);\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Inject new modules into Angular\r\n\t                 * @param moduleName\r\n\t                 * @param localParams\r\n\t                 * @param real\r\n\t                 */\r\n\t                inject: function inject(moduleName) {\r\n\t                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\r\n\t                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\r\n\t\r\n\t                    var self = this,\r\n\t                        deferred = $q.defer();\r\n\t                    if (angular.isDefined(moduleName) && moduleName !== null) {\r\n\t                        if (angular.isArray(moduleName)) {\r\n\t                            var promisesList = [];\r\n\t                            angular.forEach(moduleName, function (module) {\r\n\t                                promisesList.push(self.inject(module, localParams, real));\r\n\t                            });\r\n\t                            return $q.all(promisesList);\r\n\t                        } else {\r\n\t                            self._addToLoadList(self._getModuleName(moduleName), true, real);\r\n\t                        }\r\n\t                    }\r\n\t                    if (modulesToLoad.length > 0) {\r\n\t                        var res = modulesToLoad.slice(); // clean copy\r\n\t                        var loadNext = function loadNext(moduleName) {\r\n\t                            moduleCache.push(moduleName);\r\n\t                            modulePromises[moduleName] = deferred.promise;\r\n\t                            self._loadDependencies(moduleName, localParams).then(function success() {\r\n\t                                try {\r\n\t                                    justLoaded = [];\r\n\t                                    _register(providers, moduleCache, localParams);\r\n\t                                } catch (e) {\r\n\t                                    self._$log.error(e.message);\r\n\t                                    deferred.reject(e);\r\n\t                                    return;\r\n\t                                }\r\n\t\r\n\t                                if (modulesToLoad.length > 0) {\r\n\t                                    loadNext(modulesToLoad.shift()); // load the next in list\r\n\t                                } else {\r\n\t                                        deferred.resolve(res); // everything has been loaded, resolve\r\n\t                                    }\r\n\t                            }, function error(err) {\r\n\t                                deferred.reject(err);\r\n\t                            });\r\n\t                        };\r\n\t\r\n\t                        // load the first in list\r\n\t                        loadNext(modulesToLoad.shift());\r\n\t                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\r\n\t                        return modulePromises[localParams.name];\r\n\t                    } else {\r\n\t                        deferred.resolve();\r\n\t                    }\r\n\t                    return deferred.promise;\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Get the list of required modules/services/... for this module\r\n\t                 * @param module\r\n\t                 * @returns {Array}\r\n\t                 */\r\n\t                getRequires: function getRequires(module) {\r\n\t                    var requires = [];\r\n\t                    angular.forEach(module.requires, function (requireModule) {\r\n\t                        if (regModules.indexOf(requireModule) === -1) {\r\n\t                            requires.push(requireModule);\r\n\t                        }\r\n\t                    });\r\n\t                    return requires;\r\n\t                },\r\n\t\r\n\t                /**\r\n\t                 * Invoke the new modules & component by their providers\r\n\t                 * @param providers\r\n\t                 * @param queue\r\n\t                 * @param moduleName\r\n\t                 * @param reconfig\r\n\t                 * @private\r\n\t                 */\r\n\t                _invokeQueue: _invokeQueue,\r\n\t\r\n\t                /**\r\n\t                 * Check if a module has been invoked and registers it if not\r\n\t                 * @param args\r\n\t                 * @param moduleName\r\n\t                 * @returns {boolean} is new\r\n\t                 */\r\n\t                _registerInvokeList: _registerInvokeList,\r\n\t\r\n\t                /**\r\n\t                 * Register a new module and loads it, executing the run/config blocks if needed\r\n\t                 * @param providers\r\n\t                 * @param registerModules\r\n\t                 * @param params\r\n\t                 * @private\r\n\t                 */\r\n\t                _register: _register,\r\n\t\r\n\t                /**\r\n\t                 * Add a module name to the list of modules that will be loaded in the next inject\r\n\t                 * @param name\r\n\t                 * @param force\r\n\t                 * @private\r\n\t                 */\r\n\t                _addToLoadList: _addToLoadList\r\n\t            };\r\n\t        }];\r\n\t\r\n\t        // Let's get the list of loaded modules & components\r\n\t        this._init(angular.element(window.document));\r\n\t    }]);\r\n\t\r\n\t    var bootstrapFct = angular.bootstrap;\r\n\t    angular.bootstrap = function (element, modules, config) {\r\n\t        // we use slice to make a clean copy\r\n\t        angular.forEach(modules.slice(), function (module) {\r\n\t            _addToLoadList(module, true, true);\r\n\t        });\r\n\t        return bootstrapFct(element, modules, config);\r\n\t    };\r\n\t\r\n\t    var _addToLoadList = function _addToLoadList(name, force, real) {\r\n\t        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\r\n\t            modulesToLoad.push(name);\r\n\t            if (real) {\r\n\t                realModules.push(name);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var ngModuleFct = angular.module;\r\n\t    angular.module = function (name, requires, configFn) {\r\n\t        _addToLoadList(name, false, true);\r\n\t        return ngModuleFct(name, requires, configFn);\r\n\t    };\r\n\t\r\n\t    // CommonJS package manager support:\r\n\t    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\r\n\t        module.exports = 'oc.lazyLoad';\r\n\t    }\r\n\t})(angular, window);\r\n\t(function (angular) {\r\n\t    'use strict';\r\n\t\r\n\t    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\r\n\t        return {\r\n\t            restrict: 'A',\r\n\t            terminal: true,\r\n\t            priority: 1000,\r\n\t            compile: function compile(element, attrs) {\r\n\t                // we store the content and remove it before compilation\r\n\t                var content = element[0].innerHTML;\r\n\t                element.html('');\r\n\t\r\n\t                return function ($scope, $element, $attr) {\r\n\t                    var model = $parse($attr.ocLazyLoad);\r\n\t                    $scope.$watch(function () {\r\n\t                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\r\n\t                    }, function (moduleName) {\r\n\t                        if (angular.isDefined(moduleName)) {\r\n\t                            $ocLazyLoad.load(moduleName).then(function () {\r\n\t                                // Attach element contents to DOM and then compile them.\r\n\t                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\r\n\t                                // of the compiled contents when attaching to the parent DOM.\r\n\t                                $animate.enter(content, $element);\r\n\t                                // get the new content & compile it\r\n\t                                $compile($element.contents())($scope);\r\n\t                            });\r\n\t                        }\r\n\t                    }, true);\r\n\t                };\r\n\t            }\r\n\t        };\r\n\t    }]);\r\n\t})(angular);\r\n\t(function (angular) {\r\n\t    'use strict';\r\n\t\r\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\r\n\t            var uaCssChecked = false,\r\n\t                useCssLoadPatch = false,\r\n\t                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\r\n\t\r\n\t            /**\r\n\t             * Load a js/css file\r\n\t             * @param type\r\n\t             * @param path\r\n\t             * @param params\r\n\t             * @returns promise\r\n\t             */\r\n\t            $delegate.buildElement = function buildElement(type, path, params) {\r\n\t                var deferred = $q.defer(),\r\n\t                    el,\r\n\t                    loaded,\r\n\t                    filesCache = $delegate._getFilesCache(),\r\n\t                    cacheBuster = function cacheBuster(url) {\r\n\t                    var dc = new Date().getTime();\r\n\t                    if (url.indexOf('?') >= 0) {\r\n\t                        if (url.substring(0, url.length - 1) === '&') {\r\n\t                            return url + '_dc=' + dc;\r\n\t                        }\r\n\t                        return url + '&_dc=' + dc;\r\n\t                    } else {\r\n\t                        return url + '?_dc=' + dc;\r\n\t                    }\r\n\t                };\r\n\t\r\n\t                // Store the promise early so the file load can be detected by other parallel lazy loads\r\n\t                // (ie: multiple routes on one page) a 'true' value isn't sufficient\r\n\t                // as it causes false positive load results.\r\n\t                if (angular.isUndefined(filesCache.get(path))) {\r\n\t                    filesCache.put(path, deferred.promise);\r\n\t                }\r\n\t\r\n\t                // Switch in case more content types are added later\r\n\t                switch (type) {\r\n\t                    case 'css':\r\n\t                        el = $window.document.createElement('link');\r\n\t                        el.type = 'text/css';\r\n\t                        el.rel = 'stylesheet';\r\n\t                        el.href = params.cache === false ? cacheBuster(path) : path;\r\n\t                        break;\r\n\t                    case 'js':\r\n\t                        el = $window.document.createElement('script');\r\n\t                        el.src = params.cache === false ? cacheBuster(path) : path;\r\n\t                        break;\r\n\t                    default:\r\n\t                        filesCache.remove(path);\r\n\t                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\r\n\t                        break;\r\n\t                }\r\n\t                el.onload = el['onreadystatechange'] = function (e) {\r\n\t                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\r\n\t                    el.onload = el['onreadystatechange'] = null;\r\n\t                    loaded = 1;\r\n\t                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\r\n\t                    deferred.resolve();\r\n\t                };\r\n\t                el.onerror = function () {\r\n\t                    filesCache.remove(path);\r\n\t                    deferred.reject(new Error('Unable to load ' + path));\r\n\t                };\r\n\t                el.async = params.serie ? 0 : 1;\r\n\t\r\n\t                var insertBeforeElem = anchor.lastChild;\r\n\t                if (params.insertBefore) {\r\n\t                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\r\n\t                    if (element && element.length > 0) {\r\n\t                        insertBeforeElem = element[0];\r\n\t                    }\r\n\t                }\r\n\t                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\r\n\t\r\n\t                /*\r\n\t                 The event load or readystatechange doesn't fire in:\r\n\t                 - iOS < 6       (default mobile browser)\r\n\t                 - Android < 4.4 (default mobile browser)\r\n\t                 - Safari < 6    (desktop browser)\r\n\t                 */\r\n\t                if (type == 'css') {\r\n\t                    if (!uaCssChecked) {\r\n\t                        var ua = $window.navigator.userAgent.toLowerCase();\r\n\t\r\n\t                        // iOS < 6\r\n\t                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\r\n\t                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\r\n\t                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\r\n\t                            useCssLoadPatch = iOSVersion < 6;\r\n\t                        } else if (ua.indexOf(\"android\") > -1) {\r\n\t                            // Android < 4.4\r\n\t                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\r\n\t                            useCssLoadPatch = androidVersion < 4.4;\r\n\t                        } else if (ua.indexOf('safari') > -1) {\r\n\t                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\r\n\t                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\r\n\t                        }\r\n\t                    }\r\n\t\r\n\t                    if (useCssLoadPatch) {\r\n\t                        var tries = 1000; // * 20 = 20000 miliseconds\r\n\t                        var interval = $interval(function () {\r\n\t                            try {\r\n\t                                el.sheet.cssRules;\r\n\t                                $interval.cancel(interval);\r\n\t                                el.onload();\r\n\t                            } catch (e) {\r\n\t                                if (--tries <= 0) {\r\n\t                                    el.onerror();\r\n\t                                }\r\n\t                            }\r\n\t                        }, 20);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                return deferred.promise;\r\n\t            };\r\n\t\r\n\t            return $delegate;\r\n\t        }]);\r\n\t    }]);\r\n\t})(angular);\r\n\t(function (angular) {\r\n\t    'use strict';\r\n\t\r\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\r\n\t            /**\r\n\t             * The function that loads new files\r\n\t             * @param config\r\n\t             * @param params\r\n\t             * @returns {*}\r\n\t             */\r\n\t            $delegate.filesLoader = function filesLoader(config) {\r\n\t                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\r\n\t\r\n\t                var cssFiles = [],\r\n\t                    templatesFiles = [],\r\n\t                    jsFiles = [],\r\n\t                    promises = [],\r\n\t                    cachePromise = null,\r\n\t                    filesCache = $delegate._getFilesCache();\r\n\t\r\n\t                $delegate.toggleWatch(true); // start watching angular.module calls\r\n\t\r\n\t                angular.extend(params, config);\r\n\t\r\n\t                var pushFile = function pushFile(path) {\r\n\t                    var file_type = null,\r\n\t                        m;\r\n\t                    if (angular.isObject(path)) {\r\n\t                        file_type = path.type;\r\n\t                        path = path.path;\r\n\t                    }\r\n\t                    cachePromise = filesCache.get(path);\r\n\t                    if (angular.isUndefined(cachePromise) || params.cache === false) {\r\n\t\r\n\t                        // always check for requirejs syntax just in case\r\n\t                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\r\n\t                            // Detect file type using preceding type declaration (ala requireJS)\r\n\t                            file_type = m[1];\r\n\t                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\r\n\t                        }\r\n\t\r\n\t                        if (!file_type) {\r\n\t                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\r\n\t                                // Detect file type via file extension\r\n\t                                file_type = m[1];\r\n\t                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\r\n\t                                // requirejs\r\n\t                                file_type = 'js';\r\n\t                            } else {\r\n\t                                $delegate._$log.error('File type could not be determined. ' + path);\r\n\t                                return;\r\n\t                            }\r\n\t                        }\r\n\t\r\n\t                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\r\n\t                            cssFiles.push(path);\r\n\t                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\r\n\t                            templatesFiles.push(path);\r\n\t                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\r\n\t                            jsFiles.push(path);\r\n\t                        } else {\r\n\t                            $delegate._$log.error('File type is not valid. ' + path);\r\n\t                        }\r\n\t                    } else if (cachePromise) {\r\n\t                        promises.push(cachePromise);\r\n\t                    }\r\n\t                };\r\n\t\r\n\t                if (params.serie) {\r\n\t                    pushFile(params.files.shift());\r\n\t                } else {\r\n\t                    angular.forEach(params.files, function (path) {\r\n\t                        pushFile(path);\r\n\t                    });\r\n\t                }\r\n\t\r\n\t                if (cssFiles.length > 0) {\r\n\t                    var cssDeferred = $q.defer();\r\n\t                    $delegate.cssLoader(cssFiles, function (err) {\r\n\t                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\r\n\t                            $delegate._$log.error(err);\r\n\t                            cssDeferred.reject(err);\r\n\t                        } else {\r\n\t                            cssDeferred.resolve();\r\n\t                        }\r\n\t                    }, params);\r\n\t                    promises.push(cssDeferred.promise);\r\n\t                }\r\n\t\r\n\t                if (templatesFiles.length > 0) {\r\n\t                    var templatesDeferred = $q.defer();\r\n\t                    $delegate.templatesLoader(templatesFiles, function (err) {\r\n\t                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\r\n\t                            $delegate._$log.error(err);\r\n\t                            templatesDeferred.reject(err);\r\n\t                        } else {\r\n\t                            templatesDeferred.resolve();\r\n\t                        }\r\n\t                    }, params);\r\n\t                    promises.push(templatesDeferred.promise);\r\n\t                }\r\n\t\r\n\t                if (jsFiles.length > 0) {\r\n\t                    var jsDeferred = $q.defer();\r\n\t                    $delegate.jsLoader(jsFiles, function (err) {\r\n\t                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\r\n\t                            $delegate._$log.error(err);\r\n\t                            jsDeferred.reject(err);\r\n\t                        } else {\r\n\t                            jsDeferred.resolve();\r\n\t                        }\r\n\t                    }, params);\r\n\t                    promises.push(jsDeferred.promise);\r\n\t                }\r\n\t\r\n\t                if (promises.length === 0) {\r\n\t                    var deferred = $q.defer(),\r\n\t                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\r\n\t                    $delegate._$log.error(err);\r\n\t                    deferred.reject(err);\r\n\t                    return deferred.promise;\r\n\t                } else if (params.serie && params.files.length > 0) {\r\n\t                    return $q.all(promises).then(function () {\r\n\t                        return $delegate.filesLoader(config, params);\r\n\t                    });\r\n\t                } else {\r\n\t                    return $q.all(promises)['finally'](function (res) {\r\n\t                        $delegate.toggleWatch(false); // stop watching angular.module calls\r\n\t                        return res;\r\n\t                    });\r\n\t                }\r\n\t            };\r\n\t\r\n\t            /**\r\n\t             * Load a module or a list of modules into Angular\r\n\t             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n\t             * @param params Object optional parameters\r\n\t             * @returns promise\r\n\t             */\r\n\t            $delegate.load = function (originalModule) {\r\n\t                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\r\n\t\r\n\t                var self = this,\r\n\t                    config = null,\r\n\t                    deferredList = [],\r\n\t                    deferred = $q.defer(),\r\n\t                    errText;\r\n\t\r\n\t                // clean copy\r\n\t                var module = angular.copy(originalModule);\r\n\t                var params = angular.copy(originalParams);\r\n\t\r\n\t                // If module is an array, break it down\r\n\t                if (angular.isArray(module)) {\r\n\t                    // Resubmit each entry as a single module\r\n\t                    angular.forEach(module, function (m) {\r\n\t                        deferredList.push(self.load(m, params));\r\n\t                    });\r\n\t\r\n\t                    // Resolve the promise once everything has loaded\r\n\t                    $q.all(deferredList).then(function (res) {\r\n\t                        deferred.resolve(res);\r\n\t                    }, function (err) {\r\n\t                        deferred.reject(err);\r\n\t                    });\r\n\t\r\n\t                    return deferred.promise;\r\n\t                }\r\n\t\r\n\t                // Get or Set a configuration depending on what was passed in\r\n\t                if (angular.isString(module)) {\r\n\t                    config = self.getModuleConfig(module);\r\n\t                    if (!config) {\r\n\t                        config = {\r\n\t                            files: [module]\r\n\t                        };\r\n\t                    }\r\n\t                } else if (angular.isObject(module)) {\r\n\t                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\r\n\t                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\r\n\t                        config = {\r\n\t                            files: [module]\r\n\t                        };\r\n\t                    } else {\r\n\t                        config = self.setModuleConfig(module);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                if (config === null) {\r\n\t                    var moduleName = self._getModuleName(module);\r\n\t                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\r\n\t                    $delegate._$log.error(errText);\r\n\t                    deferred.reject(new Error(errText));\r\n\t                    return deferred.promise;\r\n\t                } else {\r\n\t                    // deprecated\r\n\t                    if (angular.isDefined(config.template)) {\r\n\t                        if (angular.isUndefined(config.files)) {\r\n\t                            config.files = [];\r\n\t                        }\r\n\t                        if (angular.isString(config.template)) {\r\n\t                            config.files.push(config.template);\r\n\t                        } else if (angular.isArray(config.template)) {\r\n\t                            config.files.concat(config.template);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                var localParams = angular.extend({}, params, config);\r\n\t\r\n\t                // if someone used an external loader and called the load function with just the module name\r\n\t                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\r\n\t                    return $delegate.inject(config.name, localParams, true);\r\n\t                }\r\n\t\r\n\t                $delegate.filesLoader(config, localParams).then(function () {\r\n\t                    $delegate.inject(null, localParams).then(function (res) {\r\n\t                        deferred.resolve(res);\r\n\t                    }, function (err) {\r\n\t                        deferred.reject(err);\r\n\t                    });\r\n\t                }, function (err) {\r\n\t                    deferred.reject(err);\r\n\t                });\r\n\t\r\n\t                return deferred.promise;\r\n\t            };\r\n\t\r\n\t            // return the patched service\r\n\t            return $delegate;\r\n\t        }]);\r\n\t    }]);\r\n\t})(angular);\r\n\t(function (angular) {\r\n\t    'use strict';\r\n\t\r\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\r\n\t            /**\r\n\t             * cssLoader function\r\n\t             * @type Function\r\n\t             * @param paths array list of css files to load\r\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\r\n\t             * @param params object config parameters\r\n\t             * because the user can overwrite cssLoader and it will probably not use promises :(\r\n\t             */\r\n\t            $delegate.cssLoader = function (paths, callback, params) {\r\n\t                var promises = [];\r\n\t                angular.forEach(paths, function (path) {\r\n\t                    promises.push($delegate.buildElement('css', path, params));\r\n\t                });\r\n\t                $q.all(promises).then(function () {\r\n\t                    callback();\r\n\t                }, function (err) {\r\n\t                    callback(err);\r\n\t                });\r\n\t            };\r\n\t            $delegate.cssLoader.ocLazyLoadLoader = true;\r\n\t\r\n\t            return $delegate;\r\n\t        }]);\r\n\t    }]);\r\n\t})(angular);\r\n\t(function (angular) {\r\n\t    'use strict';\r\n\t\r\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\r\n\t            /**\r\n\t             * jsLoader function\r\n\t             * @type Function\r\n\t             * @param paths array list of js files to load\r\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\r\n\t             * @param params object config parameters\r\n\t             * because the user can overwrite jsLoader and it will probably not use promises :(\r\n\t             */\r\n\t            $delegate.jsLoader = function (paths, callback, params) {\r\n\t                var promises = [];\r\n\t                angular.forEach(paths, function (path) {\r\n\t                    promises.push($delegate.buildElement('js', path, params));\r\n\t                });\r\n\t                $q.all(promises).then(function () {\r\n\t                    callback();\r\n\t                }, function (err) {\r\n\t                    callback(err);\r\n\t                });\r\n\t            };\r\n\t            $delegate.jsLoader.ocLazyLoadLoader = true;\r\n\t\r\n\t            return $delegate;\r\n\t        }]);\r\n\t    }]);\r\n\t})(angular);\r\n\t(function (angular) {\r\n\t    'use strict';\r\n\t\r\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\r\n\t            /**\r\n\t             * templatesLoader function\r\n\t             * @type Function\r\n\t             * @param paths array list of css files to load\r\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\r\n\t             * @param params object config parameters for $http\r\n\t             * because the user can overwrite templatesLoader and it will probably not use promises :(\r\n\t             */\r\n\t            $delegate.templatesLoader = function (paths, callback, params) {\r\n\t                var promises = [],\r\n\t                    filesCache = $delegate._getFilesCache();\r\n\t\r\n\t                angular.forEach(paths, function (url) {\r\n\t                    var deferred = $q.defer();\r\n\t                    promises.push(deferred.promise);\r\n\t                    $http.get(url, params).success(function (data) {\r\n\t                        if (angular.isString(data) && data.length > 0) {\r\n\t                            angular.forEach(angular.element(data), function (node) {\r\n\t                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\r\n\t                                    $templateCache.put(node.id, node.innerHTML);\r\n\t                                }\r\n\t                            });\r\n\t                        }\r\n\t                        if (angular.isUndefined(filesCache.get(url))) {\r\n\t                            filesCache.put(url, true);\r\n\t                        }\r\n\t                        deferred.resolve();\r\n\t                    }).error(function (err) {\r\n\t                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\r\n\t                    });\r\n\t                });\r\n\t                return $q.all(promises).then(function () {\r\n\t                    callback();\r\n\t                }, function (err) {\r\n\t                    callback(err);\r\n\t                });\r\n\t            };\r\n\t            $delegate.templatesLoader.ocLazyLoadLoader = true;\r\n\t\r\n\t            return $delegate;\r\n\t        }]);\r\n\t    }]);\r\n\t})(angular);\r\n\t// Array.indexOf polyfill for IE8\r\n\tif (!Array.prototype.indexOf) {\r\n\t        Array.prototype.indexOf = function (searchElement, fromIndex) {\r\n\t                var k;\r\n\t\r\n\t                // 1. Let O be the result of calling ToObject passing\r\n\t                //    the this value as the argument.\r\n\t                if (this == null) {\r\n\t                        throw new TypeError('\"this\" is null or not defined');\r\n\t                }\r\n\t\r\n\t                var O = Object(this);\r\n\t\r\n\t                // 2. Let lenValue be the result of calling the Get\r\n\t                //    internal method of O with the argument \"length\".\r\n\t                // 3. Let len be ToUint32(lenValue).\r\n\t                var len = O.length >>> 0;\r\n\t\r\n\t                // 4. If len is 0, return -1.\r\n\t                if (len === 0) {\r\n\t                        return -1;\r\n\t                }\r\n\t\r\n\t                // 5. If argument fromIndex was passed let n be\r\n\t                //    ToInteger(fromIndex); else let n be 0.\r\n\t                var n = +fromIndex || 0;\r\n\t\r\n\t                if (Math.abs(n) === Infinity) {\r\n\t                        n = 0;\r\n\t                }\r\n\t\r\n\t                // 6. If n >= len, return -1.\r\n\t                if (n >= len) {\r\n\t                        return -1;\r\n\t                }\r\n\t\r\n\t                // 7. If n >= 0, then Let k be n.\r\n\t                // 8. Else, n<0, Let k be len - abs(n).\r\n\t                //    If k is less than 0, then let k be 0.\r\n\t                k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\r\n\t\r\n\t                // 9. Repeat, while k < len\r\n\t                while (k < len) {\r\n\t                        // a. Let Pk be ToString(k).\r\n\t                        //   This is implicit for LHS operands of the in operator\r\n\t                        // b. Let kPresent be the result of calling the\r\n\t                        //    HasProperty internal method of O with argument Pk.\r\n\t                        //   This step can be combined with c\r\n\t                        // c. If kPresent is true, then\r\n\t                        //    i.  Let elementK be the result of calling the Get\r\n\t                        //        internal method of O with the argument ToString(k).\r\n\t                        //   ii.  Let same be the result of applying the\r\n\t                        //        Strict Equality Comparison Algorithm to\r\n\t                        //        searchElement and elementK.\r\n\t                        //  iii.  If same is true, return k.\r\n\t                        if (k in O && O[k] === searchElement) {\r\n\t                                return k;\r\n\t                        }\r\n\t                        k++;\r\n\t                }\r\n\t                return -1;\r\n\t        };\r\n\t}\n\n/***/ },\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */\n/***/ function(module, exports) {\n\n\t/*\n\t * angular-ui-bootstrap\n\t * http://angular-ui.github.io/bootstrap/\n\t\n\t * Version: 0.14.3 - 2015-10-23\n\t * License: MIT\n\t */\n\tangular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\n\tangular.module(\"ui.bootstrap.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/carousel/carousel.html\",\"template/carousel/slide.html\",\"template/datepicker/datepicker.html\",\"template/datepicker/day.html\",\"template/datepicker/month.html\",\"template/datepicker/popup.html\",\"template/datepicker/year.html\",\"template/modal/backdrop.html\",\"template/modal/window.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/tooltip/tooltip-template-popup.html\",\"template/popover/popover-html.html\",\"template/popover/popover-template.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/progressbar/progressbar.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/timepicker/timepicker.html\",\"template/typeahead/typeahead-match.html\",\"template/typeahead/typeahead-popup.html\"]);\n\tangular.module('ui.bootstrap.collapse', [])\n\t\n\t  .directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {\n\t    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n\t    return {\n\t      link: function(scope, element, attrs) {\n\t        function expand() {\n\t          element.removeClass('collapse')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', true)\n\t            .attr('aria-hidden', false);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              addClass: 'in',\n\t              easing: 'ease',\n\t              to: { height: element[0].scrollHeight + 'px' }\n\t            }).start().finally(expandDone);\n\t          } else {\n\t            $animate.addClass(element, 'in', {\n\t              to: { height: element[0].scrollHeight + 'px' }\n\t            }).then(expandDone);\n\t          }\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse')\n\t            .css({height: 'auto'});\n\t        }\n\t\n\t        function collapse() {\n\t          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n\t            return collapseDone();\n\t          }\n\t\n\t          element\n\t            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n\t            // Otherwise, the browser attempts to animate from height 0 (in\n\t            // collapsing class) to the given height here.\n\t            .css({height: element[0].scrollHeight + 'px'})\n\t            // initially all panel collapse have the collapse class, this removal\n\t            // prevents the animation from jumping to collapsed state\n\t            .removeClass('collapse')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', false)\n\t            .attr('aria-hidden', true);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              removeClass: 'in',\n\t              to: {height: '0'}\n\t            }).start().finally(collapseDone);\n\t          } else {\n\t            $animate.removeClass(element, 'in', {\n\t              to: {height: '0'}\n\t            }).then(collapseDone);\n\t          }\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse');\n\t        }\n\t\n\t        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\t/* Deprecated collapse below */\n\t\n\tangular.module('ui.bootstrap.collapse')\n\t\n\t  .value('$collapseSuppressWarning', false)\n\t\n\t  .directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {\n\t    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n\t    return {\n\t      link: function(scope, element, attrs) {\n\t        if (!$collapseSuppressWarning) {\n\t          $log.warn('collapse is now deprecated. Use uib-collapse instead.');\n\t        }\n\t\n\t        function expand() {\n\t          element.removeClass('collapse')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', true)\n\t            .attr('aria-hidden', false);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              easing: 'ease',\n\t              to: { height: element[0].scrollHeight + 'px' }\n\t            }).start().done(expandDone);\n\t          } else {\n\t            $animate.animate(element, {}, {\n\t              height: element[0].scrollHeight + 'px'\n\t            }).then(expandDone);\n\t          }\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse in')\n\t            .css({height: 'auto'});\n\t        }\n\t\n\t        function collapse() {\n\t          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n\t            return collapseDone();\n\t          }\n\t\n\t          element\n\t            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n\t            // Otherwise, the browser attempts to animate from height 0 (in\n\t            // collapsing class) to the given height here.\n\t            .css({height: element[0].scrollHeight + 'px'})\n\t            // initially all panel collapse have the collapse class, this removal\n\t            // prevents the animation from jumping to collapsed state\n\t            .removeClass('collapse in')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', false)\n\t            .attr('aria-hidden', true);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              to: {height: '0'}\n\t            }).start().done(collapseDone);\n\t          } else {\n\t            $animate.animate(element, {}, {\n\t              height: '0'\n\t            }).then(collapseDone);\n\t          }\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse');\n\t        }\n\t\n\t        scope.$watch(attrs.collapse, function(shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\t\n\t.constant('uibAccordionConfig', {\n\t  closeOthers: true\n\t})\n\t\n\t.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n\t  // This array keeps track of the accordion groups\n\t  this.groups = [];\n\t\n\t  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n\t  this.closeOthers = function(openGroup) {\n\t    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n\t      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n\t    if (closeOthers) {\n\t      angular.forEach(this.groups, function(group) {\n\t        if (group !== openGroup) {\n\t          group.isOpen = false;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  // This is called from the accordion-group directive to add itself to the accordion\n\t  this.addGroup = function(groupScope) {\n\t    var that = this;\n\t    this.groups.push(groupScope);\n\t\n\t    groupScope.$on('$destroy', function(event) {\n\t      that.removeGroup(groupScope);\n\t    });\n\t  };\n\t\n\t  // This is called from the accordion-group directive when to remove itself\n\t  this.removeGroup = function(group) {\n\t    var index = this.groups.indexOf(group);\n\t    if (index !== -1) {\n\t      this.groups.splice(index, 1);\n\t    }\n\t  };\n\t\n\t}])\n\t\n\t// The accordion directive simply sets up the directive controller\n\t// and adds an accordion CSS class to itself element.\n\t.directive('uibAccordion', function() {\n\t  return {\n\t    controller: 'UibAccordionController',\n\t    controllerAs: 'accordion',\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/accordion/accordion.html';\n\t    }\n\t  };\n\t})\n\t\n\t// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n\t.directive('uibAccordionGroup', function() {\n\t  return {\n\t    require: '^uibAccordion',         // We need this directive to be inside an accordion\n\t    transclude: true,              // It transcludes the contents of the directive into the template\n\t    replace: true,                // The element containing the directive will be replaced with the template\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/accordion/accordion-group.html';\n\t    },\n\t    scope: {\n\t      heading: '@',               // Interpolate the heading attribute onto this scope\n\t      isOpen: '=?',\n\t      isDisabled: '=?'\n\t    },\n\t    controller: function() {\n\t      this.setHeading = function(element) {\n\t        this.heading = element;\n\t      };\n\t    },\n\t    link: function(scope, element, attrs, accordionCtrl) {\n\t      accordionCtrl.addGroup(scope);\n\t\n\t      scope.openClass = attrs.openClass || 'panel-open';\n\t      scope.panelClass = attrs.panelClass;\n\t      scope.$watch('isOpen', function(value) {\n\t        element.toggleClass(scope.openClass, !!value);\n\t        if (value) {\n\t          accordionCtrl.closeOthers(scope);\n\t        }\n\t      });\n\t\n\t      scope.toggleOpen = function($event) {\n\t        if (!scope.isDisabled) {\n\t          if (!$event || $event.which === 32) {\n\t            scope.isOpen = !scope.isOpen;\n\t          }\n\t        }\n\t      };\n\t    }\n\t  };\n\t})\n\t\n\t// Use accordion-heading below an accordion-group to provide a heading containing HTML\n\t.directive('uibAccordionHeading', function() {\n\t  return {\n\t    transclude: true,   // Grab the contents to be used as the heading\n\t    template: '',       // In effect remove this element!\n\t    replace: true,\n\t    require: '^uibAccordionGroup',\n\t    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n\t      // Pass the heading to the accordion-group controller\n\t      // so that it can be transcluded into the right place in the template\n\t      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n\t    }\n\t  };\n\t})\n\t\n\t// Use in the accordion-group template to indicate where you want the heading to be transcluded\n\t// You must provide the property on the accordion-group controller that will hold the transcluded element\n\t.directive('uibAccordionTransclude', function() {\n\t  return {\n\t    require: ['?^uibAccordionGroup', '?^accordionGroup'],\n\t    link: function(scope, element, attrs, controller) {\n\t      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation\n\t      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n\t        if (heading) {\n\t          element.find('span').html('');\n\t          element.find('span').append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated accordion below */\n\t\n\tangular.module('ui.bootstrap.accordion')\n\t\n\t  .value('$accordionSuppressWarning', false)\n\t\n\t  .controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {\n\t    if (!$accordionSuppressWarning) {\n\t      $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibAccordionController', {\n\t      $scope: $scope,\n\t      $attrs: $attrs\n\t    }));\n\t  }])\n\t\n\t  .directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      restrict: 'EA',\n\t      controller: 'AccordionController',\n\t      controllerAs: 'accordion',\n\t      transclude: true,\n\t      replace: false,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.templateUrl || 'template/accordion/accordion.html';\n\t      },\n\t      link: function() {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion is now deprecated. Use uib-accordion instead.');\n\t        }\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      require: '^accordion',         // We need this directive to be inside an accordion\n\t      restrict: 'EA',\n\t      transclude: true,              // It transcludes the contents of the directive into the template\n\t      replace: true,                // The element containing the directive will be replaced with the template\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.templateUrl || 'template/accordion/accordion-group.html';\n\t      },\n\t      scope: {\n\t        heading: '@',               // Interpolate the heading attribute onto this scope\n\t        isOpen: '=?',\n\t        isDisabled: '=?'\n\t      },\n\t      controller: function() {\n\t        this.setHeading = function(element) {\n\t          this.heading = element;\n\t        };\n\t      },\n\t      link: function(scope, element, attrs, accordionCtrl) {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');\n\t        }\n\t\n\t        accordionCtrl.addGroup(scope);\n\t\n\t        scope.openClass = attrs.openClass || 'panel-open';\n\t        scope.panelClass = attrs.panelClass;\n\t        scope.$watch('isOpen', function(value) {\n\t          element.toggleClass(scope.openClass, !!value);\n\t          if (value) {\n\t            accordionCtrl.closeOthers(scope);\n\t          }\n\t        });\n\t\n\t        scope.toggleOpen = function($event) {\n\t          if (!scope.isDisabled) {\n\t            if (!$event || $event.which === 32) {\n\t              scope.isOpen = !scope.isOpen;\n\t            }\n\t          }\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      restrict: 'EA',\n\t      transclude: true,   // Grab the contents to be used as the heading\n\t      template: '',       // In effect remove this element!\n\t      replace: true,\n\t      require: '^accordionGroup',\n\t      link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');\n\t        }\n\t        // Pass the heading to the accordion-group controller\n\t        // so that it can be transcluded into the right place in the template\n\t        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      require: '^accordionGroup',\n\t      link: function(scope, element, attr, controller) {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');\n\t        }\n\t\n\t        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n\t          if (heading) {\n\t            element.find('span').html('');\n\t            element.find('span').append(heading);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\t\n\tangular.module('ui.bootstrap.alert', [])\n\t\n\t.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n\t  $scope.closeable = !!$attrs.close;\n\t\n\t  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n\t    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\t\n\t  if (dismissOnTimeout) {\n\t    $timeout(function() {\n\t      $scope.close();\n\t    }, parseInt(dismissOnTimeout, 10));\n\t  }\n\t}])\n\t\n\t.directive('uibAlert', function() {\n\t  return {\n\t    controller: 'UibAlertController',\n\t    controllerAs: 'alert',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/alert/alert.html';\n\t    },\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@',\n\t      close: '&'\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated alert below */\n\t\n\tangular.module('ui.bootstrap.alert')\n\t\n\t  .value('$alertSuppressWarning', false)\n\t\n\t  .controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {\n\t    if (!$alertSuppressWarning) {\n\t      $log.warn('AlertController is now deprecated. Use UibAlertController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibAlertController', {\n\t      $scope: $scope,\n\t      $attrs: $attrs\n\t    }));\n\t  }])\n\t\n\t  .directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {\n\t    return {\n\t      controller: 'AlertController',\n\t      controllerAs: 'alert',\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.templateUrl || 'template/alert/alert.html';\n\t      },\n\t      transclude: true,\n\t      replace: true,\n\t      scope: {\n\t        type: '@',\n\t        close: '&'\n\t      },\n\t      link: function() {\n\t        if (!$alertSuppressWarning) {\n\t          $log.warn('alert is now deprecated. Use uib-alert instead.');\n\t        }\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.buttons', [])\n\t\n\t.constant('uibButtonConfig', {\n\t  activeClass: 'active',\n\t  toggleEvent: 'click'\n\t})\n\t\n\t.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n\t  this.activeClass = buttonConfig.activeClass || 'active';\n\t  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n\t}])\n\t\n\t.directive('uibBtnRadio', function() {\n\t  return {\n\t    require: ['uibBtnRadio', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'buttons',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n\t            ngModelCtrl.$render();\n\t          });\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibBtnCheckbox', function() {\n\t  return {\n\t    require: ['uibBtnCheckbox', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'button',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      function getTrueValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t      }\n\t\n\t      function getFalseValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t      }\n\t\n\t      function getCheckboxValue(attribute, defaultValue) {\n\t        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n\t      }\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        scope.$apply(function() {\n\t          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t          ngModelCtrl.$render();\n\t        });\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated buttons below */\n\t\n\tangular.module('ui.bootstrap.buttons')\n\t\n\t  .value('$buttonsSuppressWarning', false)\n\t\n\t  .controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {\n\t    if (!$buttonsSuppressWarning) {\n\t      $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibButtonsController'));\n\t  }])\n\t\n\t  .directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {\n\t    return {\n\t      require: ['btnRadio', 'ngModel'],\n\t      controller: 'ButtonsController',\n\t      controllerAs: 'buttons',\n\t      link: function(scope, element, attrs, ctrls) {\n\t        if (!$buttonsSuppressWarning) {\n\t          $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');\n\t        }\n\t\n\t        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t        element.find('input').css({display: 'none'});\n\t\n\t        //model -> UI\n\t        ngModelCtrl.$render = function() {\n\t          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n\t        };\n\t\n\t        //ui->model\n\t        element.bind(buttonsCtrl.toggleEvent, function() {\n\t          if (attrs.disabled) {\n\t            return;\n\t          }\n\t\n\t          var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t          if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t            scope.$apply(function() {\n\t              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n\t              ngModelCtrl.$render();\n\t            });\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {\n\t    return {\n\t      require: ['btnCheckbox', 'ngModel'],\n\t      controller: 'ButtonsController',\n\t      controllerAs: 'button',\n\t      link: function(scope, element, attrs, ctrls) {\n\t        if (!$buttonsSuppressWarning) {\n\t          $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');\n\t        }\n\t\n\t        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t        element.find('input').css({display: 'none'});\n\t\n\t        function getTrueValue() {\n\t          return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t        }\n\t\n\t        function getFalseValue() {\n\t          return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t        }\n\t\n\t        function getCheckboxValue(attributeValue, defaultValue) {\n\t          var val = scope.$eval(attributeValue);\n\t          return angular.isDefined(val) ? val : defaultValue;\n\t        }\n\t\n\t        //model -> UI\n\t        ngModelCtrl.$render = function() {\n\t          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t        };\n\t\n\t        //ui->model\n\t        element.bind(buttonsCtrl.toggleEvent, function() {\n\t          if (attrs.disabled) {\n\t            return;\n\t          }\n\t\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t            ngModelCtrl.$render();\n\t          });\n\t        });\n\t\n\t        //accessibility\n\t        element.on('keypress', function(e) {\n\t          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {\n\t            return;\n\t          }\n\t\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t            ngModelCtrl.$render();\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.bootstrap.carousel\n\t *\n\t * @description\n\t * AngularJS version of an image carousel.\n\t *\n\t */\n\tangular.module('ui.bootstrap.carousel', [])\n\t\n\t.controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {\n\t  var self = this,\n\t    slides = self.slides = $scope.slides = [],\n\t    NEW_ANIMATE = angular.version.minor >= 4,\n\t    NO_TRANSITION = 'uib-noTransition',\n\t    SLIDE_DIRECTION = 'uib-slideDirection',\n\t    currentIndex = -1,\n\t    currentInterval, isPlaying;\n\t  self.currentSlide = null;\n\t\n\t  var destroyed = false;\n\t  /* direction: \"prev\" or \"next\" */\n\t  self.select = $scope.select = function(nextSlide, direction) {\n\t    var nextIndex = $scope.indexOfSlide(nextSlide);\n\t    //Decide direction if it's not given\n\t    if (direction === undefined) {\n\t      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n\t    }\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {\n\t      goNext(nextSlide, nextIndex, direction);\n\t    }\n\t  };\n\t\n\t  function goNext(slide, index, direction) {\n\t    // Scope has been destroyed, stop here.\n\t    if (destroyed) { return; }\n\t\n\t    angular.extend(slide, {direction: direction, active: true});\n\t    angular.extend(self.currentSlide || {}, {direction: direction, active: false});\n\t    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&\n\t      slide.$element && self.slides.length > 1) {\n\t      slide.$element.data(SLIDE_DIRECTION, slide.direction);\n\t      if (self.currentSlide && self.currentSlide.$element) {\n\t        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);\n\t      }\n\t\n\t      $scope.$currentTransition = true;\n\t      if (NEW_ANIMATE) {\n\t        $animate.on('addClass', slide.$element, function(element, phase) {\n\t          if (phase === 'close') {\n\t            $scope.$currentTransition = null;\n\t            $animate.off('addClass', element);\n\t          }\n\t        });\n\t      } else {\n\t        slide.$element.one('$animate:close', function closeFn() {\n\t          $scope.$currentTransition = null;\n\t        });\n\t      }\n\t    }\n\t\n\t    self.currentSlide = slide;\n\t    currentIndex = index;\n\t\n\t    //every time you change slides, reset the timer\n\t    restartTimer();\n\t  }\n\t\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t  });\n\t\n\t  function getSlideByIndex(index) {\n\t    if (angular.isUndefined(slides[index].index)) {\n\t      return slides[index];\n\t    }\n\t    var i, len = slides.length;\n\t    for (i = 0; i < slides.length; ++i) {\n\t      if (slides[i].index == index) {\n\t        return slides[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  self.getCurrentIndex = function() {\n\t    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {\n\t      return +self.currentSlide.index;\n\t    }\n\t    return currentIndex;\n\t  };\n\t\n\t  /* Allow outside people to call indexOf on slides array */\n\t  $scope.indexOfSlide = function(slide) {\n\t    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);\n\t  };\n\t\n\t  $scope.next = function() {\n\t    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\t\n\t    if (newIndex === 0 && $scope.noWrap()) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(getSlideByIndex(newIndex), 'next');\n\t  };\n\t\n\t  $scope.prev = function() {\n\t    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\t\n\t    if ($scope.noWrap() && newIndex === slides.length - 1) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(getSlideByIndex(newIndex), 'prev');\n\t  };\n\t\n\t  $scope.isActive = function(slide) {\n\t     return self.currentSlide === slide;\n\t  };\n\t\n\t  $scope.$watch('interval', restartTimer);\n\t  $scope.$watchCollection('slides', resetTransition);\n\t  $scope.$on('$destroy', resetTimer);\n\t\n\t  function restartTimer() {\n\t    resetTimer();\n\t    var interval = +$scope.interval;\n\t    if (!isNaN(interval) && interval > 0) {\n\t      currentInterval = $interval(timerFn, interval);\n\t    }\n\t  }\n\t\n\t  function resetTimer() {\n\t    if (currentInterval) {\n\t      $interval.cancel(currentInterval);\n\t      currentInterval = null;\n\t    }\n\t  }\n\t\n\t  function timerFn() {\n\t    var interval = +$scope.interval;\n\t    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n\t      $scope.next();\n\t    } else {\n\t      $scope.pause();\n\t    }\n\t  }\n\t\n\t  function resetTransition(slides) {\n\t    if (!slides.length) {\n\t      $scope.$currentTransition = null;\n\t    }\n\t  }\n\t\n\t  $scope.play = function() {\n\t    if (!isPlaying) {\n\t      isPlaying = true;\n\t      restartTimer();\n\t    }\n\t  };\n\t  $scope.pause = function() {\n\t    if (!$scope.noPause) {\n\t      isPlaying = false;\n\t      resetTimer();\n\t    }\n\t  };\n\t\n\t  self.addSlide = function(slide, element) {\n\t    slide.$element = element;\n\t    slides.push(slide);\n\t    //if this is the first slide or the slide is set to active, select it\n\t    if (slides.length === 1 || slide.active) {\n\t      self.select(slides[slides.length - 1]);\n\t      if (slides.length === 1) {\n\t        $scope.play();\n\t      }\n\t    } else {\n\t      slide.active = false;\n\t    }\n\t  };\n\t\n\t  self.removeSlide = function(slide) {\n\t    if (angular.isDefined(slide.index)) {\n\t      slides.sort(function(a, b) {\n\t        return +a.index > +b.index;\n\t      });\n\t    }\n\t    //get the index of the slide inside the carousel\n\t    var index = slides.indexOf(slide);\n\t    slides.splice(index, 1);\n\t    if (slides.length > 0 && slide.active) {\n\t      if (index >= slides.length) {\n\t        self.select(slides[index - 1]);\n\t      } else {\n\t        self.select(slides[index]);\n\t      }\n\t    } else if (currentIndex > index) {\n\t      currentIndex--;\n\t    }\n\t\n\t    //clean the currentSlide when no more slide\n\t    if (slides.length === 0) {\n\t      self.currentSlide = null;\n\t    }\n\t  };\n\t\n\t  $scope.$watch('noTransition', function(noTransition) {\n\t    $element.data(NO_TRANSITION, noTransition);\n\t  });\n\t\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:carousel\n\t * @restrict EA\n\t *\n\t * @description\n\t * Carousel is the outer container for a set of image 'slides' to showcase.\n\t *\n\t * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n\t * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n\t * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <uib-carousel>\n\t      <uib-slide>\n\t        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>Beautiful!</p>\n\t        </div>\n\t      </uib-slide>\n\t      <uib-slide>\n\t        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>D'aww!</p>\n\t        </div>\n\t      </uib-slide>\n\t    </uib-carousel>\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t */\n\t.directive('uibCarousel', [function() {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'UibCarouselController',\n\t    controllerAs: 'carousel',\n\t    require: 'carousel',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/carousel.html';\n\t    },\n\t    scope: {\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '=',\n\t      noWrap: '&'\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:slide\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n\t *\n\t * @param {boolean=} active Model binding, whether or not this slide is currently active.\n\t * @param {number=} index The index of the slide. The slides will be sorted by this parameter.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t<div ng-controller=\"CarouselDemoCtrl\">\n\t  <uib-carousel>\n\t    <uib-slide ng-repeat=\"slide in slides\" active=\"slide.active\" index=\"$index\">\n\t      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n\t      <div class=\"carousel-caption\">\n\t        <h4>Slide {{$index}}</h4>\n\t        <p>{{slide.text}}</p>\n\t      </div>\n\t    </uib-slide>\n\t  </uib-carousel>\n\t  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n\t  <br />Enter a negative number to stop the interval.\n\t</div>\n\t  </file>\n\t  <file name=\"script.js\">\n\tfunction CarouselDemoCtrl($scope) {\n\t  $scope.myInterval = 5000;\n\t}\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t*/\n\t\n\t.directive('uibSlide', function() {\n\t  return {\n\t    require: '^uibCarousel',\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/slide.html';\n\t    },\n\t    scope: {\n\t      active: '=?',\n\t      actual: '=?',\n\t      index: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          carouselCtrl.select(scope);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.animation('.item', [\n\t         '$injector', '$animate',\n\tfunction ($injector, $animate) {\n\t  var NO_TRANSITION = 'uib-noTransition',\n\t    SLIDE_DIRECTION = 'uib-slideDirection',\n\t    $animateCss = null;\n\t\n\t  if ($injector.has('$animateCss')) {\n\t    $animateCss = $injector.get('$animateCss');\n\t  }\n\t\n\t  function removeClass(element, className, callback) {\n\t    element.removeClass(className);\n\t    if (callback) {\n\t      callback();\n\t    }\n\t  }\n\t\n\t  return {\n\t    beforeAddClass: function(element, className, done) {\n\t      // Due to transclusion, noTransition property is on parent's scope\n\t      if (className == 'active' && element.parent() && element.parent().parent() &&\n\t          !element.parent().parent().data(NO_TRANSITION)) {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction == 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element,\n\t          directionClass + ' ' + direction, done);\n\t        element.addClass(direction);\n\t\n\t        if ($animateCss) {\n\t          $animateCss(element, {addClass: directionClass})\n\t            .start()\n\t            .done(removeClassFn);\n\t        } else {\n\t          $animate.addClass(element, directionClass).then(function () {\n\t            if (!stopped) {\n\t              removeClassFn();\n\t            }\n\t            done();\n\t          });\n\t        }\n\t\n\t        return function () {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    },\n\t    beforeRemoveClass: function (element, className, done) {\n\t      // Due to transclusion, noTransition property is on parent's scope\n\t      if (className === 'active' && element.parent() && element.parent().parent() &&\n\t          !element.parent().parent().data(NO_TRANSITION)) {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction == 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\t\n\t        if ($animateCss) {\n\t          $animateCss(element, {addClass: directionClass})\n\t            .start()\n\t            .done(removeClassFn);\n\t        } else {\n\t          $animate.addClass(element, directionClass).then(function() {\n\t            if (!stopped) {\n\t              removeClassFn();\n\t            }\n\t            done();\n\t          });\n\t        }\n\t        return function() {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    }\n\t  };\n\t}]);\n\t\n\t/* deprecated carousel below */\n\t\n\tangular.module('ui.bootstrap.carousel')\n\t\n\t.value('$carouselSuppressWarning', false)\n\t\n\t.controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {\n\t  if (!$carouselSuppressWarning) {\n\t    $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');\n\t  }\n\t\n\t  angular.extend(this, $controller('UibCarouselController', {\n\t    $scope: $scope,\n\t    $element: $element\n\t  }));\n\t}])\n\t\n\t.directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'CarouselController',\n\t    controllerAs: 'carousel',\n\t    require: 'carousel',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/carousel.html';\n\t    },\n\t    scope: {\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '=',\n\t      noWrap: '&'\n\t    },\n\t    link: function() {\n\t      if (!$carouselSuppressWarning) {\n\t        $log.warn('carousel is now deprecated. Use uib-carousel instead.');\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n\t  return {\n\t    require: '^carousel',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/slide.html';\n\t    },\n\t    scope: {\n\t      active: '=?',\n\t      actual: '=?',\n\t      index: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      if (!$carouselSuppressWarning) {\n\t        $log.warn('slide is now deprecated. Use uib-slide instead.');\n\t      }\n\t\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          carouselCtrl.select(scope);\n\t        }\n\t      });\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.dateparser', [])\n\t\n\t.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {\n\t  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n\t  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\t\n\t  var localeId;\n\t  var formatCodeToRegex;\n\t\n\t  this.init = function() {\n\t    localeId = $locale.id;\n\t\n\t    this.parsers = {};\n\t\n\t    formatCodeToRegex = {\n\t      'yyyy': {\n\t        regex: '\\\\d{4}',\n\t        apply: function(value) { this.year = +value; }\n\t      },\n\t      'yy': {\n\t        regex: '\\\\d{2}',\n\t        apply: function(value) { this.year = +value + 2000; }\n\t      },\n\t      'y': {\n\t        regex: '\\\\d{1,4}',\n\t        apply: function(value) { this.year = +value; }\n\t      },\n\t      'MMMM': {\n\t        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n\t      },\n\t      'MMM': {\n\t        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n\t      },\n\t      'MM': {\n\t        regex: '0[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; }\n\t      },\n\t      'M': {\n\t        regex: '[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; }\n\t      },\n\t      'dd': {\n\t        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; }\n\t      },\n\t      'd': {\n\t        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; }\n\t      },\n\t      'EEEE': {\n\t        regex: $locale.DATETIME_FORMATS.DAY.join('|')\n\t      },\n\t      'EEE': {\n\t        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n\t      },\n\t      'HH': {\n\t        regex: '(?:0|1)[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'hh': {\n\t        regex: '0[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'H': {\n\t        regex: '1?[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'h': {\n\t        regex: '[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'mm': {\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; }\n\t      },\n\t      'm': {\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; }\n\t      },\n\t      'sss': {\n\t        regex: '[0-9][0-9][0-9]',\n\t        apply: function(value) { this.milliseconds = +value; }\n\t      },\n\t      'ss': {\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; }\n\t      },\n\t      's': {\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; }\n\t      },\n\t      'a': {\n\t        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n\t        apply: function(value) {\n\t          if (this.hours === 12) {\n\t            this.hours = 0;\n\t          }\n\t\n\t          if (value === 'PM') {\n\t            this.hours += 12;\n\t          }\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  this.init();\n\t\n\t  function createParser(format) {\n\t    var map = [], regex = format.split('');\n\t\n\t    angular.forEach(formatCodeToRegex, function(data, code) {\n\t      var index = format.indexOf(code);\n\t\n\t      if (index > -1) {\n\t        format = format.split('');\n\t\n\t        regex[index] = '(' + data.regex + ')';\n\t        format[index] = '$'; // Custom symbol to define consumed part of format\n\t        for (var i = index + 1, n = index + code.length; i < n; i++) {\n\t          regex[i] = '';\n\t          format[i] = '$';\n\t        }\n\t        format = format.join('');\n\t\n\t        map.push({ index: index, apply: data.apply });\n\t      }\n\t    });\n\t\n\t    return {\n\t      regex: new RegExp('^' + regex.join('') + '$'),\n\t      map: orderByFilter(map, 'index')\n\t    };\n\t  }\n\t\n\t  this.parse = function(input, format, baseDate) {\n\t    if (!angular.isString(input) || !format) {\n\t      return input;\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\t\n\t    if ($locale.id !== localeId) {\n\t      this.init();\n\t    }\n\t\n\t    if (!this.parsers[format]) {\n\t      this.parsers[format] = createParser(format);\n\t    }\n\t\n\t    var parser = this.parsers[format],\n\t        regex = parser.regex,\n\t        map = parser.map,\n\t        results = input.match(regex);\n\t\n\t    if (results && results.length) {\n\t      var fields, dt;\n\t      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n\t        fields = {\n\t          year: baseDate.getFullYear(),\n\t          month: baseDate.getMonth(),\n\t          date: baseDate.getDate(),\n\t          hours: baseDate.getHours(),\n\t          minutes: baseDate.getMinutes(),\n\t          seconds: baseDate.getSeconds(),\n\t          milliseconds: baseDate.getMilliseconds()\n\t        };\n\t      } else {\n\t        if (baseDate) {\n\t          $log.warn('dateparser:', 'baseDate is not a valid date');\n\t        }\n\t        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n\t      }\n\t\n\t      for (var i = 1, n = results.length; i < n; i++) {\n\t        var mapper = map[i-1];\n\t        if (mapper.apply) {\n\t          mapper.apply.call(fields, results[i]);\n\t        }\n\t      }\n\t\n\t      if (isValid(fields.year, fields.month, fields.date)) {\n\t        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n\t          dt = new Date(baseDate);\n\t          dt.setFullYear(fields.year, fields.month, fields.date,\n\t            fields.hours, fields.minutes, fields.seconds,\n\t            fields.milliseconds || 0);\n\t        } else {\n\t          dt = new Date(fields.year, fields.month, fields.date,\n\t            fields.hours, fields.minutes, fields.seconds,\n\t            fields.milliseconds || 0);\n\t        }\n\t      }\n\t\n\t      return dt;\n\t    }\n\t  };\n\t\n\t  // Check if date is valid for specific month (and year for February).\n\t  // Month: 0 = Jan, 1 = Feb, etc\n\t  function isValid(year, month, date) {\n\t    if (date < 1) {\n\t      return false;\n\t    }\n\t\n\t    if (month === 1 && date > 28) {\n\t      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n\t    }\n\t\n\t    if (month === 3 || month === 5 || month === 8 || month === 10) {\n\t      return date < 31;\n\t    }\n\t\n\t    return true;\n\t  }\n\t}]);\n\t\n\t/* Deprecated dateparser below */\n\t\n\tangular.module('ui.bootstrap.dateparser')\n\t\n\t.value('$dateParserSuppressWarning', false)\n\t\n\t.service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {\n\t  if (!$dateParserSuppressWarning) {\n\t    $log.warn('dateParser is now deprecated. Use uibDateParser instead.');\n\t  }\n\t\n\t  angular.extend(this, uibDateParser);\n\t}]);\n\t\n\tangular.module('ui.bootstrap.position', [])\n\t\n\t/**\n\t * A set of utility methods that can be use to retrieve position of DOM elements.\n\t * It is meant to be used where we need to absolute-position DOM elements in\n\t * relation to other, existing elements (this is the case for tooltips, popovers,\n\t * typeahead suggestions etc.).\n\t */\n\t  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n\t    function getStyle(el, cssprop) {\n\t      if (el.currentStyle) { //IE\n\t        return el.currentStyle[cssprop];\n\t      } else if ($window.getComputedStyle) {\n\t        return $window.getComputedStyle(el)[cssprop];\n\t      }\n\t      // finally try and get inline style\n\t      return el.style[cssprop];\n\t    }\n\t\n\t    /**\n\t     * Checks if a given element is statically positioned\n\t     * @param element - raw DOM element\n\t     */\n\t    function isStaticPositioned(element) {\n\t      return (getStyle(element, 'position') || 'static' ) === 'static';\n\t    }\n\t\n\t    /**\n\t     * returns the closest, non-statically positioned parentOffset of a given element\n\t     * @param element\n\t     */\n\t    var parentOffsetEl = function(element) {\n\t      var docDomEl = $document[0];\n\t      var offsetParent = element.offsetParent || docDomEl;\n\t      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n\t        offsetParent = offsetParent.offsetParent;\n\t      }\n\t      return offsetParent || docDomEl;\n\t    };\n\t\n\t    return {\n\t      /**\n\t       * Provides read-only equivalent of jQuery's position function:\n\t       * http://api.jquery.com/position/\n\t       */\n\t      position: function(element) {\n\t        var elBCR = this.offset(element);\n\t        var offsetParentBCR = { top: 0, left: 0 };\n\t        var offsetParentEl = parentOffsetEl(element[0]);\n\t        if (offsetParentEl != $document[0]) {\n\t          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n\t          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n\t          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n\t        }\n\t\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: elBCR.top - offsetParentBCR.top,\n\t          left: elBCR.left - offsetParentBCR.left\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's offset function:\n\t       * http://api.jquery.com/offset/\n\t       */\n\t      offset: function(element) {\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n\t          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides coordinates for the targetEl in relation to hostEl\n\t       */\n\t      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {\n\t        var positionStrParts = positionStr.split('-');\n\t        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\t\n\t        var hostElPos,\n\t          targetElWidth,\n\t          targetElHeight,\n\t          targetElPos;\n\t\n\t        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\t\n\t        targetElWidth = targetEl.prop('offsetWidth');\n\t        targetElHeight = targetEl.prop('offsetHeight');\n\t\n\t        var shiftWidth = {\n\t          center: function() {\n\t            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n\t          },\n\t          left: function() {\n\t            return hostElPos.left;\n\t          },\n\t          right: function() {\n\t            return hostElPos.left + hostElPos.width;\n\t          }\n\t        };\n\t\n\t        var shiftHeight = {\n\t          center: function() {\n\t            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n\t          },\n\t          top: function() {\n\t            return hostElPos.top;\n\t          },\n\t          bottom: function() {\n\t            return hostElPos.top + hostElPos.height;\n\t          }\n\t        };\n\t\n\t        switch (pos0) {\n\t          case 'right':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: shiftWidth[pos0]()\n\t            };\n\t            break;\n\t          case 'left':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: hostElPos.left - targetElWidth\n\t            };\n\t            break;\n\t          case 'bottom':\n\t            targetElPos = {\n\t              top: shiftHeight[pos0](),\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t          default:\n\t            targetElPos = {\n\t              top: hostElPos.top - targetElHeight,\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t        }\n\t\n\t        return targetElPos;\n\t      }\n\t    };\n\t  }]);\n\t\n\t/* Deprecated position below */\n\t\n\tangular.module('ui.bootstrap.position')\n\t\n\t.value('$positionSuppressWarning', false)\n\t\n\t.service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {\n\t  if (!$positionSuppressWarning) {\n\t    $log.warn('$position is now deprecated. Use $uibPosition instead.');\n\t  }\n\t\n\t  angular.extend(this, $uibPosition);\n\t}]);\n\t\n\tangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\t\n\t.value('$datepickerSuppressError', false)\n\t\n\t.constant('uibDatepickerConfig', {\n\t  formatDay: 'dd',\n\t  formatMonth: 'MMMM',\n\t  formatYear: 'yyyy',\n\t  formatDayHeader: 'EEE',\n\t  formatDayTitle: 'MMMM yyyy',\n\t  formatMonthTitle: 'yyyy',\n\t  datepickerMode: 'day',\n\t  minMode: 'day',\n\t  maxMode: 'year',\n\t  showWeeks: true,\n\t  startingDay: 0,\n\t  yearRange: 20,\n\t  minDate: null,\n\t  maxDate: null,\n\t  shortcutPropagation: false\n\t})\n\t\n\t.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\t\n\t  // Modes chain\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  // Configuration attributes\n\t  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n\t                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n\t    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n\t  });\n\t\n\t  // Watchable date attributes\n\t  angular.forEach(['minDate', 'maxDate'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = value ? new Date(value) : null;\n\t        self.refreshView();\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n\t    }\n\t  });\n\t\n\t  angular.forEach(['minMode', 'maxMode'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = angular.isDefined(value) ? value : $attrs[key];\n\t        $scope[key] = self[key];\n\t        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n\t          $scope.datepickerMode = self[key];\n\t        }\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] || null;\n\t      $scope[key] = self[key];\n\t    }\n\t  });\n\t\n\t  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t\n\t  if (angular.isDefined($attrs.initDate)) {\n\t    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n\t    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n\t      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t        self.activeDate = initDate;\n\t        self.refreshView();\n\t      }\n\t    });\n\t  } else {\n\t    this.activeDate = new Date();\n\t  }\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if (ngModelCtrl.$viewValue) {\n\t      var date = new Date(ngModelCtrl.$viewValue),\n\t          isValid = !isNaN(date);\n\t\n\t      if (isValid) {\n\t        this.activeDate = date;\n\t      } else if (!$datepickerSuppressError) {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t      }\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if (this.element) {\n\t      this._refreshView();\n\t\n\t      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t    return {\n\t      date: date,\n\t      label: dateFilter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0,\n\t      customClass: this.customClass(date)\n\t    };\n\t  };\n\t\n\t  this.isDisabled = function(date) {\n\t    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n\t  };\n\t\n\t  this.customClass = function(date) {\n\t    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  $scope.select = function(date) {\n\t    if ($scope.datepickerMode === self.minMode) {\n\t      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n\t      ngModelCtrl.$setViewValue(dt);\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n\t    }\n\t  };\n\t\n\t  $scope.move = function(direction) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function(direction) {\n\t    direction = direction || 1;\n\t\n\t    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n\t      return;\n\t    }\n\t\n\t    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\t\n\t  var focusElement = function() {\n\t    self.element[0].focus();\n\t  };\n\t\n\t  // Listen for focus requests from popup directive\n\t  $scope.$on('uib:datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function(evt) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if (!key || evt.shiftKey || evt.altKey) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    if (!self.shortcutPropagation) {\n\t      evt.stopPropagation();\n\t    }\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if (self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\t\n\t  this.step = { months: 1 };\n\t  this.element = $element;\n\t  function getDaysInMonth(year, month) {\n\t    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n\t  }\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    scope.showWeeks = ctrl.showWeeks;\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this.getDates = function(startDate, n) {\n\t    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n\t    while (i < n) {\n\t      date = new Date(current);\n\t      dates[i++] = date;\n\t      current.setDate(current.getDate() + 1);\n\t    }\n\t    return dates;\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var year = this.activeDate.getFullYear(),\n\t      month = this.activeDate.getMonth(),\n\t      firstDayOfMonth = new Date(this.activeDate);\n\t\n\t    firstDayOfMonth.setFullYear(year, month, 1);\n\t\n\t    var difference = this.startingDay - firstDayOfMonth.getDay(),\n\t      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n\t      firstDate = new Date(firstDayOfMonth);\n\t\n\t    if (numDisplayedFromPreviousMonth > 0) {\n\t      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n\t    }\n\t\n\t    // 42 is the number of days on a six-month calendar\n\t    var days = this.getDates(firstDate, 42);\n\t    for (var i = 0; i < 42; i ++) {\n\t      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n\t        secondary: days[i].getMonth() !== month,\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.labels = new Array(7);\n\t    for (var j = 0; j < 7; j++) {\n\t      scope.labels[j] = {\n\t        abbr: dateFilter(days[j].date, this.formatDayHeader),\n\t        full: dateFilter(days[j].date, 'EEEE')\n\t      };\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n\t    scope.rows = this.split(days, 7);\n\t\n\t    if (scope.showWeeks) {\n\t      scope.weekNumbers = [];\n\t      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n\t          numWeeks = scope.rows.length;\n\t      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n\t        scope.weekNumbers.push(\n\t          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n\t      }\n\t    }\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n\t  };\n\t\n\t  function getISO8601WeekNumber(date) {\n\t    var checkDate = new Date(date);\n\t    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n\t    var time = checkDate.getTime();\n\t    checkDate.setMonth(0); // Compare with Jan 1\n\t    checkDate.setDate(1);\n\t    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t  }\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getDate();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;   // up\n\t    } else if (key === 'up') {\n\t      date = date - 7;   // down\n\t    } else if (key === 'right') {\n\t      date = date + 1;   // down\n\t    } else if (key === 'down') {\n\t      date = date + 7;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setMonth(month, 1);\n\t      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n\t    } else if (key === 'home') {\n\t      date = 1;\n\t    } else if (key === 'end') {\n\t      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n\t    }\n\t    this.activeDate.setDate(date);\n\t  };\n\t}])\n\t\n\t.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  this.step = { years: 1 };\n\t  this.element = $element;\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var months = new Array(12),\n\t        year = this.activeDate.getFullYear(),\n\t        date;\n\t\n\t    for (var i = 0; i < 12; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(year, i, 1);\n\t      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n\t    scope.rows = this.split(months, 3);\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getMonth();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;   // up\n\t    } else if (key === 'up') {\n\t      date = date - 3;   // down\n\t    } else if (key === 'right') {\n\t      date = date + 1;   // down\n\t    } else if (key === 'down') {\n\t      date = date + 3;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setFullYear(year);\n\t    } else if (key === 'home') {\n\t      date = 0;\n\t    } else if (key === 'end') {\n\t      date = 11;\n\t    }\n\t    this.activeDate.setMonth(date);\n\t  };\n\t}])\n\t\n\t.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var range;\n\t  this.element = $element;\n\t\n\t  function getStartingYear(year) {\n\t    return parseInt((year - 1) / range, 10) * range + 1;\n\t  }\n\t\n\t  this.yearpickerInit = function() {\n\t    range = this.yearRange;\n\t    this.step = { years: range };\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var years = new Array(range), date;\n\t\n\t    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(start + i, 0, 1);\n\t      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n\t    scope.rows = this.split(years, 5);\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return date1.getFullYear() - date2.getFullYear();\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getFullYear();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;   // up\n\t    } else if (key === 'up') {\n\t      date = date - 5;   // down\n\t    } else if (key === 'right') {\n\t      date = date + 1;   // down\n\t    } else if (key === 'down') {\n\t      date = date + 5;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      date += (key === 'pageup' ? - 1 : 1) * this.step.years;\n\t    } else if (key === 'home') {\n\t      date = getStartingYear(this.activeDate.getFullYear());\n\t    } else if (key === 'end') {\n\t      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n\t    }\n\t    this.activeDate.setFullYear(date);\n\t  };\n\t}])\n\t\n\t.directive('uibDatepicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n\t    },\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      dateDisabled: '&',\n\t      customClass: '&',\n\t      shortcutPropagation: '&?'\n\t    },\n\t    require: ['uibDatepicker', '^ngModel'],\n\t    controller: 'UibDatepickerController',\n\t    controllerAs: 'datepicker',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      datepickerCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDaypicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/day.html';\n\t    },\n\t    require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],\n\t    controller: 'UibDaypickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0] || ctrls[2],\n\t        daypickerCtrl = ctrls[1];\n\t\n\t      daypickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibMonthpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/month.html';\n\t    },\n\t    require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],\n\t    controller: 'UibMonthpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0] || ctrls[2],\n\t        monthpickerCtrl = ctrls[1];\n\t\n\t      monthpickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibYearpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/year.html';\n\t    },\n\t    require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],\n\t    controller: 'UibYearpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ctrl = ctrls[0] || ctrls[2];\n\t      angular.extend(ctrl, ctrls[1]);\n\t      ctrl.yearpickerInit();\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t})\n\t\n\t.constant('uibDatepickerPopupConfig', {\n\t  datepickerPopup: 'yyyy-MM-dd',\n\t  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',\n\t  datepickerTemplateUrl: 'template/datepicker/datepicker.html',\n\t  html5Types: {\n\t    date: 'yyyy-MM-dd',\n\t    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n\t    'month': 'yyyy-MM'\n\t  },\n\t  currentText: 'Today',\n\t  clearText: 'Clear',\n\t  closeText: 'Done',\n\t  closeOnDateSelection: true,\n\t  appendToBody: false,\n\t  showButtonBar: true,\n\t  onOpenFocus: true\n\t})\n\t\n\t.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout',\n\tfunction(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {\n\t  var self = this;\n\t  var cache = {},\n\t    isHtml5DateInput = false;\n\t  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n\t    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,\n\t    ngModel, $popup;\n\t\n\t  scope.watchData = {};\n\t\n\t  this.init = function(_ngModel_) {\n\t    ngModel = _ngModel_;\n\t    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n\t    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n\t    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n\t    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;\n\t    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\t\n\t    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\t\n\t    if (datepickerPopupConfig.html5Types[attrs.type]) {\n\t      dateFormat = datepickerPopupConfig.html5Types[attrs.type];\n\t      isHtml5DateInput = true;\n\t    } else {\n\t      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n\t      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n\t          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n\t          // Invalidate the $modelValue to ensure that formatters re-run\n\t          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n\t          if (newDateFormat !== dateFormat) {\n\t            dateFormat = newDateFormat;\n\t            ngModel.$modelValue = null;\n\t\n\t            if (!dateFormat) {\n\t              throw new Error('uibDatepickerPopup must have a date format specified.');\n\t            }\n\t          }\n\t      });\n\t    }\n\t\n\t    if (!dateFormat) {\n\t      throw new Error('uibDatepickerPopup must have a date format specified.');\n\t    }\n\t\n\t    if (isHtml5DateInput && attrs.datepickerPopup) {\n\t      throw new Error('HTML5 date input types do not support custom formats.');\n\t    }\n\t\n\t    // popup element used to display calendar\n\t    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n\t    popupEl.attr({\n\t      'ng-model': 'date',\n\t      'ng-change': 'dateSelection(date)',\n\t      'template-url': datepickerPopupTemplateUrl\n\t    });\n\t\n\t    // datepicker element\n\t    datepickerEl = angular.element(popupEl.children()[0]);\n\t    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\t\n\t    if (isHtml5DateInput) {\n\t      if (attrs.type === 'month') {\n\t        datepickerEl.attr('datepicker-mode', '\"month\"');\n\t        datepickerEl.attr('min-mode', 'month');\n\t      }\n\t    }\n\t\n\t    if (attrs.datepickerOptions) {\n\t      var options = scope.$parent.$eval(attrs.datepickerOptions);\n\t      if (options && options.initDate) {\n\t        scope.initDate = options.initDate;\n\t        datepickerEl.attr('init-date', 'initDate');\n\t        delete options.initDate;\n\t      }\n\t      angular.forEach(options, function(value, option) {\n\t        datepickerEl.attr(cameltoDash(option), value);\n\t      });\n\t    }\n\t\n\t    angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {\n\t      if (attrs[key]) {\n\t        var getAttribute = $parse(attrs[key]);\n\t        scope.$parent.$watch(getAttribute, function(value) {\n\t          scope.watchData[key] = value;\n\t          if (key === 'minDate' || key === 'maxDate') {\n\t            cache[key] = new Date(value);\n\t          }\n\t        });\n\t        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\t\n\t        // Propagate changes from datepicker to outside\n\t        if (key === 'datepickerMode') {\n\t          var setAttribute = getAttribute.assign;\n\t          scope.$watch('watchData.' + key, function(value, oldvalue) {\n\t            if (angular.isFunction(setAttribute) && value !== oldvalue) {\n\t              setAttribute(scope.$parent, value);\n\t            }\n\t          });\n\t        }\n\t      }\n\t    });\n\t    if (attrs.dateDisabled) {\n\t      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n\t    }\n\t\n\t    if (attrs.showWeeks) {\n\t      datepickerEl.attr('show-weeks', attrs.showWeeks);\n\t    }\n\t\n\t    if (attrs.customClass) {\n\t      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n\t    }\n\t\n\t    if (!isHtml5DateInput) {\n\t      // Internal API to maintain the correct ng-invalid-[key] class\n\t      ngModel.$$parserName = 'date';\n\t      ngModel.$validators.date = validator;\n\t      ngModel.$parsers.unshift(parseDate);\n\t      ngModel.$formatters.push(function(value) {\n\t        scope.date = value;\n\t        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);\n\t      });\n\t    } else {\n\t      ngModel.$formatters.push(function(value) {\n\t        scope.date = value;\n\t        return value;\n\t      });\n\t    }\n\t\n\t    // Detect changes in the view from the text box\n\t    ngModel.$viewChangeListeners.push(function() {\n\t      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);\n\t    });\n\t\n\t    element.bind('keydown', inputKeydownBind);\n\t\n\t    $popup = $compile(popupEl)(scope);\n\t    // Prevent jQuery cache memory leak (template is now redundant after linking)\n\t    popupEl.remove();\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    scope.$on('$destroy', function() {\n\t      if (scope.isOpen === true) {\n\t        if (!$rootScope.$$phase) {\n\t          scope.$apply(function() {\n\t            scope.isOpen = false;\n\t          });\n\t        }\n\t      }\n\t\n\t      $popup.remove();\n\t      element.unbind('keydown', inputKeydownBind);\n\t      $document.unbind('click', documentClickBind);\n\t    });\n\t  };\n\t\n\t  scope.getText = function(key) {\n\t    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n\t  };\n\t\n\t  scope.isDisabled = function(date) {\n\t    if (date === 'today') {\n\t      date = new Date();\n\t    }\n\t\n\t    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||\n\t      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));\n\t  };\n\t\n\t  scope.compare = function(date1, date2) {\n\t    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n\t  };\n\t\n\t  // Inner change\n\t  scope.dateSelection = function(dt) {\n\t    if (angular.isDefined(dt)) {\n\t      scope.date = dt;\n\t    }\n\t    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n\t    element.val(date);\n\t    ngModel.$setViewValue(date);\n\t\n\t    if (closeOnDateSelection) {\n\t      scope.isOpen = false;\n\t      element[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.keydown = function(evt) {\n\t    if (evt.which === 27) {\n\t      scope.isOpen = false;\n\t      element[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.select = function(date) {\n\t    if (date === 'today') {\n\t      var today = new Date();\n\t      if (angular.isDate(scope.date)) {\n\t        date = new Date(scope.date);\n\t        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n\t      } else {\n\t        date = new Date(today.setHours(0, 0, 0, 0));\n\t      }\n\t    }\n\t    scope.dateSelection(date);\n\t  };\n\t\n\t  scope.close = function() {\n\t    scope.isOpen = false;\n\t    element[0].focus();\n\t  };\n\t\n\t  scope.$watch('isOpen', function(value) {\n\t    if (value) {\n\t      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t      scope.position.top = scope.position.top + element.prop('offsetHeight');\n\t\n\t      $timeout(function() {\n\t        if (onOpenFocus) {\n\t          scope.$broadcast('uib:datepicker.focus');\n\t        }\n\t        $document.bind('click', documentClickBind);\n\t      }, 0, false);\n\t    } else {\n\t      $document.unbind('click', documentClickBind);\n\t    }\n\t  });\n\t\n\t  function cameltoDash(string) {\n\t    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n\t  }\n\t\n\t  function parseDate(viewValue) {\n\t    if (angular.isNumber(viewValue)) {\n\t      // presumably timestamp to date object\n\t      viewValue = new Date(viewValue);\n\t    }\n\t\n\t    if (!viewValue) {\n\t      return null;\n\t    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n\t      return viewValue;\n\t    } else if (angular.isString(viewValue)) {\n\t      var date = dateParser.parse(viewValue, dateFormat, scope.date);\n\t      if (isNaN(date)) {\n\t        return undefined;\n\t      } else {\n\t        return date;\n\t      }\n\t    } else {\n\t      return undefined;\n\t    }\n\t  }\n\t\n\t  function validator(modelValue, viewValue) {\n\t    var value = modelValue || viewValue;\n\t\n\t    if (!attrs.ngRequired && !value) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isNumber(value)) {\n\t      value = new Date(value);\n\t    }\n\t    if (!value) {\n\t      return true;\n\t    } else if (angular.isDate(value) && !isNaN(value)) {\n\t      return true;\n\t    } else if (angular.isString(value)) {\n\t      var date = dateParser.parse(value, dateFormat);\n\t      return !isNaN(date);\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  function documentClickBind(event) {\n\t    var popup = $popup[0];\n\t    var dpContainsTarget = element[0].contains(event.target);\n\t    // The popup node may not be an element node\n\t    // In some browsers (IE) only element nodes have the 'contains' function\n\t    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n\t    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n\t      scope.$apply(function() {\n\t        scope.isOpen = false;\n\t      });\n\t    }\n\t  }\n\t\n\t  function inputKeydownBind(evt) {\n\t    if (evt.which === 27 && scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      scope.$apply(function() {\n\t        scope.isOpen = false;\n\t      });\n\t      element[0].focus();\n\t    } else if (evt.which === 40 && !scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      scope.$apply(function() {\n\t        scope.isOpen = true;\n\t      });\n\t    }\n\t  }\n\t}])\n\t\n\t.directive('uibDatepickerPopup', function() {\n\t  return {\n\t    require: ['ngModel', 'uibDatepickerPopup'],\n\t    controller: 'UibDatepickerPopupController',\n\t    scope: {\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&',\n\t      customClass: '&'\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ngModel = ctrls[0],\n\t        ctrl = ctrls[1];\n\t\n\t      ctrl.init(ngModel);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDatepickerPopupWrap', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/popup.html';\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated datepicker below */\n\t\n\tangular.module('ui.bootstrap.datepicker')\n\t\n\t.value('$datepickerSuppressWarning', false)\n\t\n\t.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {\n\t  if (!$datepickerSuppressWarning) {\n\t    $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\t\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n\t    'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n\t    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n\t  });\n\t\n\t  angular.forEach(['minDate', 'maxDate'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = value ? new Date(value) : null;\n\t        self.refreshView();\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n\t    }\n\t  });\n\t\n\t  angular.forEach(['minMode', 'maxMode'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = angular.isDefined(value) ? value : $attrs[key];\n\t        $scope[key] = self[key];\n\t        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n\t          $scope.datepickerMode = self[key];\n\t        }\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] || null;\n\t      $scope[key] = self[key];\n\t    }\n\t  });\n\t\n\t  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t\n\t  if (angular.isDefined($attrs.initDate)) {\n\t    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n\t    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n\t      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t        self.activeDate = initDate;\n\t        self.refreshView();\n\t      }\n\t    });\n\t  } else {\n\t    this.activeDate = new Date();\n\t  }\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if (ngModelCtrl.$viewValue) {\n\t      var date = new Date(ngModelCtrl.$viewValue),\n\t        isValid = !isNaN(date);\n\t\n\t      if (isValid) {\n\t        this.activeDate = date;\n\t      } else if (!$datepickerSuppressError) {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t      }\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if (this.element) {\n\t      this._refreshView();\n\t\n\t      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t    return {\n\t      date: date,\n\t      label: dateFilter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0,\n\t      customClass: this.customClass(date)\n\t    };\n\t  };\n\t\n\t  this.isDisabled = function(date) {\n\t    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n\t  };\n\t\n\t  this.customClass = function(date) {\n\t    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  this.fixTimeZone = function(date) {\n\t    var hours = date.getHours();\n\t    date.setHours(hours === 23 ? hours + 2 : 0);\n\t  };\n\t\n\t  $scope.select = function(date) {\n\t    if ($scope.datepickerMode === self.minMode) {\n\t      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n\t      ngModelCtrl.$setViewValue(dt);\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n\t    }\n\t  };\n\t\n\t  $scope.move = function(direction) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t      month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function(direction) {\n\t    direction = direction || 1;\n\t\n\t    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n\t      return;\n\t    }\n\t\n\t    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\t\n\t  var focusElement = function() {\n\t    self.element[0].focus();\n\t  };\n\t\n\t  $scope.$on('uib:datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function(evt) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if (!key || evt.shiftKey || evt.altKey) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    if (!self.shortcutPropagation) {\n\t      evt.stopPropagation();\n\t    }\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if (self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n\t    },\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      dateDisabled: '&',\n\t      customClass: '&',\n\t      shortcutPropagation: '&?'\n\t    },\n\t    require: ['datepicker', '^ngModel'],\n\t    controller: 'DatepickerController',\n\t    controllerAs: 'datepicker',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');\n\t      }\n\t\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      datepickerCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/day.html',\n\t    require: ['^datepicker', 'daypicker'],\n\t    controller: 'UibDaypickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');\n\t      }\n\t\n\t      var datepickerCtrl = ctrls[0],\n\t        daypickerCtrl = ctrls[1];\n\t\n\t      daypickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/month.html',\n\t    require: ['^datepicker', 'monthpicker'],\n\t    controller: 'UibMonthpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');\n\t      }\n\t\n\t      var datepickerCtrl = ctrls[0],\n\t        monthpickerCtrl = ctrls[1];\n\t\n\t      monthpickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/year.html',\n\t    require: ['^datepicker', 'yearpicker'],\n\t    controller: 'UibYearpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');\n\t      }\n\t\n\t      var ctrl = ctrls[0];\n\t      angular.extend(ctrl, ctrls[1]);\n\t      ctrl.yearpickerInit();\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    require: ['ngModel', 'datepickerPopup'],\n\t    controller: 'UibDatepickerPopupController',\n\t    scope: {\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&',\n\t      customClass: '&'\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');\n\t      }\n\t\n\t      var ngModel = ctrls[0],\n\t        ctrl = ctrls[1];\n\t\n\t      ctrl.init(ngModel);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/popup.html';\n\t    },\n\t    link: function() {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\t\n\t.constant('uibDropdownConfig', {\n\t  openClass: 'open'\n\t})\n\t\n\t.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n\t  var openScope = null;\n\t\n\t  this.open = function(dropdownScope) {\n\t    if (!openScope) {\n\t      $document.bind('click', closeDropdown);\n\t      $document.bind('keydown', keybindFilter);\n\t    }\n\t\n\t    if (openScope && openScope !== dropdownScope) {\n\t      openScope.isOpen = false;\n\t    }\n\t\n\t    openScope = dropdownScope;\n\t  };\n\t\n\t  this.close = function(dropdownScope) {\n\t    if (openScope === dropdownScope) {\n\t      openScope = null;\n\t      $document.unbind('click', closeDropdown);\n\t      $document.unbind('keydown', keybindFilter);\n\t    }\n\t  };\n\t\n\t  var closeDropdown = function(evt) {\n\t    // This method may still be called during the same mouse event that\n\t    // unbound this event handler. So check openScope before proceeding.\n\t    if (!openScope) { return; }\n\t\n\t    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }\n\t\n\t    var toggleElement = openScope.getToggleElement();\n\t    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    var dropdownElement = openScope.getDropdownElement();\n\t    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n\t      dropdownElement && dropdownElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    openScope.isOpen = false;\n\t\n\t    if (!$rootScope.$$phase) {\n\t      openScope.$apply();\n\t    }\n\t  };\n\t\n\t  var keybindFilter = function(evt) {\n\t    if (evt.which === 27) {\n\t      openScope.focusToggleElement();\n\t      closeDropdown();\n\t    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      openScope.focusDropdownEntry(evt.which);\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n\t  var self = this,\n\t    scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t    templateScope,\n\t    openClass = dropdownConfig.openClass,\n\t    getIsOpen,\n\t    setIsOpen = angular.noop,\n\t    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n\t    appendToBody = false,\n\t    keynavEnabled =false,\n\t    selectedOption = null;\n\t\n\t\n\t  $element.addClass('dropdown');\n\t\n\t  this.init = function() {\n\t    if ($attrs.isOpen) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t\n\t    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n\t    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\t\n\t    if (appendToBody && self.dropdownMenu) {\n\t      $document.find('body').append(self.dropdownMenu);\n\t      $element.on('$destroy', function handleDestroyEvent() {\n\t        self.dropdownMenu.remove();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function(open) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.getAutoClose = function() {\n\t    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n\t  };\n\t\n\t  scope.getElement = function() {\n\t    return $element;\n\t  };\n\t\n\t  scope.isKeynavEnabled = function() {\n\t    return keynavEnabled;\n\t  };\n\t\n\t  scope.focusDropdownEntry = function(keyCode) {\n\t    var elems = self.dropdownMenu ? //If append to body is used.\n\t      (angular.element(self.dropdownMenu).find('a')) :\n\t      (angular.element($element).find('ul').eq(0).find('a'));\n\t\n\t    switch (keyCode) {\n\t      case (40): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = 0;\n\t        } else {\n\t          self.selectedOption = (self.selectedOption === elems.length - 1 ?\n\t            self.selectedOption :\n\t            self.selectedOption + 1);\n\t        }\n\t        break;\n\t      }\n\t      case (38): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = elems.length - 1;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === 0 ?\n\t            0 : self.selectedOption - 1;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    elems[self.selectedOption].focus();\n\t  };\n\t\n\t  scope.getDropdownElement = function() {\n\t    return self.dropdownMenu;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if (self.toggleElement) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function(isOpen, wasOpen) {\n\t    if (appendToBody && self.dropdownMenu) {\n\t      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n\t      var css = {\n\t        top: pos.top + 'px',\n\t        display: isOpen ? 'block' : 'none'\n\t      };\n\t\n\t      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n\t      if (!rightalign) {\n\t        css.left = pos.left + 'px';\n\t        css.right = 'auto';\n\t      } else {\n\t        css.left = 'auto';\n\t        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n\t      }\n\t\n\t      self.dropdownMenu.css(css);\n\t    }\n\t\n\t    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n\t      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t        toggleInvoker($scope, { open: !!isOpen });\n\t      }\n\t    });\n\t\n\t    if (isOpen) {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n\t          templateScope = scope.$new();\n\t          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n\t            var newEl = dropdownElement;\n\t            self.dropdownMenu.replaceWith(newEl);\n\t            self.dropdownMenu = newEl;\n\t          });\n\t        });\n\t      }\n\t\n\t      scope.focusToggleElement();\n\t      uibDropdownService.open(scope);\n\t    } else {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        if (templateScope) {\n\t          templateScope.$destroy();\n\t        }\n\t        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n\t        self.dropdownMenu.replaceWith(newEl);\n\t        self.dropdownMenu = newEl;\n\t      }\n\t\n\t      uibDropdownService.close(scope);\n\t      self.selectedOption = null;\n\t    }\n\t\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen($scope, isOpen);\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    if (scope.getAutoClose() !== 'disabled') {\n\t      scope.isOpen = false;\n\t    }\n\t  });\n\t\n\t  var offDestroy = $scope.$on('$destroy', function() {\n\t    scope.$destroy();\n\t  });\n\t  scope.$on('$destroy', offDestroy);\n\t}])\n\t\n\t.directive('uibDropdown', function() {\n\t  return {\n\t    controller: 'UibDropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      dropdownCtrl.init();\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownMenu', function() {\n\t  return {\n\t    restrict: 'AC',\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-menu');\n\t\n\t      var tplUrl = attrs.templateUrl;\n\t      if (tplUrl) {\n\t        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n\t      }\n\t\n\t      if (!dropdownCtrl.dropdownMenu) {\n\t        dropdownCtrl.dropdownMenu = element;\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibKeyboardNav', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      element.bind('keydown', function(e) {\n\t        if ([38, 40].indexOf(e.which) !== -1) {\n\t          e.preventDefault();\n\t          e.stopPropagation();\n\t\n\t          var elems = dropdownCtrl.dropdownMenu.find('a');\n\t\n\t          switch (e.which) {\n\t            case (40): { // Down\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = 0;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n\t                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n\t              }\n\t              break;\n\t            }\n\t            case (38): { // Up\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = elems.length - 1;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n\t                  0 : dropdownCtrl.selectedOption - 1;\n\t              }\n\t              break;\n\t            }\n\t          }\n\t          elems[dropdownCtrl.selectedOption].focus();\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownToggle', function() {\n\t  return {\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-toggle');\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if (!element.hasClass('disabled') && !attrs.disabled) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated dropdown below */\n\t\n\tangular.module('ui.bootstrap.dropdown')\n\t\n\t.value('$dropdownSuppressWarning', false)\n\t\n\t.service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {\n\t  if (!$dropdownSuppressWarning) {\n\t    $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');\n\t  }\n\t\n\t  angular.extend(this, uibDropdownService);\n\t}])\n\t\n\t.controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {\n\t  if (!$dropdownSuppressWarning) {\n\t    $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t    templateScope,\n\t    openClass = dropdownConfig.openClass,\n\t    getIsOpen,\n\t    setIsOpen = angular.noop,\n\t    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n\t    appendToBody = false,\n\t    keynavEnabled =false,\n\t    selectedOption = null;\n\t\n\t\n\t  $element.addClass('dropdown');\n\t\n\t  this.init = function() {\n\t    if ($attrs.isOpen) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t\n\t    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n\t    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\t\n\t    if (appendToBody && self.dropdownMenu) {\n\t      $document.find('body').append(self.dropdownMenu);\n\t      $element.on('$destroy', function handleDestroyEvent() {\n\t        self.dropdownMenu.remove();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function(open) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.getAutoClose = function() {\n\t    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n\t  };\n\t\n\t  scope.getElement = function() {\n\t    return $element;\n\t  };\n\t\n\t  scope.isKeynavEnabled = function() {\n\t    return keynavEnabled;\n\t  };\n\t\n\t  scope.focusDropdownEntry = function(keyCode) {\n\t    var elems = self.dropdownMenu ? //If append to body is used.\n\t      (angular.element(self.dropdownMenu).find('a')) :\n\t      (angular.element($element).find('ul').eq(0).find('a'));\n\t\n\t    switch (keyCode) {\n\t      case (40): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = 0;\n\t        } else {\n\t          self.selectedOption = (self.selectedOption === elems.length -1 ?\n\t            self.selectedOption :\n\t          self.selectedOption + 1);\n\t        }\n\t        break;\n\t      }\n\t      case (38): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = elems.length - 1;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === 0 ?\n\t            0 : self.selectedOption - 1;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    elems[self.selectedOption].focus();\n\t  };\n\t\n\t  scope.getDropdownElement = function() {\n\t    return self.dropdownMenu;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if (self.toggleElement) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function(isOpen, wasOpen) {\n\t    if (appendToBody && self.dropdownMenu) {\n\t      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n\t      var css = {\n\t        top: pos.top + 'px',\n\t        display: isOpen ? 'block' : 'none'\n\t      };\n\t\n\t      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n\t      if (!rightalign) {\n\t        css.left = pos.left + 'px';\n\t        css.right = 'auto';\n\t      } else {\n\t        css.left = 'auto';\n\t        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n\t      }\n\t\n\t      self.dropdownMenu.css(css);\n\t    }\n\t\n\t    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n\t      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t        toggleInvoker($scope, { open: !!isOpen });\n\t      }\n\t    });\n\t\n\t    if (isOpen) {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n\t          templateScope = scope.$new();\n\t          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n\t            var newEl = dropdownElement;\n\t            self.dropdownMenu.replaceWith(newEl);\n\t            self.dropdownMenu = newEl;\n\t          });\n\t        });\n\t      }\n\t\n\t      scope.focusToggleElement();\n\t      uibDropdownService.open(scope);\n\t    } else {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        if (templateScope) {\n\t          templateScope.$destroy();\n\t        }\n\t        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n\t        self.dropdownMenu.replaceWith(newEl);\n\t        self.dropdownMenu = newEl;\n\t      }\n\t\n\t      uibDropdownService.close(scope);\n\t      self.selectedOption = null;\n\t    }\n\t\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen($scope, isOpen);\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    if (scope.getAutoClose() !== 'disabled') {\n\t      scope.isOpen = false;\n\t    }\n\t  });\n\t\n\t  var offDestroy = $scope.$on('$destroy', function() {\n\t    scope.$destroy();\n\t  });\n\t  scope.$on('$destroy', offDestroy);\n\t}])\n\t\n\t.directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    controller: 'DropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');\n\t      }\n\t\n\t      dropdownCtrl.init();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    restrict: 'AC',\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n\t        return;\n\t      }\n\t\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');\n\t      }\n\t\n\t      element.addClass('dropdown-menu');\n\t\n\t      var tplUrl = attrs.templateUrl;\n\t      if (tplUrl) {\n\t        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n\t      }\n\t\n\t      if (!dropdownCtrl.dropdownMenu) {\n\t        dropdownCtrl.dropdownMenu = element;\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');\n\t      }\n\t\n\t      element.bind('keydown', function(e) {\n\t        if ([38, 40].indexOf(e.which) !== -1) {\n\t          e.preventDefault();\n\t          e.stopPropagation();\n\t\n\t          var elems = dropdownCtrl.dropdownMenu.find('a');\n\t\n\t          switch (e.which) {\n\t            case (40): { // Down\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = 0;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n\t                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n\t              }\n\t              break;\n\t            }\n\t            case (38): { // Up\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = elems.length - 1;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n\t                  0 : dropdownCtrl.selectedOption - 1;\n\t              }\n\t              break;\n\t            }\n\t          }\n\t          elems[dropdownCtrl.selectedOption].focus();\n\t        }\n\t      });\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');\n\t      }\n\t\n\t      if (!dropdownCtrl) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-toggle');\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if (!element.hasClass('disabled') && !attrs.disabled) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.stackedMap', [])\n\t/**\n\t * A helper, internal data structure that acts as a map but also allows getting / removing\n\t * elements in the LIFO order\n\t */\n\t  .factory('$$stackedMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var stack = [];\n\t\n\t        return {\n\t          add: function(key, value) {\n\t            stack.push({\n\t              key: key,\n\t              value: value\n\t            });\n\t          },\n\t          get: function(key) {\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                return stack[i];\n\t              }\n\t            }\n\t          },\n\t          keys: function() {\n\t            var keys = [];\n\t            for (var i = 0; i < stack.length; i++) {\n\t              keys.push(stack[i].key);\n\t            }\n\t            return keys;\n\t          },\n\t          top: function() {\n\t            return stack[stack.length - 1];\n\t          },\n\t          remove: function(key) {\n\t            var idx = -1;\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                idx = i;\n\t                break;\n\t              }\n\t            }\n\t            return stack.splice(idx, 1)[0];\n\t          },\n\t          removeTop: function() {\n\t            return stack.splice(stack.length - 1, 1)[0];\n\t          },\n\t          length: function() {\n\t            return stack.length;\n\t          }\n\t        };\n\t      }\n\t    };\n\t  });\n\tangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n\t/**\n\t * A helper, internal data structure that stores all references attached to key\n\t */\n\t  .factory('$$multiMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var map = {};\n\t\n\t        return {\n\t          entries: function() {\n\t            return Object.keys(map).map(function(key) {\n\t              return {\n\t                key: key,\n\t                value: map[key]\n\t              };\n\t            });\n\t          },\n\t          get: function(key) {\n\t            return map[key];\n\t          },\n\t          hasKey: function(key) {\n\t            return !!map[key];\n\t          },\n\t          keys: function() {\n\t            return Object.keys(map);\n\t          },\n\t          put: function(key, value) {\n\t            if (!map[key]) {\n\t              map[key] = [];\n\t            }\n\t\n\t            map[key].push(value);\n\t          },\n\t          remove: function(key, value) {\n\t            var values = map[key];\n\t\n\t            if (!values) {\n\t              return;\n\t            }\n\t\n\t            var idx = values.indexOf(value);\n\t\n\t            if (idx !== -1) {\n\t              values.splice(idx, 1);\n\t            }\n\t\n\t            if (!values.length) {\n\t              delete map[key];\n\t            }\n\t          }\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t/**\n\t * A helper directive for the $modal service. It creates a backdrop element.\n\t */\n\t  .directive('uibModalBackdrop', [\n\t           '$animate', '$injector', '$uibModalStack',\n\t  function($animate ,  $injector,   $modalStack) {\n\t    var $animateCss = null;\n\t\n\t    if ($injector.has('$animateCss')) {\n\t      $animateCss = $injector.get('$animateCss');\n\t    }\n\t\n\t    return {\n\t      replace: true,\n\t      templateUrl: 'template/modal/backdrop.html',\n\t      compile: function(tElement, tAttrs) {\n\t        tElement.addClass(tAttrs.backdropClass);\n\t        return linkFn;\n\t      }\n\t    };\n\t\n\t    function linkFn(scope, element, attrs) {\n\t      // Temporary fix for prefixing\n\t      element.addClass('modal-backdrop');\n\t\n\t      if (attrs.modalInClass) {\n\t        if ($animateCss) {\n\t          $animateCss(element, {\n\t            addClass: attrs.modalInClass\n\t          }).start();\n\t        } else {\n\t          $animate.addClass(element, attrs.modalInClass);\n\t        }\n\t\n\t        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t          var done = setIsAsync();\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              removeClass: attrs.modalInClass\n\t            }).start().then(done);\n\t          } else {\n\t            $animate.removeClass(element, attrs.modalInClass).then(done);\n\t          }\n\t        });\n\t      }\n\t    }\n\t  }])\n\t\n\t  .directive('uibModalWindow', [\n\t           '$uibModalStack', '$q', '$animate', '$injector',\n\t  function($modalStack ,  $q ,  $animate,   $injector) {\n\t    var $animateCss = null;\n\t\n\t    if ($injector.has('$animateCss')) {\n\t      $animateCss = $injector.get('$animateCss');\n\t    }\n\t\n\t    return {\n\t      scope: {\n\t        index: '@'\n\t      },\n\t      replace: true,\n\t      transclude: true,\n\t      templateUrl: function(tElement, tAttrs) {\n\t        return tAttrs.templateUrl || 'template/modal/window.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        element.addClass(attrs.windowClass || '');\n\t        element.addClass(attrs.windowTopClass || '');\n\t        scope.size = attrs.size;\n\t\n\t        scope.close = function(evt) {\n\t          var modal = $modalStack.getTop();\n\t          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n\t            evt.preventDefault();\n\t            evt.stopPropagation();\n\t            $modalStack.dismiss(modal.key, 'backdrop click');\n\t          }\n\t        };\n\t\n\t        // moved from template to fix issue #2280\n\t        element.on('click', scope.close);\n\t\n\t        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n\t        // We can detect that by using this property in the template associated with this directive and then use\n\t        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n\t        scope.$isRendered = true;\n\t\n\t        // Deferred object that will be resolved when this modal is render.\n\t        var modalRenderDeferObj = $q.defer();\n\t        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n\t        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n\t        attrs.$observe('modalRender', function(value) {\n\t          if (value == 'true') {\n\t            modalRenderDeferObj.resolve();\n\t          }\n\t        });\n\t\n\t        modalRenderDeferObj.promise.then(function() {\n\t          var animationPromise = null;\n\t\n\t          if (attrs.modalInClass) {\n\t            if ($animateCss) {\n\t              animationPromise = $animateCss(element, {\n\t                addClass: attrs.modalInClass\n\t              }).start();\n\t            } else {\n\t              animationPromise = $animate.addClass(element, attrs.modalInClass);\n\t            }\n\t\n\t            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t              var done = setIsAsync();\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  removeClass: attrs.modalInClass\n\t                }).start().then(done);\n\t              } else {\n\t                $animate.removeClass(element, attrs.modalInClass).then(done);\n\t              }\n\t            });\n\t          }\n\t\n\t\n\t          $q.when(animationPromise).then(function() {\n\t            var inputWithAutofocus = element[0].querySelector('[autofocus]');\n\t            /**\n\t             * Auto-focusing of a freshly-opened modal element causes any child elements\n\t             * with the autofocus attribute to lose focus. This is an issue on touch\n\t             * based devices which will show and then hide the onscreen keyboard.\n\t             * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t             * the modal element if the modal does not contain an autofocus element.\n\t             */\n\t            if (inputWithAutofocus) {\n\t              inputWithAutofocus.focus();\n\t            } else {\n\t              element[0].focus();\n\t            }\n\t          });\n\t\n\t          // Notify {@link $modalStack} that modal is rendered.\n\t          var modal = $modalStack.getTop();\n\t          if (modal) {\n\t            $modalStack.modalRendered(modal.key);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('uibModalAnimationClass', function() {\n\t    return {\n\t      compile: function(tElement, tAttrs) {\n\t        if (tAttrs.modalAnimation) {\n\t          tElement.addClass(tAttrs.uibModalAnimationClass);\n\t        }\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibModalTransclude', function() {\n\t    return {\n\t      link: function($scope, $element, $attrs, controller, $transclude) {\n\t        $transclude($scope.$parent, function(clone) {\n\t          $element.empty();\n\t          $element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  })\n\t\n\t  .factory('$uibModalStack', [\n\t             '$animate', '$timeout', '$document', '$compile', '$rootScope',\n\t             '$q',\n\t             '$injector',\n\t             '$$multiMap',\n\t             '$$stackedMap',\n\t    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n\t              $q,\n\t              $injector,\n\t              $$multiMap,\n\t              $$stackedMap) {\n\t      var $animateCss = null;\n\t\n\t      if ($injector.has('$animateCss')) {\n\t        $animateCss = $injector.get('$animateCss');\n\t      }\n\t\n\t      var OPENED_MODAL_CLASS = 'modal-open';\n\t\n\t      var backdropDomEl, backdropScope;\n\t      var openedWindows = $$stackedMap.createNew();\n\t      var openedClasses = $$multiMap.createNew();\n\t      var $modalStack = {\n\t        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n\t      };\n\t\n\t      //Modal focus behavior\n\t      var focusableElementList;\n\t      var focusIndex = 0;\n\t      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n\t        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n\t        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\t\n\t      function backdropIndex() {\n\t        var topBackdropIndex = -1;\n\t        var opened = openedWindows.keys();\n\t        for (var i = 0; i < opened.length; i++) {\n\t          if (openedWindows.get(opened[i]).value.backdrop) {\n\t            topBackdropIndex = i;\n\t          }\n\t        }\n\t        return topBackdropIndex;\n\t      }\n\t\n\t      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n\t        if (backdropScope) {\n\t          backdropScope.index = newBackdropIndex;\n\t        }\n\t      });\n\t\n\t      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n\t        var body = $document.find('body').eq(0);\n\t        var modalWindow = openedWindows.get(modalInstance).value;\n\t\n\t        //clean up the stack\n\t        openedWindows.remove(modalInstance);\n\t\n\t        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n\t          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n\t          openedClasses.remove(modalBodyClass, modalInstance);\n\t          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n\t          toggleTopWindowClass(true);\n\t        });\n\t        checkRemoveBackdrop();\n\t\n\t        //move focus to specified element if available, or else to body\n\t        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n\t          elementToReceiveFocus.focus();\n\t        } else {\n\t          body.focus();\n\t        }\n\t      }\n\t\n\t      // Add or remove \"windowTopClass\" from the top window in the stack\n\t      function toggleTopWindowClass(toggleSwitch) {\n\t        var modalWindow;\n\t\n\t        if (openedWindows.length() > 0) {\n\t          modalWindow = openedWindows.top().value;\n\t          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n\t        }\n\t      }\n\t\n\t      function checkRemoveBackdrop() {\n\t        //remove backdrop if no longer needed\n\t        if (backdropDomEl && backdropIndex() == -1) {\n\t          var backdropScopeRef = backdropScope;\n\t          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n\t            backdropScopeRef = null;\n\t          });\n\t          backdropDomEl = undefined;\n\t          backdropScope = undefined;\n\t        }\n\t      }\n\t\n\t      function removeAfterAnimate(domEl, scope, done) {\n\t        var asyncDeferred;\n\t        var asyncPromise = null;\n\t        var setIsAsync = function() {\n\t          if (!asyncDeferred) {\n\t            asyncDeferred = $q.defer();\n\t            asyncPromise = asyncDeferred.promise;\n\t          }\n\t\n\t          return function asyncDone() {\n\t            asyncDeferred.resolve();\n\t          };\n\t        };\n\t        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\t\n\t        // Note that it's intentional that asyncPromise might be null.\n\t        // That's when setIsAsync has not been called during the\n\t        // NOW_CLOSING_EVENT broadcast.\n\t        return $q.when(asyncPromise).then(afterAnimating);\n\t\n\t        function afterAnimating() {\n\t          if (afterAnimating.done) {\n\t            return;\n\t          }\n\t          afterAnimating.done = true;\n\t\n\t          if ($animateCss) {\n\t            $animateCss(domEl, {\n\t              event: 'leave'\n\t            }).start().then(function() {\n\t              domEl.remove();\n\t            });\n\t          } else {\n\t            $animate.leave(domEl);\n\t          }\n\t          scope.$destroy();\n\t          if (done) {\n\t            done();\n\t          }\n\t        }\n\t      }\n\t\n\t      $document.bind('keydown', function(evt) {\n\t        if (evt.isDefaultPrevented()) {\n\t          return evt;\n\t        }\n\t\n\t        var modal = openedWindows.top();\n\t        if (modal && modal.value.keyboard) {\n\t          switch (evt.which) {\n\t            case 27: {\n\t              evt.preventDefault();\n\t              $rootScope.$apply(function() {\n\t                $modalStack.dismiss(modal.key, 'escape key press');\n\t              });\n\t              break;\n\t            }\n\t            case 9: {\n\t              $modalStack.loadFocusElementList(modal);\n\t              var focusChanged = false;\n\t              if (evt.shiftKey) {\n\t                if ($modalStack.isFocusInFirstItem(evt)) {\n\t                  focusChanged = $modalStack.focusLastFocusableElement();\n\t                }\n\t              } else {\n\t                if ($modalStack.isFocusInLastItem(evt)) {\n\t                  focusChanged = $modalStack.focusFirstFocusableElement();\n\t                }\n\t              }\n\t\n\t              if (focusChanged) {\n\t                evt.preventDefault();\n\t                evt.stopPropagation();\n\t              }\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      });\n\t\n\t      $modalStack.open = function(modalInstance, modal) {\n\t        var modalOpener = $document[0].activeElement,\n\t          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\t\n\t        toggleTopWindowClass(false);\n\t\n\t        openedWindows.add(modalInstance, {\n\t          deferred: modal.deferred,\n\t          renderDeferred: modal.renderDeferred,\n\t          modalScope: modal.scope,\n\t          backdrop: modal.backdrop,\n\t          keyboard: modal.keyboard,\n\t          openedClass: modal.openedClass,\n\t          windowTopClass: modal.windowTopClass\n\t        });\n\t\n\t        openedClasses.put(modalBodyClass, modalInstance);\n\t\n\t        var body = $document.find('body').eq(0),\n\t            currBackdropIndex = backdropIndex();\n\t\n\t        if (currBackdropIndex >= 0 && !backdropDomEl) {\n\t          backdropScope = $rootScope.$new(true);\n\t          backdropScope.index = currBackdropIndex;\n\t          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n\t          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n\t          if (modal.animation) {\n\t            angularBackgroundDomEl.attr('modal-animation', 'true');\n\t          }\n\t          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n\t          body.append(backdropDomEl);\n\t        }\n\t\n\t        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n\t        angularDomEl.attr({\n\t          'template-url': modal.windowTemplateUrl,\n\t          'window-class': modal.windowClass,\n\t          'window-top-class': modal.windowTopClass,\n\t          'size': modal.size,\n\t          'index': openedWindows.length() - 1,\n\t          'animate': 'animate'\n\t        }).html(modal.content);\n\t        if (modal.animation) {\n\t          angularDomEl.attr('modal-animation', 'true');\n\t        }\n\t\n\t        var modalDomEl = $compile(angularDomEl)(modal.scope);\n\t        openedWindows.top().value.modalDomEl = modalDomEl;\n\t        openedWindows.top().value.modalOpener = modalOpener;\n\t        body.append(modalDomEl);\n\t        body.addClass(modalBodyClass);\n\t\n\t        $modalStack.clearFocusListCache();\n\t      };\n\t\n\t      function broadcastClosing(modalWindow, resultOrReason, closing) {\n\t        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n\t      }\n\t\n\t      $modalStack.close = function(modalInstance, result) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.resolve(result);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismiss = function(modalInstance, reason) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.reject(reason);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismissAll = function(reason) {\n\t        var topModal = this.getTop();\n\t        while (topModal && this.dismiss(topModal.key, reason)) {\n\t          topModal = this.getTop();\n\t        }\n\t      };\n\t\n\t      $modalStack.getTop = function() {\n\t        return openedWindows.top();\n\t      };\n\t\n\t      $modalStack.modalRendered = function(modalInstance) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.renderDeferred.resolve();\n\t        }\n\t      };\n\t\n\t      $modalStack.focusFirstFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[0].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t      $modalStack.focusLastFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[focusableElementList.length - 1].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInFirstItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) == focusableElementList[0];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInLastItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.clearFocusListCache = function() {\n\t        focusableElementList = [];\n\t        focusIndex = 0;\n\t      };\n\t\n\t      $modalStack.loadFocusElementList = function(modalWindow) {\n\t        if (focusableElementList === undefined || !focusableElementList.length) {\n\t          if (modalWindow) {\n\t            var modalDomE1 = modalWindow.value.modalDomEl;\n\t            if (modalDomE1 && modalDomE1.length) {\n\t              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      return $modalStack;\n\t    }])\n\t\n\t  .provider('$uibModal', function() {\n\t    var $modalProvider = {\n\t      options: {\n\t        animation: true,\n\t        backdrop: true, //can also be false or 'static'\n\t        keyboard: true\n\t      },\n\t      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log',\n\t        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {\n\t          var $modal = {};\n\t\n\t          function getTemplatePromise(options) {\n\t            return options.template ? $q.when(options.template) :\n\t              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);\n\t          }\n\t\n\t          function getResolvePromises(resolves) {\n\t            var promisesArr = [];\n\t            angular.forEach(resolves, function(value) {\n\t              if (angular.isFunction(value) || angular.isArray(value)) {\n\t                promisesArr.push($q.when($injector.invoke(value)));\n\t              } else if (angular.isString(value)) {\n\t                promisesArr.push($q.when($injector.get(value)));\n\t              } else {\n\t                promisesArr.push($q.when(value));\n\t              }\n\t            });\n\t            return promisesArr;\n\t          }\n\t\n\t          var promiseChain = null;\n\t          $modal.getPromiseChain = function() {\n\t            return promiseChain;\n\t          };\n\t\n\t          $modal.open = function(modalOptions) {\n\t            var modalResultDeferred = $q.defer();\n\t            var modalOpenedDeferred = $q.defer();\n\t            var modalRenderDeferred = $q.defer();\n\t\n\t            //prepare an instance of a modal to be injected into controllers and returned to a caller\n\t            var modalInstance = {\n\t              result: modalResultDeferred.promise,\n\t              opened: modalOpenedDeferred.promise,\n\t              rendered: modalRenderDeferred.promise,\n\t              close: function (result) {\n\t                return $modalStack.close(modalInstance, result);\n\t              },\n\t              dismiss: function (reason) {\n\t                return $modalStack.dismiss(modalInstance, reason);\n\t              }\n\t            };\n\t\n\t            //merge and clean up options\n\t            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n\t            modalOptions.resolve = modalOptions.resolve || {};\n\t\n\t            //verify options\n\t            if (!modalOptions.template && !modalOptions.templateUrl) {\n\t              throw new Error('One of template or templateUrl options is required.');\n\t            }\n\t\n\t            var templateAndResolvePromise =\n\t              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\t\n\t            function resolveWithTemplate() {\n\t              return templateAndResolvePromise;\n\t            }\n\t\n\t            // Wait for the resolution of the existing promise chain.\n\t            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n\t            // Then add to $modalStack and resolve opened.\n\t            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n\t            var samePromise;\n\t            samePromise = promiseChain = $q.all([promiseChain])\n\t              .then(resolveWithTemplate, resolveWithTemplate)\n\t              .then(function resolveSuccess(tplAndVars) {\n\t\n\t                var modalScope = (modalOptions.scope || $rootScope).$new();\n\t                modalScope.$close = modalInstance.close;\n\t                modalScope.$dismiss = modalInstance.dismiss;\n\t\n\t                modalScope.$on('$destroy', function() {\n\t                  if (!modalScope.$$uibDestructionScheduled) {\n\t                    modalScope.$dismiss('$uibUnscheduledDestruction');\n\t                  }\n\t                });\n\t\n\t                var ctrlInstance, ctrlLocals = {};\n\t                var resolveIter = 1;\n\t\n\t                //controllers\n\t                if (modalOptions.controller) {\n\t                  ctrlLocals.$scope = modalScope;\n\t                  ctrlLocals.$uibModalInstance = modalInstance;\n\t                  Object.defineProperty(ctrlLocals, '$modalInstance', {\n\t                    get: function() {\n\t                      if (!$modalSuppressWarning) {\n\t                        $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');\n\t                      }\n\t\n\t                      return modalInstance;\n\t                    }\n\t                  });\n\t                  angular.forEach(modalOptions.resolve, function(value, key) {\n\t                    ctrlLocals[key] = tplAndVars[resolveIter++];\n\t                  });\n\t\n\t                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n\t                  if (modalOptions.controllerAs) {\n\t                    if (modalOptions.bindToController) {\n\t                      angular.extend(ctrlInstance, modalScope);\n\t                    }\n\t\n\t                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n\t                  }\n\t                }\n\t\n\t                $modalStack.open(modalInstance, {\n\t                  scope: modalScope,\n\t                  deferred: modalResultDeferred,\n\t                  renderDeferred: modalRenderDeferred,\n\t                  content: tplAndVars[0],\n\t                  animation: modalOptions.animation,\n\t                  backdrop: modalOptions.backdrop,\n\t                  keyboard: modalOptions.keyboard,\n\t                  backdropClass: modalOptions.backdropClass,\n\t                  windowTopClass: modalOptions.windowTopClass,\n\t                  windowClass: modalOptions.windowClass,\n\t                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n\t                  size: modalOptions.size,\n\t                  openedClass: modalOptions.openedClass\n\t                });\n\t                modalOpenedDeferred.resolve(true);\n\t\n\t            }, function resolveError(reason) {\n\t              modalOpenedDeferred.reject(reason);\n\t              modalResultDeferred.reject(reason);\n\t            })\n\t            .finally(function() {\n\t              if (promiseChain === samePromise) {\n\t                promiseChain = null;\n\t              }\n\t            });\n\t\n\t            return modalInstance;\n\t          };\n\t\n\t          return $modal;\n\t        }\n\t      ]\n\t    };\n\t\n\t    return $modalProvider;\n\t  });\n\t\n\t/* deprecated modal below */\n\t\n\tangular.module('ui.bootstrap.modal')\n\t\n\t  .value('$modalSuppressWarning', false)\n\t\n\t  /**\n\t   * A helper directive for the $modal service. It creates a backdrop element.\n\t   */\n\t  .directive('modalBackdrop', [\n\t    '$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning',\n\t    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {\n\t      var $animateCss = null;\n\t\n\t      if ($injector.has('$animateCss')) {\n\t        $animateCss = $injector.get('$animateCss');\n\t      }\n\t\n\t      return {\n\t        replace: true,\n\t        templateUrl: 'template/modal/backdrop.html',\n\t        compile: function(tElement, tAttrs) {\n\t          tElement.addClass(tAttrs.backdropClass);\n\t          return linkFn;\n\t        }\n\t      };\n\t\n\t      function linkFn(scope, element, attrs) {\n\t        if (!$modalSuppressWarning) {\n\t          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');\n\t        }\n\t        element.addClass('modal-backdrop');\n\t\n\t        if (attrs.modalInClass) {\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              addClass: attrs.modalInClass\n\t            }).start();\n\t          } else {\n\t            $animate.addClass(element, attrs.modalInClass);\n\t          }\n\t\n\t          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t            var done = setIsAsync();\n\t            if ($animateCss) {\n\t              $animateCss(element, {\n\t                removeClass: attrs.modalInClass\n\t              }).start().then(done);\n\t            } else {\n\t              $animate.removeClass(element, attrs.modalInClass).then(done);\n\t            }\n\t          });\n\t        }\n\t      }\n\t    }])\n\t\n\t  .directive('modalWindow', [\n\t    '$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning',\n\t    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {\n\t      var $animateCss = null;\n\t\n\t      if ($injector.has('$animateCss')) {\n\t        $animateCss = $injector.get('$animateCss');\n\t      }\n\t\n\t      return {\n\t        scope: {\n\t          index: '@'\n\t        },\n\t        replace: true,\n\t        transclude: true,\n\t        templateUrl: function(tElement, tAttrs) {\n\t          return tAttrs.templateUrl || 'template/modal/window.html';\n\t        },\n\t        link: function(scope, element, attrs) {\n\t          if (!$modalSuppressWarning) {\n\t            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');\n\t          }\n\t          element.addClass(attrs.windowClass || '');\n\t          element.addClass(attrs.windowTopClass || '');\n\t          scope.size = attrs.size;\n\t\n\t          scope.close = function(evt) {\n\t            var modal = $modalStack.getTop();\n\t            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n\t              evt.preventDefault();\n\t              evt.stopPropagation();\n\t              $modalStack.dismiss(modal.key, 'backdrop click');\n\t            }\n\t          };\n\t\n\t          // moved from template to fix issue #2280\n\t          element.on('click', scope.close);\n\t\n\t          // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n\t          // We can detect that by using this property in the template associated with this directive and then use\n\t          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n\t          scope.$isRendered = true;\n\t\n\t          // Deferred object that will be resolved when this modal is render.\n\t          var modalRenderDeferObj = $q.defer();\n\t          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n\t          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n\t          attrs.$observe('modalRender', function(value) {\n\t            if (value == 'true') {\n\t              modalRenderDeferObj.resolve();\n\t            }\n\t          });\n\t\n\t          modalRenderDeferObj.promise.then(function() {\n\t            var animationPromise = null;\n\t\n\t            if (attrs.modalInClass) {\n\t              if ($animateCss) {\n\t                animationPromise = $animateCss(element, {\n\t                  addClass: attrs.modalInClass\n\t                }).start();\n\t              } else {\n\t                animationPromise = $animate.addClass(element, attrs.modalInClass);\n\t              }\n\t\n\t              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t                var done = setIsAsync();\n\t                if ($animateCss) {\n\t                  $animateCss(element, {\n\t                    removeClass: attrs.modalInClass\n\t                  }).start().then(done);\n\t                } else {\n\t                  $animate.removeClass(element, attrs.modalInClass).then(done);\n\t                }\n\t              });\n\t            }\n\t\n\t\n\t            $q.when(animationPromise).then(function() {\n\t              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n\t              /**\n\t               * Auto-focusing of a freshly-opened modal element causes any child elements\n\t               * with the autofocus attribute to lose focus. This is an issue on touch\n\t               * based devices which will show and then hide the onscreen keyboard.\n\t               * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t               * the modal element if the modal does not contain an autofocus element.\n\t               */\n\t              if (inputWithAutofocus) {\n\t                inputWithAutofocus.focus();\n\t              } else {\n\t                element[0].focus();\n\t              }\n\t            });\n\t\n\t            // Notify {@link $modalStack} that modal is rendered.\n\t            var modal = $modalStack.getTop();\n\t            if (modal) {\n\t              $modalStack.modalRendered(modal.key);\n\t            }\n\t          });\n\t        }\n\t      };\n\t    }])\n\t\n\t  .directive('modalAnimationClass', [\n\t    '$log', '$modalSuppressWarning',\n\t    function ($log, $modalSuppressWarning) {\n\t      return {\n\t        compile: function(tElement, tAttrs) {\n\t          if (!$modalSuppressWarning) {\n\t            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');\n\t          }\n\t          if (tAttrs.modalAnimation) {\n\t            tElement.addClass(tAttrs.modalAnimationClass);\n\t          }\n\t        }\n\t      };\n\t    }])\n\t\n\t  .directive('modalTransclude', [\n\t    '$log', '$modalSuppressWarning',\n\t    function ($log, $modalSuppressWarning) {\n\t    return {\n\t      link: function($scope, $element, $attrs, controller, $transclude) {\n\t        if (!$modalSuppressWarning) {\n\t          $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');\n\t        }\n\t        $transclude($scope.$parent, function(clone) {\n\t          $element.empty();\n\t          $element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .service('$modalStack', [\n\t    '$animate', '$timeout', '$document', '$compile', '$rootScope',\n\t    '$q',\n\t    '$injector',\n\t    '$$multiMap',\n\t    '$$stackedMap',\n\t    '$uibModalStack',\n\t    '$log',\n\t    '$modalSuppressWarning',\n\t    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n\t             $q,\n\t             $injector,\n\t             $$multiMap,\n\t             $$stackedMap,\n\t             $uibModalStack,\n\t             $log,\n\t             $modalSuppressWarning) {\n\t      if (!$modalSuppressWarning) {\n\t        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');\n\t      }\n\t\n\t      angular.extend(this, $uibModalStack);\n\t    }])\n\t\n\t  .provider('$modal', ['$uibModalProvider', function($uibModalProvider) {\n\t    angular.extend(this, $uibModalProvider);\n\t\n\t    this.$get = ['$injector', '$log', '$modalSuppressWarning',\n\t      function ($injector, $log, $modalSuppressWarning) {\n\t        if (!$modalSuppressWarning) {\n\t          $log.warn('$modal is now deprecated. Use $uibModal instead.');\n\t        }\n\t\n\t        return $injector.invoke($uibModalProvider.$get);\n\t      }];\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.pagination', [])\n\t.controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t\n\t  this.init = function(ngModelCtrl_, config) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    this.config = config;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t\n\t    if ($attrs.itemsPerPage) {\n\t      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n\t        self.itemsPerPage = parseInt(value, 10);\n\t        $scope.totalPages = self.calculateTotalPages();\n\t      });\n\t    } else {\n\t      this.itemsPerPage = config.itemsPerPage;\n\t    }\n\t\n\t    $scope.$watch('totalItems', function() {\n\t      $scope.totalPages = self.calculateTotalPages();\n\t    });\n\t\n\t    $scope.$watch('totalPages', function(value) {\n\t      setNumPages($scope.$parent, value); // Readonly variable\n\t\n\t      if ( $scope.page > value ) {\n\t        $scope.selectPage(value);\n\t      } else {\n\t        ngModelCtrl.$render();\n\t      }\n\t    });\n\t  };\n\t\n\t  this.calculateTotalPages = function() {\n\t    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n\t    return Math.max(totalPages || 0, 1);\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n\t  };\n\t\n\t  $scope.selectPage = function(page, evt) {\n\t    if (evt) {\n\t      evt.preventDefault();\n\t    }\n\t\n\t    var clickAllowed = !$scope.ngDisabled || !evt;\n\t    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t      if (evt && evt.target) {\n\t        evt.target.blur();\n\t      }\n\t      ngModelCtrl.$setViewValue(page);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.getText = function(key) {\n\t    return $scope[key + 'Text'] || self.config[key + 'Text'];\n\t  };\n\t\n\t  $scope.noPrevious = function() {\n\t    return $scope.page === 1;\n\t  };\n\t\n\t  $scope.noNext = function() {\n\t    return $scope.page === $scope.totalPages;\n\t  };\n\t}])\n\t\n\t.constant('uibPaginationConfig', {\n\t  itemsPerPage: 10,\n\t  boundaryLinks: false,\n\t  directionLinks: true,\n\t  firstText: 'First',\n\t  previousText: 'Previous',\n\t  nextText: 'Next',\n\t  lastText: 'Last',\n\t  rotate: true\n\t})\n\t\n\t.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@',\n\t      ngDisabled:'='\n\t    },\n\t    require: ['uibPagination', '?ngModel'],\n\t    controller: 'UibPaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pagination.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      // Setup configuration parameters\n\t      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n\t          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n\t      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n\t      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\t\n\t      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\t\n\t      if (attrs.maxSize) {\n\t        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n\t          maxSize = parseInt(value, 10);\n\t          paginationCtrl.render();\n\t        });\n\t      }\n\t\n\t      // Create page object used in template\n\t      function makePage(number, text, isActive) {\n\t        return {\n\t          number: number,\n\t          text: text,\n\t          active: isActive\n\t        };\n\t      }\n\t\n\t      function getPages(currentPage, totalPages) {\n\t        var pages = [];\n\t\n\t        // Default page limits\n\t        var startPage = 1, endPage = totalPages;\n\t        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\t\n\t        // recompute if maxSize\n\t        if (isMaxSized) {\n\t          if (rotate) {\n\t            // Current page is displayed in the middle of the visible ones\n\t            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n\t            endPage   = startPage + maxSize - 1;\n\t\n\t            // Adjust if limit is exceeded\n\t            if (endPage > totalPages) {\n\t              endPage   = totalPages;\n\t              startPage = endPage - maxSize + 1;\n\t            }\n\t          } else {\n\t            // Visible pages are paginated with maxSize\n\t            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\t\n\t            // Adjust last page if limit is exceeded\n\t            endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t          }\n\t        }\n\t\n\t        // Add page number links\n\t        for (var number = startPage; number <= endPage; number++) {\n\t          var page = makePage(number, number, number === currentPage);\n\t          pages.push(page);\n\t        }\n\t\n\t        // Add links to move between page sets\n\t        if (isMaxSized && ! rotate) {\n\t          if (startPage > 1) {\n\t            var previousPageSet = makePage(startPage - 1, '...', false);\n\t            pages.unshift(previousPageSet);\n\t          }\n\t\n\t          if (endPage < totalPages) {\n\t            var nextPageSet = makePage(endPage + 1, '...', false);\n\t            pages.push(nextPageSet);\n\t          }\n\t        }\n\t\n\t        return pages;\n\t      }\n\t\n\t      var originalRender = paginationCtrl.render;\n\t      paginationCtrl.render = function() {\n\t        originalRender();\n\t        if (scope.page > 0 && scope.page <= scope.totalPages) {\n\t          scope.pages = getPages(scope.page, scope.totalPages);\n\t        }\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('uibPagerConfig', {\n\t  itemsPerPage: 10,\n\t  previousText: ' Previous',\n\t  nextText: 'Next ',\n\t  align: true\n\t})\n\t\n\t.directive('uibPager', ['uibPagerConfig', function(pagerConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      ngDisabled: '='\n\t    },\n\t    require: ['uibPager', '?ngModel'],\n\t    controller: 'UibPaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pager.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n\t      paginationCtrl.init(ngModelCtrl, pagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/* Deprecated Pagination Below */\n\t\n\tangular.module('ui.bootstrap.pagination')\n\t.value('$paginationSuppressWarning', false)\n\t.controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {\n\t  if (!$paginationSuppressWarning) {\n\t    $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t\n\t  this.init = function(ngModelCtrl_, config) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    this.config = config;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t\n\t    if ($attrs.itemsPerPage) {\n\t      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n\t        self.itemsPerPage = parseInt(value, 10);\n\t        $scope.totalPages = self.calculateTotalPages();\n\t      });\n\t    } else {\n\t      this.itemsPerPage = config.itemsPerPage;\n\t    }\n\t\n\t    $scope.$watch('totalItems', function() {\n\t      $scope.totalPages = self.calculateTotalPages();\n\t    });\n\t\n\t    $scope.$watch('totalPages', function(value) {\n\t      setNumPages($scope.$parent, value); // Readonly variable\n\t\n\t      if ( $scope.page > value ) {\n\t        $scope.selectPage(value);\n\t      } else {\n\t        ngModelCtrl.$render();\n\t      }\n\t    });\n\t  };\n\t\n\t  this.calculateTotalPages = function() {\n\t    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n\t    return Math.max(totalPages || 0, 1);\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n\t  };\n\t\n\t  $scope.selectPage = function(page, evt) {\n\t    if (evt) {\n\t      evt.preventDefault();\n\t    }\n\t\n\t    var clickAllowed = !$scope.ngDisabled || !evt;\n\t    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t      if (evt && evt.target) {\n\t        evt.target.blur();\n\t      }\n\t      ngModelCtrl.$setViewValue(page);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.getText = function(key) {\n\t    return $scope[key + 'Text'] || self.config[key + 'Text'];\n\t  };\n\t\n\t  $scope.noPrevious = function() {\n\t    return $scope.page === 1;\n\t  };\n\t\n\t  $scope.noNext = function() {\n\t    return $scope.page === $scope.totalPages;\n\t  };\n\t}])\n\t.directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@',\n\t      ngDisabled:'='\n\t    },\n\t    require: ['pagination', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pagination.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$paginationSuppressWarning) {\n\t        $log.warn('pagination is now deprecated. Use uib-pagination instead.');\n\t      }\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      // Setup configuration parameters\n\t      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n\t          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n\t      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n\t      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\t\n\t      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\t\n\t      if (attrs.maxSize) {\n\t        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n\t          maxSize = parseInt(value, 10);\n\t          paginationCtrl.render();\n\t        });\n\t      }\n\t\n\t      // Create page object used in template\n\t      function makePage(number, text, isActive) {\n\t        return {\n\t          number: number,\n\t          text: text,\n\t          active: isActive\n\t        };\n\t      }\n\t\n\t      function getPages(currentPage, totalPages) {\n\t        var pages = [];\n\t\n\t        // Default page limits\n\t        var startPage = 1, endPage = totalPages;\n\t        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\t\n\t        // recompute if maxSize\n\t        if (isMaxSized) {\n\t          if (rotate) {\n\t            // Current page is displayed in the middle of the visible ones\n\t            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n\t            endPage   = startPage + maxSize - 1;\n\t\n\t            // Adjust if limit is exceeded\n\t            if (endPage > totalPages) {\n\t              endPage   = totalPages;\n\t              startPage = endPage - maxSize + 1;\n\t            }\n\t          } else {\n\t            // Visible pages are paginated with maxSize\n\t            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\t\n\t            // Adjust last page if limit is exceeded\n\t            endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t          }\n\t        }\n\t\n\t        // Add page number links\n\t        for (var number = startPage; number <= endPage; number++) {\n\t          var page = makePage(number, number, number === currentPage);\n\t          pages.push(page);\n\t        }\n\t\n\t        // Add links to move between page sets\n\t        if (isMaxSized && ! rotate) {\n\t          if (startPage > 1) {\n\t            var previousPageSet = makePage(startPage - 1, '...', false);\n\t            pages.unshift(previousPageSet);\n\t          }\n\t\n\t          if (endPage < totalPages) {\n\t            var nextPageSet = makePage(endPage + 1, '...', false);\n\t            pages.push(nextPageSet);\n\t          }\n\t        }\n\t\n\t        return pages;\n\t      }\n\t\n\t      var originalRender = paginationCtrl.render;\n\t      paginationCtrl.render = function() {\n\t        originalRender();\n\t        if (scope.page > 0 && scope.page <= scope.totalPages) {\n\t          scope.pages = getPages(scope.page, scope.totalPages);\n\t        }\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      ngDisabled: '='\n\t    },\n\t    require: ['pager', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pager.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$paginationSuppressWarning) {\n\t        $log.warn('pager is now deprecated. Use uib-pager instead.');\n\t      }\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n\t      paginationCtrl.init(ngModelCtrl, pagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html tooltips, and selector delegation.\n\t */\n\tangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\t\n\t/**\n\t * The $tooltip service creates tooltip- and popover-like directives as well as\n\t * houses global options for them.\n\t */\n\t.provider('$uibTooltip', function() {\n\t  // The default options tooltip and popover.\n\t  var defaultOptions = {\n\t    placement: 'top',\n\t    animation: true,\n\t    popupDelay: 0,\n\t    popupCloseDelay: 0,\n\t    useContentExp: false\n\t  };\n\t\n\t  // Default hide triggers for each show trigger\n\t  var triggerMap = {\n\t    'mouseenter': 'mouseleave',\n\t    'click': 'click',\n\t    'focus': 'blur',\n\t    'none': ''\n\t  };\n\t\n\t  // The options specified to the provider globally.\n\t  var globalOptions = {};\n\t\n\t  /**\n\t   * `options({})` allows global configuration of all tooltips in the\n\t   * application.\n\t   *\n\t   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n\t   *     // place tooltips left instead of top by default\n\t   *     $tooltipProvider.options( { placement: 'left' } );\n\t   *   });\n\t   */\n\t\tthis.options = function(value) {\n\t\t\tangular.extend(globalOptions, value);\n\t\t};\n\t\n\t  /**\n\t   * This allows you to extend the set of trigger mappings available. E.g.:\n\t   *\n\t   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n\t   */\n\t  this.setTriggers = function setTriggers(triggers) {\n\t    angular.extend(triggerMap, triggers);\n\t  };\n\t\n\t  /**\n\t   * This is a helper function for translating camel-case to snake-case.\n\t   */\n\t  function snake_case(name) {\n\t    var regexp = /[A-Z]/g;\n\t    var separator = '-';\n\t    return name.replace(regexp, function(letter, pos) {\n\t      return (pos ? separator : '') + letter.toLowerCase();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns the actual instance of the $tooltip service.\n\t   * TODO support multiple triggers\n\t   */\n\t  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n\t    var openedTooltips = $$stackedMap.createNew();\n\t    $document.on('keypress', function(e) {\n\t      if (e.which === 27) {\n\t        var last = openedTooltips.top();\n\t        if (last) {\n\t          last.value.close();\n\t          openedTooltips.removeTop();\n\t          last = null;\n\t        }\n\t      }\n\t    });\n\t\n\t    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n\t      options = angular.extend({}, defaultOptions, globalOptions, options);\n\t\n\t      /**\n\t       * Returns an object of show and hide triggers.\n\t       *\n\t       * If a trigger is supplied,\n\t       * it is used to show the tooltip; otherwise, it will use the `trigger`\n\t       * option passed to the `$tooltipProvider.options` method; else it will\n\t       * default to the trigger supplied to this directive factory.\n\t       *\n\t       * The hide trigger is based on the show trigger. If the `trigger` option\n\t       * was passed to the `$tooltipProvider.options` method, it will use the\n\t       * mapped trigger from `triggerMap` or the passed trigger if the map is\n\t       * undefined; otherwise, it uses the `triggerMap` value of the show\n\t       * trigger; else it will just use the show trigger.\n\t       */\n\t      function getTriggers(trigger) {\n\t        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n\t        var hide = show.map(function(trigger) {\n\t          return triggerMap[trigger] || trigger;\n\t        });\n\t        return {\n\t          show: show,\n\t          hide: hide\n\t        };\n\t      }\n\t\n\t      var directiveName = snake_case(ttType);\n\t\n\t      var startSym = $interpolate.startSymbol();\n\t      var endSym = $interpolate.endSymbol();\n\t      var template =\n\t        '<div '+ directiveName + '-popup '+\n\t          'title=\"' + startSym + 'title' + endSym + '\" '+\n\t          (options.useContentExp ?\n\t            'content-exp=\"contentExp()\" ' :\n\t            'content=\"' + startSym + 'content' + endSym + '\" ') +\n\t          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n\t          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n\t          'animation=\"animation\" ' +\n\t          'is-open=\"isOpen\"' +\n\t          'origin-scope=\"origScope\" ' +\n\t          'style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"' +\n\t          '>' +\n\t        '</div>';\n\t\n\t      return {\n\t        compile: function(tElem, tAttrs) {\n\t          var tooltipLinker = $compile(template);\n\t\n\t          return function link(scope, element, attrs, tooltipCtrl) {\n\t            var tooltip;\n\t            var tooltipLinkedScope;\n\t            var transitionTimeout;\n\t            var showTimeout;\n\t            var hideTimeout;\n\t            var positionTimeout;\n\t            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n\t            var triggers = getTriggers(undefined);\n\t            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n\t            var ttScope = scope.$new(true);\n\t            var repositionScheduled = false;\n\t            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n\t            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n\t            var observers = [];\n\t\n\t            var positionTooltip = function() {\n\t              // check if tooltip exists and is not empty\n\t              if (!tooltip || !tooltip.html()) { return; }\n\t\n\t              if (!positionTimeout) {\n\t                positionTimeout = $timeout(function() {\n\t                  // Reset the positioning.\n\t                  tooltip.css({ top: 0, left: 0 });\n\t\n\t                  // Now set the calculated positioning.\n\t                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n\t                  ttCss.top += 'px';\n\t                  ttCss.left += 'px';\n\t                  ttCss.visibility = 'visible';\n\t                  tooltip.css(ttCss);\n\t\n\t                  positionTimeout = null;\n\t                }, 0, false);\n\t              }\n\t            };\n\t\n\t            // Set up the correct scope to allow transclusion later\n\t            ttScope.origScope = scope;\n\t\n\t            // By default, the tooltip is not open.\n\t            // TODO add ability to start tooltip opened\n\t            ttScope.isOpen = false;\n\t            openedTooltips.add(ttScope, {\n\t              close: hide\n\t            });\n\t\n\t            function toggleTooltipBind() {\n\t              if (!ttScope.isOpen) {\n\t                showTooltipBind();\n\t              } else {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip with delay if specified, otherwise show it immediately\n\t            function showTooltipBind() {\n\t              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n\t                return;\n\t              }\n\t\n\t              cancelHide();\n\t              prepareTooltip();\n\t\n\t              if (ttScope.popupDelay) {\n\t                // Do nothing if the tooltip was already scheduled to pop-up.\n\t                // This happens if show is triggered multiple times before any hide is triggered.\n\t                if (!showTimeout) {\n\t                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n\t                }\n\t              } else {\n\t                show();\n\t              }\n\t            }\n\t\n\t            function hideTooltipBind() {\n\t              cancelShow();\n\t\n\t              if (ttScope.popupCloseDelay) {\n\t                if (!hideTimeout) {\n\t                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n\t                }\n\t              } else {\n\t                hide();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip popup element.\n\t            function show() {\n\t              cancelShow();\n\t              cancelHide();\n\t\n\t              // Don't show empty tooltips.\n\t              if (!ttScope.content) {\n\t                return angular.noop;\n\t              }\n\t\n\t              createTooltip();\n\t\n\t              // And show the tooltip.\n\t              ttScope.$evalAsync(function() {\n\t                ttScope.isOpen = true;\n\t                assignIsOpen(true);\n\t                positionTooltip();\n\t              });\n\t            }\n\t\n\t            function cancelShow() {\n\t              if (showTimeout) {\n\t                $timeout.cancel(showTimeout);\n\t                showTimeout = null;\n\t              }\n\t\n\t              if (positionTimeout) {\n\t                $timeout.cancel(positionTimeout);\n\t                positionTimeout = null;\n\t              }\n\t            }\n\t\n\t            // Hide the tooltip popup element.\n\t            function hide() {\n\t              cancelShow();\n\t              cancelHide();\n\t\n\t              if (!ttScope) {\n\t                return;\n\t              }\n\t\n\t              // First things first: we don't show it anymore.\n\t              ttScope.$evalAsync(function() {\n\t                ttScope.isOpen = false;\n\t                assignIsOpen(false);\n\t                // And now we remove it from the DOM. However, if we have animation, we\n\t                // need to wait for it to expire beforehand.\n\t                // FIXME: this is a placeholder for a port of the transitions library.\n\t                // The fade transition in TWBS is 150ms.\n\t                if (ttScope.animation) {\n\t                  if (!transitionTimeout) {\n\t                    transitionTimeout = $timeout(removeTooltip, 150, false);\n\t                  }\n\t                } else {\n\t                  removeTooltip();\n\t                }\n\t              });\n\t            }\n\t\n\t            function cancelHide() {\n\t              if (hideTimeout) {\n\t                $timeout.cancel(hideTimeout);\n\t                hideTimeout = null;\n\t              }\n\t              if (transitionTimeout) {\n\t                $timeout.cancel(transitionTimeout);\n\t                transitionTimeout = null;\n\t              }\n\t            }\n\t\n\t            function createTooltip() {\n\t              // There can only be one tooltip element per directive shown at once.\n\t              if (tooltip) {\n\t                return;\n\t              }\n\t\n\t              tooltipLinkedScope = ttScope.$new();\n\t              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n\t                if (appendToBody) {\n\t                  $document.find('body').append(tooltip);\n\t                } else {\n\t                  element.after(tooltip);\n\t                }\n\t              });\n\t\n\t              prepObservers();\n\t            }\n\t\n\t            function removeTooltip() {\n\t              unregisterObservers();\n\t\n\t              transitionTimeout = null;\n\t              if (tooltip) {\n\t                tooltip.remove();\n\t                tooltip = null;\n\t              }\n\t              if (tooltipLinkedScope) {\n\t                tooltipLinkedScope.$destroy();\n\t                tooltipLinkedScope = null;\n\t              }\n\t            }\n\t\n\t            /**\n\t             * Set the inital scope values. Once\n\t             * the tooltip is created, the observers\n\t             * will be added to keep things in synch.\n\t             */\n\t            function prepareTooltip() {\n\t              ttScope.title = attrs[prefix + 'Title'];\n\t              if (contentParse) {\n\t                ttScope.content = contentParse(scope);\n\t              } else {\n\t                ttScope.content = attrs[ttType];\n\t              }\n\t\n\t              ttScope.popupClass = attrs[prefix + 'Class'];\n\t              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\t\n\t              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n\t              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n\t              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n\t              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n\t            }\n\t\n\t            function assignIsOpen(isOpen) {\n\t              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n\t                isOpenParse.assign(scope, isOpen);\n\t              }\n\t            }\n\t\n\t            ttScope.contentExp = function() {\n\t              return ttScope.content;\n\t            };\n\t\n\t            /**\n\t             * Observe the relevant attributes.\n\t             */\n\t            attrs.$observe('disabled', function(val) {\n\t              if (val) {\n\t                cancelShow();\n\t              }\n\t\n\t              if (val && ttScope.isOpen) {\n\t                hide();\n\t              }\n\t            });\n\t\n\t            if (isOpenParse) {\n\t              scope.$watch(isOpenParse, function(val) {\n\t                /*jshint -W018 */\n\t                if (ttScope && !val === ttScope.isOpen) {\n\t                  toggleTooltipBind();\n\t                }\n\t                /*jshint +W018 */\n\t              });\n\t            }\n\t\n\t            function prepObservers() {\n\t              observers.length = 0;\n\t\n\t              if (contentParse) {\n\t                observers.push(\n\t                  scope.$watch(contentParse, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    }\n\t                  })\n\t                );\n\t\n\t                observers.push(\n\t                  tooltipLinkedScope.$watch(function() {\n\t                    if (!repositionScheduled) {\n\t                      repositionScheduled = true;\n\t                      tooltipLinkedScope.$$postDigest(function() {\n\t                        repositionScheduled = false;\n\t                        if (ttScope && ttScope.isOpen) {\n\t                          positionTooltip();\n\t                        }\n\t                      });\n\t                    }\n\t                  })\n\t                );\n\t              } else {\n\t                observers.push(\n\t                  attrs.$observe(ttType, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    } else {\n\t                      positionTooltip();\n\t                    }\n\t                  })\n\t                );\n\t              }\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Title', function(val) {\n\t                  ttScope.title = val;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Placement', function(val) {\n\t                  ttScope.placement = val ? val : options.placement;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t            }\n\t\n\t            function unregisterObservers() {\n\t              if (observers.length) {\n\t                angular.forEach(observers, function(observer) {\n\t                  observer();\n\t                });\n\t                observers.length = 0;\n\t              }\n\t            }\n\t\n\t            var unregisterTriggers = function() {\n\t              triggers.show.forEach(function(trigger) {\n\t                element.unbind(trigger, showTooltipBind);\n\t              });\n\t              triggers.hide.forEach(function(trigger) {\n\t                trigger.split(' ').forEach(function(hideTrigger) {\n\t                  element[0].removeEventListener(hideTrigger, hideTooltipBind);\n\t                });\n\t              });\n\t            };\n\t\n\t            function prepTriggers() {\n\t              var val = attrs[prefix + 'Trigger'];\n\t              unregisterTriggers();\n\t\n\t              triggers = getTriggers(val);\n\t\n\t              if (triggers.show !== 'none') {\n\t                triggers.show.forEach(function(trigger, idx) {\n\t                  // Using raw addEventListener due to jqLite/jQuery bug - #4060\n\t                  if (trigger === triggers.hide[idx]) {\n\t                    element[0].addEventListener(trigger, toggleTooltipBind);\n\t                  } else if (trigger) {\n\t                    element[0].addEventListener(trigger, showTooltipBind);\n\t                    triggers.hide[idx].split(' ').forEach(function(trigger) {\n\t                      element[0].addEventListener(trigger, hideTooltipBind);\n\t                    });\n\t                  }\n\t\n\t                  element.on('keypress', function(e) {\n\t                    if (e.which === 27) {\n\t                      hideTooltipBind();\n\t                    }\n\t                  });\n\t                });\n\t              }\n\t            }\n\t\n\t            prepTriggers();\n\t\n\t            var animation = scope.$eval(attrs[prefix + 'Animation']);\n\t            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\t\n\t            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);\n\t            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\t\n\t            // if a tooltip is attached to <body> we need to remove it on\n\t            // location change as its parent scope will probably not be destroyed\n\t            // by the change.\n\t            if (appendToBody) {\n\t              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {\n\t                if (ttScope.isOpen) {\n\t                  hide();\n\t                }\n\t              });\n\t            }\n\t\n\t            // Make sure tooltip is destroyed and removed.\n\t            scope.$on('$destroy', function onDestroyTooltip() {\n\t              cancelShow();\n\t              cancelHide();\n\t              unregisterTriggers();\n\t              removeTooltip();\n\t              openedTooltips.remove(ttScope);\n\t              ttScope = null;\n\t            });\n\t          };\n\t        }\n\t      };\n\t    };\n\t  }];\n\t})\n\t\n\t// This is mostly ngInclude code but with a custom scope\n\t.directive('uibTooltipTemplateTransclude', [\n\t         '$animate', '$sce', '$compile', '$templateRequest',\n\tfunction ($animate ,  $sce ,  $compile ,  $templateRequest) {\n\t  return {\n\t    link: function(scope, elem, attrs) {\n\t      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\t\n\t      var changeCounter = 0,\n\t        currentScope,\n\t        previousElement,\n\t        currentElement;\n\t\n\t      var cleanupLastIncludeContent = function() {\n\t        if (previousElement) {\n\t          previousElement.remove();\n\t          previousElement = null;\n\t        }\n\t\n\t        if (currentScope) {\n\t          currentScope.$destroy();\n\t          currentScope = null;\n\t        }\n\t\n\t        if (currentElement) {\n\t          $animate.leave(currentElement).then(function() {\n\t            previousElement = null;\n\t          });\n\t          previousElement = currentElement;\n\t          currentElement = null;\n\t        }\n\t      };\n\t\n\t      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n\t        var thisChangeId = ++changeCounter;\n\t\n\t        if (src) {\n\t          //set the 2nd param to true to ignore the template request error so that the inner\n\t          //contents and scope can be cleaned up.\n\t          $templateRequest(src, true).then(function(response) {\n\t            if (thisChangeId !== changeCounter) { return; }\n\t            var newScope = origScope.$new();\n\t            var template = response;\n\t\n\t            var clone = $compile(template)(newScope, function(clone) {\n\t              cleanupLastIncludeContent();\n\t              $animate.enter(clone, elem);\n\t            });\n\t\n\t            currentScope = newScope;\n\t            currentElement = clone;\n\t\n\t            currentScope.$emit('$includeContentLoaded', src);\n\t          }, function() {\n\t            if (thisChangeId === changeCounter) {\n\t              cleanupLastIncludeContent();\n\t              scope.$emit('$includeContentError', src);\n\t            }\n\t          });\n\t          scope.$emit('$includeContentRequested', src);\n\t        } else {\n\t          cleanupLastIncludeContent();\n\t        }\n\t      });\n\t\n\t      scope.$on('$destroy', cleanupLastIncludeContent);\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * Note that it's intentional that these classes are *not* applied through $animate.\n\t * They must not be animated as they're expected to be present on the tooltip on\n\t * initialization.\n\t */\n\t.directive('uibTooltipClasses', function() {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attrs) {\n\t      if (scope.placement) {\n\t        element.addClass(scope.placement);\n\t      }\n\t\n\t      if (scope.popupClass) {\n\t        element.addClass(scope.popupClass);\n\t      }\n\t\n\t      if (scope.animation()) {\n\t        element.addClass(attrs.tooltipAnimationClass);\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltipPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-popup.html',\n\t    link: function(scope, element) {\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n\t}])\n\t\n\t.directive('uibTooltipTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n\t    link: function(scope, element) {\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibTooltipHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n\t    link: function(scope, element) {\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}]);\n\t\n\t/* Deprecated tooltip below */\n\t\n\tangular.module('ui.bootstrap.tooltip')\n\t\n\t.value('$tooltipSuppressWarning', false)\n\t\n\t.provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {\n\t  angular.extend(this, $uibTooltipProvider);\n\t\n\t  this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {\n\t    if (!$tooltipSuppressWarning) {\n\t      $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');\n\t    }\n\t\n\t    return $injector.invoke($uibTooltipProvider.$get);\n\t  }];\n\t}])\n\t\n\t// This is mostly ngInclude code but with a custom scope\n\t.directive('tooltipTemplateTransclude', [\n\t         '$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning',\n\tfunction ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {\n\t  return {\n\t    link: function(scope, elem, attrs) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');\n\t      }\n\t\n\t      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\t\n\t      var changeCounter = 0,\n\t        currentScope,\n\t        previousElement,\n\t        currentElement;\n\t\n\t      var cleanupLastIncludeContent = function() {\n\t        if (previousElement) {\n\t          previousElement.remove();\n\t          previousElement = null;\n\t        }\n\t        if (currentScope) {\n\t          currentScope.$destroy();\n\t          currentScope = null;\n\t        }\n\t        if (currentElement) {\n\t          $animate.leave(currentElement).then(function() {\n\t            previousElement = null;\n\t          });\n\t          previousElement = currentElement;\n\t          currentElement = null;\n\t        }\n\t      };\n\t\n\t      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {\n\t        var thisChangeId = ++changeCounter;\n\t\n\t        if (src) {\n\t          //set the 2nd param to true to ignore the template request error so that the inner\n\t          //contents and scope can be cleaned up.\n\t          $templateRequest(src, true).then(function(response) {\n\t            if (thisChangeId !== changeCounter) { return; }\n\t            var newScope = origScope.$new();\n\t            var template = response;\n\t\n\t            var clone = $compile(template)(newScope, function(clone) {\n\t              cleanupLastIncludeContent();\n\t              $animate.enter(clone, elem);\n\t            });\n\t\n\t            currentScope = newScope;\n\t            currentElement = clone;\n\t\n\t            currentScope.$emit('$includeContentLoaded', src);\n\t          }, function() {\n\t            if (thisChangeId === changeCounter) {\n\t              cleanupLastIncludeContent();\n\t              scope.$emit('$includeContentError', src);\n\t            }\n\t          });\n\t          scope.$emit('$includeContentRequested', src);\n\t        } else {\n\t          cleanupLastIncludeContent();\n\t        }\n\t      });\n\t\n\t      scope.$on('$destroy', cleanupLastIncludeContent);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attrs) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');\n\t      }\n\t\n\t      if (scope.placement) {\n\t        element.addClass(scope.placement);\n\t      }\n\t      if (scope.popupClass) {\n\t        element.addClass(scope.popupClass);\n\t      }\n\t      if (scope.animation()) {\n\t        element.addClass(attrs.tooltipAnimationClass);\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-popup.html',\n\t    link: function(scope, element) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');\n\t      }\n\t\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltip', ['$tooltip', function($tooltip) {\n\t  return $tooltip('tooltip', 'tooltip', 'mouseenter');\n\t}])\n\t\n\t.directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n\t    link: function(scope, element) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');\n\t      }\n\t\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipTemplate', ['$tooltip', function($tooltip) {\n\t  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n\t    link: function(scope, element) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');\n\t      }\n\t\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipHtml', ['$tooltip', function($tooltip) {\n\t  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: popup delay, animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, and selector delegatation.\n\t */\n\tangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\t\n\t.directive('uibPopoverTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/popover/popover-template.html',\n\t    link: function(scope, element) {\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover-html.html',\n\t    link: function(scope, element) {\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover.html',\n\t    link: function(scope, element) {\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopover', 'popover', 'click');\n\t}]);\n\t\n\t/* Deprecated popover below */\n\t\n\tangular.module('ui.bootstrap.popover')\n\t\n\t.value('$popoverSuppressWarning', false)\n\t\n\t.directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/popover/popover-template.html',\n\t    link: function(scope, element) {\n\t      if (!$popoverSuppressWarning) {\n\t        $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');\n\t      }\n\t\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('popoverTemplate', ['$tooltip', function($tooltip) {\n\t  return $tooltip('popoverTemplate', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover-html.html',\n\t    link: function(scope, element) {\n\t      if (!$popoverSuppressWarning) {\n\t        $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');\n\t      }\n\t\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('popoverHtml', ['$tooltip', function($tooltip) {\n\t  return $tooltip('popoverHtml', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover.html',\n\t    link: function(scope, element) {\n\t      if (!$popoverSuppressWarning) {\n\t        $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');\n\t      }\n\t\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('popover', ['$tooltip', function($tooltip) {\n\t\n\t  return $tooltip('popover', 'popover', 'click');\n\t}]);\n\t\n\tangular.module('ui.bootstrap.progressbar', [])\n\t\n\t.constant('uibProgressConfig', {\n\t  animate: true,\n\t  max: 100\n\t})\n\t\n\t.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n\t  var self = this,\n\t      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t  this.bars = [];\n\t  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\t\n\t  this.addBar = function(bar, element, attrs) {\n\t    if (!animate) {\n\t      element.css({'transition': 'none'});\n\t    }\n\t\n\t    this.bars.push(bar);\n\t\n\t    bar.max = $scope.max;\n\t    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\t\n\t    bar.$watch('value', function(value) {\n\t      bar.recalculatePercentage();\n\t    });\n\t\n\t    bar.recalculatePercentage = function() {\n\t      var totalPercentage = self.bars.reduce(function(total, bar) {\n\t        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\t        return total + bar.percent;\n\t      }, 0);\n\t\n\t      if (totalPercentage > 100) {\n\t        bar.percent -= totalPercentage - 100;\n\t      }\n\t    };\n\t\n\t    bar.$on('$destroy', function() {\n\t      element = null;\n\t      self.removeBar(bar);\n\t    });\n\t  };\n\t\n\t  this.removeBar = function(bar) {\n\t    this.bars.splice(this.bars.indexOf(bar), 1);\n\t    this.bars.forEach(function (bar) {\n\t      bar.recalculatePercentage();\n\t    });\n\t  };\n\t\n\t  $scope.$watch('max', function(max) {\n\t    self.bars.forEach(function(bar) {\n\t      bar.max = $scope.max;\n\t      bar.recalculatePercentage();\n\t    });\n\t  });\n\t}])\n\t\n\t.directive('uibProgress', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    require: 'uibProgress',\n\t    scope: {\n\t      max: '=?'\n\t    },\n\t    templateUrl: 'template/progressbar/progress.html'\n\t  };\n\t})\n\t\n\t.directive('uibBar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    require: '^uibProgress',\n\t    scope: {\n\t      value: '=',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/bar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, element, attrs);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibProgressbar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    scope: {\n\t      value: '=',\n\t      max: '=?',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/progressbar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated progressbar below */\n\t\n\tangular.module('ui.bootstrap.progressbar')\n\t\n\t.value('$progressSuppressWarning', false)\n\t\n\t.controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {\n\t  if (!$progressSuppressWarning) {\n\t    $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t  this.bars = [];\n\t  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\t\n\t  this.addBar = function(bar, element, attrs) {\n\t    if (!animate) {\n\t      element.css({'transition': 'none'});\n\t    }\n\t\n\t    this.bars.push(bar);\n\t\n\t    bar.max = $scope.max;\n\t    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\t\n\t    bar.$watch('value', function(value) {\n\t      bar.recalculatePercentage();\n\t    });\n\t\n\t    bar.recalculatePercentage = function() {\n\t      bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\t\n\t      var totalPercentage = self.bars.reduce(function(total, bar) {\n\t        return total + bar.percent;\n\t      }, 0);\n\t\n\t      if (totalPercentage > 100) {\n\t        bar.percent -= totalPercentage - 100;\n\t      }\n\t    };\n\t\n\t    bar.$on('$destroy', function() {\n\t      element = null;\n\t      self.removeBar(bar);\n\t    });\n\t  };\n\t\n\t  this.removeBar = function(bar) {\n\t    this.bars.splice(this.bars.indexOf(bar), 1);\n\t  };\n\t\n\t  $scope.$watch('max', function(max) {\n\t    self.bars.forEach(function(bar) {\n\t      bar.max = $scope.max;\n\t      bar.recalculatePercentage();\n\t    });\n\t  });\n\t}])\n\t\n\t.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'ProgressController',\n\t    require: 'progress',\n\t    scope: {\n\t      max: '=?',\n\t      title: '@?'\n\t    },\n\t    templateUrl: 'template/progressbar/progress.html',\n\t    link: function() {\n\t      if (!$progressSuppressWarning) {\n\t        $log.warn('progress is now deprecated. Use uib-progress instead.');\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    require: '^progress',\n\t    scope: {\n\t      value: '=',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/bar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      if (!$progressSuppressWarning) {\n\t        $log.warn('bar is now deprecated. Use uib-bar instead.');\n\t      }\n\t      progressCtrl.addBar(scope, element);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'ProgressController',\n\t    scope: {\n\t      value: '=',\n\t      max: '=?',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/progressbar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      if (!$progressSuppressWarning) {\n\t        $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');\n\t      }\n\t      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.rating', [])\n\t\n\t.constant('uibRatingConfig', {\n\t  max: 5,\n\t  stateOn: null,\n\t  stateOff: null,\n\t  titles : ['one', 'two', 'three', 'four', 'five']\n\t})\n\t\n\t.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n\t  var ngModelCtrl  = { $setViewValue: angular.noop };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.push(function(value) {\n\t      if (angular.isNumber(value) && value << 0 !== value) {\n\t        value = Math.round(value);\n\t      }\n\t      return value;\n\t    });\n\t\n\t    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n\t    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\t    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n\t    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n\t      tmpTitles : ratingConfig.titles;\n\t\n\t    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n\t      $scope.$parent.$eval($attrs.ratingStates) :\n\t      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n\t    $scope.range = this.buildTemplateObjects(ratingStates);\n\t  };\n\t\n\t  this.buildTemplateObjects = function(states) {\n\t    for (var i = 0, n = states.length; i < n; i++) {\n\t      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n\t    }\n\t    return states;\n\t  };\n\t\n\t  this.getTitle = function(index) {\n\t    if (index >= this.titles.length) {\n\t      return index + 1;\n\t    } else {\n\t      return this.titles[index];\n\t    }\n\t  };\n\t\n\t  $scope.rate = function(value) {\n\t    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n\t      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.enter = function(value) {\n\t    if (!$scope.readonly) {\n\t      $scope.value = value;\n\t    }\n\t    $scope.onHover({value: value});\n\t  };\n\t\n\t  $scope.reset = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t    $scope.onLeave();\n\t  };\n\t\n\t  $scope.onKeydown = function(evt) {\n\t    if (/(37|38|39|40)/.test(evt.which)) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n\t    }\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t  };\n\t}])\n\t\n\t.directive('uibRating', function() {\n\t  return {\n\t    require: ['uibRating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'UibRatingController',\n\t    templateUrl: 'template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      ratingCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated rating below */\n\t\n\tangular.module('ui.bootstrap.rating')\n\t\n\t.value('$ratingSuppressWarning', false)\n\t\n\t.controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {\n\t  if (!$ratingSuppressWarning) {\n\t    $log.warn('RatingController is now deprecated. Use UibRatingController instead.');\n\t  }\n\t\n\t  angular.extend(this, $controller('UibRatingController', {\n\t    $scope: $scope,\n\t    $attrs: $attrs\n\t  }));\n\t}])\n\t\n\t.directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {\n\t  return {\n\t    require: ['rating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'RatingController',\n\t    templateUrl: 'template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$ratingSuppressWarning) {\n\t        $log.warn('rating is now deprecated. Use uib-rating instead.');\n\t      }\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      ratingCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t}]);\n\t\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.bootstrap.tabs\n\t *\n\t * @description\n\t * AngularJS version of the tabs directive.\n\t */\n\t\n\tangular.module('ui.bootstrap.tabs', [])\n\t\n\t.controller('UibTabsetController', ['$scope', function ($scope) {\n\t  var ctrl = this,\n\t      tabs = ctrl.tabs = $scope.tabs = [];\n\t\n\t  ctrl.select = function(selectedTab) {\n\t    angular.forEach(tabs, function(tab) {\n\t      if (tab.active && tab !== selectedTab) {\n\t        tab.active = false;\n\t        tab.onDeselect();\n\t        selectedTab.selectCalled = false;\n\t      }\n\t    });\n\t    selectedTab.active = true;\n\t    // only call select if it has not already been called\n\t    if (!selectedTab.selectCalled) {\n\t      selectedTab.onSelect();\n\t      selectedTab.selectCalled = true;\n\t    }\n\t  };\n\t\n\t  ctrl.addTab = function addTab(tab) {\n\t    tabs.push(tab);\n\t    // we can't run the select function on the first tab\n\t    // since that would select it twice\n\t    if (tabs.length === 1 && tab.active !== false) {\n\t      tab.active = true;\n\t    } else if (tab.active) {\n\t      ctrl.select(tab);\n\t    } else {\n\t      tab.active = false;\n\t    }\n\t  };\n\t\n\t  ctrl.removeTab = function removeTab(tab) {\n\t    var index = tabs.indexOf(tab);\n\t    //Select a new tab if the tab to be removed is selected and not destroyed\n\t    if (tab.active && tabs.length > 1 && !destroyed) {\n\t      //If this is the last tab, select the previous tab. else, the next tab.\n\t      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n\t      ctrl.select(tabs[newActiveIndex]);\n\t    }\n\t    tabs.splice(index, 1);\n\t  };\n\t\n\t  var destroyed;\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t  });\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabset\n\t * @restrict EA\n\t *\n\t * @description\n\t * Tabset is the outer container for the tabs directive\n\t *\n\t * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n\t * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <uib-tabset>\n\t      <uib-tab heading=\"Tab 1\"><b>First</b> Content!</uib-tab>\n\t      <uib-tab heading=\"Tab 2\"><i>Second</i> Content!</uib-tab>\n\t    </uib-tabset>\n\t    <hr />\n\t    <uib-tabset vertical=\"true\">\n\t      <uib-tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</uib-tab>\n\t      <uib-tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</uib-tab>\n\t    </uib-tabset>\n\t    <uib-tabset justified=\"true\">\n\t      <uib-tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</uib-tab>\n\t      <uib-tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</uib-tab>\n\t    </uib-tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('uibTabset', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@'\n\t    },\n\t    controller: 'UibTabsetController',\n\t    templateUrl: 'template/tabs/tabset.html',\n\t    link: function(scope, element, attrs) {\n\t      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n\t      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n\t    }\n\t  };\n\t})\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tab\n\t * @restrict EA\n\t *\n\t * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n\t * @param {string=} select An expression to evaluate when the tab is selected.\n\t * @param {boolean=} active A binding, telling whether or not this tab is selected.\n\t * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n\t *\n\t * @description\n\t * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <div ng-controller=\"TabsDemoCtrl\">\n\t      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n\t        Select item 1, using active binding\n\t      </button>\n\t      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n\t        Enable/disable item 2, using disabled binding\n\t      </button>\n\t      <br />\n\t      <uib-tabset>\n\t        <uib-tab heading=\"Tab 1\">First Tab</uib-tab>\n\t        <uib-tab select=\"alertMe()\">\n\t          <uib-tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n\t          Second Tab, with alert callback and html heading!\n\t        </uib-tab>\n\t        <uib-tab ng-repeat=\"item in items\"\n\t          heading=\"{{item.title}}\"\n\t          disabled=\"item.disabled\"\n\t          active=\"item.active\">\n\t          {{item.content}}\n\t        </uib-tab>\n\t      </uib-tabset>\n\t    </div>\n\t  </file>\n\t  <file name=\"script.js\">\n\t    function TabsDemoCtrl($scope) {\n\t      $scope.items = [\n\t        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n\t        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n\t      ];\n\t\n\t      $scope.alertMe = function() {\n\t        setTimeout(function() {\n\t          alert(\"You've selected the alert tab!\");\n\t        });\n\t      };\n\t    };\n\t  </file>\n\t</example>\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabHeading\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <uib-tabset>\n\t      <uib-tab>\n\t        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>\n\t        And some content, too!\n\t      </uib-tab>\n\t      <uib-tab>\n\t        <uib-tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n\t        That's right.\n\t      </uib-tab>\n\t    </uib-tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('uibTab', ['$parse', function($parse) {\n\t  return {\n\t    require: '^uibTabset',\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/tabs/tab.html',\n\t    transclude: true,\n\t    scope: {\n\t      active: '=?',\n\t      heading: '@',\n\t      onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t                          //once it inserts the tab's content into the dom\n\t      onDeselect: '&deselect'\n\t    },\n\t    controller: function() {\n\t      //Empty controller so other directives can require being 'under' a tab\n\t    },\n\t    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          tabsetCtrl.select(scope);\n\t        }\n\t      });\n\t\n\t      scope.disabled = false;\n\t      if (attrs.disable) {\n\t        scope.$parent.$watch($parse(attrs.disable), function(value) {\n\t          scope.disabled = !! value;\n\t        });\n\t      }\n\t\n\t      scope.select = function() {\n\t        if (!scope.disabled) {\n\t          scope.active = true;\n\t        }\n\t      };\n\t\n\t      tabsetCtrl.addTab(scope);\n\t      scope.$on('$destroy', function() {\n\t        tabsetCtrl.removeTab(scope);\n\t      });\n\t\n\t      //We need to transclude later, once the content container is ready.\n\t      //when this link happens, we're inside a tab heading.\n\t      scope.$transcludeFn = transclude;\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTabHeadingTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uibTab', '?^tab'], // TODO: change to '^uibTab' after deprecation removal\n\t    link: function(scope, elm) {\n\t      scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t        if (heading) {\n\t          elm.html('');\n\t          elm.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTabContentTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uibTabset', '?^tabset'], // TODO: change to '^uibTabset' after deprecation removal\n\t    link: function(scope, elm, attrs) {\n\t      var tab = scope.$eval(attrs.uibTabContentTransclude);\n\t\n\t      //Now our tab is ready to be transcluded: both the tab heading area\n\t      //and the tab content area are loaded.  Transclude 'em both.\n\t      tab.$transcludeFn(tab.$parent, function(contents) {\n\t        angular.forEach(contents, function(node) {\n\t          if (isTabHeading(node)) {\n\t            //Let tabHeadingTransclude know.\n\t            tab.headingElement = node;\n\t          } else {\n\t            elm.append(node);\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t\n\t  function isTabHeading(node) {\n\t    return node.tagName && (\n\t      node.hasAttribute('tab-heading') || // TODO: remove after deprecation removal\n\t      node.hasAttribute('data-tab-heading') || // TODO: remove after deprecation removal\n\t      node.hasAttribute('x-tab-heading') || // TODO: remove after deprecation removal\n\t      node.hasAttribute('uib-tab-heading') ||\n\t      node.hasAttribute('data-uib-tab-heading') ||\n\t      node.hasAttribute('x-uib-tab-heading') ||\n\t      node.tagName.toLowerCase() === 'tab-heading' || // TODO: remove after deprecation removal\n\t      node.tagName.toLowerCase() === 'data-tab-heading' || // TODO: remove after deprecation removal\n\t      node.tagName.toLowerCase() === 'x-tab-heading' || // TODO: remove after deprecation removal\n\t      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n\t    );\n\t  }\n\t});\n\t\n\t/* deprecated tabs below */\n\t\n\tangular.module('ui.bootstrap.tabs')\n\t\n\t  .value('$tabsSuppressWarning', false)\n\t\n\t  .controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {\n\t    if (!$tabsSuppressWarning) {\n\t      $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibTabsetController', {\n\t      $scope: $scope\n\t    }));\n\t  }])\n\t\n\t  .directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n\t    return {\n\t      restrict: 'EA',\n\t      transclude: true,\n\t      replace: true,\n\t      scope: {\n\t        type: '@'\n\t      },\n\t      controller: 'TabsetController',\n\t      templateUrl: 'template/tabs/tabset.html',\n\t      link: function(scope, element, attrs) {\n\t\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tabset is now deprecated. Use uib-tabset instead.');\n\t        }\n\t        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n\t        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {\n\t    return {\n\t      require: '^tabset',\n\t      restrict: 'EA',\n\t      replace: true,\n\t      templateUrl: 'template/tabs/tab.html',\n\t      transclude: true,\n\t      scope: {\n\t        active: '=?',\n\t        heading: '@',\n\t        onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t        //once it inserts the tab's content into the dom\n\t        onDeselect: '&deselect'\n\t      },\n\t      controller: function() {\n\t        //Empty controller so other directives can require being 'under' a tab\n\t      },\n\t      link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tab is now deprecated. Use uib-tab instead.');\n\t        }\n\t\n\t        scope.$watch('active', function(active) {\n\t          if (active) {\n\t            tabsetCtrl.select(scope);\n\t          }\n\t        });\n\t\n\t        scope.disabled = false;\n\t        if (attrs.disable) {\n\t          scope.$parent.$watch($parse(attrs.disable), function(value) {\n\t            scope.disabled = !!value;\n\t          });\n\t        }\n\t\n\t        scope.select = function() {\n\t          if (!scope.disabled) {\n\t            scope.active = true;\n\t          }\n\t        };\n\t\n\t        tabsetCtrl.addTab(scope);\n\t        scope.$on('$destroy', function() {\n\t          tabsetCtrl.removeTab(scope);\n\t        });\n\t\n\t        //We need to transclude later, once the content container is ready.\n\t        //when this link happens, we're inside a tab heading.\n\t        scope.$transcludeFn = transclude;\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n\t    return {\n\t      restrict: 'A',\n\t      require: '^tab',\n\t      link: function(scope, elm) {\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');\n\t        }\n\t\n\t        scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t          if (heading) {\n\t            elm.html('');\n\t            elm.append(heading);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n\t    return {\n\t      restrict: 'A',\n\t      require: '^tabset',\n\t      link: function(scope, elm, attrs) {\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');\n\t        }\n\t\n\t        var tab = scope.$eval(attrs.tabContentTransclude);\n\t\n\t        //Now our tab is ready to be transcluded: both the tab heading area\n\t        //and the tab content area are loaded.  Transclude 'em both.\n\t        tab.$transcludeFn(tab.$parent, function(contents) {\n\t          angular.forEach(contents, function(node) {\n\t            if (isTabHeading(node)) {\n\t              //Let tabHeadingTransclude know.\n\t              tab.headingElement = node;\n\t            }\n\t            else {\n\t              elm.append(node);\n\t            }\n\t          });\n\t        });\n\t      }\n\t    };\n\t\n\t    function isTabHeading(node) {\n\t      return node.tagName && (\n\t          node.hasAttribute('tab-heading') ||\n\t          node.hasAttribute('data-tab-heading') ||\n\t          node.hasAttribute('x-tab-heading') ||\n\t          node.tagName.toLowerCase() === 'tab-heading' ||\n\t          node.tagName.toLowerCase() === 'data-tab-heading' ||\n\t          node.tagName.toLowerCase() === 'x-tab-heading'\n\t        );\n\t    }\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.timepicker', [])\n\t\n\t.constant('uibTimepickerConfig', {\n\t  hourStep: 1,\n\t  minuteStep: 1,\n\t  showMeridian: true,\n\t  meridians: null,\n\t  readonlyInput: false,\n\t  mousewheel: true,\n\t  arrowkeys: true,\n\t  showSpinners: true\n\t})\n\t\n\t.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n\t  var selected = new Date(),\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\t\n\t  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n\t  $element.removeAttr('tabindex');\n\t\n\t  this.init = function(ngModelCtrl_, inputs) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.unshift(function(modelValue) {\n\t      return modelValue ? new Date(modelValue) : null;\n\t    });\n\t\n\t    var hoursInputEl = inputs.eq(0),\n\t        minutesInputEl = inputs.eq(1);\n\t\n\t    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\t    if (mousewheel) {\n\t      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);\n\t    }\n\t\n\t    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n\t    if (arrowkeys) {\n\t      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);\n\t    }\n\t\n\t    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n\t    this.setupInputEvents(hoursInputEl, minutesInputEl);\n\t  };\n\t\n\t  var hourStep = timepickerConfig.hourStep;\n\t  if ($attrs.hourStep) {\n\t    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n\t      hourStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  var minuteStep = timepickerConfig.minuteStep;\n\t  if ($attrs.minuteStep) {\n\t    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n\t      minuteStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  var min;\n\t  $scope.$parent.$watch($parse($attrs.min), function(value) {\n\t    var dt = new Date(value);\n\t    min = isNaN(dt) ? undefined : dt;\n\t  });\n\t\n\t  var max;\n\t  $scope.$parent.$watch($parse($attrs.max), function(value) {\n\t    var dt = new Date(value);\n\t    max = isNaN(dt) ? undefined : dt;\n\t  });\n\t\n\t  $scope.noIncrementHours = function() {\n\t    var incrementedSelected = addMinutes(selected, hourStep * 60);\n\t    return incrementedSelected > max ||\n\t      (incrementedSelected < selected && incrementedSelected < min);\n\t  };\n\t\n\t  $scope.noDecrementHours = function() {\n\t    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n\t    return decrementedSelected < min ||\n\t      (decrementedSelected > selected && decrementedSelected > max);\n\t  };\n\t\n\t  $scope.noIncrementMinutes = function() {\n\t    var incrementedSelected = addMinutes(selected, minuteStep);\n\t    return incrementedSelected > max ||\n\t      (incrementedSelected < selected && incrementedSelected < min);\n\t  };\n\t\n\t  $scope.noDecrementMinutes = function() {\n\t    var decrementedSelected = addMinutes(selected, -minuteStep);\n\t    return decrementedSelected < min ||\n\t      (decrementedSelected > selected && decrementedSelected > max);\n\t  };\n\t\n\t  $scope.noToggleMeridian = function() {\n\t    if (selected.getHours() < 13) {\n\t      return addMinutes(selected, 12 * 60) > max;\n\t    } else {\n\t      return addMinutes(selected, -12 * 60) < min;\n\t    }\n\t  };\n\t\n\t  // 12H / 24H mode\n\t  $scope.showMeridian = timepickerConfig.showMeridian;\n\t  if ($attrs.showMeridian) {\n\t    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n\t      $scope.showMeridian = !!value;\n\t\n\t      if (ngModelCtrl.$error.time) {\n\t        // Evaluate from template\n\t        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n\t        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t          selected.setHours(hours);\n\t          refresh();\n\t        }\n\t      } else {\n\t        updateTemplate();\n\t      }\n\t    });\n\t  }\n\t\n\t  // Get $scope.hours in 24H mode if valid\n\t  function getHoursFromTemplate() {\n\t    var hours = parseInt($scope.hours, 10);\n\t    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n\t    if (!valid) {\n\t      return undefined;\n\t    }\n\t\n\t    if ($scope.showMeridian) {\n\t      if (hours === 12) {\n\t        hours = 0;\n\t      }\n\t      if ($scope.meridian === meridians[1]) {\n\t        hours = hours + 12;\n\t      }\n\t    }\n\t    return hours;\n\t  }\n\t\n\t  function getMinutesFromTemplate() {\n\t    var minutes = parseInt($scope.minutes, 10);\n\t    return (minutes >= 0 && minutes < 60) ? minutes : undefined;\n\t  }\n\t\n\t  function pad(value) {\n\t    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();\n\t  }\n\t\n\t  // Respond on mousewheel spin\n\t  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {\n\t    var isScrollingUp = function(e) {\n\t      if (e.originalEvent) {\n\t        e = e.originalEvent;\n\t      }\n\t      //pick correct delta variable depending on event\n\t      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n\t      return (e.detail || delta > 0);\n\t    };\n\t\n\t    hoursInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n\t      e.preventDefault();\n\t    });\n\t\n\t    minutesInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n\t      e.preventDefault();\n\t    });\n\t\n\t  };\n\t\n\t  // Respond on up/down arrowkeys\n\t  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {\n\t    hoursInputEl.bind('keydown', function(e) {\n\t      if (e.which === 38) { // up\n\t        e.preventDefault();\n\t        $scope.incrementHours();\n\t        $scope.$apply();\n\t      } else if (e.which === 40) { // down\n\t        e.preventDefault();\n\t        $scope.decrementHours();\n\t        $scope.$apply();\n\t      }\n\t    });\n\t\n\t    minutesInputEl.bind('keydown', function(e) {\n\t      if (e.which === 38) { // up\n\t        e.preventDefault();\n\t        $scope.incrementMinutes();\n\t        $scope.$apply();\n\t      } else if (e.which === 40) { // down\n\t        e.preventDefault();\n\t        $scope.decrementMinutes();\n\t        $scope.$apply();\n\t      }\n\t    });\n\t  };\n\t\n\t  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {\n\t    if ($scope.readonlyInput) {\n\t      $scope.updateHours = angular.noop;\n\t      $scope.updateMinutes = angular.noop;\n\t      return;\n\t    }\n\t\n\t    var invalidate = function(invalidHours, invalidMinutes) {\n\t      ngModelCtrl.$setViewValue(null);\n\t      ngModelCtrl.$setValidity('time', false);\n\t      if (angular.isDefined(invalidHours)) {\n\t        $scope.invalidHours = invalidHours;\n\t      }\n\t      if (angular.isDefined(invalidMinutes)) {\n\t        $scope.invalidMinutes = invalidMinutes;\n\t      }\n\t    };\n\t\n\t    $scope.updateHours = function() {\n\t      var hours = getHoursFromTemplate(),\n\t        minutes = getMinutesFromTemplate();\n\t\n\t      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t        selected.setHours(hours);\n\t        if (selected < min || selected > max) {\n\t          invalidate(true);\n\t        } else {\n\t          refresh('h');\n\t        }\n\t      } else {\n\t        invalidate(true);\n\t      }\n\t    };\n\t\n\t    hoursInputEl.bind('blur', function(e) {\n\t      if (!$scope.invalidHours && $scope.hours < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.hours = pad($scope.hours);\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateMinutes = function() {\n\t      var minutes = getMinutesFromTemplate(),\n\t        hours = getHoursFromTemplate();\n\t\n\t      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n\t        selected.setMinutes(minutes);\n\t        if (selected < min || selected > max) {\n\t          invalidate(undefined, true);\n\t        } else {\n\t          refresh('m');\n\t        }\n\t      } else {\n\t        invalidate(undefined, true);\n\t      }\n\t    };\n\t\n\t    minutesInputEl.bind('blur', function(e) {\n\t      if (!$scope.invalidMinutes && $scope.minutes < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.minutes = pad($scope.minutes);\n\t        });\n\t      }\n\t    });\n\t\n\t  };\n\t\n\t  this.render = function() {\n\t    var date = ngModelCtrl.$viewValue;\n\t\n\t    if (isNaN(date)) {\n\t      ngModelCtrl.$setValidity('time', false);\n\t      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t    } else {\n\t      if (date) {\n\t        selected = date;\n\t      }\n\t\n\t      if (selected < min || selected > max) {\n\t        ngModelCtrl.$setValidity('time', false);\n\t        $scope.invalidHours = true;\n\t        $scope.invalidMinutes = true;\n\t      } else {\n\t        makeValid();\n\t      }\n\t      updateTemplate();\n\t    }\n\t  };\n\t\n\t  // Call internally when we know that model is valid.\n\t  function refresh(keyboardChange) {\n\t    makeValid();\n\t    ngModelCtrl.$setViewValue(new Date(selected));\n\t    updateTemplate(keyboardChange);\n\t  }\n\t\n\t  function makeValid() {\n\t    ngModelCtrl.$setValidity('time', true);\n\t    $scope.invalidHours = false;\n\t    $scope.invalidMinutes = false;\n\t  }\n\t\n\t  function updateTemplate(keyboardChange) {\n\t    var hours = selected.getHours(), minutes = selected.getMinutes();\n\t\n\t    if ($scope.showMeridian) {\n\t      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system\n\t    }\n\t\n\t    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n\t    if (keyboardChange !== 'm') {\n\t      $scope.minutes = pad(minutes);\n\t    }\n\t    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t  }\n\t\n\t  function addMinutes(date, minutes) {\n\t    var dt = new Date(date.getTime() + minutes * 60000);\n\t    var newDate = new Date(date);\n\t    newDate.setHours(dt.getHours(), dt.getMinutes());\n\t    return newDate;\n\t  }\n\t\n\t  function addMinutesToSelected(minutes) {\n\t    selected = addMinutes(selected, minutes);\n\t    refresh();\n\t  }\n\t\n\t  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n\t    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\t\n\t  $scope.incrementHours = function() {\n\t    if (!$scope.noIncrementHours()) {\n\t      addMinutesToSelected(hourStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.decrementHours = function() {\n\t    if (!$scope.noDecrementHours()) {\n\t      addMinutesToSelected(-hourStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.incrementMinutes = function() {\n\t    if (!$scope.noIncrementMinutes()) {\n\t      addMinutesToSelected(minuteStep);\n\t    }\n\t  };\n\t\n\t  $scope.decrementMinutes = function() {\n\t    if (!$scope.noDecrementMinutes()) {\n\t      addMinutesToSelected(-minuteStep);\n\t    }\n\t  };\n\t\n\t  $scope.toggleMeridian = function() {\n\t    if (!$scope.noToggleMeridian()) {\n\t      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTimepicker', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['uibTimepicker', '?^ngModel'],\n\t    controller: 'UibTimepickerController',\n\t    controllerAs: 'timepicker',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (ngModelCtrl) {\n\t        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n\t      }\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated timepicker below */\n\t\n\tangular.module('ui.bootstrap.timepicker')\n\t\n\t.value('$timepickerSuppressWarning', false)\n\t\n\t.controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {\n\t  if (!$timepickerSuppressWarning) {\n\t    $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');\n\t  }\n\t\n\t  angular.extend(this, $controller('UibTimepickerController', {\n\t    $scope: $scope,\n\t    $element: $element,\n\t    $attrs: $attrs\n\t  }));\n\t}])\n\t\n\t.directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['timepicker', '?^ngModel'],\n\t    controller: 'TimepickerController',\n\t    controllerAs: 'timepicker',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$timepickerSuppressWarning) {\n\t        $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');\n\t      }\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (ngModelCtrl) {\n\t        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])\n\t\n\t/**\n\t * A helper service that can parse typeahead's syntax (string provided by users)\n\t * Extracted to a separate service for ease of unit testing\n\t */\n\t  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n\t    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n\t    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\t    return {\n\t      parse: function(input) {\n\t        var match = input.match(TYPEAHEAD_REGEXP);\n\t        if (!match) {\n\t          throw new Error(\n\t            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n\t              ' but got \"' + input + '\".');\n\t        }\n\t\n\t        return {\n\t          itemName: match[3],\n\t          source: $parse(match[4]),\n\t          viewMapper: $parse(match[2] || match[1]),\n\t          modelMapper: $parse(match[1])\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser',\n\t    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {\n\t    var HOT_KEYS = [9, 13, 27, 38, 40];\n\t    var eventDebounceTime = 200;\n\t    var modelCtrl, ngModelOptions;\n\t    //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t    //minimal no of characters that needs to be entered before typeahead kicks-in\n\t    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n\t    if (!minLength && minLength !== 0) {\n\t      minLength = 1;\n\t    }\n\t\n\t    //minimal wait time after last character typed before typeahead kicks-in\n\t    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t    //should it restrict model values to the ones selected from the popup only?\n\t    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t\n\t    //binding to a variable that indicates if matches are being retrieved asynchronously\n\t    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t    //a callback executed when a match is selected\n\t    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t    //should it select highlighted popup value when losing focus?\n\t    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\t\n\t    //binding to a variable that indicates if there were no results after the query is completed\n\t    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\t\n\t    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t    var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\t\n\t    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\t\n\t    //If input matches an item of the list exactly, select it automatically\n\t    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\t\n\t    //INTERNAL VARIABLES\n\t\n\t    //model setter executed upon match selection\n\t    var parsedModel = $parse(attrs.ngModel);\n\t    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n\t    var $setModelValue = function(scope, newValue) {\n\t      if (angular.isFunction(parsedModel(originalScope)) &&\n\t        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n\t        return invokeModelSetter(scope, {$$$p: newValue});\n\t      } else {\n\t        return parsedModel.assign(scope, newValue);\n\t      }\n\t    };\n\t\n\t    //expressions used by typeahead\n\t    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\t\n\t    var hasFocus;\n\t\n\t    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n\t    //mousedown & mouseup events\n\t    //Issue #3699\n\t    var selected;\n\t\n\t    //create a child scope for the typeahead directive so we are not polluting original scope\n\t    //with typeahead-specific data (matches, query etc.)\n\t    var scope = originalScope.$new();\n\t    var offDestroy = originalScope.$on('$destroy', function() {\n\t      scope.$destroy();\n\t    });\n\t    scope.$on('$destroy', offDestroy);\n\t\n\t    // WAI-ARIA\n\t    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t    element.attr({\n\t      'aria-autocomplete': 'list',\n\t      'aria-expanded': false,\n\t      'aria-owns': popupId\n\t    });\n\t\n\t    //pop-up element used to display matches\n\t    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n\t    popUpEl.attr({\n\t      id: popupId,\n\t      matches: 'matches',\n\t      active: 'activeIdx',\n\t      select: 'select(activeIdx)',\n\t      'move-in-progress': 'moveInProgress',\n\t      query: 'query',\n\t      position: 'position'\n\t    });\n\t    //custom item template\n\t    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t    }\n\t\n\t    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n\t      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n\t    }\n\t\n\t    var resetMatches = function() {\n\t      scope.matches = [];\n\t      scope.activeIdx = -1;\n\t      element.attr('aria-expanded', false);\n\t    };\n\t\n\t    var getMatchId = function(index) {\n\t      return popupId + '-option-' + index;\n\t    };\n\t\n\t    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t    // This attribute is added or removed automatically when the `activeIdx` changes.\n\t    scope.$watch('activeIdx', function(index) {\n\t      if (index < 0) {\n\t        element.removeAttr('aria-activedescendant');\n\t      } else {\n\t        element.attr('aria-activedescendant', getMatchId(index));\n\t      }\n\t    });\n\t\n\t    var inputIsExactMatch = function(inputValue, index) {\n\t      if (scope.matches.length > index && inputValue) {\n\t        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    var getMatchesAsync = function(inputValue) {\n\t      var locals = {$viewValue: inputValue};\n\t      isLoadingSetter(originalScope, true);\n\t      isNoResultsSetter(originalScope, false);\n\t      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t        //it might happen that several async queries were in progress if a user were typing fast\n\t        //but we are interested only in responses that correspond to the current view value\n\t        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n\t        if (onCurrentRequest && hasFocus) {\n\t          if (matches && matches.length > 0) {\n\t            scope.activeIdx = focusFirst ? 0 : -1;\n\t            isNoResultsSetter(originalScope, false);\n\t            scope.matches.length = 0;\n\t\n\t            //transform labels\n\t            for (var i = 0; i < matches.length; i++) {\n\t              locals[parserResult.itemName] = matches[i];\n\t              scope.matches.push({\n\t                id: getMatchId(i),\n\t                label: parserResult.viewMapper(scope, locals),\n\t                model: matches[i]\n\t              });\n\t            }\n\t\n\t            scope.query = inputValue;\n\t            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t            //due to other elements being rendered\n\t            recalculatePosition();\n\t\n\t            element.attr('aria-expanded', true);\n\t\n\t            //Select the single remaining option if user input matches\n\t            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n\t              scope.select(0);\n\t            }\n\t          } else {\n\t            resetMatches();\n\t            isNoResultsSetter(originalScope, true);\n\t          }\n\t        }\n\t        if (onCurrentRequest) {\n\t          isLoadingSetter(originalScope, false);\n\t        }\n\t      }, function() {\n\t        resetMatches();\n\t        isLoadingSetter(originalScope, false);\n\t        isNoResultsSetter(originalScope, true);\n\t      });\n\t    };\n\t\n\t    // bind events only if appendToBody params exist - performance feature\n\t    if (appendToBody) {\n\t      angular.element($window).bind('resize', fireRecalculating);\n\t      $document.find('body').bind('scroll', fireRecalculating);\n\t    }\n\t\n\t    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t    var timeoutEventPromise;\n\t\n\t    // Default progress type\n\t    scope.moveInProgress = false;\n\t\n\t    function fireRecalculating() {\n\t      if (!scope.moveInProgress) {\n\t        scope.moveInProgress = true;\n\t        scope.$digest();\n\t      }\n\t\n\t      // Cancel previous timeout\n\t      if (timeoutEventPromise) {\n\t        $timeout.cancel(timeoutEventPromise);\n\t      }\n\t\n\t      // Debounced executing recalculate after events fired\n\t      timeoutEventPromise = $timeout(function() {\n\t        // if popup is visible\n\t        if (scope.matches.length) {\n\t          recalculatePosition();\n\t        }\n\t\n\t        scope.moveInProgress = false;\n\t      }, eventDebounceTime);\n\t    }\n\t\n\t    // recalculate actual position and set new values to scope\n\t    // after digest loop is popup in right position\n\t    function recalculatePosition() {\n\t      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t      scope.position.top += element.prop('offsetHeight');\n\t    }\n\t\n\t    //we need to propagate user's query so we can higlight matches\n\t    scope.query = undefined;\n\t\n\t    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t    var timeoutPromise;\n\t\n\t    var scheduleSearchWithTimeout = function(inputValue) {\n\t      timeoutPromise = $timeout(function() {\n\t        getMatchesAsync(inputValue);\n\t      }, waitTime);\n\t    };\n\t\n\t    var cancelPreviousTimeout = function() {\n\t      if (timeoutPromise) {\n\t        $timeout.cancel(timeoutPromise);\n\t      }\n\t    };\n\t\n\t    resetMatches();\n\t\n\t    scope.select = function(activeIdx) {\n\t      //called from within the $digest() cycle\n\t      var locals = {};\n\t      var model, item;\n\t\n\t      selected = true;\n\t      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t      model = parserResult.modelMapper(originalScope, locals);\n\t      $setModelValue(originalScope, model);\n\t      modelCtrl.$setValidity('editable', true);\n\t      modelCtrl.$setValidity('parse', true);\n\t\n\t      onSelectCallback(originalScope, {\n\t        $item: item,\n\t        $model: model,\n\t        $label: parserResult.viewMapper(originalScope, locals)\n\t      });\n\t\n\t      resetMatches();\n\t\n\t      //return focus to the input element if a match was selected via a mouse click event\n\t      // use timeout to avoid $rootScope:inprog error\n\t      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n\t        $timeout(function() { element[0].focus(); }, 0, false);\n\t      }\n\t    };\n\t\n\t    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t    element.bind('keydown', function(evt) {\n\t      //typeahead is open and an \"interesting\" key was pressed\n\t      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t        return;\n\t      }\n\t\n\t      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n\t      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n\t        resetMatches();\n\t        scope.$digest();\n\t        return;\n\t      }\n\t\n\t      evt.preventDefault();\n\t\n\t      if (evt.which === 40) {\n\t        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t        scope.$digest();\n\t      } else if (evt.which === 38) {\n\t        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n\t        scope.$digest();\n\t      } else if (evt.which === 13 || evt.which === 9) {\n\t        scope.$apply(function () {\n\t          scope.select(scope.activeIdx);\n\t        });\n\t      } else if (evt.which === 27) {\n\t        evt.stopPropagation();\n\t\n\t        resetMatches();\n\t        scope.$digest();\n\t      }\n\t    });\n\t\n\t    element.bind('blur', function() {\n\t      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n\t        selected = true;\n\t        scope.$apply(function() {\n\t          scope.select(scope.activeIdx);\n\t        });\n\t      }\n\t      hasFocus = false;\n\t      selected = false;\n\t    });\n\t\n\t    // Keep reference to click handler to unbind it.\n\t    var dismissClickHandler = function(evt) {\n\t      // Issue #3973\n\t      // Firefox treats right click as a click on document\n\t      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n\t        resetMatches();\n\t        if (!$rootScope.$$phase) {\n\t          scope.$digest();\n\t        }\n\t      }\n\t    };\n\t\n\t    $document.bind('click', dismissClickHandler);\n\t\n\t    originalScope.$on('$destroy', function() {\n\t      $document.unbind('click', dismissClickHandler);\n\t      if (appendToBody || appendToElementId) {\n\t        $popup.remove();\n\t      }\n\t\n\t      if (appendToBody) {\n\t        angular.element($window).unbind('resize', fireRecalculating);\n\t        $document.find('body').unbind('scroll', fireRecalculating);\n\t      }\n\t      // Prevent jQuery cache memory leak\n\t      popUpEl.remove();\n\t    });\n\t\n\t    var $popup = $compile(popUpEl)(scope);\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else if (appendToElementId !== false) {\n\t      angular.element($document[0].getElementById(appendToElementId)).append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    this.init = function(_modelCtrl, _ngModelOptions) {\n\t      modelCtrl = _modelCtrl;\n\t      ngModelOptions = _ngModelOptions;\n\t\n\t      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t      modelCtrl.$parsers.unshift(function(inputValue) {\n\t        hasFocus = true;\n\t\n\t        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n\t          if (waitTime > 0) {\n\t            cancelPreviousTimeout();\n\t            scheduleSearchWithTimeout(inputValue);\n\t          } else {\n\t            getMatchesAsync(inputValue);\n\t          }\n\t        } else {\n\t          isLoadingSetter(originalScope, false);\n\t          cancelPreviousTimeout();\n\t          resetMatches();\n\t        }\n\t\n\t        if (isEditable) {\n\t          return inputValue;\n\t        } else {\n\t          if (!inputValue) {\n\t            // Reset in case user had typed something previously.\n\t            modelCtrl.$setValidity('editable', true);\n\t            return null;\n\t          } else {\n\t            modelCtrl.$setValidity('editable', false);\n\t            return undefined;\n\t          }\n\t        }\n\t      });\n\t\n\t      modelCtrl.$formatters.push(function(modelValue) {\n\t        var candidateViewValue, emptyViewValue;\n\t        var locals = {};\n\t\n\t        // The validity may be set to false via $parsers (see above) if\n\t        // the model is restricted to selected values. If the model\n\t        // is set manually it is considered to be valid.\n\t        if (!isEditable) {\n\t          modelCtrl.$setValidity('editable', true);\n\t        }\n\t\n\t        if (inputFormatter) {\n\t          locals.$model = modelValue;\n\t          return inputFormatter(originalScope, locals);\n\t        } else {\n\t          //it might happen that we don't have enough info to properly render input value\n\t          //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t          locals[parserResult.itemName] = modelValue;\n\t          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t          locals[parserResult.itemName] = undefined;\n\t          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n\t        }\n\t      });\n\t    };\n\t  }])\n\t\n\t  .directive('uibTypeahead', function() {\n\t    return {\n\t      controller: 'UibTypeaheadController',\n\t      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n\t      link: function(originalScope, element, attrs, ctrls) {\n\t        ctrls[2].init(ctrls[0], ctrls[1]);\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibTypeaheadPopup', function() {\n\t    return {\n\t      scope: {\n\t        matches: '=',\n\t        query: '=',\n\t        active: '=',\n\t        position: '&',\n\t        moveInProgress: '=',\n\t        select: '&'\n\t      },\n\t      replace: true,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function() {\n\t          return scope.matches.length > 0;\n\t        };\n\t\n\t        scope.isActive = function(matchIdx) {\n\t          return scope.active == matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function(matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function(activeIdx) {\n\t          scope.select({activeIdx:activeIdx});\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n\t    return {\n\t      scope: {\n\t        index: '=',\n\t        match: '=',\n\t        query: '='\n\t      },\n\t      link:function(scope, element, attrs) {\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n\t        $templateRequest(tplUrl).then(function(tplContent) {\n\t          $compile(tplContent.trim())(scope, function(clonedElement) {\n\t            element.replaceWith(clonedElement);\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n\t    var isSanitizePresent;\n\t    isSanitizePresent = $injector.has('$sanitize');\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      // Regex: capture the whole query string and replace it with the string that will be used to match\n\t      // the results, for example if the capture is \"a\" the result will be \\a\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    function containsHtml(matchItem) {\n\t      return /<.*>/g.test(matchItem);\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      if (!isSanitizePresent && containsHtml(matchItem)) {\n\t        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n\t      }\n\t      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n\t      if (!isSanitizePresent) {\n\t        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n\t      }\n\t      return matchItem;\n\t    };\n\t  }]);\n\t\n\t/* Deprecated typeahead below */\n\t  \n\tangular.module('ui.bootstrap.typeahead')\n\t  .value('$typeaheadSuppressWarning', false)\n\t  .service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {\n\t    if (!$typeaheadSuppressWarning) {\n\t      $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');\n\t    }\n\t\n\t    return uibTypeaheadParser;\n\t  }])\n\t\n\t  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning',\n\t    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {\n\t    var HOT_KEYS = [9, 13, 27, 38, 40];\n\t    var eventDebounceTime = 200;\n\t    return {\n\t      require: ['ngModel', '^?ngModelOptions'],\n\t      link: function(originalScope, element, attrs, ctrls) {\n\t        if (!$typeaheadSuppressWarning) {\n\t          $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');\n\t        }\n\t        var modelCtrl = ctrls[0];\n\t        var ngModelOptions = ctrls[1];\n\t        //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t        //minimal no of characters that needs to be entered before typeahead kicks-in\n\t        var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n\t        if (!minLength && minLength !== 0) {\n\t          minLength = 1;\n\t        }\n\t\n\t        //minimal wait time after last character typed before typeahead kicks-in\n\t        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t        //should it restrict model values to the ones selected from the popup only?\n\t        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t\n\t        //binding to a variable that indicates if matches are being retrieved asynchronously\n\t        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t        //a callback executed when a match is selected\n\t        var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t        //should it select highlighted popup value when losing focus?\n\t        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\t\n\t        //binding to a variable that indicates if there were no results after the query is completed\n\t        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\t\n\t        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t        var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\t\n\t        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\t\n\t        //If input matches an item of the list exactly, select it automatically\n\t        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\t\n\t        //INTERNAL VARIABLES\n\t\n\t        //model setter executed upon match selection\n\t        var parsedModel = $parse(attrs.ngModel);\n\t        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n\t        var $setModelValue = function(scope, newValue) {\n\t          if (angular.isFunction(parsedModel(originalScope)) &&\n\t            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n\t            return invokeModelSetter(scope, {$$$p: newValue});\n\t          } else {\n\t            return parsedModel.assign(scope, newValue);\n\t          }\n\t        };\n\t\n\t        //expressions used by typeahead\n\t        var parserResult = typeaheadParser.parse(attrs.typeahead);\n\t\n\t        var hasFocus;\n\t\n\t        //Used to avoid bug in iOS webview where iOS keyboard does not fire\n\t        //mousedown & mouseup events\n\t        //Issue #3699\n\t        var selected;\n\t\n\t        //create a child scope for the typeahead directive so we are not polluting original scope\n\t        //with typeahead-specific data (matches, query etc.)\n\t        var scope = originalScope.$new();\n\t        var offDestroy = originalScope.$on('$destroy', function() {\n\t\t\t\t    scope.$destroy();\n\t        });\n\t        scope.$on('$destroy', offDestroy);\n\t\n\t        // WAI-ARIA\n\t        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t        element.attr({\n\t          'aria-autocomplete': 'list',\n\t          'aria-expanded': false,\n\t          'aria-owns': popupId\n\t        });\n\t\n\t        //pop-up element used to display matches\n\t        var popUpEl = angular.element('<div typeahead-popup></div>');\n\t        popUpEl.attr({\n\t          id: popupId,\n\t          matches: 'matches',\n\t          active: 'activeIdx',\n\t          select: 'select(activeIdx)',\n\t          'move-in-progress': 'moveInProgress',\n\t          query: 'query',\n\t          position: 'position'\n\t        });\n\t        //custom item template\n\t        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t        }\n\t\n\t        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n\t          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n\t        }\n\t\n\t        var resetMatches = function() {\n\t          scope.matches = [];\n\t          scope.activeIdx = -1;\n\t          element.attr('aria-expanded', false);\n\t        };\n\t\n\t        var getMatchId = function(index) {\n\t          return popupId + '-option-' + index;\n\t        };\n\t\n\t        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t        // This attribute is added or removed automatically when the `activeIdx` changes.\n\t        scope.$watch('activeIdx', function(index) {\n\t          if (index < 0) {\n\t            element.removeAttr('aria-activedescendant');\n\t          } else {\n\t            element.attr('aria-activedescendant', getMatchId(index));\n\t          }\n\t        });\n\t\n\t        var inputIsExactMatch = function(inputValue, index) {\n\t          if (scope.matches.length > index && inputValue) {\n\t            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n\t          }\n\t\n\t          return false;\n\t        };\n\t\n\t        var getMatchesAsync = function(inputValue) {\n\t          var locals = {$viewValue: inputValue};\n\t          isLoadingSetter(originalScope, true);\n\t          isNoResultsSetter(originalScope, false);\n\t          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t            //it might happen that several async queries were in progress if a user were typing fast\n\t            //but we are interested only in responses that correspond to the current view value\n\t            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n\t            if (onCurrentRequest && hasFocus) {\n\t              if (matches && matches.length > 0) {\n\t                scope.activeIdx = focusFirst ? 0 : -1;\n\t                isNoResultsSetter(originalScope, false);\n\t                scope.matches.length = 0;\n\t\n\t                //transform labels\n\t                for (var i = 0; i < matches.length; i++) {\n\t                  locals[parserResult.itemName] = matches[i];\n\t                  scope.matches.push({\n\t                    id: getMatchId(i),\n\t                    label: parserResult.viewMapper(scope, locals),\n\t                    model: matches[i]\n\t                  });\n\t                }\n\t\n\t                scope.query = inputValue;\n\t                //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t                //due to other elements being rendered\n\t                recalculatePosition();\n\t\n\t                element.attr('aria-expanded', true);\n\t\n\t                //Select the single remaining option if user input matches\n\t                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n\t                  scope.select(0);\n\t                }\n\t              } else {\n\t                resetMatches();\n\t                isNoResultsSetter(originalScope, true);\n\t              }\n\t            }\n\t            if (onCurrentRequest) {\n\t              isLoadingSetter(originalScope, false);\n\t            }\n\t          }, function() {\n\t            resetMatches();\n\t            isLoadingSetter(originalScope, false);\n\t            isNoResultsSetter(originalScope, true);\n\t          });\n\t        };\n\t\n\t        // bind events only if appendToBody params exist - performance feature\n\t        if (appendToBody) {\n\t          angular.element($window).bind('resize', fireRecalculating);\n\t          $document.find('body').bind('scroll', fireRecalculating);\n\t        }\n\t\n\t        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t        var timeoutEventPromise;\n\t\n\t        // Default progress type\n\t        scope.moveInProgress = false;\n\t\n\t        function fireRecalculating() {\n\t          if (!scope.moveInProgress) {\n\t            scope.moveInProgress = true;\n\t            scope.$digest();\n\t          }\n\t\n\t          // Cancel previous timeout\n\t          if (timeoutEventPromise) {\n\t            $timeout.cancel(timeoutEventPromise);\n\t          }\n\t\n\t          // Debounced executing recalculate after events fired\n\t          timeoutEventPromise = $timeout(function() {\n\t            // if popup is visible\n\t            if (scope.matches.length) {\n\t              recalculatePosition();\n\t            }\n\t\n\t            scope.moveInProgress = false;\n\t          }, eventDebounceTime);\n\t        }\n\t\n\t        // recalculate actual position and set new values to scope\n\t        // after digest loop is popup in right position\n\t        function recalculatePosition() {\n\t          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t          scope.position.top += element.prop('offsetHeight');\n\t        }\n\t\n\t        resetMatches();\n\t\n\t        //we need to propagate user's query so we can higlight matches\n\t        scope.query = undefined;\n\t\n\t        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t        var timeoutPromise;\n\t\n\t        var scheduleSearchWithTimeout = function(inputValue) {\n\t          timeoutPromise = $timeout(function() {\n\t            getMatchesAsync(inputValue);\n\t          }, waitTime);\n\t        };\n\t\n\t        var cancelPreviousTimeout = function() {\n\t          if (timeoutPromise) {\n\t            $timeout.cancel(timeoutPromise);\n\t          }\n\t        };\n\t\n\t        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t        modelCtrl.$parsers.unshift(function(inputValue) {\n\t          hasFocus = true;\n\t\n\t          if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n\t            if (waitTime > 0) {\n\t              cancelPreviousTimeout();\n\t              scheduleSearchWithTimeout(inputValue);\n\t            } else {\n\t              getMatchesAsync(inputValue);\n\t            }\n\t          } else {\n\t            isLoadingSetter(originalScope, false);\n\t            cancelPreviousTimeout();\n\t            resetMatches();\n\t          }\n\t\n\t          if (isEditable) {\n\t            return inputValue;\n\t          } else {\n\t            if (!inputValue) {\n\t              // Reset in case user had typed something previously.\n\t              modelCtrl.$setValidity('editable', true);\n\t              return null;\n\t            } else {\n\t              modelCtrl.$setValidity('editable', false);\n\t              return undefined;\n\t            }\n\t          }\n\t        });\n\t\n\t        modelCtrl.$formatters.push(function(modelValue) {\n\t          var candidateViewValue, emptyViewValue;\n\t          var locals = {};\n\t\n\t          // The validity may be set to false via $parsers (see above) if\n\t          // the model is restricted to selected values. If the model\n\t          // is set manually it is considered to be valid.\n\t          if (!isEditable) {\n\t            modelCtrl.$setValidity('editable', true);\n\t          }\n\t\n\t          if (inputFormatter) {\n\t            locals.$model = modelValue;\n\t            return inputFormatter(originalScope, locals);\n\t          } else {\n\t            //it might happen that we don't have enough info to properly render input value\n\t            //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t            locals[parserResult.itemName] = modelValue;\n\t            candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t            locals[parserResult.itemName] = undefined;\n\t            emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n\t          }\n\t        });\n\t\n\t        scope.select = function(activeIdx) {\n\t          //called from within the $digest() cycle\n\t          var locals = {};\n\t          var model, item;\n\t\n\t          selected = true;\n\t          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t          model = parserResult.modelMapper(originalScope, locals);\n\t          $setModelValue(originalScope, model);\n\t          modelCtrl.$setValidity('editable', true);\n\t          modelCtrl.$setValidity('parse', true);\n\t\n\t          onSelectCallback(originalScope, {\n\t            $item: item,\n\t            $model: model,\n\t            $label: parserResult.viewMapper(originalScope, locals)\n\t          });\n\t\n\t          resetMatches();\n\t\n\t          //return focus to the input element if a match was selected via a mouse click event\n\t          // use timeout to avoid $rootScope:inprog error\n\t          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n\t            $timeout(function() { element[0].focus(); }, 0, false);\n\t          }\n\t        };\n\t\n\t        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t        element.bind('keydown', function(evt) {\n\t          //typeahead is open and an \"interesting\" key was pressed\n\t          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t            return;\n\t          }\n\t\n\t          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n\t          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n\t            resetMatches();\n\t            scope.$digest();\n\t            return;\n\t          }\n\t\n\t          evt.preventDefault();\n\t\n\t          if (evt.which === 40) {\n\t            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t            scope.$digest();\n\t          } else if (evt.which === 38) {\n\t            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n\t            scope.$digest();\n\t          } else if (evt.which === 13 || evt.which === 9) {\n\t            scope.$apply(function () {\n\t              scope.select(scope.activeIdx);\n\t            });\n\t          } else if (evt.which === 27) {\n\t            evt.stopPropagation();\n\t\n\t            resetMatches();\n\t            scope.$digest();\n\t          }\n\t        });\n\t\n\t        element.bind('blur', function() {\n\t          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n\t            selected = true;\n\t            scope.$apply(function() {\n\t              scope.select(scope.activeIdx);\n\t            });\n\t          }\n\t          hasFocus = false;\n\t          selected = false;\n\t        });\n\t\n\t        // Keep reference to click handler to unbind it.\n\t        var dismissClickHandler = function(evt) {\n\t          // Issue #3973\n\t          // Firefox treats right click as a click on document\n\t          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n\t            resetMatches();\n\t            if (!$rootScope.$$phase) {\n\t              scope.$digest();\n\t            }\n\t          }\n\t        };\n\t\n\t        $document.bind('click', dismissClickHandler);\n\t\n\t        originalScope.$on('$destroy', function() {\n\t          $document.unbind('click', dismissClickHandler);\n\t          if (appendToBody || appendToElementId) {\n\t            $popup.remove();\n\t          }\n\t\n\t          if (appendToBody) {\n\t            angular.element($window).unbind('resize', fireRecalculating);\n\t            $document.find('body').unbind('scroll', fireRecalculating);\n\t          }\n\t          // Prevent jQuery cache memory leak\n\t          popUpEl.remove();\n\t        });\n\t\n\t        var $popup = $compile(popUpEl)(scope);\n\t\n\t        if (appendToBody) {\n\t          $document.find('body').append($popup);\n\t        } else if (appendToElementId !== false) {\n\t          angular.element($document[0].getElementById(appendToElementId)).append($popup);\n\t        } else {\n\t          element.after($popup);\n\t        }\n\t      }\n\t    };\n\t  }])\n\t  \n\t  .directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {\n\t    return {\n\t      scope: {\n\t        matches: '=',\n\t        query: '=',\n\t        active: '=',\n\t        position: '&',\n\t        moveInProgress: '=',\n\t        select: '&'\n\t      },\n\t      replace: true,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        \n\t        if (!$typeaheadSuppressWarning) {\n\t          $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');\n\t        }\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function() {\n\t          return scope.matches.length > 0;\n\t        };\n\t\n\t        scope.isActive = function(matchIdx) {\n\t          return scope.active == matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function(matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function(activeIdx) {\n\t          scope.select({activeIdx:activeIdx});\n\t        };\n\t      }\n\t    };\n\t  }])\n\t  \n\t  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {\n\t    return {\n\t      restrict: 'EA',\n\t      scope: {\n\t        index: '=',\n\t        match: '=',\n\t        query: '='\n\t      },\n\t      link:function(scope, element, attrs) {\n\t        if (!$typeaheadSuppressWarning) {\n\t          $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');\n\t        }\n\t\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n\t        $templateRequest(tplUrl).then(function(tplContent) {\n\t          $compile(tplContent.trim())(scope, function(clonedElement) {\n\t            element.replaceWith(clonedElement);\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }])\n\t  \n\t  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {\n\t    var isSanitizePresent;\n\t    isSanitizePresent = $injector.has('$sanitize');\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      // Regex: capture the whole query string and replace it with the string that will be used to match\n\t      // the results, for example if the capture is \"a\" the result will be \\a\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    function containsHtml(matchItem) {\n\t      return /<.*>/g.test(matchItem);\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      if (!$typeaheadSuppressWarning) {\n\t        $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');\n\t      }\n\t\n\t      if (!isSanitizePresent && containsHtml(matchItem)) {\n\t        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n\t      }\n\t\n\t      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n\t      if (!isSanitizePresent) {\n\t        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n\t      }\n\t\n\t      return matchItem;\n\t    };\n\t  }]);\n\t\n\tangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/accordion/accordion-group.html\",\n\t    \"<div class=\\\"panel {{panelClass || 'panel-default'}}\\\">\\n\" +\n\t    \"  <div class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n\t    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n\t    \"      <a href tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n\t    \"    </h4>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"  <div class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n\t    \"\t  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/accordion/accordion.html\",\n\t    \"<div class=\\\"panel-group\\\" ng-transclude></div>\");\n\t}]);\n\t\n\tangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/alert/alert.html\",\n\t    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n\t    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n\t    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n\t    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n\t    \"    </button>\\n\" +\n\t    \"    <div ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/carousel/carousel.html\",\n\t    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n\t    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n\t    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"  </ol>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/carousel/slide.html\",\n\t    \"<div ng-class=\\\"{\\n\" +\n\t    \"    'active': active\\n\" +\n\t    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/datepicker.html\",\n\t    \"<div ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n\t    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n\t    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n\t    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/day.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n\t    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default btn-sm\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/month.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" dropdown-nested ng-if=\\\"isOpen\\\" style=\\\"display: block\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n\t    \"\t<li ng-transclude></li>\\n\" +\n\t    \"\t<li ng-if=\\\"showButtonBar\\\" style=\\\"padding:10px 9px 2px\\\">\\n\" +\n\t    \"\t\t<span class=\\\"btn-group pull-left\\\">\\n\" +\n\t    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-info\\\" ng-click=\\\"select('today')\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n\t    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n\t    \"\t\t</span>\\n\" +\n\t    \"\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n\t    \"\t</li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/year.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"3\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/modal/backdrop.html\",\n\t    \"<div uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"     modal-in-class=\\\"in\\\"\\n\" +\n\t    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n\t    \"></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/modal/window.html\",\n\t    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n\t    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"    modal-in-class=\\\"in\\\"\\n\" +\n\t    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n\t    \"    <div class=\\\"modal-dialog\\\" ng-class=\\\"size ? 'modal-' + size : ''\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/pagination/pager.html\",\n\t    \"<ul class=\\\"pager\\\">\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/pagination/pagination.html\",\n\t    \"<ul class=\\\"pagination\\\">\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-html-popup.html\",\n\t    \"<div\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\n\t    \"<div\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-template-popup.html\",\n\t    \"<div\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n\t    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover-html.html\",\n\t    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover-template.html\",\n\t    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\"\\n\" +\n\t    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover.html\",\n\t    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/bar.html\",\n\t    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/progress.html\",\n\t    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/progressbar.html\",\n\t    \"<div class=\\\"progress\\\">\\n\" +\n\t    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/rating/rating.html\",\n\t    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n\t    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n\t    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n\t    \"</span>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tabs/tab.html\",\n\t    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\">\\n\" +\n\t    \"  <a href ng-click=\\\"select()\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n\t    \"</li>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tabs/tabset.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n\t    \"  <div class=\\\"tab-content\\\">\\n\" +\n\t    \"    <div class=\\\"tab-pane\\\" \\n\" +\n\t    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n\t    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n\t    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n\t    \"    </div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/timepicker/timepicker.html\",\n\t    \"<table>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td>:</td>\\n\" +\n\t    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/typeahead/typeahead-match.html\",\n\t    \"<a href tabindex=\\\"-1\\\" ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"></a>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/typeahead/typeahead-popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" style=\\\"display: block;\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n\t    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t!angular.$$csp() && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendors.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t2:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".app.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap af4f9cc29930c1488753\n **/","module.exports = angular;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 3\n ** module chunks = 2\n **/","//! api-check version 7.5.5 built with  by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) ( _)==(_ )\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"apiCheck\"] = factory();\n\telse\n\t\troot[\"apiCheck\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _apiCheck = __webpack_require__(1);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = _apiCheck2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\tvar apiCheckUtil = __webpack_require__(3);\n\tvar each = apiCheckUtil.each;\n\tvar isError = apiCheckUtil.isError;\n\tvar t = apiCheckUtil.t;\n\tvar arrayify = apiCheckUtil.arrayify;\n\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\tvar typeOf = apiCheckUtil.typeOf;\n\tvar getError = apiCheckUtil.getError;\n\n\tvar checkers = __webpack_require__(4);\n\tvar apiCheckApis = getApiCheckApis();\n\n\tmodule.exports = getApiCheckInstance;\n\tmodule.exports.VERSION = (\"7.5.5\");\n\tmodule.exports.utils = apiCheckUtil;\n\tmodule.exports.globalConfig = {\n\t  verbose: false,\n\t  disabled: false\n\t};\n\n\tvar apiCheckApiCheck = getApiCheckInstance({\n\t  output: { prefix: 'apiCheck' }\n\t});\n\tmodule.exports.internalChecker = apiCheckApiCheck;\n\n\teach(checkers, function (checker, name) {\n\t  return module.exports[name] = checker;\n\t});\n\n\tfunction getApiCheckInstance() {\n\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t  /* eslint complexity:[2, 6] */\n\t  if (apiCheckApiCheck && arguments.length) {\n\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t      prefix: 'creating an apiCheck instance'\n\t    });\n\t  }\n\n\t  var additionalProperties = {\n\t    'throw': getApiCheck(true),\n\t    warn: getApiCheck(false),\n\t    getErrorMessage: getErrorMessage,\n\t    handleErrorMessage: handleErrorMessage,\n\t    config: {\n\t      output: config.output || {\n\t        prefix: '',\n\t        suffix: '',\n\t        docsBaseUrl: ''\n\t      },\n\t      verbose: config.verbose || false,\n\t      disabled: config.disabled || false\n\t    },\n\t    utils: apiCheckUtil\n\t  };\n\n\t  each(additionalProperties, function (wrapper, name) {\n\t    return apiCheck[name] = wrapper;\n\t  });\n\n\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\t  each(extraCheckers, function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\n\t  return apiCheck;\n\n\t  /**\n\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t   * @param {Array} api - the checkers to check with\n\t   * @param {Array} args - the args to check\n\t   * @param {Object} output - output options\n\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t   */\n\t  function apiCheck(api, args, output) {\n\t    /* eslint complexity:[2, 8] */\n\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t      return {\n\t        apiTypes: {}, argTypes: {},\n\t        passed: true, message: '',\n\t        failed: false\n\t      }; // empty version of what is normally returned\n\t    }\n\t    checkApiCheckApi(arguments);\n\t    if (!Array.isArray(api)) {\n\t      api = [api];\n\t      args = [args];\n\t    } else {\n\t      // turn arguments into an array\n\t      args = Array.prototype.slice.call(args);\n\t    }\n\t    var messages = checkEnoughArgs(api, args);\n\t    if (!messages.length) {\n\t      // this is where we actually go perform the checks.\n\t      messages = checkApiWithArgs(api, args);\n\t    }\n\n\t    var returnObject = getTypes(api, args);\n\t    returnObject.args = args;\n\t    if (messages.length) {\n\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t      returnObject.failed = true;\n\t      returnObject.passed = false;\n\t    } else {\n\t      returnObject.message = '';\n\t      returnObject.failed = false;\n\t      returnObject.passed = true;\n\t    }\n\t    return returnObject;\n\t  }\n\n\t  /**\n\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t   */\n\t  function checkApiCheckApi(checkApiArgs) {\n\t    var api = checkApiArgs[0];\n\t    var args = checkApiArgs[1];\n\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\n\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t    }\n\t    // dog fooding here\n\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t    if (errors.length) {\n\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t        prefix: 'apiCheck'\n\t      });\n\t      apiCheck.handleErrorMessage(message, true);\n\t    }\n\t  }\n\n\t  function getApiCheck(shouldThrow) {\n\t    return function apiCheckWrapper(api, args, output) {\n\t      var result = apiCheck(api, args, output);\n\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t      return result; // wont get here if an error is thrown\n\t    };\n\t  }\n\n\t  function handleErrorMessage(message, shouldThrow) {\n\t    if (shouldThrow && message) {\n\t      throw new Error(message);\n\t    } else if (message) {\n\t      /* eslint no-console:0 */\n\t      console.warn(message);\n\t    }\n\t  }\n\n\t  function getErrorMessage(api, args) {\n\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n\t    var gOut = apiCheck.config.output || {};\n\t    var prefix = getPrefix();\n\t    var suffix = getSuffix();\n\t    var url = getUrl();\n\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\n\t    function getPrefix() {\n\t      var p = output.onlyPrefix;\n\t      if (!p) {\n\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t      }\n\t      return p;\n\t    }\n\n\t    function getSuffix() {\n\t      var s = output.onlySuffix;\n\t      if (!s) {\n\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t      }\n\t      return s;\n\t    }\n\n\t    function getUrl() {\n\t      var u = output.url;\n\t      if (!u) {\n\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t      }\n\t      return u;\n\t    }\n\t  }\n\n\t  function buildMessageFromApiAndArgs(api, args) {\n\t    var _getTypes = getTypes(api, args);\n\n\t    var apiTypes = _getTypes.apiTypes;\n\t    var argTypes = _getTypes.argTypes;\n\n\t    var copy = Array.prototype.slice.call(args || []);\n\t    var replacedItems = [];\n\t    replaceFunctionWithName(copy);\n\t    var passedArgs = getObjectString(copy);\n\t    argTypes = getObjectString(argTypes);\n\t    apiTypes = getObjectString(apiTypes);\n\n\t    return generateMessage();\n\n\t    // functions\n\n\t    function replaceFunctionWithName(obj) {\n\t      each(obj, function (val, name) {\n\t        /* eslint complexity:[2, 6] */\n\t        if (replacedItems.indexOf(val) === -1) {\n\t          // avoid recursive problems\n\t          replacedItems.push(val);\n\t          if (typeof val === 'object') {\n\t            replaceFunctionWithName(obj);\n\t          } else if (typeof val === 'function') {\n\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t          }\n\t        }\n\t      });\n\t    }\n\n\t    function getObjectString(types) {\n\t      if (!types || !types.length) {\n\t        return 'nothing';\n\t      } else if (types && types.length === 1) {\n\t        types = types[0];\n\t      }\n\t      return stringify(types, null, 2);\n\t    }\n\n\t    function generateMessage() {\n\t      var n = '\\n';\n\t      var useS = true;\n\t      if (args && args.length === 1) {\n\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t          useS = !!Object.keys(args[0]).length;\n\t        } else {\n\t          useS = false;\n\t        }\n\t      }\n\t      var types = 'type' + (useS ? 's' : '');\n\t      var newLine = n + n;\n\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t    }\n\t  }\n\n\t  function getTypes(api, args) {\n\t    api = arrayify(api);\n\t    args = arrayify(args);\n\t    var apiTypes = api.map(function (checker, index) {\n\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t      return getCheckerDisplay(checker, {\n\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t        obj: args[index],\n\t        addHelpers: true\n\t      });\n\t    });\n\t    var argTypes = args.map(function (arg) {\n\t      return getArgDisplay(arg, []);\n\t    });\n\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t  }\n\t}\n\n\t// STATELESS FUNCTIONS\n\n\t/**\n\t * This is where the magic happens for actually checking the arguments with the api.\n\t * @param {Array} api - checkers\n\t * @param  {Array} args - and arguments object\n\t * @returns {Array} - the error messages\n\t */\n\tfunction checkApiWithArgs(api, args) {\n\t  /* eslint complexity:[2, 7] */\n\t  var messages = [];\n\t  var failed = false;\n\t  var checkerIndex = 0;\n\t  var argIndex = 0;\n\t  var arg = undefined,\n\t      checker = undefined,\n\t      res = undefined,\n\t      lastChecker = undefined,\n\t      argName = undefined,\n\t      argFailed = undefined,\n\t      skipPreviousChecker = undefined;\n\t  /* jshint -W084 */\n\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t    arg = args[argIndex++];\n\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t    res = checker(arg, 'value', argName);\n\t    argFailed = isError(res);\n\t    lastChecker = checkerIndex >= api.length;\n\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t      failed = true;\n\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t    } else if (argFailed && checker.isOptional) {\n\t      argIndex--;\n\t    } else {\n\t      messages.push(t(argName) + ' passed');\n\t    }\n\t  }\n\t  return failed ? messages : [];\n\t}\n\n\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\tfunction checkerTypeType(checkerType, name, location) {\n\t  var apiCheckDataChecker = checkers.shape({\n\t    type: checkers.string,\n\t    optional: checkers.bool\n\t  });\n\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t  if (isError(wrongShape)) {\n\t    return wrongShape;\n\t  }\n\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t    return getError(name, location, checkerTypeType.type);\n\t  }\n\t}\n\n\tfunction getCheckerErrorMessage(res, checker, val) {\n\t  var checkerHelp = getCheckerHelp(checker, val);\n\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t  return res.message + checkerHelp;\n\t}\n\n\tfunction getCheckerHelp(_ref, val) {\n\t  var help = _ref.help;\n\n\t  if (!help) {\n\t    return '';\n\t  }\n\t  if (typeof help === 'function') {\n\t    help = help(val);\n\t  }\n\t  return help;\n\t}\n\n\tfunction checkEnoughArgs(api, args) {\n\t  var requiredArgs = api.filter(function (a) {\n\t    return !a.isOptional;\n\t  });\n\t  if (args.length < requiredArgs.length) {\n\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t  } else {\n\t    return [];\n\t  }\n\t}\n\n\tfunction getArgDisplay(arg, gottenArgs) {\n\t  /* eslint complexity:[2, 7] */\n\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t  var type = typeOf(arg);\n\t  if (type === 'function') {\n\t    if (hasKeys()) {\n\t      var properties = stringify(getDisplayIfNotGotten());\n\t      return cName + ' (with properties: ' + properties + ')';\n\t    }\n\t    return cName;\n\t  }\n\n\t  if (arg === null) {\n\t    return 'null';\n\t  }\n\n\t  if (type !== 'array' && type !== 'object') {\n\t    return type;\n\t  }\n\n\t  if (hasKeys()) {\n\t    return getDisplayIfNotGotten();\n\t  }\n\n\t  return cName;\n\n\t  // utility functions\n\t  function hasKeys() {\n\t    return arg && Object.keys(arg).length;\n\t  }\n\n\t  function getDisplayIfNotGotten() {\n\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t      return '[Circular]';\n\t    }\n\t    gottenArgs.push(arg);\n\t    return getDisplay(arg, gottenArgs);\n\t  }\n\t}\n\n\tfunction getDisplay(obj, gottenArgs) {\n\t  var argDisplay = {};\n\t  each(obj, function (v, k) {\n\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t  });\n\t  return argDisplay;\n\t}\n\n\tfunction getApiCheckApis() {\n\t  var os = checkers.string.optional;\n\n\t  var checkerFnChecker = checkers.func.withProperties({\n\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t    displayName: checkers.string.optional,\n\t    shortType: checkers.string.optional,\n\t    notOptional: checkers.bool.optional,\n\t    notRequired: checkers.bool.optional\n\t  });\n\n\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t    output: checkers.shape({\n\t      prefix: checkers.string.optional,\n\t      suffix: checkers.string.optional,\n\t      docsBaseUrl: checkers.string.optional\n\t    }).strict.optional,\n\t    verbose: checkers.bool.optional,\n\t    disabled: checkers.bool.optional\n\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\n\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t  }).strict.optional];\n\n\t  return {\n\t    checkerFnChecker: checkerFnChecker,\n\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t    checkApiCheckApi: checkApiCheckApi\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = stringify;\n\n\tfunction getSerialize (fn, decycle) {\n\t  var seen = [], keys = [];\n\t  decycle = decycle || function(key, value) {\n\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t  };\n\t  return function(key, value) {\n\t    var ret = value;\n\t    if (typeof value === 'object' && value) {\n\t      if (seen.indexOf(value) !== -1)\n\t        ret = decycle(key, value);\n\t      else {\n\t        seen.push(value);\n\t        keys.push(key);\n\t      }\n\t    }\n\t    if (fn) ret = fn(key, ret);\n\t    return ret;\n\t  }\n\t}\n\n\tfunction getPath (value, seen, keys) {\n\t  var index = seen.indexOf(value);\n\t  var path = [ keys[index] ];\n\t  for (index--; index >= 0; index--) {\n\t    if (seen[index][ path[0] ] === value) {\n\t      value = seen[index];\n\t      path.unshift(keys[index]);\n\t    }\n\t  }\n\t  return '~' + path.join('.');\n\t}\n\n\tfunction stringify(obj, fn, spaces, decycle) {\n\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t}\n\n\tstringify.getSerialize = getSerialize;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\tvar stringify = __webpack_require__(2);\n\tvar checkerHelpers = {\n\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t};\n\n\tmodule.exports = {\n\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t  noop: noop\n\t};\n\n\tfunction copy(obj) {\n\t  var type = typeOf(obj);\n\t  var daCopy = undefined;\n\t  if (type === 'array') {\n\t    daCopy = [];\n\t  } else if (type === 'object') {\n\t    daCopy = {};\n\t  } else {\n\t    return obj;\n\t  }\n\t  each(obj, function (val, key) {\n\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t  });\n\t  return daCopy;\n\t}\n\n\tfunction typeOf(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return 'array';\n\t  } else if (obj instanceof RegExp) {\n\t    return 'object';\n\t  } else {\n\t    return typeof obj;\n\t  }\n\t}\n\n\tfunction getCheckerDisplay(checker, options) {\n\t  /* eslint complexity:[2, 7] */\n\t  var display = undefined;\n\t  var short = options && options.short;\n\t  if (short && checker.shortType) {\n\t    display = checker.shortType;\n\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t    display = getCheckerType(checker, options);\n\t  } else {\n\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t  }\n\t  return display;\n\t}\n\n\tfunction getCheckerType(_ref, options) {\n\t  var type = _ref.type;\n\n\t  if (typeof type === 'function') {\n\t    var __apiCheckData = type.__apiCheckData;\n\t    var typeTypes = type(options);\n\t    type = _defineProperty({\n\t      __apiCheckData: __apiCheckData\n\t    }, __apiCheckData.type, typeTypes);\n\t  }\n\t  return type;\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (!obj) {\n\t    return [];\n\t  } else if (Array.isArray(obj)) {\n\t    return obj;\n\t  } else {\n\t    return [obj];\n\t  }\n\t}\n\n\tfunction each(obj, iterator, context) {\n\t  if (Array.isArray(obj)) {\n\t    return eachArry(obj, iterator, context);\n\t  } else {\n\t    return eachObj(obj, iterator, context);\n\t  }\n\t}\n\n\tfunction eachObj(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t  for (var key in obj) {\n\t    if (hasOwn.call(obj, key)) {\n\t      ret = iterator.call(context, obj[key], key, obj);\n\t      if (ret === false) {\n\t        return ret;\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction eachArry(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var length = obj.length;\n\t  for (var i = 0; i < length; i++) {\n\t    ret = iterator.call(context, obj[i], i, obj);\n\t    if (ret === false) {\n\t      return ret;\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction isError(obj) {\n\t  return obj instanceof Error;\n\t}\n\n\tfunction list(arry, join, finalJoin) {\n\t  arry = arrayify(arry);\n\t  var copy = arry.slice();\n\t  var last = copy.pop();\n\t  if (copy.length === 1) {\n\t    join = ' ';\n\t  }\n\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t}\n\n\tfunction getError(name, location, checkerType) {\n\t  if (typeof checkerType === 'function') {\n\t    checkerType = checkerType({ short: true });\n\t  }\n\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t}\n\n\tfunction nAtL(name, location) {\n\t  var tName = t(name || 'value');\n\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t  return '' + tName + tLocation;\n\t}\n\n\tfunction t(thing) {\n\t  return '`' + thing + '`';\n\t}\n\n\tfunction undef(thing) {\n\t  return typeof thing === 'undefined';\n\t}\n\n\t/**\n\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t * optional version\n\t *\n\t * @param {Function} checker - the checker to setup with properties\n\t * @param {Object} properties - properties to add to the checker\n\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t * @returns {Function} checker - the setup checker\n\t */\n\tfunction setupChecker(checker, properties, disabled) {\n\t  /* eslint complexity:[2, 9] */\n\t  if (disabled) {\n\t    // swap out the checker for its own copy of noop\n\t    checker = getNoop();\n\t    checker.isNoop = true;\n\t  }\n\n\t  if (typeof checker.type === 'string') {\n\t    checker.shortType = checker.type;\n\t  }\n\n\t  // assign all properties given\n\t  each(properties, function (prop, name) {\n\t    return checker[name] = prop;\n\t  });\n\n\t  if (!checker.displayName) {\n\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t  }\n\n\t  if (!checker.notRequired) {\n\t    checker = getRequiredVersion(checker, disabled);\n\t  }\n\n\t  if (!checker.notNullable) {\n\t    addNullable(checker, disabled);\n\t  }\n\n\t  if (!checker.notOptional) {\n\t    addOptional(checker, disabled);\n\t  }\n\n\t  return checker;\n\t}\n\n\tfunction getRequiredVersion(checker, disabled) {\n\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t    if (undef(val) && !checker.isOptional) {\n\t      var tLocation = location ? ' in ' + t(location) : '';\n\t      var type = getCheckerDisplay(checker, { short: true });\n\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t    } else {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  copyProps(checker, requiredChecker);\n\t  requiredChecker.originalChecker = checker;\n\t  return requiredChecker;\n\t}\n\n\tfunction addOptional(checker, disabled) {\n\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t    if (!undef(val)) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, optionalCheck);\n\n\t  optionalCheck.isOptional = true;\n\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t  optionalCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .optional to the end of the checkers\n\t  checker.optional = optionalCheck;\n\n\t  fixType(checker, checker.optional);\n\t}\n\n\tfunction addNullable(checker, disabled) {\n\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t    if (val !== null) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, nullableCheck);\n\n\t  nullableCheck.isNullable = true;\n\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t  nullableCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t  checker.nullable = nullableCheck;\n\n\t  fixType(checker, checker.nullable);\n\t  if (!checker.notOptional) {\n\t    addOptional(checker.nullable, disabled);\n\t  }\n\t}\n\n\tfunction fixType(checker, checkerCopy) {\n\t  // fix type, because it's not a straight copy...\n\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t  // we also want to add \"(optional)\" to the types with a string\n\t  if (typeof checkerCopy.type === 'object') {\n\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t  } else if (typeof checkerCopy.type === 'function') {\n\t      checkerCopy.type = function () {\n\t        return checker.type.apply(checker, arguments);\n\t      };\n\t    } else {\n\t      checkerCopy.type += ' (optional)';\n\t      return;\n\t    }\n\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t  checkerCopy.type.__apiCheckData.optional = true;\n\t}\n\n\t// UTILS\n\n\tfunction copyProps(src, dest) {\n\t  each(Object.keys(src), function (key) {\n\t    return dest[key] = src[key];\n\t  });\n\t}\n\n\tfunction noop() {}\n\n\tfunction getNoop() {\n\t  /* eslint no-shadow:0 */\n\t  /* istanbul ignore next */\n\t  return function noop() {};\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\n\tvar _require = __webpack_require__(3);\n\n\tvar typeOf = _require.typeOf;\n\tvar each = _require.each;\n\tvar copy = _require.copy;\n\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\tvar isError = _require.isError;\n\tvar arrayify = _require.arrayify;\n\tvar list = _require.list;\n\tvar getError = _require.getError;\n\tvar nAtL = _require.nAtL;\n\tvar t = _require.t;\n\tvar checkerHelpers = _require.checkerHelpers;\n\tvar undef = _require.undef;\n\tvar setupChecker = checkerHelpers.setupChecker;\n\n\tvar checkers = module.exports = getCheckers();\n\tmodule.exports.getCheckers = getCheckers;\n\n\tfunction getCheckers(disabled) {\n\t  return {\n\t    array: typeOfCheckGetter('Array'),\n\t    bool: typeOfCheckGetter('Boolean'),\n\t    number: typeOfCheckGetter('Number'),\n\t    string: typeOfCheckGetter('String'),\n\t    func: funcCheckGetter(),\n\t    object: objectCheckGetter(),\n\n\t    emptyObject: emptyObjectCheckGetter(),\n\n\t    instanceOf: instanceCheckGetter,\n\t    oneOf: oneOfCheckGetter,\n\t    oneOfType: oneOfTypeCheckGetter,\n\n\t    arrayOf: arrayOfCheckGetter,\n\t    objectOf: objectOfCheckGetter,\n\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\n\t    range: rangeCheckGetter,\n\t    lessThan: lessThanCheckGetter,\n\t    greaterThan: greaterThanCheckGetter,\n\n\t    shape: getShapeCheckGetter(),\n\t    args: argumentsCheckerGetter(),\n\n\t    any: anyCheckGetter(),\n\t    'null': nullCheckGetter()\n\n\t  };\n\n\t  function typeOfCheckGetter(type) {\n\t    var lType = type.toLowerCase();\n\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== lType) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function funcCheckGetter() {\n\t    var type = 'Function';\n\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'function') {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\n\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t      if (isError(apiError)) {\n\t        throw apiError;\n\t      }\n\t      var shapeChecker = checkers.shape(properties, true);\n\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\n\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t        var notFunction = checkers.func(val, name, location);\n\t        if (isError(notFunction)) {\n\t          return notFunction;\n\t        }\n\t        return shapeChecker(val, name, location);\n\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t    };\n\t    return functionChecker;\n\t  }\n\n\t  function objectCheckGetter() {\n\t    var type = 'Object';\n\t    var nullType = 'Object (null ok)';\n\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'object') {\n\t        return getError(name, location, nullType);\n\t      }\n\t    }, { type: nullType }, disabled);\n\n\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t        return getError(name, location, objectChecker.type);\n\t      }\n\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\n\t    return objectChecker;\n\t  }\n\n\t  function instanceCheckGetter(classToCheck) {\n\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t      if (!(val instanceof classToCheck)) {\n\t        return getError(name, location, classToCheck.name);\n\t      }\n\t    }, { type: classToCheck.name }, disabled);\n\t  }\n\n\t  function oneOfCheckGetter(enums) {\n\t    var type = {\n\t      __apiCheckData: { optional: false, type: 'enum' },\n\t      'enum': enums\n\t    };\n\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t      return stringify(enm);\n\t    }).join(', ') + ']';\n\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t      if (!enums.some(function (enm) {\n\t        return enm === val;\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t      return getCheckerDisplay(checker, { short: true });\n\t    });\n\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return typeCheckers.map(function (checker) {\n\t        return getCheckerDisplay(checker, options);\n\t      });\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t      if (!typeCheckers.some(function (checker) {\n\t        return !isError(checker(val, name, location));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function arrayOfCheckGetter(checker) {\n\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\n\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t        return !isError(checker(item));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function objectOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\n\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t      var notObject = checkers.object(val, name, location);\n\t      if (isError(notObject)) {\n\t        return notObject;\n\t      }\n\t      var allTypesSuccess = each(val, function (item, key) {\n\t        if (isError(checker(item, key, name))) {\n\t          return false;\n\t        }\n\t      });\n\t      if (!allTypesSuccess) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function typeOrArrayOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\n\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function getShapeCheckGetter() {\n\t    function shapeCheckGetter(shape, nonObject) {\n\t      var shapeTypes = {};\n\t      each(shape, function (checker, prop) {\n\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t      });\n\t      function type() {\n\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t        var ret = {};\n\t        var terse = options.terse;\n\t        var obj = options.obj;\n\t        var addHelpers = options.addHelpers;\n\n\t        var parentRequired = options.required;\n\t        each(shape, function (checker, prop) {\n\t          /* eslint complexity:[2, 6] */\n\t          var specified = obj && obj.hasOwnProperty(prop);\n\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t          if (!terse || (specified || !checker.isOptional)) {\n\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t          }\n\t          if (addHelpers) {\n\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t          }\n\t        });\n\t        return ret;\n\n\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t          if (!specified && required && !checker.isOptional) {\n\t            var item = 'ITEM';\n\t            if (checker.type && checker.type.__apiCheckData) {\n\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t            }\n\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t          } else if (specified) {\n\t            var error = checker(obj[prop], prop, null, obj);\n\t            if (isError(error)) {\n\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t            }\n\t          }\n\n\t          function addHelper(property, objectMessage, stringMessage) {\n\t            if (typeof theRet[prop] === 'string') {\n\t              theRet[prop] += stringMessage;\n\t            } else {\n\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t        /* eslint complexity:[2, 6] */\n\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t        if (isError(isObject)) {\n\t          return isObject;\n\t        }\n\t        var shapePropError = undefined;\n\t        location = location ? location + (name ? '/' : '') : '';\n\t        name = name || '';\n\t        each(shape, function (checker, prop) {\n\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t            return !isError(shapePropError);\n\t          }\n\t        });\n\t        if (isError(shapePropError)) {\n\t          return shapePropError;\n\t        }\n\t      }, { type: type, shortType: 'shape' }, disabled);\n\n\t      function strictType() {\n\t        return type.apply(undefined, arguments);\n\t      }\n\n\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t      strictType.__apiCheckData.strict = true;\n\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t        var shapeError = shapeChecker(val, name, location);\n\t        if (isError(shapeError)) {\n\t          return shapeError;\n\t        }\n\t        var allowedProperties = Object.keys(shape);\n\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t          return allowedProperties.indexOf(prop) === -1;\n\t        });\n\t        if (extraProps.length) {\n\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t        }\n\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\n\t      return shapeChecker;\n\t    }\n\n\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t      } else {\n\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (propExists === otherPropsExist) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t      otherProps = arrayify(otherProps);\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t      } else {\n\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t        var othersPresent = otherProps.every(function (property) {\n\t          return obj.hasOwnProperty(property);\n\t        });\n\t        if (!othersPresent) {\n\t          return getError(propName, location, type);\n\t        } else {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        throw new Error('requiredIfNot.all must be passed an array');\n\t      }\n\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t    };\n\n\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t      var props = t(otherProps.join(', '));\n\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var iteration = all ? 'every' : 'some';\n\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (!otherPropsExist && !propExists) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, notRequired: true }, disabled);\n\t    }\n\n\t    return shapeCheckGetter;\n\n\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t      function type(options) {\n\t        if (options && options.short) {\n\t          return shortType;\n\t        }\n\t        return getCheckerDisplay(propChecker);\n\t      }\n\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t      return type;\n\t    }\n\t  }\n\n\t  function argumentsCheckerGetter() {\n\t    var type = 'function arguments';\n\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function anyCheckGetter() {\n\t    return setupChecker(function anyCheckerDefinition() {\n\t      // don't do anything\n\t    }, { type: 'any' }, disabled);\n\t  }\n\n\t  function nullCheckGetter() {\n\t    var type = 'null';\n\t    return setupChecker(function nullChecker(val, name, location) {\n\t      if (val !== null) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function rangeCheckGetter(min, max) {\n\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t    return setupChecker(function rangeChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < min || val > max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function lessThanCheckGetter(min) {\n\t    var type = 'lessThan[' + min + ']';\n\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val > min) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function greaterThanCheckGetter(max) {\n\t    var type = 'greaterThan[' + max + ']';\n\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function emptyObjectCheckGetter() {\n\t    var type = 'empty object';\n\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/api-check/dist/api-check.js\n ** module id = 4\n ** module chunks = 2\n **/","/*!\n* angular-formly JavaScript Library v7.3.2\n*\n* @license MIT (http://license.angular-formly.com)\n*\n* built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n* ( _)==(_ )\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _indexCommon = __webpack_require__(1);\n\n\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\n\texports['default'] = _indexCommon2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\n\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\n\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\n\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\n\tvar _providersFormlyUsability = __webpack_require__(7);\n\n\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\n\tvar _providersFormlyConfig = __webpack_require__(8);\n\n\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\n\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\n\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\n\tvar _servicesFormlyUtil = __webpack_require__(11);\n\n\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\n\tvar _servicesFormlyWarn = __webpack_require__(12);\n\n\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\n\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\n\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\n\tvar _directivesFormlyField = __webpack_require__(14);\n\n\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\n\tvar _directivesFormlyFocus = __webpack_require__(15);\n\n\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\n\tvar _directivesFormlyForm = __webpack_require__(16);\n\n\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\n\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\n\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\n\tvar _runFormlyCustomTags = __webpack_require__(18);\n\n\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\n\tvar ngModuleName = 'formly';\n\n\texports['default'] = ngModuleName;\n\n\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\n\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\tngModule.constant('formlyVersion', (\"7.3.2\")); // <-- webpack variable\n\n\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\n\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\n\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\n\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\tngModule.run(_runFormlyCustomTags2['default']);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar angular = __webpack_require__(3);\n\n\t/* istanbul ignore next */\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\texports['default'] = angular;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\tvar apiCheck = (0, _apiCheck2['default'])({\n\t  output: {\n\t    prefix: 'angular-formly:',\n\t    docsBaseUrl: __webpack_require__(6)\n\t  }\n\t});\n\n\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t    otherProps = [otherProps];\n\t  }\n\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\n\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t      return obj && obj.hasOwnProperty(otherProp);\n\t    });\n\t    if (!otherPropsExist && !propExists) {\n\t      return apiCheck.utils.getError(propName, location, type);\n\t    } else if (propExists) {\n\t      return propChecker(prop, propName, location, obj);\n\t    }\n\t  }\n\n\t  shapeRequiredIfNotDefinition.type = type;\n\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t}\n\n\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\n\tvar apiCheckProperty = apiCheck.func;\n\n\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t  warn: apiCheck.func,\n\t  'throw': apiCheck.func,\n\t  shape: apiCheck.func\n\t}));\n\n\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\n\tvar formlyWrapperType = apiCheck.shape({\n\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  overwriteOk: apiCheck.bool.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional\n\t}).strict;\n\n\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\n\tvar templateManipulators = apiCheck.shape({\n\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t}).strict.nullable;\n\n\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar fieldOptionsApiShape = {\n\t  $$hashKey: apiCheck.any.optional,\n\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  model: modelChecker.optional,\n\t  originalModel: modelChecker.optional,\n\t  className: apiCheck.string.optional,\n\t  id: apiCheck.string.optional,\n\t  name: apiCheck.string.optional,\n\t  expressionProperties: expressionProperties.optional,\n\t  extras: apiCheck.shape({\n\t    validateOnModelChange: apiCheck.bool.optional,\n\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t  }).strict.optional,\n\t  data: apiCheck.object.optional,\n\t  templateOptions: apiCheck.object.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  modelOptions: apiCheck.shape({\n\t    updateOn: apiCheck.string.optional,\n\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t    allowInvalid: apiCheck.bool.optional,\n\t    getterSetter: apiCheck.bool.optional,\n\t    timezone: apiCheck.string.optional\n\t  }).optional,\n\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t    expression: formlyExpression.optional,\n\t    listener: formlyExpression\n\t  })).optional,\n\t  validators: validatorChecker.optional,\n\t  asyncValidators: validatorChecker.optional,\n\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t  noFormControl: apiCheck.bool.optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t  }).strict).optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  link: apiCheck.func.optional,\n\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t  validation: apiCheck.shape({\n\t    show: apiCheck.bool.nullable.optional,\n\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t  }).optional,\n\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t  value: apiCheck.func.optional,\n\t  runExpressions: apiCheck.func.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  initialValue: apiCheck.any.optional,\n\t  defaultValue: apiCheck.any.optional\n\t};\n\n\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\n\tvar formOptionsApi = apiCheck.shape({\n\t  formState: apiCheck.object.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t  data: apiCheck.object.optional\n\t}).strict;\n\n\tvar fieldGroup = apiCheck.shape({\n\t  $$hashKey: apiCheck.any.optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  // danger. Nested field groups wont get api-checked...\n\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t  className: apiCheck.string.optional,\n\t  options: formOptionsApi.optional,\n\t  templateOptions: apiCheck.object.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  data: apiCheck.object.optional,\n\t  model: modelChecker.optional,\n\t  form: apiCheck.object.optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t}).strict;\n\n\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\n\tvar formlyTypeOptions = apiCheck.shape({\n\t  name: apiCheck.string,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t  link: apiCheck.func.optional,\n\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t  'extends': apiCheck.string.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  data: apiCheck.object.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional,\n\t  overwriteOk: apiCheck.bool.optional\n\t}).strict;\n\n\t_angularFix2['default'].extend(apiCheck, {\n\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t});\n\n\texports['default'] = apiCheck;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.3.2\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyUsability;\n\n\t// @ngInject\n\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t  var _this = this;\n\n\t  _angularFix2['default'].extend(this, {\n\t    getFormlyError: getFormlyError,\n\t    getFieldError: getFieldError,\n\t    checkWrapper: checkWrapper,\n\t    checkWrapperTemplate: checkWrapperTemplate,\n\t    getErrorMessage: getErrorMessage,\n\t    $get: function $get() {\n\t      return _this;\n\t    }\n\t  });\n\n\t  function getFieldError(errorInfoSlug, message, field) {\n\t    if (arguments.length < 3) {\n\t      field = message;\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t  }\n\n\t  function getFormlyError(errorInfoSlug, message) {\n\t    if (!message) {\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t  }\n\n\t  function getErrorMessage(errorInfoSlug, message) {\n\t    var url = '';\n\t    if (errorInfoSlug !== null) {\n\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t    }\n\t    return 'Formly Error: ' + message + '. ' + url;\n\t  }\n\n\t  function checkWrapper(wrapper) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t      prefix: 'formlyConfig.setWrapper',\n\t      urlSuffix: 'setwrapper-validation-failed'\n\t    });\n\t  }\n\n\t  function checkWrapperTemplate(template, additionalInfo) {\n\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t    if (template.indexOf(formlyTransclude) === -1) {\n\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t    }\n\t  }\n\t}\n\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyConfig;\n\n\t// @ngInject\n\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t  var _this2 = this;\n\n\t  var typeMap = {};\n\t  var templateWrappersMap = {};\n\t  var defaultWrapperName = 'default';\n\t  var _this = this;\n\t  var getError = formlyUsabilityProvider.getFormlyError;\n\n\t  _angularFix2['default'].extend(this, {\n\t    setType: setType,\n\t    getType: getType,\n\t    getTypeHeritage: getTypeHeritage,\n\t    setWrapper: setWrapper,\n\t    getWrapper: getWrapper,\n\t    getWrapperByType: getWrapperByType,\n\t    removeWrapperByName: removeWrapperByName,\n\t    removeWrappersForType: removeWrappersForType,\n\t    disableWarnings: false,\n\t    extras: {\n\t      disableNgModelAttrsManipulator: false,\n\t      fieldTransform: [],\n\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t      removeChromeAutoComplete: false,\n\t      defaultHideDirective: 'ng-if',\n\t      getFieldId: null\n\t    },\n\t    templateManipulators: {\n\t      preWrapper: [],\n\t      postWrapper: []\n\t    },\n\t    $get: function $get() {\n\t      return _this2;\n\t    }\n\t  });\n\n\t  function setType(options) {\n\t    if (_angularFix2['default'].isArray(options)) {\n\t      var _ret = (function () {\n\t        var allTypes = [];\n\t        _angularFix2['default'].forEach(options, function (item) {\n\t          allTypes.push(setType(item));\n\t        });\n\t        return {\n\t          v: allTypes\n\t        };\n\t      })();\n\n\t      if (typeof _ret === 'object') return _ret.v;\n\t    } else if (_angularFix2['default'].isObject(options)) {\n\t      checkType(options);\n\t      if (options['extends']) {\n\t        extendTypeOptions(options);\n\t      }\n\t      typeMap[options.name] = options;\n\t      return typeMap[options.name];\n\t    } else {\n\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t    }\n\t  }\n\n\t  function checkType(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t      prefix: 'formlyConfig.setType',\n\t      url: 'settype-validation-failed'\n\t    });\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t    } else {\n\t      options.overwriteOk = undefined;\n\t    }\n\t  }\n\n\t  function extendTypeOptions(options) {\n\t    var extendsType = getType(options['extends'], true, options);\n\t    extendTypeControllerFunction(options, extendsType);\n\t    extendTypeLinkFunction(options, extendsType);\n\t    extendTypeDefaultOptions(options, extendsType);\n\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t    extendTemplate(options, extendsType);\n\t  }\n\n\t  function extendTemplate(options, extendsType) {\n\t    if (options.template && extendsType.templateUrl) {\n\t      delete options.templateUrl;\n\t    } else if (options.templateUrl && extendsType.template) {\n\t      delete options.template;\n\t    }\n\t  }\n\n\t  function extendTypeControllerFunction(options, extendsType) {\n\t    var extendsCtrl = extendsType.controller;\n\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t      return;\n\t    }\n\t    var optionsCtrl = options.controller;\n\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t      options.controller = function ($scope, $controller) {\n\t        $controller(extendsCtrl, { $scope: $scope });\n\t        $controller(optionsCtrl, { $scope: $scope });\n\t      };\n\t      options.controller.$inject = ['$scope', '$controller'];\n\t    } else {\n\t      options.controller = extendsCtrl;\n\t    }\n\t  }\n\n\t  function extendTypeLinkFunction(options, extendsType) {\n\t    var extendsFn = extendsType.link;\n\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t      return;\n\t    }\n\t    var optionsFn = options.link;\n\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t      options.link = function () {\n\t        extendsFn.apply(undefined, arguments);\n\t        optionsFn.apply(undefined, arguments);\n\t      };\n\t    } else {\n\t      options.link = extendsFn;\n\t    }\n\t  }\n\n\t  function extendTypeDefaultOptions(options, extendsType) {\n\t    var extendsDO = extendsType.defaultOptions;\n\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t      return;\n\t    }\n\t    var optionsDO = options.defaultOptions;\n\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t    if (extendsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t        var mergedDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t        var extenderOptionsDefaultOptions = optionsDO;\n\t        if (optionsDOIsFn) {\n\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t        }\n\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t        return extendsDefaultOptions;\n\t      };\n\t    } else if (optionsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var newDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t        return optionsDO(newDefaultOptions, scope);\n\t      };\n\t    }\n\t  }\n\n\t  function getType(name, throwError, errorContext) {\n\t    if (!name) {\n\t      return undefined;\n\t    }\n\t    var type = typeMap[name];\n\t    if (!type && throwError === true) {\n\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t    } else {\n\t      return type;\n\t    }\n\t  }\n\n\t  function getTypeHeritage(parent) {\n\t    var heritage = [];\n\t    var type = parent;\n\t    if (_angularFix2['default'].isString(type)) {\n\t      type = getType(parent);\n\t    }\n\t    parent = type['extends'];\n\t    while (parent) {\n\t      type = getType(parent);\n\t      heritage.push(type);\n\t      parent = type['extends'];\n\t    }\n\t    return heritage;\n\t  }\n\n\t  function setWrapper(_x, _x2) {\n\t    var _again = true;\n\n\t    _function: while (_again) {\n\t      var options = _x,\n\t          name = _x2;\n\t      _again = false;\n\n\t      if (_angularFix2['default'].isArray(options)) {\n\t        return options.map(function (wrapperOptions) {\n\t          return setWrapper(wrapperOptions);\n\t        });\n\t      } else if (_angularFix2['default'].isObject(options)) {\n\t        options.types = getOptionsTypes(options);\n\t        options.name = getOptionsName(options, name);\n\t        checkWrapperAPI(options);\n\t        templateWrappersMap[options.name] = options;\n\t        return options;\n\t      } else if (_angularFix2['default'].isString(options)) {\n\t        _x = {\n\t          template: options,\n\t          name: name\n\t        };\n\t        _x2 = undefined;\n\t        _again = true;\n\t        continue _function;\n\t      }\n\t    }\n\t  }\n\n\t  function getOptionsTypes(options) {\n\t    if (_angularFix2['default'].isString(options.types)) {\n\t      return [options.types];\n\t    }\n\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t      return [];\n\t    } else {\n\t      return options.types;\n\t    }\n\t  }\n\n\t  function getOptionsName(options, name) {\n\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t  }\n\n\t  function checkWrapperAPI(options) {\n\t    formlyUsabilityProvider.checkWrapper(options);\n\t    if (options.template) {\n\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t    }\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t    } else {\n\t      delete options.overwriteOk;\n\t    }\n\t    checkWrapperTypes(options);\n\t  }\n\n\t  function checkWrapperTypes(options) {\n\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t    if (shouldThrow) {\n\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t    }\n\t  }\n\n\t  function checkOverwrite(property, object, newValue, objectName) {\n\t    if (object.hasOwnProperty(property)) {\n\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t    }\n\t  }\n\n\t  function getWrapper(name) {\n\t    return templateWrappersMap[name || defaultWrapperName];\n\t  }\n\n\t  function getWrapperByType(type) {\n\t    /* eslint prefer-const:0 */\n\t    var wrappers = [];\n\t    for (var _name in templateWrappersMap) {\n\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t          wrappers.push(templateWrappersMap[_name]);\n\t        }\n\t      }\n\t    }\n\t    return wrappers;\n\t  }\n\n\t  function removeWrapperByName(name) {\n\t    var wrapper = templateWrappersMap[name];\n\t    delete templateWrappersMap[name];\n\t    return wrapper;\n\t  }\n\n\t  function removeWrappersForType(type) {\n\t    var wrappers = getWrapperByType(type);\n\t    if (!wrappers) {\n\t      return undefined;\n\t    }\n\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t      return removeWrapperByName(wrappers.name);\n\t    } else {\n\t      wrappers.forEach(function (wrapper) {\n\t        return removeWrapperByName(wrapper.name);\n\t      });\n\t      return wrappers;\n\t    }\n\t  }\n\n\t  function warn() {\n\t    if (!_this.disableWarnings && console.warn) {\n\t      /* eslint no-console:0 */\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      console.warn.apply(console, _toConsumableArray(args));\n\t    }\n\t  }\n\t}\n\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = {\n\t  formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName, arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t};\n\n\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t  if (_angularFix2['default'].isFunction(expression)) {\n\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t  } else {\n\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t  }\n\t}\n\n\tfunction getFieldId(formId, options, index) {\n\t  if (options.id) {\n\t    return options.id;\n\t  }\n\t  var type = options.type;\n\t  if (!type && options.template) {\n\t    type = 'template';\n\t  } else if (!type && options.templateUrl) {\n\t    type = 'templateUrl';\n\t  }\n\n\t  return [formId, type, options.key, index].join('_');\n\t}\n\n\tfunction reverseDeepMerge(dest) {\n\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t    if (!index) {\n\t      return;\n\t    }\n\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t        dest[prop] = _angularFix2['default'].copy(val);\n\t      } else if (objAndSameType(dest[prop], val)) {\n\t        reverseDeepMerge(dest[prop], val);\n\t      }\n\t    });\n\t  });\n\t  return dest;\n\t}\n\n\tfunction objAndSameType(obj1, obj2) {\n\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t}\n\n\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\tfunction findByNodeName(el, nodeName) {\n\t  if (!el.prop) {\n\t    // not a jQuery or jqLite object -> wrap it\n\t    el = _angularFix2['default'].element(el);\n\t  }\n\n\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t    return el;\n\t  }\n\n\t  var c = el.children();\n\t  for (var i = 0; c && i < c.length; i++) {\n\t    var node = findByNodeName(c[i], nodeName);\n\t    if (node) {\n\t      return node;\n\t    }\n\t  }\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t    obj = [obj];\n\t  } else if (!obj) {\n\t    obj = [];\n\t  }\n\t  return obj;\n\t}\n\n\tfunction extendFunction() {\n\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t    fns[_key] = arguments[_key];\n\t  }\n\n\t  return function extendedFunction() {\n\t    var args = arguments;\n\t    fns.forEach(function (fn) {\n\t      return fn.apply(null, args);\n\t    });\n\t  };\n\t}\n\n\tfunction extendArray(primary, secondary, property) {\n\t  if (property) {\n\t    primary = primary[property];\n\t    secondary = secondary[property];\n\t  }\n\t  if (secondary && primary) {\n\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t      if (primary.indexOf(item) === -1) {\n\t        primary.push(item);\n\t      }\n\t    });\n\t    return primary;\n\t  } else if (secondary) {\n\t    return secondary;\n\t  } else {\n\t    return primary;\n\t  }\n\t}\n\n\tfunction startsWith(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n\tfunction contains(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = formlyValidationMessages;\n\n\t// @ngInject\n\tfunction formlyValidationMessages() {\n\n\t  var validationMessages = {\n\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t    addStringMessage: addStringMessage,\n\t    messages: {}\n\t  };\n\n\t  return validationMessages;\n\n\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t  }\n\n\t  function addStringMessage(name, string) {\n\t    validationMessages.messages[name] = function () {\n\t      return string;\n\t    };\n\t  }\n\n\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t      if (scope.options.templateOptions[prop]) {\n\t        return prefix + \" \" + scope.options.templateOptions[prop] + \" \" + suffix;\n\t      } else {\n\t        return alternate;\n\t      }\n\t    };\n\t  }\n\t}\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyUtil;\n\n\t// @ngInject\n\tfunction formlyUtil() {\n\t  return _otherUtils2['default'];\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\texports['default'] = formlyWarn;\n\n\t// @ngInject\n\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t  return function warn() {\n\t    if (!formlyConfig.disableWarnings) {\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      $log.warn.apply($log, _toConsumableArray(args));\n\t    }\n\t  };\n\t}\n\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyCustomValidation;\n\n\t// @ngInject\n\tfunction formlyCustomValidation(formlyUtil) {\n\t  return {\n\t    restrict: 'A',\n\t    require: 'ngModel',\n\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t      var opts = scope.options;\n\t      opts.validation.messages = opts.validation.messages || {};\n\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t        opts.validation.messages[key] = function () {\n\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t        };\n\t      });\n\n\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\n\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t        setupMessage(validator, name);\n\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t        if (useNewValidatorsApi) {\n\t          setupWithValidators(validator, name, isAsync);\n\t        } else {\n\t          setupWithParsers(validator, name, isAsync);\n\t        }\n\t      }\n\n\t      function setupMessage(validator, name) {\n\t        var message = validator.message;\n\t        if (message) {\n\t          opts.validation.messages[name] = function () {\n\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t          };\n\t        }\n\t      }\n\n\t      function setupWithValidators(validator, name, isAsync) {\n\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\n\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t        };\n\t      }\n\n\t      function setupWithParsers(validator, name, isAsync) {\n\t        var inFlightValidator = undefined;\n\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t          if (isAsync) {\n\t            ctrl.$pending = ctrl.$pending || {};\n\t            ctrl.$pending[name] = true;\n\t            inFlightValidator = isValid;\n\t            isValid.then(function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, true);\n\t              }\n\t            })['catch'](function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, false);\n\t              }\n\t            })['finally'](function () {\n\t              var $pending = ctrl.$pending || {};\n\t              if (Object.keys($pending).length === 1) {\n\t                delete ctrl.$pending;\n\t              } else {\n\t                delete ctrl.$pending[name];\n\t              }\n\t            });\n\t          } else {\n\t            ctrl.$setValidity(name, isValid);\n\t          }\n\t          return viewValue;\n\t        });\n\t      }\n\t    }\n\t  };\n\t}\n\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = formlyField;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyField\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t  var arrayify = formlyUtil.arrayify;\n\n\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t  return {\n\t    restrict: 'AE',\n\t    transclude: true,\n\t    require: '?^formlyForm',\n\t    scope: {\n\t      options: '=',\n\t      model: '=',\n\t      originalModel: '=?',\n\t      formId: '@', // TODO remove formId in a breaking release\n\t      index: '=?',\n\t      fields: '=?',\n\t      formState: '=?',\n\t      formOptions: '=?',\n\t      form: '=?' },\n\t    // TODO require form in a breaking release\n\t    controller: FormlyFieldController,\n\t    link: fieldLink\n\t  };\n\n\t  // @ngInject\n\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t    /* eslint max-statements:[2, 31] */\n\t    if ($scope.options.fieldGroup) {\n\t      setupFieldGroup();\n\t      return;\n\t    }\n\n\t    var fieldType = getFieldType($scope.options);\n\t    simplifyLife($scope.options);\n\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t    checkApi($scope.options);\n\t    // set field id to link labels and fields\n\n\t    // initalization\n\t    setFieldIdAndName();\n\t    setDefaultValue();\n\t    setInitialValue();\n\t    runExpressions();\n\t    addValidationMessages($scope.options);\n\t    invokeControllers($scope, $scope.options, fieldType);\n\n\t    // function definitions\n\t    function runExpressions() {\n\t      // must run on next tick to make sure that the current value is correct.\n\t      return $timeout(function runExpressionsOnNextTick() {\n\t        var field = $scope.options;\n\t        var currentValue = valueGetterSetter();\n\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t          var setter = $parse(prop).assign;\n\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t          promise.then(function setFieldValue(value) {\n\t            setter(field, value);\n\t          });\n\t        });\n\t      }, 0, false);\n\t    }\n\n\t    function valueGetterSetter(newVal) {\n\t      if (!$scope.model || !$scope.options.key) {\n\t        return undefined;\n\t      }\n\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t        parseSet($scope.options.key, $scope.model, newVal);\n\t      }\n\t      return parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function parseSet(key, model, newVal) {\n\t      // If either of these are null/undefined then just return undefined\n\t      if (!key || !model) {\n\t        return;\n\t      }\n\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t      if (_angularFix2['default'].isNumber(key)) {\n\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t        model[key] = newVal;\n\t      } else {\n\t        var setter = $parse($scope.options.key).assign;\n\t        if (setter) {\n\t          setter($scope.model, newVal);\n\t        }\n\t      }\n\t    }\n\n\t    function parseGet(key, model) {\n\t      // If either of these are null/undefined then just return undefined\n\t      if (!key || !model) {\n\t        return undefined;\n\t      }\n\n\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t      if (_angularFix2['default'].isNumber(key)) {\n\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t        return model[key];\n\t      } else {\n\t        return $parse(key)(model);\n\t      }\n\t    }\n\n\t    function simplifyLife(options) {\n\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t      formlyUtil.reverseDeepMerge(options, {\n\t        originalModel: options.model,\n\t        extras: {},\n\t        data: {},\n\t        templateOptions: {},\n\t        validation: {}\n\t      });\n\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t      $scope.to = $scope.options.templateOptions;\n\t      $scope.formOptions = $scope.formOptions || {};\n\t    }\n\n\t    function setFieldIdAndName() {\n\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t      } else {\n\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t      }\n\t      $scope.options.id = $scope.id;\n\t      $scope.name = $scope.options.name || $scope.options.id;\n\t      $scope.options.name = $scope.name;\n\t    }\n\n\t    function setDefaultValue() {\n\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined(parseGet($scope.options.key, $scope.model))) {\n\t        parseSet($scope.options.key, $scope.model, $scope.options.defaultValue);\n\t      }\n\t    }\n\n\t    function setInitialValue() {\n\t      $scope.options.initialValue = $scope.model && parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t      if (type) {\n\t        mergeOptions(options, type.defaultOptions);\n\t      }\n\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t      });\n\t    }\n\n\t    function mergeOptions(options, extraOptions) {\n\t      if (extraOptions) {\n\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t          extraOptions = extraOptions(options, $scope);\n\t        }\n\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t      }\n\t    }\n\n\t    function extendOptionsWithDefaults(options, index) {\n\t      var key = options.key || index || 0;\n\t      _angularFix2['default'].extend(options, {\n\t        // attach the key in case the formly-field directive is used directly\n\t        key: key,\n\t        value: options.value || valueGetterSetter,\n\t        runExpressions: runExpressions,\n\t        resetModel: resetModel,\n\t        updateInitialValue: updateInitialValue\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      parseSet($scope.options.key, $scope.model, $scope.options.initialValue);\n\t      if ($scope.options.formControl) {\n\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t            resetFormControl(formControl, true);\n\t          });\n\t        } else {\n\t          resetFormControl($scope.options.formControl);\n\t        }\n\t      }\n\t    }\n\n\t    function resetFormControl(formControl, isMultiNgModel) {\n\t      if (!isMultiNgModel) {\n\t        formControl.$setViewValue(parseGet($scope.options.key, $scope.model));\n\t      }\n\n\t      formControl.$render();\n\t      formControl.$setUntouched && formControl.$setUntouched();\n\t      formControl.$setPristine();\n\n\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t      if (!$scope.$root.$$phase) {\n\t        $scope.$digest();\n\t      }\n\t    }\n\n\t    function updateInitialValue() {\n\t      $scope.options.initialValue = parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function addValidationMessages(options) {\n\t      options.validation.messages = options.validation.messages || {};\n\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t        if (!options.validation.messages[name]) {\n\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t          };\n\t        }\n\t      });\n\t    }\n\n\t    function invokeControllers(scope) {\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t        if (controller) {\n\t          $controller(controller, { $scope: scope });\n\t        }\n\t      });\n\t    }\n\n\t    function setupFieldGroup() {\n\t      $scope.options.options = $scope.options.options || {};\n\t      $scope.options.options.formState = $scope.formState;\n\t      $scope.to = $scope.options.templateOptions;\n\t    }\n\t  }\n\n\t  // link function\n\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t    if (scope.options.fieldGroup) {\n\t      setFieldGroupTemplate();\n\t      return;\n\t    }\n\n\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t    if (!formlyFormCtrl && scope.options.model) {\n\t      scope.$watch('options.model', function () {\n\t        return scope.options.runExpressions();\n\t      }, true);\n\t    }\n\n\t    addAttributes();\n\t    addClasses();\n\n\t    var type = getFieldType(scope.options);\n\t    var args = arguments;\n\t    var thusly = this;\n\t    var fieldCount = 0;\n\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t    });\n\n\t    function setFieldGroupTemplate() {\n\t      checkFieldGroupApi(scope.options);\n\t      el.addClass('formly-field-group');\n\t      var extraAttributes = '';\n\t      if (scope.options.elementAttributes) {\n\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t        }).join(' ');\n\t      }\n\t      var modelValue = 'model';\n\t      scope.options.form = scope.form;\n\t      if (scope.options.key) {\n\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t      }\n\t      getTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ').then(transcludeInWrappers(scope.options, scope.formOptions)).then(setElementTemplate);\n\t    }\n\n\t    function addAttributes() {\n\t      if (scope.options.elementAttributes) {\n\t        el.attr(scope.options.elementAttributes);\n\t      }\n\t    }\n\n\t    function addClasses() {\n\t      if (scope.options.className) {\n\t        el.addClass(scope.options.className);\n\t      }\n\t      if (scope.options.type) {\n\t        el.addClass('formly-field-' + scope.options.type);\n\t      }\n\t    }\n\n\t    function setElementTemplate(templateString) {\n\t      el.html(asHtml(templateString));\n\t      $compile(el.contents())(scope);\n\t      return templateString;\n\t    }\n\n\t    function watchFormControl(templateString) {\n\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t      if (scope.options.noFormControl) {\n\t        return;\n\t      }\n\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\n\t      if (ngModelNodes.length) {\n\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t          fieldCount++;\n\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t        });\n\t      }\n\n\t      function watchFieldNameOrExistence(name) {\n\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t        var nameExpression = nameExpressionRegex.exec(name);\n\t        if (nameExpression) {\n\t          name = $interpolate(name)(scope);\n\t        }\n\t        watchFieldExistence(name);\n\t      }\n\n\t      function watchFieldExistence(name) {\n\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t          if (formControl) {\n\t            if (fieldCount > 1) {\n\t              if (!scope.options.formControl) {\n\t                scope.options.formControl = [];\n\t              }\n\t              scope.options.formControl.push(formControl);\n\t            } else {\n\t              scope.options.formControl = formControl;\n\t            }\n\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t            stopWatchingShowError();\n\t            addShowMessagesWatcher();\n\t            addParsers();\n\t            addFormatters();\n\t          }\n\t        });\n\t      }\n\n\t      function addShowMessagesWatcher() {\n\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t          var options = scope.options;\n\t          var fc = scope.fc;\n\n\t          if (!fc.$invalid) {\n\t            return false;\n\t          } else if (typeof options.validation.show === 'boolean') {\n\t            return options.validation.show;\n\t          } else if (customExpression) {\n\t            return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t          } else {\n\t            var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t            return scope.fc.$touched || noTouchedButDirty;\n\t          }\n\t        }, function onShowValidationChange(show) {\n\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t          scope.showError = show; // shortcut for template authors\n\t        });\n\t      }\n\n\t      function addParsers() {\n\t        setParsersOrFormatters('parsers');\n\t      }\n\n\t      function addFormatters() {\n\t        setParsersOrFormatters('formatters');\n\t        var ctrl = scope.fc;\n\t        var formWasPristine = scope.form.$pristine;\n\t        if (scope.options.formatters) {\n\t          (function () {\n\t            var value = ctrl.$modelValue;\n\t            ctrl.$formatters.forEach(function (formatter) {\n\t              value = formatter(value);\n\t            });\n\n\t            ctrl.$setViewValue(value);\n\t            ctrl.$render();\n\t            ctrl.$setPristine();\n\t            if (formWasPristine) {\n\t              scope.form.$setPristine();\n\t            }\n\t          })();\n\t        }\n\t      }\n\n\t      function setParsersOrFormatters(which) {\n\t        var originalThingProp = 'originalParser';\n\t        if (which === 'formatters') {\n\t          originalThingProp = 'originalFormatter';\n\t        }\n\n\t        // init with type's parsers\n\t        var things = getThingsFromType(type);\n\n\t        // get optionsTypes things\n\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\n\t        // get field's things\n\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\n\t        // convert things into formlyExpression things\n\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t          things[index] = getFormlyExpressionThing(thing);\n\t        });\n\n\t        var ngModelCtrls = scope.fc;\n\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t          ngModelCtrls = [ngModelCtrls];\n\t        }\n\n\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t          var _ngModelCtrl;\n\n\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t        });\n\n\t        function getThingsFromType(theType) {\n\t          if (!theType) {\n\t            return [];\n\t          }\n\t          if (_angularFix2['default'].isString(theType)) {\n\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t          }\n\t          var typeThings = [];\n\n\t          // get things from parent\n\t          if (theType['extends']) {\n\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t          }\n\n\t          // get own type's things\n\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\n\t          // get things from optionsTypes\n\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\n\t          return typeThings;\n\t        }\n\n\t        function getThingsFromOptionsTypes() {\n\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n\t          var optionsTypesThings = [];\n\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t          });\n\t          return optionsTypesThings;\n\t        }\n\n\t        function getFormlyExpressionThing(thing) {\n\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t          return formlyExpressionParserOrFormatterFunction;\n\n\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t            var $modelValue = scope.options.value();\n\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    function callLinkFunctions() {\n\t      if (type && type.link) {\n\t        type.link.apply(thusly, args);\n\t      }\n\t      if (scope.options.link) {\n\t        scope.options.link.apply(thusly, args);\n\t      }\n\t    }\n\n\t    function runManipulators(manipulators) {\n\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t        var chain = $q.when(templateToManipulate);\n\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t          chain = chain.then(function (template) {\n\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t            });\n\t          });\n\t        });\n\t        return chain;\n\t      };\n\t    }\n\t  }\n\n\t  // sort-of stateless util functions\n\t  function asHtml(el) {\n\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t    return wrapper.append(el).html();\n\t  }\n\n\t  function getFieldType(options) {\n\t    return options.type && formlyConfig.getType(options.type);\n\t  }\n\n\t  function getManipulators(options, formOptions) {\n\t    var preWrapper = [];\n\t    var postWrapper = [];\n\t    addManipulators(options.templateManipulators);\n\t    addManipulators(formOptions.templateManipulators);\n\t    addManipulators(formlyConfig.templateManipulators);\n\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\n\t    function addManipulators(manipulators) {\n\t      /* eslint-disable */ // it doesn't understand this :-(\n\n\t      var _ref = manipulators || {};\n\n\t      var _ref$preWrapper = _ref.preWrapper;\n\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t      var _ref$postWrapper = _ref.postWrapper;\n\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\n\t      preWrapper = preWrapper.concat(pre);\n\t      postWrapper = postWrapper.concat(post);\n\t      /* eslint-enable */\n\t    }\n\t  }\n\n\t  function getFieldTemplate(options) {\n\t    function fromOptionsOrType(key, fieldType) {\n\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t        return options[key];\n\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t        return fieldType[key];\n\t      }\n\t    }\n\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    var template = fromOptionsOrType('template', type);\n\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t    }\n\n\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t  }\n\n\t  function getTemplate(template, isUrl, options) {\n\t    var templatePromise = undefined;\n\t    if (_angularFix2['default'].isFunction(template)) {\n\t      templatePromise = $q.when(template(options));\n\t    } else {\n\t      templatePromise = $q.when(template);\n\t    }\n\n\t    if (!isUrl) {\n\t      return templatePromise;\n\t    } else {\n\t      var _ret2 = (function () {\n\t        var httpOptions = { cache: $templateCache };\n\t        return {\n\t          v: templatePromise.then(function (url) {\n\t            return $http.get(url, httpOptions);\n\t          }).then(function (response) {\n\t            return response.data;\n\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t          })\n\t        };\n\t      })();\n\n\t      if (typeof _ret2 === 'object') return _ret2.v;\n\t    }\n\t  }\n\n\t  function transcludeInWrappers(options, formOptions) {\n\t    var wrapper = getWrapperOption(options, formOptions);\n\n\t    return function transcludeTemplate(template) {\n\t      if (!wrapper.length) {\n\t        return $q.when(template);\n\t      }\n\n\t      wrapper.forEach(function (aWrapper) {\n\t        formlyUsability.checkWrapper(aWrapper, options);\n\t        runApiCheck(aWrapper, options);\n\t      });\n\t      var promises = wrapper.map(function (w) {\n\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t      });\n\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t        });\n\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t        var totalWrapper = wrappersTemplates.shift();\n\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t        });\n\t        return doTransclusion(totalWrapper, template);\n\t      });\n\t    };\n\t  }\n\n\t  function doTransclusion(wrapper, template) {\n\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t    superWrapper.append(wrapper);\n\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t    if (!transcludeEl.length) {\n\t      // try it using our custom find function\n\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t    }\n\t    transcludeEl.replaceWith(template);\n\t    return superWrapper.html();\n\t  }\n\n\t  function getWrapperOption(options, formOptions) {\n\t    /* eslint complexity:[2, 6] */\n\t    var wrapper = options.wrapper;\n\t    // explicit null means no wrapper\n\t    if (wrapper === null) {\n\t      return [];\n\t    }\n\n\t    // nothing specified means use the default wrapper for the type\n\t    if (!wrapper) {\n\t      // get all wrappers that specify they apply to this type\n\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t    } else {\n\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t    }\n\n\t    // get all wrappers for that the type specified that it uses.\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    if (type && type.wrapper) {\n\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(typeWrappers);\n\t    }\n\n\t    // add form wrappers\n\t    if (formOptions.wrapper) {\n\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(formWrappers);\n\t    }\n\n\t    // add the default wrapper last\n\t    var defaultWrapper = formlyConfig.getWrapper();\n\t    if (defaultWrapper) {\n\t      wrapper.push(defaultWrapper);\n\t    }\n\t    return wrapper;\n\t  }\n\n\t  function checkApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t    // validate with the type\n\t    var type = options.type && formlyConfig.getType(options.type);\n\t    if (type) {\n\t      runApiCheck(type, options, true);\n\t    }\n\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t    }\n\t  }\n\n\t  function checkFieldGroupApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t  }\n\n\t  function runApiCheck(_ref2, options, forType) {\n\t    var apiCheck = _ref2.apiCheck;\n\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\n\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t    if (forType && options.type) {\n\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t      });\n\t    }\n\t  }\n\n\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t    /* eslint complexity:[2, 9] */\n\t    if (!apiCheck) {\n\t      return;\n\t    }\n\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t      return;\n\t    }\n\t    var fn = apiCheckFunction || 'warn';\n\t    // this is the new API\n\t    var checkerObjects = apiCheck(instance);\n\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t      var checker = instance.shape(shape);\n\t      var checkOptions = _angularFix2['default'].extend({\n\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t      }, apiCheckOptions);\n\t      instance[fn](checker, options[name], checkOptions);\n\t    });\n\t  }\n\t}\n\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\n\t// Stateless util functions\n\tfunction getDefaultOptionsOptionsTypes(type) {\n\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t}\n\n\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = formlyFocus;\n\n\t// @ngInject\n\tfunction formlyFocus($timeout, $document) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function formlyFocusLink(scope, element, attrs) {\n\t      var previousEl = null;\n\t      var el = element[0];\n\t      var doc = $document[0];\n\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t        if (value === 'true') {\n\t          $timeout(function setElementFocus() {\n\t            previousEl = doc.activeElement;\n\t            el.focus();\n\t          }, ~ ~attrs.focusWait);\n\t        } else if (value === 'false') {\n\t          if (doc.activeElement === el) {\n\t            el.blur();\n\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t              previousEl.focus();\n\t            }\n\t          }\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar _slice = Array.prototype.slice;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyForm;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyForm\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t  var currentFormId = 1;\n\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t  return {\n\t    restrict: 'AE',\n\t    template: formlyFormGetTemplate,\n\t    replace: true,\n\t    transclude: true,\n\t    scope: {\n\t      fields: '=',\n\t      model: '=',\n\t      form: '=?',\n\t      options: '=?'\n\t    },\n\t    controller: FormlyFormController,\n\t    link: formlyFormLink\n\t  };\n\n\t  function formlyFormGetTemplate(el, attrs) {\n\t    var rootEl = getRootEl();\n\t    var fieldRootEl = getFieldRootEl();\n\t    var formId = 'formly_' + currentFormId++;\n\t    var parentFormAttributes = '';\n\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t    }\n\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\n\t    function getRootEl() {\n\t      return attrs.rootEl || 'ng-form';\n\t    }\n\n\t    function getFieldRootEl() {\n\t      return attrs.fieldRootEl || 'div';\n\t    }\n\n\t    function getHideDirective() {\n\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t    }\n\n\t    function getTrackBy() {\n\t      if (!attrs.trackBy) {\n\t        return '';\n\t      } else {\n\t        return 'track by ' + attrs.trackBy;\n\t      }\n\t    }\n\n\t    function getFormName() {\n\t      var formName = formId;\n\t      var bindName = attrs.bindName;\n\t      if (bindName) {\n\t        if (_angularFix2['default'].version.minor < 3) {\n\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t        }\n\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t      }\n\t      return formName;\n\t    }\n\n\t    function getTranscludeClass() {\n\t      return attrs.transcludeClass || '';\n\t    }\n\n\t    function copyAttributes(attributes) {\n\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t      var arrayAttrs = [];\n\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t        var nodeName = _ref.nodeName;\n\t        var value = _ref.value;\n\n\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t        }\n\t      });\n\t      return arrayAttrs.join(' ');\n\t    }\n\t  }\n\n\t  // @ngInject\n\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t    setupOptions();\n\t    $scope.model = $scope.model || {};\n\t    setupFields();\n\n\t    // watch the model and evaluate watch expressions that depend on it.\n\t    $scope.$watch('model', onModelOrFormStateChange, true);\n\t    if ($scope.options.formState) {\n\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t    }\n\n\t    function onModelOrFormStateChange() {\n\t      _angularFix2['default'].forEach($scope.fields, function runFieldExpressionProperties(field, index) {\n\t        var model = field.model || $scope.model;\n\t        var promise = field.runExpressions && field.runExpressions();\n\t        if (field.hideExpression) {\n\t          // can't use hide with expressionProperties reliably\n\t          var val = model[field.key];\n\t          field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t        }\n\t        if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t          var validate = field.formControl.$validate;\n\t          if (promise) {\n\t            promise.then(validate);\n\t          } else {\n\t            validate();\n\t          }\n\t        }\n\t      });\n\t    }\n\n\t    function setupFields() {\n\t      $scope.fields = $scope.fields || [];\n\n\t      checkDeprecatedOptions($scope.options);\n\n\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\n\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t        fieldTransforms = [fieldTransforms];\n\t      }\n\n\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t        if (fieldTransform) {\n\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t          if (!$scope.fields) {\n\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t          }\n\t        }\n\t      });\n\n\t      setupModels();\n\n\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t    }\n\n\t    function checkDeprecatedOptions(options) {\n\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t      }\n\t    }\n\n\t    function setupOptions() {\n\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t      $scope.options = $scope.options || {};\n\t      $scope.options.formState = $scope.options.formState || {};\n\n\t      _angularFix2['default'].extend($scope.options, {\n\t        updateInitialValue: updateInitialValue,\n\t        resetModel: resetModel\n\t      });\n\t    }\n\n\t    function updateInitialValue() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.updateInitialValue();\n\t        } else {\n\t          field.updateInitialValue();\n\t        }\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.resetModel();\n\t        } else if (field.resetModel) {\n\t          field.resetModel();\n\t        }\n\t      });\n\t    }\n\n\t    function setupModels() {\n\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t      var watchedModels = [$scope.model];\n\n\t      if ($scope.options.formState) {\n\t        // $scope.options.formState will have its own watcher\n\t        watchedModels.push($scope.options.formState);\n\t      }\n\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        var isNewModel = initModel(field);\n\n\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1) {\n\t          $scope.$watch(function () {\n\t            return field.model;\n\t          }, onModelOrFormStateChange, true);\n\t          watchedModels.push(field.model);\n\t        }\n\t      });\n\t    }\n\n\t    function initModel(field) {\n\t      var isNewModel = true;\n\n\t      if (_angularFix2['default'].isString(field.model)) {\n\t        var expression = field.model;\n\t        var index = $scope.fields.indexOf(field);\n\n\t        isNewModel = !refrencesCurrentlyWatchedModel(expression);\n\n\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t        if (!field.model) {\n\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t        }\n\t      }\n\t      return isNewModel;\n\t    }\n\n\t    function refrencesCurrentlyWatchedModel(expression) {\n\t      return ['model', 'formState'].some(function (item) {\n\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t      });\n\t    }\n\n\t    function attachKey(field, index) {\n\t      if (!isFieldGroup(field)) {\n\t        field.key = field.key || index || 0;\n\t      }\n\t    }\n\n\t    function setupWatchers(field, index) {\n\t      if (isFieldGroup(field) || !_angularFix2['default'].isDefined(field.watcher)) {\n\t        return;\n\t      }\n\t      var watchers = field.watcher;\n\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t        watchers = [watchers];\n\t      }\n\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t        if (!_angularFix2['default'].isDefined(watcher.listener)) {\n\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t        }\n\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t        var watchListener = getWatchListener(watcher, field, index);\n\n\t        var type = watcher.type || '$watch';\n\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t      });\n\t    }\n\n\t    function getWatchExpression(watcher, field, index) {\n\t      var watchExpression = watcher.expression || 'model[\\'' + field.key + '\\']';\n\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t        (function () {\n\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalExpression = watchExpression;\n\t          watchExpression = function formlyWatchExpression() {\n\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t          };\n\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchExpression;\n\t    }\n\n\t    function getWatchListener(watcher, field, index) {\n\t      var watchListener = watcher.listener;\n\t      if (_angularFix2['default'].isFunction(watchListener)) {\n\t        (function () {\n\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalListener = watchListener;\n\t          watchListener = function formlyWatchListener() {\n\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t            return originalListener.apply(undefined, _toConsumableArray(args));\n\t          };\n\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchListener;\n\t    }\n\n\t    function modifyArgs(watcher, index) {\n\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t        originalArgs[_key - 2] = arguments[_key];\n\t      }\n\n\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t    }\n\n\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t    }\n\n\t    function getFormlyFieldLikeLocals(field, index) {\n\t      // this makes it closer to what a regular formlyExpression would be\n\t      return {\n\t        options: field,\n\t        index: index,\n\t        formState: $scope.options.formState,\n\t        formId: $scope.formId\n\t      };\n\t    }\n\t  }\n\n\t  function formlyFormLink(scope, el, attrs) {\n\t    setFormController();\n\t    fixChromeAutocomplete();\n\n\t    function setFormController() {\n\t      var formId = attrs.name;\n\t      scope.formId = formId;\n\t      scope.theFormlyForm = scope[formId];\n\t      if (attrs.form) {\n\t        var getter = $parse(attrs.form);\n\t        var setter = getter.assign;\n\t        var parentForm = getter(scope.$parent);\n\t        if (parentForm) {\n\t          scope.theFormlyForm = parentForm;\n\t          if (scope[formId]) {\n\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t          }\n\n\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t          // to children forms :-( This line was added to solve this issue:\n\t          // https://github.com/formly-js/angular-formly/issues/287\n\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t          // so I expect it will remain this way for the life of angular 1.x\n\t          el.removeData('$formController');\n\t        } else {\n\t          setter(scope.$parent, scope[formId]);\n\t        }\n\t      }\n\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t        /* eslint no-console:0 */\n\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t      }\n\t    }\n\n\t    /*\n\t     * chrome autocomplete lameness\n\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t     * ()   ()     ()\n\t     */\n\t    function fixChromeAutocomplete() {\n\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t      if (global && !offInstance || onInstance) {\n\t        var input = document.createElement('input');\n\t        input.setAttribute('autocomplete', 'address-level4');\n\t        input.setAttribute('hidden', 'true');\n\t        el[0].appendChild(input);\n\t      }\n\t    }\n\t  }\n\n\t  // stateless util functions\n\t  function toKebabCase(string) {\n\t    if (string) {\n\t      return string.replace(/([A-Z])/g, function ($1) {\n\t        return '-' + $1.toLowerCase();\n\t      });\n\t    } else {\n\t      return '';\n\t    }\n\t  }\n\n\t  function isFieldGroup(field) {\n\t    return field && !!field.fieldGroup;\n\t  }\n\t}\n\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\texports['default'] = addFormlyNgModelAttrsManipulator;\n\n\t// @ngInject\n\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t    return;\n\t  }\n\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\n\t  function ngModelAttrsManipulator(template, options, scope) {\n\t    var node = document.createElement('div');\n\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t    if (skip === true) {\n\t      return template;\n\t    }\n\t    node.innerHTML = template;\n\n\t    var modelNodes = getNgModelNodes(node, skip);\n\t    if (!modelNodes || !modelNodes.length) {\n\t      return template;\n\t    }\n\n\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\n\t    addValidation();\n\t    alterNgModelAttr();\n\t    addModelOptions();\n\t    addTemplateOptionsAttrs();\n\t    addNgModelElAttrs();\n\n\t    return node.innerHTML;\n\n\t    function addValidation() {\n\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t      }\n\t    }\n\n\t    function alterNgModelAttr() {\n\t      if (isPropertyAccessor(options.key)) {\n\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t      }\n\t    }\n\n\t    function addModelOptions() {\n\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t        if (options.modelOptions.getterSetter) {\n\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t        }\n\t      }\n\t    }\n\n\t    function addTemplateOptionsAttrs() {\n\t      if (!options.templateOptions && !options.expressionProperties) {\n\t        // no need to run these if there are no templateOptions or expressionProperties\n\t        return;\n\t      }\n\t      var to = options.templateOptions || {};\n\t      var ep = options.expressionProperties || {};\n\n\t      var ngModelAttributes = getBuiltInAttributes();\n\n\t      // extend with the user's specifications winning\n\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\n\t      // Feel free to make this more simple :-)\n\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t        /* eslint complexity:[2, 14] */\n\t        var attrVal = undefined,\n\t            attrName = undefined;\n\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t        var toVal = to[name];\n\t        var epVal = getEpValue(ep, name);\n\n\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t        if (val.value) {\n\t          // I realize this looks backwards, but it's right, trust me...\n\t          attrName = val.value;\n\t          attrVal = name;\n\t        } else if (val.statement && inTo) {\n\t          attrName = val.statement;\n\t          if (_angularFix2['default'].isString(to[name])) {\n\t            attrVal = '$eval(' + ref + ')';\n\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t          } else {\n\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t          }\n\t        } else if (val.bound && inEp) {\n\t          attrName = val.bound;\n\t          attrVal = ref;\n\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t          attrName = val.attribute || val.boolean;\n\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t        } else if (val.attribute && inTo) {\n\t          attrName = val.attribute;\n\t          attrVal = toVal;\n\t        } else if (val.boolean) {\n\t          if (inTo && !inEp && toVal) {\n\t            attrName = val.boolean;\n\t            attrVal = true;\n\t          } else {\n\t            /* eslint no-empty:0 */\n\t            // empty to illustrate that a boolean will not be added via val.bound\n\t            // if you want it added via val.bound, then put it in expressionProperties\n\t          }\n\t        } else if (val.bound && inTo) {\n\t            attrName = val.bound;\n\t            attrVal = ref;\n\t          }\n\n\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t        }\n\t      });\n\t    }\n\n\t    function addNgModelElAttrs() {\n\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t        addRegardlessOfPresence(modelNodes, name, val);\n\t      });\n\t    }\n\t  }\n\n\t  // Utility functions\n\t  function getNgModelNodes(node, skip) {\n\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t    try {\n\t      return node.querySelectorAll(query);\n\t    } catch (e) {\n\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t      //it should be removed when IE8 support is dropped\n\t      return getNgModelNodesFallback(node, skip);\n\t    }\n\t  }\n\n\t  function getNgModelNodesFallback(node, skip) {\n\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t    var matchingNgModelNodes = [];\n\n\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t    matchingNgModelNodes.item = function (i) {\n\t      return this[i];\n\t    };\n\n\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t      var ngModelNode = allNgModelNodes[i];\n\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t        matchingNgModelNodes.push(ngModelNode);\n\t      }\n\t    }\n\n\t    return matchingNgModelNodes;\n\t  }\n\n\t  function nodeMatches(node, selector) {\n\t    var div = document.createElement('div');\n\t    div.innerHTML = node.outerHTML;\n\t    return div.querySelector(selector);\n\t  }\n\n\t  function getBuiltInAttributes() {\n\t    var ngModelAttributes = {\n\t      focus: {\n\t        attribute: 'formly-focus'\n\t      }\n\t    };\n\t    var boundOnly = [];\n\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t    var attributeOnly = ['placeholder', 'min', 'max', 'tabindex', 'type'];\n\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t      bothAttributeAndBound.push('maxlength');\n\t    } else {\n\t      boundOnly.push('maxlength');\n\t    }\n\n\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t      ngModelAttributes[item] = { attribute: item };\n\t    });\n\t    return ngModelAttributes;\n\t  }\n\n\t  function getEpValue(ep, name) {\n\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t  }\n\n\t  function addIfNotPresent(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      if (!node.getAttribute(attr)) {\n\t        node.setAttribute(attr, val);\n\t      }\n\t    });\n\t  }\n\n\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      node.setAttribute(attr, val);\n\t    });\n\t  }\n\n\t  function isPropertyAccessor(key) {\n\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t  }\n\t}\n\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = addCustomTags;\n\n\t// @ngInject\n\tfunction addCustomTags($document) {\n\t  if ($document && $document.get) {\n\t    (function () {\n\t      // IE8 check ->\n\t      // http://stackoverflow.com/questions/10964966/detect-ie-version-prior-to-v9-in-javascript/10965203#10965203\n\t      var document = $document.get(0);\n\t      var div = document.createElement('div');\n\t      div.innerHTML = '<!--[if lt IE 9]><i></i><![endif]-->';\n\t      var isIeLessThan9 = div.getElementsByTagName('i').length === 1;\n\n\t      if (isIeLessThan9) {\n\t        // add the custom elements that we need for formly\n\t        var customElements = ['formly-field', 'formly-form', 'formly-custom-validation', 'formly-focus', 'formly-transpose'];\n\t        _angularFix2['default'].forEach(customElements, function (el) {\n\t          document.createElement(el);\n\t        });\n\t      }\n\t    })();\n\t  }\n\t}\n\taddCustomTags.$inject = [\"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly/dist/formly.js\n ** module id = 7\n ** module chunks = 2\n **/","//! angular-formly-templates-bootstrap version 6.1.5 built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> ( _)==(_ )\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tmodule.exports = __webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar ngModuleName = 'formlyBootstrap';\n\tvar angular = __webpack_require__(2);\n\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t  output: {\n\t    prefix: 'angular-formly-bootstrap'\n\t  }\n\t}));\n\tngModule.constant('formlyBootstrapVersion', (\"6.1.5\"));\n\n\t__webpack_require__(6)(ngModule);\n\t__webpack_require__(9)(ngModule);\n\t__webpack_require__(19)(ngModule);\n\n\texports['default'] = ngModuleName;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tvar angular = __webpack_require__(3);\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\tmodule.exports = angular;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addWrappers);\n\n\t  function addWrappers(formlyConfigProvider) {\n\t    formlyConfigProvider.setWrapper([{\n\t      name: 'bootstrapLabel',\n\t      template: __webpack_require__(7),\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string,\n\t            required: check.bool.optional,\n\t            labelSrOnly: check.bool.optional\n\t          }\n\t        };\n\t      }\n\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t  }\n\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  __webpack_require__(10)(ngModule);\n\t  __webpack_require__(12)(ngModule);\n\t  __webpack_require__(14)(ngModule);\n\t  __webpack_require__(15)(ngModule);\n\t  __webpack_require__(17)(ngModule);\n\t  __webpack_require__(18)(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'checkbox',\n\t      template: __webpack_require__(11),\n\t      wrapper: ['bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'multiCheckbox',\n\t      template: __webpack_require__(13),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      },\n\t      defaultOptions: {\n\t        noFormControl: false,\n\t        ngModelAttrs: {\n\t          required: {\n\t            attribute: '',\n\t            bound: ''\n\t          }\n\t        }\n\t      },\n\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t        var to = $scope.to;\n\t        var opts = $scope.options;\n\t        $scope.multiCheckbox = {\n\t          checked: [],\n\t          change: setModel\n\t        };\n\n\t        // initialize the checkboxes check property\n\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t          var modelValue, valueProp;\n\n\t          if (Object.keys(newModelValue).length) {\n\t            modelValue = newModelValue[opts.key];\n\n\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t                valueProp = to.valueProp || 'value';\n\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t                }\n\t              }\n\t            });\n\t          }\n\t        }, true);\n\n\t        function checkValidity(expressionValue) {\n\t          var valid;\n\n\t          if ($scope.to.required) {\n\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\n\t            $scope.fc.$setValidity('required', valid);\n\t          }\n\t        }\n\n\t        function setModel() {\n\t          $scope.model[opts.key] = [];\n\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t            if (checkbox) {\n\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t            }\n\t          });\n\n\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t          $scope.fc.$setTouched();\n\t          checkValidity(true);\n\t        }\n\n\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t          $scope.$watch(function () {\n\t            return $scope.to.required;\n\t          }, function (newValue) {\n\t            checkValidity(newValue);\n\t          });\n\t        }\n\n\t        if ($scope.to.required) {\n\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t            if (!newValue) {\n\t              return;\n\t            }\n\t            checkValidity(true);\n\t            unwatchFormControl();\n\t          });\n\t        }\n\t      }]\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addInputType);\n\n\t  function addInputType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'input',\n\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t    });\n\t  }\n\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addRadioType);\n\n\t  function addRadioType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'radio',\n\t      template: __webpack_require__(16),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        noFormControl: false\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addSelectType);\n\n\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\n\t  function addSelectType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'select',\n\t      template: template,\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: function defaultOptions(options) {\n\t        /* jshint maxlen:195 */\n\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t        return {\n\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t          })\n\t        };\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            optionsAttr: check.string.optional,\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional,\n\t            groupProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addTextareaType);\n\n\t  function addTextareaType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'textarea',\n\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        ngModelAttrs: {\n\t          rows: { attribute: 'rows' },\n\t          cols: { attribute: 'cols' }\n\t        }\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            rows: check.number.optional,\n\t            cols: check.number.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _addons = __webpack_require__(20);\n\n\tvar _addons2 = _interopRequireDefault(_addons);\n\n\tvar _description = __webpack_require__(22);\n\n\tvar _description2 = _interopRequireDefault(_description);\n\n\texports['default'] = function (ngModule) {\n\t  (0, _addons2['default'])(ngModule);\n\t  (0, _description2['default'])(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addAddonsManipulator);\n\n\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t    var addonTemplate = __webpack_require__(21);\n\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t      'class': formlyBootstrapApiCheck.string.optional,\n\t      text: formlyBootstrapApiCheck.string.optional,\n\t      onClick: formlyBootstrapApiCheck.func.optional\n\t    }).strict.optional;\n\t    var api = formlyBootstrapApiCheck.shape({\n\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t        addonLeft: addonChecker,\n\t        addonRight: addonChecker\n\t      })\n\t    });\n\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t        return template;\n\t      }\n\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t    });\n\t  }\n\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addDescriptionManipulator);\n\n\t  function addDescriptionManipulator(formlyConfig) {\n\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t      if (angular.isDefined(options.templateOptions.description)) {\n\t        var el = document.createElement('div');\n\t        el.appendChild(angular.element(template)[0]);\n\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t        if (modelEls) {\n\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t        }\n\t        return el.innerHTML;\n\t      } else {\n\t        return template;\n\t      }\n\t    });\n\t  }\n\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js\n ** module id = 13\n ** module chunks = 2\n **/","/**\n * angular-permission\n * Route permission and access control as simple as it can get\n * @version v1.1.1 - 2015-11-09\n * @link http://www.rafaelvidaurre.com\n * @author Rafael Vidaurre <narzerus@gmail.com>\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n(function () {\n  'use strict';\n\n  angular.module('permission', ['ui.router'])\n    .run(['$rootScope', 'Permission', '$state', '$q',\n    function ($rootScope, Permission, $state, $q) {\n      $rootScope.$on('$stateChangeStart',\n      function (event, toState, toParams, fromState, fromParams) {\n        if (toState.$$finishAuthorize) {\n          return;\n        }\n\n        // If there are permissions set then prevent default and attempt to authorize\n        var permissions;\n        if (toState.data && toState.data.permissions) {\n          permissions = toState.data.permissions;\n        } else if (toState.permissions) {\n          /**\n          * This way of defining permissions will be depracated in v1. Should use\n          * `data` key instead\n          */\n          console.log('Deprecation Warning: permissions should be set inside the `data` key ');\n          console.log('Setting permissions for a state outside `data` will be depracated in' +\n            ' version 1');\n          permissions = toState.permissions;\n        }\n\n        if (permissions) {\n          event.preventDefault();\n          toState = angular.extend({'$$finishAuthorize': true}, toState);\n\n          if ($rootScope.$broadcast('$stateChangePermissionStart', toState, toParams).defaultPrevented) {\n            return;\n          }\n\n          Permission.authorize(permissions, toParams).then(function () {\n            // If authorized, use call state.go without triggering the event.\n            // Then trigger $stateChangeSuccess manually to resume the rest of the process\n            // Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n              $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams);\n\n              $state.go(toState.name, toParams, {notify: false}).then(function() {\n                $rootScope\n                  .$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams);\n              });\n            }\n          }, function () {\n            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n              $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams);\n\n              var redirectTo = permissions.redirectTo;\n              var result;\n\n              if (angular.isFunction(redirectTo)) {\n                redirectTo = redirectTo();\n\n                $q.when(redirectTo).then(function (newState) {\n                  if (newState) {\n                    $state.go(newState, toParams);\n                  }\n                });\n\n              } else {\n                if (redirectTo) {\n                  $state.go(redirectTo, toParams);\n                }\n              }\n            }\n          });\n        }\n      });\n    }]);\n}());\n\n(function () {\n  'use strict';\n\n  angular.module('permission')\n    .provider('Permission', function () {\n      var roleValidationConfig = {};\n      var validateRoleDefinitionParams = function (roleName, validationFunction) {\n        if (!angular.isString(roleName)) {\n          throw new Error('Role name must be a string');\n        }\n        if (!angular.isFunction(validationFunction)) {\n          throw new Error('Validation function not provided correctly');\n        }\n      };\n\n      var validateManyRolesDefinitionParams = function(roles, validationFunction) {\n        if (!angular.isArray(roles)) {\n          throw new Error('Roles must be an array');\n        } else {\n          for(var i = 0; i < roles.length; i++) {\n            validateRoleDefinitionParams(roles[i], validationFunction);\n          }\n        }\n      };\n\n      this.defineRole = function (roleName, validationFunction) {\n        /**\n          This method is only available in config-time, and cannot access services, as they are\n          not yet injected anywere which makes this kinda useless.\n          Should remove if we cannot find a use for it.\n        **/\n        validateRoleDefinitionParams(roleName, validationFunction);\n        roleValidationConfig[roleName] = validationFunction;\n\n        return this;\n      };\n\n      this.$get = ['$q', function ($q) {\n        var Permission = {\n          _promiseify: function (value) {\n            /**\n              Converts a value into a promise, if the value is truthy it resolves it, otherwise\n              it rejects it\n            **/\n            if (value && angular.isFunction(value.then)) {\n              return value;\n            }\n\n            var deferred = $q.defer();\n            if (value) {\n              deferred.resolve();\n            } else {\n              deferred.reject();\n            }\n            return deferred.promise;\n          },\n          _validateRoleMap: function (roleMap) {\n            if (typeof(roleMap) !== 'object' || roleMap instanceof Array) {\n              throw new Error('Role map has to be an object');\n            }\n            if (roleMap.only === undefined && roleMap.except === undefined) {\n              throw new Error('Either \"only\" or \"except\" keys must me defined');\n            }\n            if (roleMap.only) {\n              if (!(roleMap.only instanceof Array)) {\n                throw new Error('Array of roles expected');\n              }\n            } else if (roleMap.except) {\n              if (!(roleMap.except instanceof Array)) {\n                throw new Error('Array of roles expected');\n              }\n            }\n          },\n          _findMatchingRole: function (rolesArray, toParams) {\n            var roles = angular.copy(rolesArray);\n            var deferred = $q.defer();\n            var currentRole = roles.shift();\n\n            // If no roles left to validate reject promise\n            if (!currentRole) {\n              deferred.reject();\n              return deferred.promise;\n            }\n            // Validate role definition exists\n            if (!angular.isFunction(Permission.roleValidations[currentRole])) {\n              throw new Error('undefined role or invalid role validation');\n            }\n\n            var validatingRole = Permission.roleValidations[currentRole](toParams, currentRole);\n            validatingRole = Permission._promiseify(validatingRole);\n\n            validatingRole.then(function () {\n              deferred.resolve();\n            }, function () {\n              Permission._findMatchingRole(roles, toParams).then(function () {\n                deferred.resolve();\n              }, function () {\n                deferred.reject();\n              });\n            });\n\n            return deferred.promise;\n          },\n          defineRole: function (roleName, validationFunction) {\n            /**\n              Service-available version of defineRole, the callback passed here lives in the\n              scope where it is defined and therefore can interact with other modules\n            **/\n            validateRoleDefinitionParams(roleName, validationFunction);\n            Permission.roleValidations[roleName] = validationFunction;\n\n            return Permission;\n          },\n          defineManyRoles: function(roles, validationFunction) {\n            validateManyRolesDefinitionParams(roles, validationFunction);\n\n            var definedPermissions = Permission;\n            for(var i = 0; i < roles.length; i++) {\n               definedPermissions = definedPermissions.defineRole(roles[i], validationFunction);\n            }\n\n            return definedPermissions;\n          },\n          resolveIfMatch: function (rolesArray, toParams) {\n            var roles = angular.copy(rolesArray);\n            var deferred = $q.defer();\n            Permission._findMatchingRole(roles, toParams).then(function () {\n              // Found role match\n              deferred.resolve();\n            }, function () {\n              // No match\n              deferred.reject();\n            });\n            return deferred.promise;\n          },\n          rejectIfMatch: function (roles, toParams) {\n            var deferred = $q.defer();\n            Permission._findMatchingRole(roles, toParams).then(function () {\n              // Role found\n              deferred.reject();\n            }, function () {\n              // Role not found\n              deferred.resolve();\n            });\n            return deferred.promise;\n          },\n          roleValidations: roleValidationConfig,\n          authorize: function (roleMap, toParams) {\n            // Validate input\n            Permission._validateRoleMap(roleMap);\n\n            var authorizing;\n\n            if (roleMap.only) {\n              authorizing = Permission.resolveIfMatch(roleMap.only, toParams);\n            } else {\n              authorizing = Permission.rejectIfMatch(roleMap.except, toParams);\n            }\n\n            return authorizing;\n          }\n        };\n\n        return Permission;\n      }];\n    });\n\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-permission/dist/angular-permission.js\n ** module id = 14\n ** module chunks = 2\n **/","require('./ui-bootstrap-tpls');\nmodule.exports = 'ui.bootstrap';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/index.js\n ** module id = 15\n ** module chunks = 2\n **/","/**\r\n * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n * @author Mark Lagendijk <mark@lagendijk.info>\r\n * @license MIT\r\n */\r\nangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n        var self = this;\r\n\r\n        /**\r\n         * Recursively sets the states using $stateProvider.state.\r\n         * Child states are defined via a `children` property.\r\n         *\r\n         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n         * 3. Sets `parent` property of the descendant states.\r\n         *\r\n         * @param {Object} state - A regular ui.router state object.\r\n         * @param {Array} [state.children] - An optional array of child states.\r\n         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n         * @param {Object} [options] - An optional options object.\r\n         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n         *     prevents conversion of names to dot notation if true.\r\n         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n         */\r\n        this.state = function(state){\r\n            var args = Array.prototype.slice.apply(arguments);\r\n            var options = {\r\n                keepOriginalNames: false,\r\n                siblingTraversal: false\r\n            };  \r\n\r\n            if (typeof args[1] === 'boolean') {\r\n                options.keepOriginalNames = args[1];\r\n            } \r\n            else if (typeof args[1] === 'object') {\r\n                angular.extend(options, args[1]);\r\n            }\r\n\r\n            if (!options.keepOriginalNames) {\r\n                fixStateName(state);\r\n            }\r\n\r\n            $stateProvider.state(state);\r\n\r\n            if(state.children && state.children.length){\r\n                state.children.forEach(function(childState){\r\n                    childState.parent = state;\r\n                    self.state(childState, options);\r\n                });\r\n\r\n                if (options.siblingTraversal) {\r\n                    addSiblings(state);\r\n                }\r\n            }\r\n\r\n            return self;\r\n        };\r\n\r\n        this.setNestedState = this.state;\r\n\r\n        self.$get = angular.noop;\r\n\r\n        /**\r\n         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n         * @param state\r\n         */\r\n        function fixStateName(state){\r\n            if(state.parent){\r\n                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n            }\r\n        }\r\n\r\n        function addSiblings(state) {\r\n            state.children.forEach(function (childState, idx, array) {\r\n                if (array[idx + 1]) {\r\n                    childState.nextSibling = array[idx + 1].name;\r\n                }\r\n                if (array[idx - 1]) {\r\n                    childState.previousSibling = array[idx - 1].name;\r\n                }\r\n            });\r\n        }\r\n    }]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router.statehelper/statehelper.js\n ** module id = 16\n ** module chunks = 2\n **/","/**\n * State-based routing for AngularJS\n * @version v0.2.15\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\]-]+)|\\{([\\w\\[\\]-]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+(-+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:  surroundPattern = ['?(', ')?']; break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n    type        = $$UMFP.type(regexp || \"string\") || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    var param = this.params[paramName];\n    var paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validate\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  function valToString(val) { return val != null ? val.toString().replace(/\\//g, \"%2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/%2F/g, \"/\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    string: {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    int: {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    bool: {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    date: {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    json: {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    any: { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n      return config.type instanceof Type ? config.type : new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {object} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. if handle is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|object} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = extend({}, state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Re-add the saved hash before we start returning things\n        if (hash) toParams['#'] = hash;\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .value('$stateParams', {})\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        if (result && options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$viewContentLoading\n         * @eventOf ui.router.state.$view\n         * @eventType broadcast on root scope\n         * @description\n         *\n         * Fired once the view **begins loading**, *before* the DOM is rendered.\n         *\n         * @param {Object} event Event object.\n         * @param {Object} viewConfig The view config properties (template, controller, etc).\n         *\n         * @example\n         *\n         * <pre>\n         * $scope.$on('$viewContentLoading',\n         * function(event, viewConfig){\n         *     // Access to all the view config properties.\n         *     // and one special property 'targetView'\n         *     // viewConfig.targetView\n         * });\n         * </pre>\n         */\n          $rootScope.$broadcast('$viewContentLoading', options);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          var promise = $animate.enter(element, null, target, cb);\n          if (promise && promise.then) promise.then(cb);\n        },\n        leave: function(element, cb) {\n          var promise = $animate.leave(element, cb);\n          if (promise && promise.then) promise.then(cb);\n        }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n        scope.$on('$viewContentLoading', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description           *\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           */\n          currentScope.$emit('$viewContentLoaded');\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n * URL, the directive will automatically generate & update the `href` attribute via \n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n * the link will trigger a state transition with optional parameters. \n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative \n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the \n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n * \n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];\n\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n      var params = null, url = null, base = stateContext(element) || $state.$current;\n      // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n      var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?\n                 'xlink:href' : 'href';\n      var newHref = null, isAnchor = element.prop(\"tagName\").toUpperCase() === \"A\";\n      var isForm = element[0].nodeName === \"FORM\";\n      var attr = isForm ? \"action\" : hrefKind, nav = true;\n\n      var options = { relative: base, inherit: true };\n      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\n      angular.forEach(allowedOptions, function(option) {\n        if (option in optionsOverride) {\n          options[option] = optionsOverride[option];\n        }\n      });\n\n      var update = function(newVal) {\n        if (newVal) params = angular.copy(newVal);\n        if (!nav) return;\n\n        newHref = $state.href(ref.state, params, options);\n\n        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n        if (activeDirective) {\n          activeDirective.$$addStateInfo(ref.state, params);\n        }\n        if (newHref === null) {\n          nav = false;\n          return false;\n        }\n        attrs.$set(attr, newHref);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n          if (newVal !== params) update(newVal);\n        }, true);\n        params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (isForm) return;\n\n      element.bind(\"click\", function(e) {\n        var button = e.which || e.button;\n        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n          var transition = $timeout(function() {\n            $state.go(ref.state, params, options);\n          });\n          e.preventDefault();\n\n          // if the state has no URL, ignore one preventDefault from the <a> directive.\n          var ignorePreventDefaultCount = isAnchor && !newHref ? 1: 0;\n          e.preventDefault = function() {\n            if (ignorePreventDefaultCount-- <= 0)\n              $timeout.cancel(transition);\n          };\n        }\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n      var states = [], activeClass;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        var state = $state.get(newState, stateContext($element));\n\n        states.push({\n          state: state || { name: newState },\n          params: newParams\n        });\n\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      // Update route state\n      function update() {\n        if (anyMatch()) {\n          $element.addClass(activeClass);\n        } else {\n          $element.removeClass(activeClass);\n        }\n      }\n\n      function anyMatch() {\n        for (var i = 0; i < states.length; i++) {\n          if (isMatch(states[i].state, states[i].params)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      function isMatch(state, params) {\n        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n          return $state.is(state.name, params);\n        } else {\n          return $state.includes(state.name, params);\n        }\n      }\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state) {\n    return $state.is(state);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state) {\n    return $state.includes(state);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router/release/angular-ui-router.js\n ** module id = 17\n ** module chunks = 2\n **/","(function (root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(['angular'], factory);\n  } else if (root.hasOwnProperty('angular')) {\n    // Browser globals (root is window), we don't register it.\n    factory(root.angular);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('angular'));\n  }\n}(this , function (angular) {\n    'use strict';\n\n    // In cases where Angular does not get passed or angular is a truthy value\n    // but misses .module we can fall back to using window.\n    angular = (angular && angular.module ) ? angular : window.angular;\n\n    /**\n     * @ngdoc overview\n     * @name ngStorage\n     */\n\n    return angular.module('ngStorage', [])\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$localStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$localStorage', _storageProvider('localStorage'))\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$sessionStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\n    function _storageProvider(storageType) {\n        return function () {\n          var storageKeyPrefix = 'ngStorage-';\n\n          this.setKeyPrefix = function (prefix) {\n            if (typeof prefix !== 'string') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n            }\n            storageKeyPrefix = prefix;\n          };\n\n          var serializer = angular.toJson;\n          var deserializer = angular.fromJson;\n\n          this.setSerializer = function (s) {\n            if (typeof s !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n            }\n\n            serializer = s;\n          };\n\n          this.setDeserializer = function (d) {\n            if (typeof d !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n            }\n\n            deserializer = d;\n          };\n\n          // Note: This is not very elegant at all.\n          this.get = function (key) {\n            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n          };\n\n          // Note: This is not very elegant at all.\n          this.set = function (key, value) {\n            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n          };\n\n          this.$get = [\n              '$rootScope',\n              '$window',\n              '$log',\n              '$timeout',\n              '$document',\n\n              function(\n                  $rootScope,\n                  $window,\n                  $log,\n                  $timeout,\n                  $document\n              ){\n                function isStorageSupported(storageType) {\n\n                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n                    // that error and allow execution to continue.\n\n                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n                    // when \"Block cookies\": \"Always block\" is turned on\n                    var supported;\n                    try {\n                        supported = $window[storageType];\n                    }\n                    catch (err) {\n                        supported = false;\n                    }\n\n                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n                    // is available, but trying to call .setItem throws an exception below:\n                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n                    if (supported && storageType === 'localStorage') {\n                        var key = '__' + Math.round(Math.random() * 1e7);\n\n                        try {\n                            localStorage.setItem(key, key);\n                            localStorage.removeItem(key);\n                        }\n                        catch (err) {\n                            supported = false;\n                        }\n                    }\n\n                    return supported;\n                }\n\n                // The magic number 10 is used which only works for some keyPrefixes...\n                // See https://github.com/gsklee/ngStorage/issues/137\n                var prefixLength = storageKeyPrefix.length;\n\n                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n                    $storage = {\n                        $default: function(items) {\n                            for (var k in items) {\n                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n                            }\n\n                            $storage.$sync();\n                            return $storage;\n                        },\n                        $reset: function(items) {\n                            for (var k in $storage) {\n                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n                            }\n\n                            return $storage.$default(items);\n                        },\n                        $sync: function () {\n                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n                            }\n                        },\n                        $apply: function() {\n                            var temp$storage;\n\n                            _debounce = null;\n\n                            if (!angular.equals($storage, _last$storage)) {\n                                temp$storage = angular.copy(_last$storage);\n                                angular.forEach($storage, function(v, k) {\n                                    if (angular.isDefined(v) && '$' !== k[0]) {\n                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n                                        delete temp$storage[k];\n                                    }\n                                });\n\n                                for (var k in temp$storage) {\n                                    webStorage.removeItem(storageKeyPrefix + k);\n                                }\n\n                                _last$storage = angular.copy($storage);\n                            }\n                        }\n                    },\n                    _last$storage,\n                    _debounce;\n\n                $storage.$sync();\n\n                _last$storage = angular.copy($storage);\n\n                $rootScope.$watch(function() {\n                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n                });\n\n                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n                $window.addEventListener && $window.addEventListener('storage', function(event) {\n                    if (!event.key) {\n                      return;\n                    }\n\n                    // Reference doc.\n                    var doc = $document[0];\n\n                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\n                        _last$storage = angular.copy($storage);\n\n                        $rootScope.$apply();\n                    }\n                });\n\n                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n                    $storage.$apply();\n                });\n\n                return $storage;\n              }\n          ];\n      };\n    }\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngstorage/ngStorage.js\n ** module id = 24\n ** module chunks = 2\n **/","/**\r\n * oclazyload - Load modules on demand (lazy load) with angularJS\r\n * @version v1.0.8\r\n * @link https://github.com/ocombe/ocLazyLoad\r\n * @license MIT\r\n * @author Olivier Combe <olivier.combe@gmail.com>\r\n */\r\n(function (angular, window) {\r\n    'use strict';\r\n\r\n    var regModules = ['ng', 'oc.lazyLoad'],\r\n        regInvokes = {},\r\n        regConfigs = [],\r\n        modulesToLoad = [],\r\n        // modules to load from angular.module or other sources\r\n    realModules = [],\r\n        // real modules called from angular.module\r\n    recordDeclarations = [],\r\n        broadcast = angular.noop,\r\n        runBlocks = {},\r\n        justLoaded = [];\r\n\r\n    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\r\n\r\n    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\r\n        var modules = {},\r\n            providers = {\r\n            $controllerProvider: $controllerProvider,\r\n            $compileProvider: $compileProvider,\r\n            $filterProvider: $filterProvider,\r\n            $provide: $provide, // other things (constant, decorator, provider, factory, service)\r\n            $injector: $injector,\r\n            $animateProvider: $animateProvider\r\n        },\r\n            debug = false,\r\n            events = false,\r\n            moduleCache = [],\r\n            modulePromises = {};\r\n\r\n        moduleCache.push = function (value) {\r\n            if (this.indexOf(value) === -1) {\r\n                Array.prototype.push.apply(this, arguments);\r\n            }\r\n        };\r\n\r\n        this.config = function (config) {\r\n            // If we want to define modules configs\r\n            if (angular.isDefined(config.modules)) {\r\n                if (angular.isArray(config.modules)) {\r\n                    angular.forEach(config.modules, function (moduleConfig) {\r\n                        modules[moduleConfig.name] = moduleConfig;\r\n                    });\r\n                } else {\r\n                    modules[config.modules.name] = config.modules;\r\n                }\r\n            }\r\n\r\n            if (angular.isDefined(config.debug)) {\r\n                debug = config.debug;\r\n            }\r\n\r\n            if (angular.isDefined(config.events)) {\r\n                events = config.events;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Get the list of existing registered modules\r\n         * @param element\r\n         */\r\n        this._init = function _init(element) {\r\n            // this is probably useless now because we override angular.bootstrap\r\n            if (modulesToLoad.length === 0) {\r\n                var elements = [element],\r\n                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\r\n                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\r\n                    append = function append(elm) {\r\n                    return elm && elements.push(elm);\r\n                };\r\n\r\n                angular.forEach(names, function (name) {\r\n                    names[name] = true;\r\n                    append(document.getElementById(name));\r\n                    name = name.replace(':', '\\\\:');\r\n                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\r\n                        angular.forEach(element[0].querySelectorAll('.' + name), append);\r\n                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\r\n                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\r\n                    }\r\n                });\r\n\r\n                angular.forEach(elements, function (elm) {\r\n                    if (modulesToLoad.length === 0) {\r\n                        var className = ' ' + element.className + ' ';\r\n                        var match = NG_APP_CLASS_REGEXP.exec(className);\r\n                        if (match) {\r\n                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\r\n                        } else {\r\n                            angular.forEach(elm.attributes, function (attr) {\r\n                                if (modulesToLoad.length === 0 && names[attr.name]) {\r\n                                    modulesToLoad.push(attr.value);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\r\n                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\r\n            }\r\n\r\n            var addReg = function addReg(moduleName) {\r\n                if (regModules.indexOf(moduleName) === -1) {\r\n                    // register existing modules\r\n                    regModules.push(moduleName);\r\n                    var mainModule = angular.module(moduleName);\r\n\r\n                    // register existing components (directives, services, ...)\r\n                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\r\n                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\r\n\r\n                    angular.forEach(mainModule.requires, addReg);\r\n                }\r\n            };\r\n\r\n            angular.forEach(modulesToLoad, function (moduleName) {\r\n                addReg(moduleName);\r\n            });\r\n\r\n            modulesToLoad = []; // reset for next bootstrap\r\n            recordDeclarations.pop(); // wait for the next lazy load\r\n        };\r\n\r\n        /**\r\n         * Like JSON.stringify but that doesn't throw on circular references\r\n         * @param obj\r\n         */\r\n        var stringify = function stringify(obj) {\r\n            try {\r\n                return JSON.stringify(obj);\r\n            } catch (e) {\r\n                var cache = [];\r\n                return JSON.stringify(obj, function (key, value) {\r\n                    if (angular.isObject(value) && value !== null) {\r\n                        if (cache.indexOf(value) !== -1) {\r\n                            // Circular reference found, discard key\r\n                            return;\r\n                        }\r\n                        // Store value in our collection\r\n                        cache.push(value);\r\n                    }\r\n                    return value;\r\n                });\r\n            }\r\n        };\r\n\r\n        var hashCode = function hashCode(str) {\r\n            var hash = 0,\r\n                i,\r\n                chr,\r\n                len;\r\n            if (str.length == 0) {\r\n                return hash;\r\n            }\r\n            for (i = 0, len = str.length; i < len; i++) {\r\n                chr = str.charCodeAt(i);\r\n                hash = (hash << 5) - hash + chr;\r\n                hash |= 0; // Convert to 32bit integer\r\n            }\r\n            return hash;\r\n        };\r\n\r\n        function _register(providers, registerModules, params) {\r\n            if (registerModules) {\r\n                var k,\r\n                    moduleName,\r\n                    moduleFn,\r\n                    tempRunBlocks = [];\r\n                for (k = registerModules.length - 1; k >= 0; k--) {\r\n                    moduleName = registerModules[k];\r\n                    if (!angular.isString(moduleName)) {\r\n                        moduleName = getModuleName(moduleName);\r\n                    }\r\n                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\r\n                        continue;\r\n                    }\r\n                    // new if not registered\r\n                    var newModule = regModules.indexOf(moduleName) === -1;\r\n                    moduleFn = ngModuleFct(moduleName);\r\n                    if (newModule) {\r\n                        regModules.push(moduleName);\r\n                        _register(providers, moduleFn.requires, params);\r\n                    }\r\n                    if (moduleFn._runBlocks.length > 0) {\r\n                        // new run blocks detected! Replace the old ones (if existing)\r\n                        runBlocks[moduleName] = [];\r\n                        while (moduleFn._runBlocks.length > 0) {\r\n                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\r\n                        }\r\n                    }\r\n                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\r\n                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\r\n                    }\r\n                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\r\n                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\r\n                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\r\n                    registerModules.pop();\r\n                    justLoaded.push(moduleName);\r\n                }\r\n                // execute the run blocks at the end\r\n                var instanceInjector = providers.getInstanceInjector();\r\n                angular.forEach(tempRunBlocks, function (fn) {\r\n                    instanceInjector.invoke(fn);\r\n                });\r\n            }\r\n        }\r\n\r\n        function _registerInvokeList(args, moduleName) {\r\n            var invokeList = args[2][0],\r\n                type = args[1],\r\n                newInvoke = false;\r\n            if (angular.isUndefined(regInvokes[moduleName])) {\r\n                regInvokes[moduleName] = {};\r\n            }\r\n            if (angular.isUndefined(regInvokes[moduleName][type])) {\r\n                regInvokes[moduleName][type] = {};\r\n            }\r\n            var onInvoke = function onInvoke(invokeName, invoke) {\r\n                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\r\n                    regInvokes[moduleName][type][invokeName] = [];\r\n                }\r\n                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\r\n                    newInvoke = true;\r\n                    regInvokes[moduleName][type][invokeName].push(invoke);\r\n                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\r\n                }\r\n            };\r\n\r\n            function checkHashes(potentialNew, invokes) {\r\n                var isNew = true,\r\n                    newHash;\r\n                if (invokes.length) {\r\n                    newHash = signature(potentialNew);\r\n                    angular.forEach(invokes, function (invoke) {\r\n                        isNew = isNew && signature(invoke) !== newHash;\r\n                    });\r\n                }\r\n                return isNew;\r\n            }\r\n\r\n            function signature(data) {\r\n                if (angular.isArray(data)) {\r\n                    // arrays are objects, we need to test for it first\r\n                    return hashCode(data.toString());\r\n                } else if (angular.isObject(data)) {\r\n                    // constants & values for example\r\n                    return hashCode(stringify(data));\r\n                } else {\r\n                    if (angular.isDefined(data) && data !== null) {\r\n                        return hashCode(data.toString());\r\n                    } else {\r\n                        // null & undefined constants\r\n                        return data;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (angular.isString(invokeList)) {\r\n                onInvoke(invokeList, args[2][1]);\r\n            } else if (angular.isObject(invokeList)) {\r\n                angular.forEach(invokeList, function (invoke, key) {\r\n                    if (angular.isString(invoke)) {\r\n                        // decorators for example\r\n                        onInvoke(invoke, invokeList[1]);\r\n                    } else {\r\n                        // components registered as object lists {\"componentName\": function() {}}\r\n                        onInvoke(key, invoke);\r\n                    }\r\n                });\r\n            } else {\r\n                return false;\r\n            }\r\n            return newInvoke;\r\n        }\r\n\r\n        function _invokeQueue(providers, queue, moduleName, reconfig) {\r\n            if (!queue) {\r\n                return;\r\n            }\r\n\r\n            var i, len, args, provider;\r\n            for (i = 0, len = queue.length; i < len; i++) {\r\n                args = queue[i];\r\n                if (angular.isArray(args)) {\r\n                    if (providers !== null) {\r\n                        if (providers.hasOwnProperty(args[0])) {\r\n                            provider = providers[args[0]];\r\n                        } else {\r\n                            throw new Error('unsupported provider ' + args[0]);\r\n                        }\r\n                    }\r\n                    var isNew = _registerInvokeList(args, moduleName);\r\n                    if (args[1] !== 'invoke') {\r\n                        if (isNew && angular.isDefined(provider)) {\r\n                            provider[args[1]].apply(provider, args[2]);\r\n                        }\r\n                    } else {\r\n                        // config block\r\n                        var callInvoke = function callInvoke(fct) {\r\n                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\r\n                            if (invoked === -1 || reconfig) {\r\n                                if (invoked === -1) {\r\n                                    regConfigs.push(moduleName + '-' + fct);\r\n                                }\r\n                                if (angular.isDefined(provider)) {\r\n                                    provider[args[1]].apply(provider, args[2]);\r\n                                }\r\n                            }\r\n                        };\r\n                        if (angular.isFunction(args[2][0])) {\r\n                            callInvoke(args[2][0]);\r\n                        } else if (angular.isArray(args[2][0])) {\r\n                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\r\n                                if (angular.isFunction(args[2][0][j])) {\r\n                                    callInvoke(args[2][0][j]);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function getModuleName(module) {\r\n            var moduleName = null;\r\n            if (angular.isString(module)) {\r\n                moduleName = module;\r\n            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\r\n                moduleName = module.name;\r\n            }\r\n            return moduleName;\r\n        }\r\n\r\n        function moduleExists(moduleName) {\r\n            if (!angular.isString(moduleName)) {\r\n                return false;\r\n            }\r\n            try {\r\n                return ngModuleFct(moduleName);\r\n            } catch (e) {\r\n                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\r\n            var instanceInjector,\r\n                filesCache = $cacheFactory('ocLazyLoad');\r\n\r\n            if (!debug) {\r\n                $log = {};\r\n                $log['error'] = angular.noop;\r\n                $log['warn'] = angular.noop;\r\n                $log['info'] = angular.noop;\r\n            }\r\n\r\n            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\r\n            providers.getInstanceInjector = function () {\r\n                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\r\n            };\r\n\r\n            broadcast = function broadcast(eventName, params) {\r\n                if (events) {\r\n                    $rootScope.$broadcast(eventName, params);\r\n                }\r\n                if (debug) {\r\n                    $log.info(eventName, params);\r\n                }\r\n            };\r\n\r\n            function reject(e) {\r\n                var deferred = $q.defer();\r\n                $log.error(e.message);\r\n                deferred.reject(e);\r\n                return deferred.promise;\r\n            }\r\n\r\n            return {\r\n                _broadcast: broadcast,\r\n\r\n                _$log: $log,\r\n\r\n                /**\r\n                 * Returns the files cache used by the loaders to store the files currently loading\r\n                 * @returns {*}\r\n                 */\r\n                _getFilesCache: function getFilesCache() {\r\n                    return filesCache;\r\n                },\r\n\r\n                /**\r\n                 * Let the service know that it should monitor angular.module because files are loading\r\n                 * @param watch boolean\r\n                 */\r\n                toggleWatch: function toggleWatch(watch) {\r\n                    if (watch) {\r\n                        recordDeclarations.push(true);\r\n                    } else {\r\n                        recordDeclarations.pop();\r\n                    }\r\n                },\r\n\r\n                /**\r\n                 * Let you get a module config object\r\n                 * @param moduleName String the name of the module\r\n                 * @returns {*}\r\n                 */\r\n                getModuleConfig: function getModuleConfig(moduleName) {\r\n                    if (!angular.isString(moduleName)) {\r\n                        throw new Error('You need to give the name of the module to get');\r\n                    }\r\n                    if (!modules[moduleName]) {\r\n                        return null;\r\n                    }\r\n                    return angular.copy(modules[moduleName]);\r\n                },\r\n\r\n                /**\r\n                 * Let you define a module config object\r\n                 * @param moduleConfig Object the module config object\r\n                 * @returns {*}\r\n                 */\r\n                setModuleConfig: function setModuleConfig(moduleConfig) {\r\n                    if (!angular.isObject(moduleConfig)) {\r\n                        throw new Error('You need to give the module config object to set');\r\n                    }\r\n                    modules[moduleConfig.name] = moduleConfig;\r\n                    return moduleConfig;\r\n                },\r\n\r\n                /**\r\n                 * Returns the list of loaded modules\r\n                 * @returns {string[]}\r\n                 */\r\n                getModules: function getModules() {\r\n                    return regModules;\r\n                },\r\n\r\n                /**\r\n                 * Let you check if a module has been loaded into Angular or not\r\n                 * @param modulesNames String/Object a module name, or a list of module names\r\n                 * @returns {boolean}\r\n                 */\r\n                isLoaded: function isLoaded(modulesNames) {\r\n                    var moduleLoaded = function moduleLoaded(module) {\r\n                        var isLoaded = regModules.indexOf(module) > -1;\r\n                        if (!isLoaded) {\r\n                            isLoaded = !!moduleExists(module);\r\n                        }\r\n                        return isLoaded;\r\n                    };\r\n                    if (angular.isString(modulesNames)) {\r\n                        modulesNames = [modulesNames];\r\n                    }\r\n                    if (angular.isArray(modulesNames)) {\r\n                        var i, len;\r\n                        for (i = 0, len = modulesNames.length; i < len; i++) {\r\n                            if (!moduleLoaded(modulesNames[i])) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                        return true;\r\n                    } else {\r\n                        throw new Error('You need to define the module(s) name(s)');\r\n                    }\r\n                },\r\n\r\n                /**\r\n                 * Given a module, return its name\r\n                 * @param module\r\n                 * @returns {String}\r\n                 */\r\n                _getModuleName: getModuleName,\r\n\r\n                /**\r\n                 * Returns a module if it exists\r\n                 * @param moduleName\r\n                 * @returns {module}\r\n                 */\r\n                _getModule: function getModule(moduleName) {\r\n                    try {\r\n                        return ngModuleFct(moduleName);\r\n                    } catch (e) {\r\n                        // this error message really suxx\r\n                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\r\n                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\r\n                        }\r\n                        throw e;\r\n                    }\r\n                },\r\n\r\n                /**\r\n                 * Check if a module exists and returns it if it does\r\n                 * @param moduleName\r\n                 * @returns {boolean}\r\n                 */\r\n                moduleExists: moduleExists,\r\n\r\n                /**\r\n                 * Load the dependencies, and might try to load new files depending on the config\r\n                 * @param moduleName (String or Array of Strings)\r\n                 * @param localParams\r\n                 * @returns {*}\r\n                 * @private\r\n                 */\r\n                _loadDependencies: function _loadDependencies(moduleName, localParams) {\r\n                    var loadedModule,\r\n                        requires,\r\n                        diff,\r\n                        promisesList = [],\r\n                        self = this;\r\n\r\n                    moduleName = self._getModuleName(moduleName);\r\n\r\n                    if (moduleName === null) {\r\n                        return $q.when();\r\n                    } else {\r\n                        try {\r\n                            loadedModule = self._getModule(moduleName);\r\n                        } catch (e) {\r\n                            return reject(e);\r\n                        }\r\n                        // get unloaded requires\r\n                        requires = self.getRequires(loadedModule);\r\n                    }\r\n\r\n                    angular.forEach(requires, function (requireEntry) {\r\n                        // If no configuration is provided, try and find one from a previous load.\r\n                        // If there isn't one, bail and let the normal flow run\r\n                        if (angular.isString(requireEntry)) {\r\n                            var config = self.getModuleConfig(requireEntry);\r\n                            if (config === null) {\r\n                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\r\n                                return;\r\n                            }\r\n                            requireEntry = config;\r\n                            // ignore the name because it's probably not a real module name\r\n                            config.name = undefined;\r\n                        }\r\n\r\n                        // Check if this dependency has been loaded previously\r\n                        if (self.moduleExists(requireEntry.name)) {\r\n                            // compare against the already loaded module to see if the new definition adds any new files\r\n                            diff = requireEntry.files.filter(function (n) {\r\n                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\r\n                            });\r\n\r\n                            // If the module was redefined, advise via the console\r\n                            if (diff.length !== 0) {\r\n                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\r\n                            }\r\n\r\n                            // Push everything to the file loader, it will weed out the duplicates.\r\n                            if (angular.isDefined(self.filesLoader)) {\r\n                                // if a files loader is defined\r\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\r\n                                    return self._loadDependencies(requireEntry);\r\n                                }));\r\n                            } else {\r\n                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\r\n                            }\r\n                            return;\r\n                        } else if (angular.isArray(requireEntry)) {\r\n                            var files = [];\r\n                            angular.forEach(requireEntry, function (entry) {\r\n                                // let's check if the entry is a file name or a config name\r\n                                var config = self.getModuleConfig(entry);\r\n                                if (config === null) {\r\n                                    files.push(entry);\r\n                                } else if (config.files) {\r\n                                    files = files.concat(config.files);\r\n                                }\r\n                            });\r\n                            if (files.length > 0) {\r\n                                requireEntry = {\r\n                                    files: files\r\n                                };\r\n                            }\r\n                        } else if (angular.isObject(requireEntry)) {\r\n                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\r\n                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\r\n                                self.setModuleConfig(requireEntry);\r\n                                moduleCache.push(requireEntry['name']);\r\n                            }\r\n                        }\r\n\r\n                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\r\n                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\r\n                            if (angular.isDefined(self.filesLoader)) {\r\n                                // if a files loader is defined\r\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\r\n                                    return self._loadDependencies(requireEntry);\r\n                                }));\r\n                            } else {\r\n                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\r\n                    return $q.all(promisesList);\r\n                },\r\n\r\n                /**\r\n                 * Inject new modules into Angular\r\n                 * @param moduleName\r\n                 * @param localParams\r\n                 * @param real\r\n                 */\r\n                inject: function inject(moduleName) {\r\n                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\r\n                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\r\n\r\n                    var self = this,\r\n                        deferred = $q.defer();\r\n                    if (angular.isDefined(moduleName) && moduleName !== null) {\r\n                        if (angular.isArray(moduleName)) {\r\n                            var promisesList = [];\r\n                            angular.forEach(moduleName, function (module) {\r\n                                promisesList.push(self.inject(module, localParams, real));\r\n                            });\r\n                            return $q.all(promisesList);\r\n                        } else {\r\n                            self._addToLoadList(self._getModuleName(moduleName), true, real);\r\n                        }\r\n                    }\r\n                    if (modulesToLoad.length > 0) {\r\n                        var res = modulesToLoad.slice(); // clean copy\r\n                        var loadNext = function loadNext(moduleName) {\r\n                            moduleCache.push(moduleName);\r\n                            modulePromises[moduleName] = deferred.promise;\r\n                            self._loadDependencies(moduleName, localParams).then(function success() {\r\n                                try {\r\n                                    justLoaded = [];\r\n                                    _register(providers, moduleCache, localParams);\r\n                                } catch (e) {\r\n                                    self._$log.error(e.message);\r\n                                    deferred.reject(e);\r\n                                    return;\r\n                                }\r\n\r\n                                if (modulesToLoad.length > 0) {\r\n                                    loadNext(modulesToLoad.shift()); // load the next in list\r\n                                } else {\r\n                                        deferred.resolve(res); // everything has been loaded, resolve\r\n                                    }\r\n                            }, function error(err) {\r\n                                deferred.reject(err);\r\n                            });\r\n                        };\r\n\r\n                        // load the first in list\r\n                        loadNext(modulesToLoad.shift());\r\n                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\r\n                        return modulePromises[localParams.name];\r\n                    } else {\r\n                        deferred.resolve();\r\n                    }\r\n                    return deferred.promise;\r\n                },\r\n\r\n                /**\r\n                 * Get the list of required modules/services/... for this module\r\n                 * @param module\r\n                 * @returns {Array}\r\n                 */\r\n                getRequires: function getRequires(module) {\r\n                    var requires = [];\r\n                    angular.forEach(module.requires, function (requireModule) {\r\n                        if (regModules.indexOf(requireModule) === -1) {\r\n                            requires.push(requireModule);\r\n                        }\r\n                    });\r\n                    return requires;\r\n                },\r\n\r\n                /**\r\n                 * Invoke the new modules & component by their providers\r\n                 * @param providers\r\n                 * @param queue\r\n                 * @param moduleName\r\n                 * @param reconfig\r\n                 * @private\r\n                 */\r\n                _invokeQueue: _invokeQueue,\r\n\r\n                /**\r\n                 * Check if a module has been invoked and registers it if not\r\n                 * @param args\r\n                 * @param moduleName\r\n                 * @returns {boolean} is new\r\n                 */\r\n                _registerInvokeList: _registerInvokeList,\r\n\r\n                /**\r\n                 * Register a new module and loads it, executing the run/config blocks if needed\r\n                 * @param providers\r\n                 * @param registerModules\r\n                 * @param params\r\n                 * @private\r\n                 */\r\n                _register: _register,\r\n\r\n                /**\r\n                 * Add a module name to the list of modules that will be loaded in the next inject\r\n                 * @param name\r\n                 * @param force\r\n                 * @private\r\n                 */\r\n                _addToLoadList: _addToLoadList\r\n            };\r\n        }];\r\n\r\n        // Let's get the list of loaded modules & components\r\n        this._init(angular.element(window.document));\r\n    }]);\r\n\r\n    var bootstrapFct = angular.bootstrap;\r\n    angular.bootstrap = function (element, modules, config) {\r\n        // we use slice to make a clean copy\r\n        angular.forEach(modules.slice(), function (module) {\r\n            _addToLoadList(module, true, true);\r\n        });\r\n        return bootstrapFct(element, modules, config);\r\n    };\r\n\r\n    var _addToLoadList = function _addToLoadList(name, force, real) {\r\n        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\r\n            modulesToLoad.push(name);\r\n            if (real) {\r\n                realModules.push(name);\r\n            }\r\n        }\r\n    };\r\n\r\n    var ngModuleFct = angular.module;\r\n    angular.module = function (name, requires, configFn) {\r\n        _addToLoadList(name, false, true);\r\n        return ngModuleFct(name, requires, configFn);\r\n    };\r\n\r\n    // CommonJS package manager support:\r\n    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\r\n        module.exports = 'oc.lazyLoad';\r\n    }\r\n})(angular, window);\r\n(function (angular) {\r\n    'use strict';\r\n\r\n    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\r\n        return {\r\n            restrict: 'A',\r\n            terminal: true,\r\n            priority: 1000,\r\n            compile: function compile(element, attrs) {\r\n                // we store the content and remove it before compilation\r\n                var content = element[0].innerHTML;\r\n                element.html('');\r\n\r\n                return function ($scope, $element, $attr) {\r\n                    var model = $parse($attr.ocLazyLoad);\r\n                    $scope.$watch(function () {\r\n                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\r\n                    }, function (moduleName) {\r\n                        if (angular.isDefined(moduleName)) {\r\n                            $ocLazyLoad.load(moduleName).then(function () {\r\n                                // Attach element contents to DOM and then compile them.\r\n                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\r\n                                // of the compiled contents when attaching to the parent DOM.\r\n                                $animate.enter(content, $element);\r\n                                // get the new content & compile it\r\n                                $compile($element.contents())($scope);\r\n                            });\r\n                        }\r\n                    }, true);\r\n                };\r\n            }\r\n        };\r\n    }]);\r\n})(angular);\r\n(function (angular) {\r\n    'use strict';\r\n\r\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\r\n            var uaCssChecked = false,\r\n                useCssLoadPatch = false,\r\n                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\r\n\r\n            /**\r\n             * Load a js/css file\r\n             * @param type\r\n             * @param path\r\n             * @param params\r\n             * @returns promise\r\n             */\r\n            $delegate.buildElement = function buildElement(type, path, params) {\r\n                var deferred = $q.defer(),\r\n                    el,\r\n                    loaded,\r\n                    filesCache = $delegate._getFilesCache(),\r\n                    cacheBuster = function cacheBuster(url) {\r\n                    var dc = new Date().getTime();\r\n                    if (url.indexOf('?') >= 0) {\r\n                        if (url.substring(0, url.length - 1) === '&') {\r\n                            return url + '_dc=' + dc;\r\n                        }\r\n                        return url + '&_dc=' + dc;\r\n                    } else {\r\n                        return url + '?_dc=' + dc;\r\n                    }\r\n                };\r\n\r\n                // Store the promise early so the file load can be detected by other parallel lazy loads\r\n                // (ie: multiple routes on one page) a 'true' value isn't sufficient\r\n                // as it causes false positive load results.\r\n                if (angular.isUndefined(filesCache.get(path))) {\r\n                    filesCache.put(path, deferred.promise);\r\n                }\r\n\r\n                // Switch in case more content types are added later\r\n                switch (type) {\r\n                    case 'css':\r\n                        el = $window.document.createElement('link');\r\n                        el.type = 'text/css';\r\n                        el.rel = 'stylesheet';\r\n                        el.href = params.cache === false ? cacheBuster(path) : path;\r\n                        break;\r\n                    case 'js':\r\n                        el = $window.document.createElement('script');\r\n                        el.src = params.cache === false ? cacheBuster(path) : path;\r\n                        break;\r\n                    default:\r\n                        filesCache.remove(path);\r\n                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\r\n                        break;\r\n                }\r\n                el.onload = el['onreadystatechange'] = function (e) {\r\n                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\r\n                    el.onload = el['onreadystatechange'] = null;\r\n                    loaded = 1;\r\n                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\r\n                    deferred.resolve();\r\n                };\r\n                el.onerror = function () {\r\n                    filesCache.remove(path);\r\n                    deferred.reject(new Error('Unable to load ' + path));\r\n                };\r\n                el.async = params.serie ? 0 : 1;\r\n\r\n                var insertBeforeElem = anchor.lastChild;\r\n                if (params.insertBefore) {\r\n                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\r\n                    if (element && element.length > 0) {\r\n                        insertBeforeElem = element[0];\r\n                    }\r\n                }\r\n                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\r\n\r\n                /*\r\n                 The event load or readystatechange doesn't fire in:\r\n                 - iOS < 6       (default mobile browser)\r\n                 - Android < 4.4 (default mobile browser)\r\n                 - Safari < 6    (desktop browser)\r\n                 */\r\n                if (type == 'css') {\r\n                    if (!uaCssChecked) {\r\n                        var ua = $window.navigator.userAgent.toLowerCase();\r\n\r\n                        // iOS < 6\r\n                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\r\n                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\r\n                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\r\n                            useCssLoadPatch = iOSVersion < 6;\r\n                        } else if (ua.indexOf(\"android\") > -1) {\r\n                            // Android < 4.4\r\n                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\r\n                            useCssLoadPatch = androidVersion < 4.4;\r\n                        } else if (ua.indexOf('safari') > -1) {\r\n                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\r\n                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\r\n                        }\r\n                    }\r\n\r\n                    if (useCssLoadPatch) {\r\n                        var tries = 1000; // * 20 = 20000 miliseconds\r\n                        var interval = $interval(function () {\r\n                            try {\r\n                                el.sheet.cssRules;\r\n                                $interval.cancel(interval);\r\n                                el.onload();\r\n                            } catch (e) {\r\n                                if (--tries <= 0) {\r\n                                    el.onerror();\r\n                                }\r\n                            }\r\n                        }, 20);\r\n                    }\r\n                }\r\n\r\n                return deferred.promise;\r\n            };\r\n\r\n            return $delegate;\r\n        }]);\r\n    }]);\r\n})(angular);\r\n(function (angular) {\r\n    'use strict';\r\n\r\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\r\n            /**\r\n             * The function that loads new files\r\n             * @param config\r\n             * @param params\r\n             * @returns {*}\r\n             */\r\n            $delegate.filesLoader = function filesLoader(config) {\r\n                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\r\n\r\n                var cssFiles = [],\r\n                    templatesFiles = [],\r\n                    jsFiles = [],\r\n                    promises = [],\r\n                    cachePromise = null,\r\n                    filesCache = $delegate._getFilesCache();\r\n\r\n                $delegate.toggleWatch(true); // start watching angular.module calls\r\n\r\n                angular.extend(params, config);\r\n\r\n                var pushFile = function pushFile(path) {\r\n                    var file_type = null,\r\n                        m;\r\n                    if (angular.isObject(path)) {\r\n                        file_type = path.type;\r\n                        path = path.path;\r\n                    }\r\n                    cachePromise = filesCache.get(path);\r\n                    if (angular.isUndefined(cachePromise) || params.cache === false) {\r\n\r\n                        // always check for requirejs syntax just in case\r\n                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\r\n                            // Detect file type using preceding type declaration (ala requireJS)\r\n                            file_type = m[1];\r\n                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\r\n                        }\r\n\r\n                        if (!file_type) {\r\n                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\r\n                                // Detect file type via file extension\r\n                                file_type = m[1];\r\n                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\r\n                                // requirejs\r\n                                file_type = 'js';\r\n                            } else {\r\n                                $delegate._$log.error('File type could not be determined. ' + path);\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\r\n                            cssFiles.push(path);\r\n                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\r\n                            templatesFiles.push(path);\r\n                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\r\n                            jsFiles.push(path);\r\n                        } else {\r\n                            $delegate._$log.error('File type is not valid. ' + path);\r\n                        }\r\n                    } else if (cachePromise) {\r\n                        promises.push(cachePromise);\r\n                    }\r\n                };\r\n\r\n                if (params.serie) {\r\n                    pushFile(params.files.shift());\r\n                } else {\r\n                    angular.forEach(params.files, function (path) {\r\n                        pushFile(path);\r\n                    });\r\n                }\r\n\r\n                if (cssFiles.length > 0) {\r\n                    var cssDeferred = $q.defer();\r\n                    $delegate.cssLoader(cssFiles, function (err) {\r\n                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\r\n                            $delegate._$log.error(err);\r\n                            cssDeferred.reject(err);\r\n                        } else {\r\n                            cssDeferred.resolve();\r\n                        }\r\n                    }, params);\r\n                    promises.push(cssDeferred.promise);\r\n                }\r\n\r\n                if (templatesFiles.length > 0) {\r\n                    var templatesDeferred = $q.defer();\r\n                    $delegate.templatesLoader(templatesFiles, function (err) {\r\n                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\r\n                            $delegate._$log.error(err);\r\n                            templatesDeferred.reject(err);\r\n                        } else {\r\n                            templatesDeferred.resolve();\r\n                        }\r\n                    }, params);\r\n                    promises.push(templatesDeferred.promise);\r\n                }\r\n\r\n                if (jsFiles.length > 0) {\r\n                    var jsDeferred = $q.defer();\r\n                    $delegate.jsLoader(jsFiles, function (err) {\r\n                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\r\n                            $delegate._$log.error(err);\r\n                            jsDeferred.reject(err);\r\n                        } else {\r\n                            jsDeferred.resolve();\r\n                        }\r\n                    }, params);\r\n                    promises.push(jsDeferred.promise);\r\n                }\r\n\r\n                if (promises.length === 0) {\r\n                    var deferred = $q.defer(),\r\n                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\r\n                    $delegate._$log.error(err);\r\n                    deferred.reject(err);\r\n                    return deferred.promise;\r\n                } else if (params.serie && params.files.length > 0) {\r\n                    return $q.all(promises).then(function () {\r\n                        return $delegate.filesLoader(config, params);\r\n                    });\r\n                } else {\r\n                    return $q.all(promises)['finally'](function (res) {\r\n                        $delegate.toggleWatch(false); // stop watching angular.module calls\r\n                        return res;\r\n                    });\r\n                }\r\n            };\r\n\r\n            /**\r\n             * Load a module or a list of modules into Angular\r\n             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n             * @param params Object optional parameters\r\n             * @returns promise\r\n             */\r\n            $delegate.load = function (originalModule) {\r\n                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\r\n\r\n                var self = this,\r\n                    config = null,\r\n                    deferredList = [],\r\n                    deferred = $q.defer(),\r\n                    errText;\r\n\r\n                // clean copy\r\n                var module = angular.copy(originalModule);\r\n                var params = angular.copy(originalParams);\r\n\r\n                // If module is an array, break it down\r\n                if (angular.isArray(module)) {\r\n                    // Resubmit each entry as a single module\r\n                    angular.forEach(module, function (m) {\r\n                        deferredList.push(self.load(m, params));\r\n                    });\r\n\r\n                    // Resolve the promise once everything has loaded\r\n                    $q.all(deferredList).then(function (res) {\r\n                        deferred.resolve(res);\r\n                    }, function (err) {\r\n                        deferred.reject(err);\r\n                    });\r\n\r\n                    return deferred.promise;\r\n                }\r\n\r\n                // Get or Set a configuration depending on what was passed in\r\n                if (angular.isString(module)) {\r\n                    config = self.getModuleConfig(module);\r\n                    if (!config) {\r\n                        config = {\r\n                            files: [module]\r\n                        };\r\n                    }\r\n                } else if (angular.isObject(module)) {\r\n                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\r\n                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\r\n                        config = {\r\n                            files: [module]\r\n                        };\r\n                    } else {\r\n                        config = self.setModuleConfig(module);\r\n                    }\r\n                }\r\n\r\n                if (config === null) {\r\n                    var moduleName = self._getModuleName(module);\r\n                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\r\n                    $delegate._$log.error(errText);\r\n                    deferred.reject(new Error(errText));\r\n                    return deferred.promise;\r\n                } else {\r\n                    // deprecated\r\n                    if (angular.isDefined(config.template)) {\r\n                        if (angular.isUndefined(config.files)) {\r\n                            config.files = [];\r\n                        }\r\n                        if (angular.isString(config.template)) {\r\n                            config.files.push(config.template);\r\n                        } else if (angular.isArray(config.template)) {\r\n                            config.files.concat(config.template);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var localParams = angular.extend({}, params, config);\r\n\r\n                // if someone used an external loader and called the load function with just the module name\r\n                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\r\n                    return $delegate.inject(config.name, localParams, true);\r\n                }\r\n\r\n                $delegate.filesLoader(config, localParams).then(function () {\r\n                    $delegate.inject(null, localParams).then(function (res) {\r\n                        deferred.resolve(res);\r\n                    }, function (err) {\r\n                        deferred.reject(err);\r\n                    });\r\n                }, function (err) {\r\n                    deferred.reject(err);\r\n                });\r\n\r\n                return deferred.promise;\r\n            };\r\n\r\n            // return the patched service\r\n            return $delegate;\r\n        }]);\r\n    }]);\r\n})(angular);\r\n(function (angular) {\r\n    'use strict';\r\n\r\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\r\n            /**\r\n             * cssLoader function\r\n             * @type Function\r\n             * @param paths array list of css files to load\r\n             * @param callback to call when everything is loaded. We use a callback and not a promise\r\n             * @param params object config parameters\r\n             * because the user can overwrite cssLoader and it will probably not use promises :(\r\n             */\r\n            $delegate.cssLoader = function (paths, callback, params) {\r\n                var promises = [];\r\n                angular.forEach(paths, function (path) {\r\n                    promises.push($delegate.buildElement('css', path, params));\r\n                });\r\n                $q.all(promises).then(function () {\r\n                    callback();\r\n                }, function (err) {\r\n                    callback(err);\r\n                });\r\n            };\r\n            $delegate.cssLoader.ocLazyLoadLoader = true;\r\n\r\n            return $delegate;\r\n        }]);\r\n    }]);\r\n})(angular);\r\n(function (angular) {\r\n    'use strict';\r\n\r\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\r\n            /**\r\n             * jsLoader function\r\n             * @type Function\r\n             * @param paths array list of js files to load\r\n             * @param callback to call when everything is loaded. We use a callback and not a promise\r\n             * @param params object config parameters\r\n             * because the user can overwrite jsLoader and it will probably not use promises :(\r\n             */\r\n            $delegate.jsLoader = function (paths, callback, params) {\r\n                var promises = [];\r\n                angular.forEach(paths, function (path) {\r\n                    promises.push($delegate.buildElement('js', path, params));\r\n                });\r\n                $q.all(promises).then(function () {\r\n                    callback();\r\n                }, function (err) {\r\n                    callback(err);\r\n                });\r\n            };\r\n            $delegate.jsLoader.ocLazyLoadLoader = true;\r\n\r\n            return $delegate;\r\n        }]);\r\n    }]);\r\n})(angular);\r\n(function (angular) {\r\n    'use strict';\r\n\r\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\r\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\r\n            /**\r\n             * templatesLoader function\r\n             * @type Function\r\n             * @param paths array list of css files to load\r\n             * @param callback to call when everything is loaded. We use a callback and not a promise\r\n             * @param params object config parameters for $http\r\n             * because the user can overwrite templatesLoader and it will probably not use promises :(\r\n             */\r\n            $delegate.templatesLoader = function (paths, callback, params) {\r\n                var promises = [],\r\n                    filesCache = $delegate._getFilesCache();\r\n\r\n                angular.forEach(paths, function (url) {\r\n                    var deferred = $q.defer();\r\n                    promises.push(deferred.promise);\r\n                    $http.get(url, params).success(function (data) {\r\n                        if (angular.isString(data) && data.length > 0) {\r\n                            angular.forEach(angular.element(data), function (node) {\r\n                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\r\n                                    $templateCache.put(node.id, node.innerHTML);\r\n                                }\r\n                            });\r\n                        }\r\n                        if (angular.isUndefined(filesCache.get(url))) {\r\n                            filesCache.put(url, true);\r\n                        }\r\n                        deferred.resolve();\r\n                    }).error(function (err) {\r\n                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\r\n                    });\r\n                });\r\n                return $q.all(promises).then(function () {\r\n                    callback();\r\n                }, function (err) {\r\n                    callback(err);\r\n                });\r\n            };\r\n            $delegate.templatesLoader.ocLazyLoadLoader = true;\r\n\r\n            return $delegate;\r\n        }]);\r\n    }]);\r\n})(angular);\r\n// Array.indexOf polyfill for IE8\r\nif (!Array.prototype.indexOf) {\r\n        Array.prototype.indexOf = function (searchElement, fromIndex) {\r\n                var k;\r\n\r\n                // 1. Let O be the result of calling ToObject passing\r\n                //    the this value as the argument.\r\n                if (this == null) {\r\n                        throw new TypeError('\"this\" is null or not defined');\r\n                }\r\n\r\n                var O = Object(this);\r\n\r\n                // 2. Let lenValue be the result of calling the Get\r\n                //    internal method of O with the argument \"length\".\r\n                // 3. Let len be ToUint32(lenValue).\r\n                var len = O.length >>> 0;\r\n\r\n                // 4. If len is 0, return -1.\r\n                if (len === 0) {\r\n                        return -1;\r\n                }\r\n\r\n                // 5. If argument fromIndex was passed let n be\r\n                //    ToInteger(fromIndex); else let n be 0.\r\n                var n = +fromIndex || 0;\r\n\r\n                if (Math.abs(n) === Infinity) {\r\n                        n = 0;\r\n                }\r\n\r\n                // 6. If n >= len, return -1.\r\n                if (n >= len) {\r\n                        return -1;\r\n                }\r\n\r\n                // 7. If n >= 0, then Let k be n.\r\n                // 8. Else, n<0, Let k be len - abs(n).\r\n                //    If k is less than 0, then let k be 0.\r\n                k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\r\n\r\n                // 9. Repeat, while k < len\r\n                while (k < len) {\r\n                        // a. Let Pk be ToString(k).\r\n                        //   This is implicit for LHS operands of the in operator\r\n                        // b. Let kPresent be the result of calling the\r\n                        //    HasProperty internal method of O with argument Pk.\r\n                        //   This step can be combined with c\r\n                        // c. If kPresent is true, then\r\n                        //    i.  Let elementK be the result of calling the Get\r\n                        //        internal method of O with the argument ToString(k).\r\n                        //   ii.  Let same be the result of applying the\r\n                        //        Strict Equality Comparison Algorithm to\r\n                        //        searchElement and elementK.\r\n                        //  iii.  If same is true, return k.\r\n                        if (k in O && O[k] === searchElement) {\r\n                                return k;\r\n                        }\r\n                        k++;\r\n                }\r\n                return -1;\r\n        };\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/oclazyload/dist/ocLazyLoad.js\n ** module id = 25\n ** module chunks = 2\n **/","/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 0.14.3 - 2015-10-23\n * License: MIT\n */\nangular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module(\"ui.bootstrap.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/carousel/carousel.html\",\"template/carousel/slide.html\",\"template/datepicker/datepicker.html\",\"template/datepicker/day.html\",\"template/datepicker/month.html\",\"template/datepicker/popup.html\",\"template/datepicker/year.html\",\"template/modal/backdrop.html\",\"template/modal/window.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/tooltip/tooltip-template-popup.html\",\"template/popover/popover-html.html\",\"template/popover/popover-template.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/progressbar/progressbar.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/timepicker/timepicker.html\",\"template/typeahead/typeahead-match.html\",\"template/typeahead/typeahead-popup.html\"]);\nangular.module('ui.bootstrap.collapse', [])\n\n  .directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        function expand() {\n          element.removeClass('collapse')\n            .addClass('collapsing')\n            .attr('aria-expanded', true)\n            .attr('aria-hidden', false);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              addClass: 'in',\n              easing: 'ease',\n              to: { height: element[0].scrollHeight + 'px' }\n            }).start().finally(expandDone);\n          } else {\n            $animate.addClass(element, 'in', {\n              to: { height: element[0].scrollHeight + 'px' }\n            }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse')\n            .css({height: 'auto'});\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          element\n            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n            // Otherwise, the browser attempts to animate from height 0 (in\n            // collapsing class) to the given height here.\n            .css({height: element[0].scrollHeight + 'px'})\n            // initially all panel collapse have the collapse class, this removal\n            // prevents the animation from jumping to collapsed state\n            .removeClass('collapse')\n            .addClass('collapsing')\n            .attr('aria-expanded', false)\n            .attr('aria-hidden', true);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              removeClass: 'in',\n              to: {height: '0'}\n            }).start().finally(collapseDone);\n          } else {\n            $animate.removeClass(element, 'in', {\n              to: {height: '0'}\n            }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n        }\n\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\n/* Deprecated collapse below */\n\nangular.module('ui.bootstrap.collapse')\n\n  .value('$collapseSuppressWarning', false)\n\n  .directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        if (!$collapseSuppressWarning) {\n          $log.warn('collapse is now deprecated. Use uib-collapse instead.');\n        }\n\n        function expand() {\n          element.removeClass('collapse')\n            .addClass('collapsing')\n            .attr('aria-expanded', true)\n            .attr('aria-hidden', false);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              easing: 'ease',\n              to: { height: element[0].scrollHeight + 'px' }\n            }).start().done(expandDone);\n          } else {\n            $animate.animate(element, {}, {\n              height: element[0].scrollHeight + 'px'\n            }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse in')\n            .css({height: 'auto'});\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          element\n            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n            // Otherwise, the browser attempts to animate from height 0 (in\n            // collapsing class) to the given height here.\n            .css({height: element[0].scrollHeight + 'px'})\n            // initially all panel collapse have the collapse class, this removal\n            // prevents the animation from jumping to collapsed state\n            .removeClass('collapse in')\n            .addClass('collapsing')\n            .attr('aria-expanded', false)\n            .attr('aria-hidden', true);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              to: {height: '0'}\n            }).start().done(collapseDone);\n          } else {\n            $animate.animate(element, {}, {\n              height: '0'\n            }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n        }\n\n        scope.$watch(attrs.collapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\n.constant('uibAccordionConfig', {\n  closeOthers: true\n})\n\n.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if (closeOthers) {\n      angular.forEach(this.groups, function(group) {\n        if (group !== openGroup) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function(event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if (index !== -1) {\n      this.groups.splice(index, 1);\n    }\n  };\n\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('uibAccordion', function() {\n  return {\n    controller: 'UibAccordionController',\n    controllerAs: 'accordion',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/accordion/accordion.html';\n    }\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('uibAccordionGroup', function() {\n  return {\n    require: '^uibAccordion',         // We need this directive to be inside an accordion\n    transclude: true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/accordion/accordion-group.html';\n    },\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      accordionCtrl.addGroup(scope);\n\n      scope.openClass = attrs.openClass || 'panel-open';\n      scope.panelClass = attrs.panelClass;\n      scope.$watch('isOpen', function(value) {\n        element.toggleClass(scope.openClass, !!value);\n        if (value) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function($event) {\n        if (!scope.isDisabled) {\n          if (!$event || $event.which === 32) {\n            scope.isOpen = !scope.isOpen;\n          }\n        }\n      };\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n.directive('uibAccordionHeading', function() {\n  return {\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n.directive('uibAccordionTransclude', function() {\n  return {\n    require: ['?^uibAccordionGroup', '?^accordionGroup'],\n    link: function(scope, element, attrs, controller) {\n      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n        if (heading) {\n          element.find('span').html('');\n          element.find('span').append(heading);\n        }\n      });\n    }\n  };\n});\n\n/* Deprecated accordion below */\n\nangular.module('ui.bootstrap.accordion')\n\n  .value('$accordionSuppressWarning', false)\n\n  .controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {\n    if (!$accordionSuppressWarning) {\n      $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');\n    }\n\n    angular.extend(this, $controller('UibAccordionController', {\n      $scope: $scope,\n      $attrs: $attrs\n    }));\n  }])\n\n  .directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      restrict: 'EA',\n      controller: 'AccordionController',\n      controllerAs: 'accordion',\n      transclude: true,\n      replace: false,\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || 'template/accordion/accordion.html';\n      },\n      link: function() {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion is now deprecated. Use uib-accordion instead.');\n        }\n      }\n    };\n  }])\n\n  .directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      require: '^accordion',         // We need this directive to be inside an accordion\n      restrict: 'EA',\n      transclude: true,              // It transcludes the contents of the directive into the template\n      replace: true,                // The element containing the directive will be replaced with the template\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || 'template/accordion/accordion-group.html';\n      },\n      scope: {\n        heading: '@',               // Interpolate the heading attribute onto this scope\n        isOpen: '=?',\n        isDisabled: '=?'\n      },\n      controller: function() {\n        this.setHeading = function(element) {\n          this.heading = element;\n        };\n      },\n      link: function(scope, element, attrs, accordionCtrl) {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');\n        }\n\n        accordionCtrl.addGroup(scope);\n\n        scope.openClass = attrs.openClass || 'panel-open';\n        scope.panelClass = attrs.panelClass;\n        scope.$watch('isOpen', function(value) {\n          element.toggleClass(scope.openClass, !!value);\n          if (value) {\n            accordionCtrl.closeOthers(scope);\n          }\n        });\n\n        scope.toggleOpen = function($event) {\n          if (!scope.isDisabled) {\n            if (!$event || $event.which === 32) {\n              scope.isOpen = !scope.isOpen;\n            }\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      restrict: 'EA',\n      transclude: true,   // Grab the contents to be used as the heading\n      template: '',       // In effect remove this element!\n      replace: true,\n      require: '^accordionGroup',\n      link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');\n        }\n        // Pass the heading to the accordion-group controller\n        // so that it can be transcluded into the right place in the template\n        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n      }\n    };\n  }])\n\n  .directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      require: '^accordionGroup',\n      link: function(scope, element, attr, controller) {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');\n        }\n\n        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n          if (heading) {\n            element.find('span').html('');\n            element.find('span').append(heading);\n          }\n        });\n      }\n    };\n  }]);\n\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n  $scope.closeable = !!$attrs.close;\n\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\n  if (dismissOnTimeout) {\n    $timeout(function() {\n      $scope.close();\n    }, parseInt(dismissOnTimeout, 10));\n  }\n}])\n\n.directive('uibAlert', function() {\n  return {\n    controller: 'UibAlertController',\n    controllerAs: 'alert',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/alert/alert.html';\n    },\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@',\n      close: '&'\n    }\n  };\n});\n\n/* Deprecated alert below */\n\nangular.module('ui.bootstrap.alert')\n\n  .value('$alertSuppressWarning', false)\n\n  .controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {\n    if (!$alertSuppressWarning) {\n      $log.warn('AlertController is now deprecated. Use UibAlertController instead.');\n    }\n\n    angular.extend(this, $controller('UibAlertController', {\n      $scope: $scope,\n      $attrs: $attrs\n    }));\n  }])\n\n  .directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {\n    return {\n      controller: 'AlertController',\n      controllerAs: 'alert',\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || 'template/alert/alert.html';\n      },\n      transclude: true,\n      replace: true,\n      scope: {\n        type: '@',\n        close: '&'\n      },\n      link: function() {\n        if (!$alertSuppressWarning) {\n          $log.warn('alert is now deprecated. Use uib-alert instead.');\n        }\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('uibButtonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('uibBtnRadio', function() {\n  return {\n    require: ['uibBtnRadio', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'buttons',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n    }\n  };\n})\n\n.directive('uibBtnCheckbox', function() {\n  return {\n    require: ['uibBtnCheckbox', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'button',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attribute, defaultValue) {\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        scope.$apply(function() {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\n/* Deprecated buttons below */\n\nangular.module('ui.bootstrap.buttons')\n\n  .value('$buttonsSuppressWarning', false)\n\n  .controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {\n    if (!$buttonsSuppressWarning) {\n      $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');\n    }\n\n    angular.extend(this, $controller('UibButtonsController'));\n  }])\n\n  .directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {\n    return {\n      require: ['btnRadio', 'ngModel'],\n      controller: 'ButtonsController',\n      controllerAs: 'buttons',\n      link: function(scope, element, attrs, ctrls) {\n        if (!$buttonsSuppressWarning) {\n          $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');\n        }\n\n        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        element.find('input').css({display: 'none'});\n\n        //model -> UI\n        ngModelCtrl.$render = function() {\n          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n        };\n\n        //ui->model\n        element.bind(buttonsCtrl.toggleEvent, function() {\n          if (attrs.disabled) {\n            return;\n          }\n\n          var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n          if (!isActive || angular.isDefined(attrs.uncheckable)) {\n            scope.$apply(function() {\n              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n              ngModelCtrl.$render();\n            });\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {\n    return {\n      require: ['btnCheckbox', 'ngModel'],\n      controller: 'ButtonsController',\n      controllerAs: 'button',\n      link: function(scope, element, attrs, ctrls) {\n        if (!$buttonsSuppressWarning) {\n          $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');\n        }\n\n        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        element.find('input').css({display: 'none'});\n\n        function getTrueValue() {\n          return getCheckboxValue(attrs.btnCheckboxTrue, true);\n        }\n\n        function getFalseValue() {\n          return getCheckboxValue(attrs.btnCheckboxFalse, false);\n        }\n\n        function getCheckboxValue(attributeValue, defaultValue) {\n          var val = scope.$eval(attributeValue);\n          return angular.isDefined(val) ? val : defaultValue;\n        }\n\n        //model -> UI\n        ngModelCtrl.$render = function() {\n          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n        };\n\n        //ui->model\n        element.bind(buttonsCtrl.toggleEvent, function() {\n          if (attrs.disabled) {\n            return;\n          }\n\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n            ngModelCtrl.$render();\n          });\n        });\n\n        //accessibility\n        element.on('keypress', function(e) {\n          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {\n            return;\n          }\n\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n            ngModelCtrl.$render();\n          });\n        });\n      }\n    };\n  }]);\n\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.carousel\n *\n * @description\n * AngularJS version of an image carousel.\n *\n */\nangular.module('ui.bootstrap.carousel', [])\n\n.controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    NEW_ANIMATE = angular.version.minor >= 4,\n    NO_TRANSITION = 'uib-noTransition',\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    currentIndex = -1,\n    currentInterval, isPlaying;\n  self.currentSlide = null;\n\n  var destroyed = false;\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = $scope.indexOfSlide(nextSlide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n    }\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {\n      goNext(nextSlide, nextIndex, direction);\n    }\n  };\n\n  function goNext(slide, index, direction) {\n    // Scope has been destroyed, stop here.\n    if (destroyed) { return; }\n\n    angular.extend(slide, {direction: direction, active: true});\n    angular.extend(self.currentSlide || {}, {direction: direction, active: false});\n    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&\n      slide.$element && self.slides.length > 1) {\n      slide.$element.data(SLIDE_DIRECTION, slide.direction);\n      if (self.currentSlide && self.currentSlide.$element) {\n        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);\n      }\n\n      $scope.$currentTransition = true;\n      if (NEW_ANIMATE) {\n        $animate.on('addClass', slide.$element, function(element, phase) {\n          if (phase === 'close') {\n            $scope.$currentTransition = null;\n            $animate.off('addClass', element);\n          }\n        });\n      } else {\n        slide.$element.one('$animate:close', function closeFn() {\n          $scope.$currentTransition = null;\n        });\n      }\n    }\n\n    self.currentSlide = slide;\n    currentIndex = index;\n\n    //every time you change slides, reset the timer\n    restartTimer();\n  }\n\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n\n  function getSlideByIndex(index) {\n    if (angular.isUndefined(slides[index].index)) {\n      return slides[index];\n    }\n    var i, len = slides.length;\n    for (i = 0; i < slides.length; ++i) {\n      if (slides[i].index == index) {\n        return slides[i];\n      }\n    }\n  }\n\n  self.getCurrentIndex = function() {\n    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {\n      return +self.currentSlide.index;\n    }\n    return currentIndex;\n  };\n\n  /* Allow outside people to call indexOf on slides array */\n  $scope.indexOfSlide = function(slide) {\n    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);\n  };\n\n  $scope.next = function() {\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\n    if (newIndex === 0 && $scope.noWrap()) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), 'next');\n  };\n\n  $scope.prev = function() {\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), 'prev');\n  };\n\n  $scope.isActive = function(slide) {\n     return self.currentSlide === slide;\n  };\n\n  $scope.$watch('interval', restartTimer);\n  $scope.$watchCollection('slides', resetTransition);\n  $scope.$on('$destroy', resetTimer);\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval > 0) {\n      currentInterval = $interval(timerFn, interval);\n    }\n  }\n\n  function resetTimer() {\n    if (currentInterval) {\n      $interval.cancel(currentInterval);\n      currentInterval = null;\n    }\n  }\n\n  function timerFn() {\n    var interval = +$scope.interval;\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n      $scope.next();\n    } else {\n      $scope.pause();\n    }\n  }\n\n  function resetTransition(slides) {\n    if (!slides.length) {\n      $scope.$currentTransition = null;\n    }\n  }\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  self.addSlide = function(slide, element) {\n    slide.$element = element;\n    slides.push(slide);\n    //if this is the first slide or the slide is set to active, select it\n    if (slides.length === 1 || slide.active) {\n      self.select(slides[slides.length - 1]);\n      if (slides.length === 1) {\n        $scope.play();\n      }\n    } else {\n      slide.active = false;\n    }\n  };\n\n  self.removeSlide = function(slide) {\n    if (angular.isDefined(slide.index)) {\n      slides.sort(function(a, b) {\n        return +a.index > +b.index;\n      });\n    }\n    //get the index of the slide inside the carousel\n    var index = slides.indexOf(slide);\n    slides.splice(index, 1);\n    if (slides.length > 0 && slide.active) {\n      if (index >= slides.length) {\n        self.select(slides[index - 1]);\n      } else {\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n    }\n\n    //clean the currentSlide when no more slide\n    if (slides.length === 0) {\n      self.currentSlide = null;\n    }\n  };\n\n  $scope.$watch('noTransition', function(noTransition) {\n    $element.data(NO_TRANSITION, noTransition);\n  });\n\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:carousel\n * @restrict EA\n *\n * @description\n * Carousel is the outer container for a set of image 'slides' to showcase.\n *\n * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <uib-carousel>\n      <uib-slide>\n        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>Beautiful!</p>\n        </div>\n      </uib-slide>\n      <uib-slide>\n        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>D'aww!</p>\n        </div>\n      </uib-slide>\n    </uib-carousel>\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n */\n.directive('uibCarousel', [function() {\n  return {\n    transclude: true,\n    replace: true,\n    controller: 'UibCarouselController',\n    controllerAs: 'carousel',\n    require: 'carousel',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/carousel.html';\n    },\n    scope: {\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    }\n  };\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:slide\n * @restrict EA\n *\n * @description\n * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n *\n * @param {boolean=} active Model binding, whether or not this slide is currently active.\n * @param {number=} index The index of the slide. The slides will be sorted by this parameter.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n<div ng-controller=\"CarouselDemoCtrl\">\n  <uib-carousel>\n    <uib-slide ng-repeat=\"slide in slides\" active=\"slide.active\" index=\"$index\">\n      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n      <div class=\"carousel-caption\">\n        <h4>Slide {{$index}}</h4>\n        <p>{{slide.text}}</p>\n      </div>\n    </uib-slide>\n  </uib-carousel>\n  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n  <br />Enter a negative number to stop the interval.\n</div>\n  </file>\n  <file name=\"script.js\">\nfunction CarouselDemoCtrl($scope) {\n  $scope.myInterval = 5000;\n}\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n*/\n\n.directive('uibSlide', function() {\n  return {\n    require: '^uibCarousel',\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/slide.html';\n    },\n    scope: {\n      active: '=?',\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n})\n\n.animation('.item', [\n         '$injector', '$animate',\nfunction ($injector, $animate) {\n  var NO_TRANSITION = 'uib-noTransition',\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    $animateCss = null;\n\n  if ($injector.has('$animateCss')) {\n    $animateCss = $injector.get('$animateCss');\n  }\n\n  function removeClass(element, className, callback) {\n    element.removeClass(className);\n    if (callback) {\n      callback();\n    }\n  }\n\n  return {\n    beforeAddClass: function(element, className, done) {\n      // Due to transclusion, noTransition property is on parent's scope\n      if (className == 'active' && element.parent() && element.parent().parent() &&\n          !element.parent().parent().data(NO_TRANSITION)) {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction == 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element,\n          directionClass + ' ' + direction, done);\n        element.addClass(direction);\n\n        if ($animateCss) {\n          $animateCss(element, {addClass: directionClass})\n            .start()\n            .done(removeClassFn);\n        } else {\n          $animate.addClass(element, directionClass).then(function () {\n            if (!stopped) {\n              removeClassFn();\n            }\n            done();\n          });\n        }\n\n        return function () {\n          stopped = true;\n        };\n      }\n      done();\n    },\n    beforeRemoveClass: function (element, className, done) {\n      // Due to transclusion, noTransition property is on parent's scope\n      if (className === 'active' && element.parent() && element.parent().parent() &&\n          !element.parent().parent().data(NO_TRANSITION)) {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction == 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\n        if ($animateCss) {\n          $animateCss(element, {addClass: directionClass})\n            .start()\n            .done(removeClassFn);\n        } else {\n          $animate.addClass(element, directionClass).then(function() {\n            if (!stopped) {\n              removeClassFn();\n            }\n            done();\n          });\n        }\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    }\n  };\n}]);\n\n/* deprecated carousel below */\n\nangular.module('ui.bootstrap.carousel')\n\n.value('$carouselSuppressWarning', false)\n\n.controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {\n  if (!$carouselSuppressWarning) {\n    $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');\n  }\n\n  angular.extend(this, $controller('UibCarouselController', {\n    $scope: $scope,\n    $element: $element\n  }));\n}])\n\n.directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n  return {\n    transclude: true,\n    replace: true,\n    controller: 'CarouselController',\n    controllerAs: 'carousel',\n    require: 'carousel',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/carousel.html';\n    },\n    scope: {\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    },\n    link: function() {\n      if (!$carouselSuppressWarning) {\n        $log.warn('carousel is now deprecated. Use uib-carousel instead.');\n      }\n    }\n  };\n}])\n\n.directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n  return {\n    require: '^carousel',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/slide.html';\n    },\n    scope: {\n      active: '=?',\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      if (!$carouselSuppressWarning) {\n        $log.warn('slide is now deprecated. Use uib-slide instead.');\n      }\n\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  var localeId;\n  var formatCodeToRegex;\n\n  this.init = function() {\n    localeId = $locale.id;\n\n    this.parsers = {};\n\n    formatCodeToRegex = {\n      'yyyy': {\n        regex: '\\\\d{4}',\n        apply: function(value) { this.year = +value; }\n      },\n      'yy': {\n        regex: '\\\\d{2}',\n        apply: function(value) { this.year = +value + 2000; }\n      },\n      'y': {\n        regex: '\\\\d{1,4}',\n        apply: function(value) { this.year = +value; }\n      },\n      'MMMM': {\n        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n      },\n      'MMM': {\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n      },\n      'MM': {\n        regex: '0[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; }\n      },\n      'M': {\n        regex: '[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; }\n      },\n      'dd': {\n        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; }\n      },\n      'd': {\n        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; }\n      },\n      'EEEE': {\n        regex: $locale.DATETIME_FORMATS.DAY.join('|')\n      },\n      'EEE': {\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n      },\n      'HH': {\n        regex: '(?:0|1)[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'hh': {\n        regex: '0[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'H': {\n        regex: '1?[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'h': {\n        regex: '[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'mm': {\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.minutes = +value; }\n      },\n      'm': {\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.minutes = +value; }\n      },\n      'sss': {\n        regex: '[0-9][0-9][0-9]',\n        apply: function(value) { this.milliseconds = +value; }\n      },\n      'ss': {\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.seconds = +value; }\n      },\n      's': {\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.seconds = +value; }\n      },\n      'a': {\n        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n        apply: function(value) {\n          if (this.hours === 12) {\n            this.hours = 0;\n          }\n\n          if (value === 'PM') {\n            this.hours += 12;\n          }\n        }\n      }\n    };\n  };\n\n  this.init();\n\n  function createParser(format) {\n    var map = [], regex = format.split('');\n\n    angular.forEach(formatCodeToRegex, function(data, code) {\n      var index = format.indexOf(code);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + code.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({ index: index, apply: data.apply });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  this.parse = function(input, format, baseDate) {\n    if (!angular.isString(input) || !format) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.parsers[format]) {\n      this.parsers[format] = createParser(format);\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex);\n\n    if (results && results.length) {\n      var fields, dt;\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n        fields = {\n          year: baseDate.getFullYear(),\n          month: baseDate.getMonth(),\n          date: baseDate.getDate(),\n          hours: baseDate.getHours(),\n          minutes: baseDate.getMinutes(),\n          seconds: baseDate.getSeconds(),\n          milliseconds: baseDate.getMilliseconds()\n        };\n      } else {\n        if (baseDate) {\n          $log.warn('dateparser:', 'baseDate is not a valid date');\n        }\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n      }\n\n      for (var i = 1, n = results.length; i < n; i++) {\n        var mapper = map[i-1];\n        if (mapper.apply) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      if (isValid(fields.year, fields.month, fields.date)) {\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n          dt = new Date(baseDate);\n          dt.setFullYear(fields.year, fields.month, fields.date,\n            fields.hours, fields.minutes, fields.seconds,\n            fields.milliseconds || 0);\n        } else {\n          dt = new Date(fields.year, fields.month, fields.date,\n            fields.hours, fields.minutes, fields.seconds,\n            fields.milliseconds || 0);\n        }\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if (date < 1) {\n      return false;\n    }\n\n    if (month === 1 && date > 28) {\n      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n    }\n\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\n      return date < 31;\n    }\n\n    return true;\n  }\n}]);\n\n/* Deprecated dateparser below */\n\nangular.module('ui.bootstrap.dateparser')\n\n.value('$dateParserSuppressWarning', false)\n\n.service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {\n  if (!$dateParserSuppressWarning) {\n    $log.warn('dateParser is now deprecated. Use uibDateParser instead.');\n  }\n\n  angular.extend(this, uibDateParser);\n}]);\n\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n    function getStyle(el, cssprop) {\n      if (el.currentStyle) { //IE\n        return el.currentStyle[cssprop];\n      } else if ($window.getComputedStyle) {\n        return $window.getComputedStyle(el)[cssprop];\n      }\n      // finally try and get inline style\n      return el.style[cssprop];\n    }\n\n    /**\n     * Checks if a given element is statically positioned\n     * @param element - raw DOM element\n     */\n    function isStaticPositioned(element) {\n      return (getStyle(element, 'position') || 'static' ) === 'static';\n    }\n\n    /**\n     * returns the closest, non-statically positioned parentOffset of a given element\n     * @param element\n     */\n    var parentOffsetEl = function(element) {\n      var docDomEl = $document[0];\n      var offsetParent = element.offsetParent || docDomEl;\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docDomEl;\n    };\n\n    return {\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/\n       */\n      position: function(element) {\n        var elBCR = this.offset(element);\n        var offsetParentBCR = { top: 0, left: 0 };\n        var offsetParentEl = parentOffsetEl(element[0]);\n        if (offsetParentEl != $document[0]) {\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n        }\n\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: elBCR.top - offsetParentBCR.top,\n          left: elBCR.left - offsetParentBCR.left\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/\n       */\n      offset: function(element) {\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n        };\n      },\n\n      /**\n       * Provides coordinates for the targetEl in relation to hostEl\n       */\n      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {\n        var positionStrParts = positionStr.split('-');\n        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\n        var hostElPos,\n          targetElWidth,\n          targetElHeight,\n          targetElPos;\n\n        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\n        targetElWidth = targetEl.prop('offsetWidth');\n        targetElHeight = targetEl.prop('offsetHeight');\n\n        var shiftWidth = {\n          center: function() {\n            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n          },\n          left: function() {\n            return hostElPos.left;\n          },\n          right: function() {\n            return hostElPos.left + hostElPos.width;\n          }\n        };\n\n        var shiftHeight = {\n          center: function() {\n            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n          },\n          top: function() {\n            return hostElPos.top;\n          },\n          bottom: function() {\n            return hostElPos.top + hostElPos.height;\n          }\n        };\n\n        switch (pos0) {\n          case 'right':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: shiftWidth[pos0]()\n            };\n            break;\n          case 'left':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: hostElPos.left - targetElWidth\n            };\n            break;\n          case 'bottom':\n            targetElPos = {\n              top: shiftHeight[pos0](),\n              left: shiftWidth[pos1]()\n            };\n            break;\n          default:\n            targetElPos = {\n              top: hostElPos.top - targetElHeight,\n              left: shiftWidth[pos1]()\n            };\n            break;\n        }\n\n        return targetElPos;\n      }\n    };\n  }]);\n\n/* Deprecated position below */\n\nangular.module('ui.bootstrap.position')\n\n.value('$positionSuppressWarning', false)\n\n.service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {\n  if (!$positionSuppressWarning) {\n    $log.warn('$position is now deprecated. Use $uibPosition instead.');\n  }\n\n  angular.extend(this, $uibPosition);\n}]);\n\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\n.value('$datepickerSuppressError', false)\n\n.constant('uibDatepickerConfig', {\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  datepickerMode: 'day',\n  minMode: 'day',\n  maxMode: 'year',\n  showWeeks: true,\n  startingDay: 0,\n  yearRange: 20,\n  minDate: null,\n  maxDate: null,\n  shortcutPropagation: false\n})\n\n.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  // Configuration attributes\n  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  // Watchable date attributes\n  angular.forEach(['minDate', 'maxDate'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  angular.forEach(['minMode', 'maxMode'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = angular.isDefined(value) ? value : $attrs[key];\n        $scope[key] = self[key];\n        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n          $scope.datepickerMode = self[key];\n        }\n      });\n    } else {\n      self[key] = datepickerConfig[key] || null;\n      $scope[key] = self[key];\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  if (angular.isDefined($attrs.initDate)) {\n    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n        self.activeDate = initDate;\n        self.refreshView();\n      }\n    });\n  } else {\n    this.activeDate = new Date();\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n          isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = date;\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date)\n    };\n  };\n\n  this.isDisabled = function(date) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  this.step = { months: 1 };\n  this.element = $element;\n  function getDaysInMonth(year, month) {\n    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n  }\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    scope.showWeeks = ctrl.showWeeks;\n    ctrl.refreshView();\n  };\n\n  this.getDates = function(startDate, n) {\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n    while (i < n) {\n      date = new Date(current);\n      dates[i++] = date;\n      current.setDate(current.getDate() + 1);\n    }\n    return dates;\n  };\n\n  this._refreshView = function() {\n    var year = this.activeDate.getFullYear(),\n      month = this.activeDate.getMonth(),\n      firstDayOfMonth = new Date(this.activeDate);\n\n    firstDayOfMonth.setFullYear(year, month, 1);\n\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\n      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n      firstDate = new Date(firstDayOfMonth);\n\n    if (numDisplayedFromPreviousMonth > 0) {\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n    }\n\n    // 42 is the number of days on a six-month calendar\n    var days = this.getDates(firstDate, 42);\n    for (var i = 0; i < 42; i ++) {\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n        secondary: days[i].getMonth() !== month,\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.labels = new Array(7);\n    for (var j = 0; j < 7; j++) {\n      scope.labels[j] = {\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\n        full: dateFilter(days[j].date, 'EEEE')\n      };\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n    scope.rows = this.split(days, 7);\n\n    if (scope.showWeeks) {\n      scope.weekNumbers = [];\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n          numWeeks = scope.rows.length;\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n        scope.weekNumbers.push(\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n      }\n    }\n  };\n\n  this.compare = function(date1, date2) {\n    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n  };\n\n  function getISO8601WeekNumber(date) {\n    var checkDate = new Date(date);\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  }\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getDate();\n\n    if (key === 'left') {\n      date = date - 1;   // up\n    } else if (key === 'up') {\n      date = date - 7;   // down\n    } else if (key === 'right') {\n      date = date + 1;   // down\n    } else if (key === 'down') {\n      date = date + 7;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setMonth(month, 1);\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n    } else if (key === 'home') {\n      date = 1;\n    } else if (key === 'end') {\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n    }\n    this.activeDate.setDate(date);\n  };\n}])\n\n.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  this.step = { years: 1 };\n  this.element = $element;\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    ctrl.refreshView();\n  };\n\n  this._refreshView = function() {\n    var months = new Array(12),\n        year = this.activeDate.getFullYear(),\n        date;\n\n    for (var i = 0; i < 12; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(year, i, 1);\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n    scope.rows = this.split(months, 3);\n  };\n\n  this.compare = function(date1, date2) {\n    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getMonth();\n\n    if (key === 'left') {\n      date = date - 1;   // up\n    } else if (key === 'up') {\n      date = date - 3;   // down\n    } else if (key === 'right') {\n      date = date + 1;   // down\n    } else if (key === 'down') {\n      date = date + 3;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setFullYear(year);\n    } else if (key === 'home') {\n      date = 0;\n    } else if (key === 'end') {\n      date = 11;\n    }\n    this.activeDate.setMonth(date);\n  };\n}])\n\n.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var range;\n  this.element = $element;\n\n  function getStartingYear(year) {\n    return parseInt((year - 1) / range, 10) * range + 1;\n  }\n\n  this.yearpickerInit = function() {\n    range = this.yearRange;\n    this.step = { years: range };\n  };\n\n  this._refreshView = function() {\n    var years = new Array(range), date;\n\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(start + i, 0, 1);\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n    scope.rows = this.split(years, 5);\n  };\n\n  this.compare = function(date1, date2) {\n    return date1.getFullYear() - date2.getFullYear();\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getFullYear();\n\n    if (key === 'left') {\n      date = date - 1;   // up\n    } else if (key === 'up') {\n      date = date - 5;   // down\n    } else if (key === 'right') {\n      date = date + 1;   // down\n    } else if (key === 'down') {\n      date = date + 5;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      date += (key === 'pageup' ? - 1 : 1) * this.step.years;\n    } else if (key === 'home') {\n      date = getStartingYear(this.activeDate.getFullYear());\n    } else if (key === 'end') {\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n    }\n    this.activeDate.setFullYear(date);\n  };\n}])\n\n.directive('uibDatepicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerMode: '=?',\n      dateDisabled: '&',\n      customClass: '&',\n      shortcutPropagation: '&?'\n    },\n    require: ['uibDatepicker', '^ngModel'],\n    controller: 'UibDatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n})\n\n.directive('uibDaypicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/day.html';\n    },\n    require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0] || ctrls[2],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibMonthpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/month.html';\n    },\n    require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0] || ctrls[2],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibYearpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/year.html';\n    },\n    require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var ctrl = ctrls[0] || ctrls[2];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n})\n\n.constant('uibDatepickerPopupConfig', {\n  datepickerPopup: 'yyyy-MM-dd',\n  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',\n  datepickerTemplateUrl: 'template/datepicker/datepicker.html',\n  html5Types: {\n    date: 'yyyy-MM-dd',\n    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n    'month': 'yyyy-MM'\n  },\n  currentText: 'Today',\n  clearText: 'Clear',\n  closeText: 'Done',\n  closeOnDateSelection: true,\n  appendToBody: false,\n  showButtonBar: true,\n  onOpenFocus: true\n})\n\n.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout',\nfunction(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {\n  var self = this;\n  var cache = {},\n    isHtml5DateInput = false;\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,\n    ngModel, $popup;\n\n  scope.watchData = {};\n\n  this.init = function(_ngModel_) {\n    ngModel = _ngModel_;\n    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;\n    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\n    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\n    if (datepickerPopupConfig.html5Types[attrs.type]) {\n      dateFormat = datepickerPopupConfig.html5Types[attrs.type];\n      isHtml5DateInput = true;\n    } else {\n      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n          // Invalidate the $modelValue to ensure that formatters re-run\n          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n          if (newDateFormat !== dateFormat) {\n            dateFormat = newDateFormat;\n            ngModel.$modelValue = null;\n\n            if (!dateFormat) {\n              throw new Error('uibDatepickerPopup must have a date format specified.');\n            }\n          }\n      });\n    }\n\n    if (!dateFormat) {\n      throw new Error('uibDatepickerPopup must have a date format specified.');\n    }\n\n    if (isHtml5DateInput && attrs.datepickerPopup) {\n      throw new Error('HTML5 date input types do not support custom formats.');\n    }\n\n    // popup element used to display calendar\n    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n    popupEl.attr({\n      'ng-model': 'date',\n      'ng-change': 'dateSelection(date)',\n      'template-url': datepickerPopupTemplateUrl\n    });\n\n    // datepicker element\n    datepickerEl = angular.element(popupEl.children()[0]);\n    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\n    if (isHtml5DateInput) {\n      if (attrs.type === 'month') {\n        datepickerEl.attr('datepicker-mode', '\"month\"');\n        datepickerEl.attr('min-mode', 'month');\n      }\n    }\n\n    if (attrs.datepickerOptions) {\n      var options = scope.$parent.$eval(attrs.datepickerOptions);\n      if (options && options.initDate) {\n        scope.initDate = options.initDate;\n        datepickerEl.attr('init-date', 'initDate');\n        delete options.initDate;\n      }\n      angular.forEach(options, function(value, option) {\n        datepickerEl.attr(cameltoDash(option), value);\n      });\n    }\n\n    angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {\n      if (attrs[key]) {\n        var getAttribute = $parse(attrs[key]);\n        scope.$parent.$watch(getAttribute, function(value) {\n          scope.watchData[key] = value;\n          if (key === 'minDate' || key === 'maxDate') {\n            cache[key] = new Date(value);\n          }\n        });\n        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\n        // Propagate changes from datepicker to outside\n        if (key === 'datepickerMode') {\n          var setAttribute = getAttribute.assign;\n          scope.$watch('watchData.' + key, function(value, oldvalue) {\n            if (angular.isFunction(setAttribute) && value !== oldvalue) {\n              setAttribute(scope.$parent, value);\n            }\n          });\n        }\n      }\n    });\n    if (attrs.dateDisabled) {\n      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n    }\n\n    if (attrs.showWeeks) {\n      datepickerEl.attr('show-weeks', attrs.showWeeks);\n    }\n\n    if (attrs.customClass) {\n      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n    }\n\n    if (!isHtml5DateInput) {\n      // Internal API to maintain the correct ng-invalid-[key] class\n      ngModel.$$parserName = 'date';\n      ngModel.$validators.date = validator;\n      ngModel.$parsers.unshift(parseDate);\n      ngModel.$formatters.push(function(value) {\n        scope.date = value;\n        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);\n      });\n    } else {\n      ngModel.$formatters.push(function(value) {\n        scope.date = value;\n        return value;\n      });\n    }\n\n    // Detect changes in the view from the text box\n    ngModel.$viewChangeListeners.push(function() {\n      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);\n    });\n\n    element.bind('keydown', inputKeydownBind);\n\n    $popup = $compile(popupEl)(scope);\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\n    popupEl.remove();\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    scope.$on('$destroy', function() {\n      if (scope.isOpen === true) {\n        if (!$rootScope.$$phase) {\n          scope.$apply(function() {\n            scope.isOpen = false;\n          });\n        }\n      }\n\n      $popup.remove();\n      element.unbind('keydown', inputKeydownBind);\n      $document.unbind('click', documentClickBind);\n    });\n  };\n\n  scope.getText = function(key) {\n    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n  };\n\n  scope.isDisabled = function(date) {\n    if (date === 'today') {\n      date = new Date();\n    }\n\n    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||\n      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));\n  };\n\n  scope.compare = function(date1, date2) {\n    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n  };\n\n  // Inner change\n  scope.dateSelection = function(dt) {\n    if (angular.isDefined(dt)) {\n      scope.date = dt;\n    }\n    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n    element.val(date);\n    ngModel.$setViewValue(date);\n\n    if (closeOnDateSelection) {\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.keydown = function(evt) {\n    if (evt.which === 27) {\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.select = function(date) {\n    if (date === 'today') {\n      var today = new Date();\n      if (angular.isDate(scope.date)) {\n        date = new Date(scope.date);\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n      } else {\n        date = new Date(today.setHours(0, 0, 0, 0));\n      }\n    }\n    scope.dateSelection(date);\n  };\n\n  scope.close = function() {\n    scope.isOpen = false;\n    element[0].focus();\n  };\n\n  scope.$watch('isOpen', function(value) {\n    if (value) {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n      $timeout(function() {\n        if (onOpenFocus) {\n          scope.$broadcast('uib:datepicker.focus');\n        }\n        $document.bind('click', documentClickBind);\n      }, 0, false);\n    } else {\n      $document.unbind('click', documentClickBind);\n    }\n  });\n\n  function cameltoDash(string) {\n    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n  }\n\n  function parseDate(viewValue) {\n    if (angular.isNumber(viewValue)) {\n      // presumably timestamp to date object\n      viewValue = new Date(viewValue);\n    }\n\n    if (!viewValue) {\n      return null;\n    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n      return viewValue;\n    } else if (angular.isString(viewValue)) {\n      var date = dateParser.parse(viewValue, dateFormat, scope.date);\n      if (isNaN(date)) {\n        return undefined;\n      } else {\n        return date;\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  function validator(modelValue, viewValue) {\n    var value = modelValue || viewValue;\n\n    if (!attrs.ngRequired && !value) {\n      return true;\n    }\n\n    if (angular.isNumber(value)) {\n      value = new Date(value);\n    }\n    if (!value) {\n      return true;\n    } else if (angular.isDate(value) && !isNaN(value)) {\n      return true;\n    } else if (angular.isString(value)) {\n      var date = dateParser.parse(value, dateFormat);\n      return !isNaN(date);\n    } else {\n      return false;\n    }\n  }\n\n  function documentClickBind(event) {\n    var popup = $popup[0];\n    var dpContainsTarget = element[0].contains(event.target);\n    // The popup node may not be an element node\n    // In some browsers (IE) only element nodes have the 'contains' function\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n    }\n  }\n\n  function inputKeydownBind(evt) {\n    if (evt.which === 27 && scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n      element[0].focus();\n    } else if (evt.which === 40 && !scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = true;\n      });\n    }\n  }\n}])\n\n.directive('uibDatepickerPopup', function() {\n  return {\n    require: ['ngModel', 'uibDatepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&',\n      customClass: '&'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n})\n\n.directive('uibDatepickerPopupWrap', function() {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/popup.html';\n    }\n  };\n});\n\n/* Deprecated datepicker below */\n\nangular.module('ui.bootstrap.datepicker')\n\n.value('$datepickerSuppressWarning', false)\n\n.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {\n  if (!$datepickerSuppressWarning) {\n    $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');\n  }\n\n  var self = this,\n    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  this.modes = ['day', 'month', 'year'];\n\n  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n    'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  angular.forEach(['minDate', 'maxDate'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  angular.forEach(['minMode', 'maxMode'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = angular.isDefined(value) ? value : $attrs[key];\n        $scope[key] = self[key];\n        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n          $scope.datepickerMode = self[key];\n        }\n      });\n    } else {\n      self[key] = datepickerConfig[key] || null;\n      $scope[key] = self[key];\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  if (angular.isDefined($attrs.initDate)) {\n    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n        self.activeDate = initDate;\n        self.refreshView();\n      }\n    });\n  } else {\n    this.activeDate = new Date();\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n        isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = date;\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date)\n    };\n  };\n\n  this.isDisabled = function(date) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  this.fixTimeZone = function(date) {\n    var hours = date.getHours();\n    date.setHours(hours === 23 ? hours + 2 : 0);\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n      month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerMode: '=?',\n      dateDisabled: '&',\n      customClass: '&',\n      shortcutPropagation: '&?'\n    },\n    require: ['datepicker', '^ngModel'],\n    controller: 'DatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');\n      }\n\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n}])\n\n.directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: 'template/datepicker/day.html',\n    require: ['^datepicker', 'daypicker'],\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');\n      }\n\n      var datepickerCtrl = ctrls[0],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n}])\n\n.directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: 'template/datepicker/month.html',\n    require: ['^datepicker', 'monthpicker'],\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');\n      }\n\n      var datepickerCtrl = ctrls[0],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n}])\n\n.directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: 'template/datepicker/year.html',\n    require: ['^datepicker', 'yearpicker'],\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');\n      }\n\n      var ctrl = ctrls[0];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    require: ['ngModel', 'datepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&',\n      customClass: '&'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');\n      }\n\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n}])\n\n.directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/popup.html';\n    },\n    link: function() {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\n.constant('uibDropdownConfig', {\n  openClass: 'open'\n})\n\n.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n  var openScope = null;\n\n  this.open = function(dropdownScope) {\n    if (!openScope) {\n      $document.bind('click', closeDropdown);\n      $document.bind('keydown', keybindFilter);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function(dropdownScope) {\n    if (openScope === dropdownScope) {\n      openScope = null;\n      $document.unbind('click', closeDropdown);\n      $document.unbind('keydown', keybindFilter);\n    }\n  };\n\n  var closeDropdown = function(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope) { return; }\n\n    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  var keybindFilter = function(evt) {\n    if (evt.which === 27) {\n      openScope.focusToggleElement();\n      closeDropdown();\n    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      openScope.focusDropdownEntry(evt.which);\n    }\n  };\n}])\n\n.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    keynavEnabled =false,\n    selectedOption = null;\n\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\n    if (appendToBody && self.dropdownMenu) {\n      $document.find('body').append(self.dropdownMenu);\n      $element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      (angular.element(self.dropdownMenu).find('a')) :\n      (angular.element($element).find('ul').eq(0).find('a'));\n\n    switch (keyCode) {\n      case (40): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = (self.selectedOption === elems.length - 1 ?\n            self.selectedOption :\n            self.selectedOption + 1);\n        }\n        break;\n      }\n      case (38): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    if (appendToBody && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n      var css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n        toggleInvoker($scope, { open: !!isOpen });\n      }\n    });\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    if (scope.getAutoClose() !== 'disabled') {\n      scope.isOpen = false;\n    }\n  });\n\n  var offDestroy = $scope.$on('$destroy', function() {\n    scope.$destroy();\n  });\n  scope.$on('$destroy', offDestroy);\n}])\n\n.directive('uibDropdown', function() {\n  return {\n    controller: 'UibDropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init();\n    }\n  };\n})\n\n.directive('uibDropdownMenu', function() {\n  return {\n    restrict: 'AC',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n})\n\n.directive('uibKeyboardNav', function() {\n  return {\n    restrict: 'A',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      element.bind('keydown', function(e) {\n        if ([38, 40].indexOf(e.which) !== -1) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          var elems = dropdownCtrl.dropdownMenu.find('a');\n\n          switch (e.which) {\n            case (40): { // Down\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = 0;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n              }\n              break;\n            }\n            case (38): { // Up\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = elems.length - 1;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n                  0 : dropdownCtrl.selectedOption - 1;\n              }\n              break;\n            }\n          }\n          elems[dropdownCtrl.selectedOption].focus();\n        }\n      });\n    }\n  };\n})\n\n.directive('uibDropdownToggle', function() {\n  return {\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n});\n\n/* Deprecated dropdown below */\n\nangular.module('ui.bootstrap.dropdown')\n\n.value('$dropdownSuppressWarning', false)\n\n.service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {\n  if (!$dropdownSuppressWarning) {\n    $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');\n  }\n\n  angular.extend(this, uibDropdownService);\n}])\n\n.controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {\n  if (!$dropdownSuppressWarning) {\n    $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');\n  }\n\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    keynavEnabled =false,\n    selectedOption = null;\n\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\n    if (appendToBody && self.dropdownMenu) {\n      $document.find('body').append(self.dropdownMenu);\n      $element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      (angular.element(self.dropdownMenu).find('a')) :\n      (angular.element($element).find('ul').eq(0).find('a'));\n\n    switch (keyCode) {\n      case (40): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = (self.selectedOption === elems.length -1 ?\n            self.selectedOption :\n          self.selectedOption + 1);\n        }\n        break;\n      }\n      case (38): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    if (appendToBody && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n      var css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n        toggleInvoker($scope, { open: !!isOpen });\n      }\n    });\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    if (scope.getAutoClose() !== 'disabled') {\n      scope.isOpen = false;\n    }\n  });\n\n  var offDestroy = $scope.$on('$destroy', function() {\n    scope.$destroy();\n  });\n  scope.$on('$destroy', offDestroy);\n}])\n\n.directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    controller: 'DropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');\n      }\n\n      dropdownCtrl.init();\n    }\n  };\n}])\n\n.directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    restrict: 'AC',\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      if (!$dropdownSuppressWarning) {\n        $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n}])\n\n.directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    restrict: 'A',\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');\n      }\n\n      element.bind('keydown', function(e) {\n        if ([38, 40].indexOf(e.which) !== -1) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          var elems = dropdownCtrl.dropdownMenu.find('a');\n\n          switch (e.which) {\n            case (40): { // Down\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = 0;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n              }\n              break;\n            }\n            case (38): { // Up\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = elems.length - 1;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n                  0 : dropdownCtrl.selectedOption - 1;\n              }\n              break;\n            }\n          }\n          elems[dropdownCtrl.selectedOption].focus();\n        }\n      });\n    }\n  };\n}])\n\n.directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');\n      }\n\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.stackedMap', [])\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function() {\n    return {\n      createNew: function() {\n        var stack = [];\n\n        return {\n          add: function(key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function(key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function() {\n            return stack[stack.length - 1];\n          },\n          remove: function(key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function() {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function() {\n            return stack.length;\n          }\n        };\n      }\n    };\n  });\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n/**\n * A helper, internal data structure that stores all references attached to key\n */\n  .factory('$$multiMap', function() {\n    return {\n      createNew: function() {\n        var map = {};\n\n        return {\n          entries: function() {\n            return Object.keys(map).map(function(key) {\n              return {\n                key: key,\n                value: map[key]\n              };\n            });\n          },\n          get: function(key) {\n            return map[key];\n          },\n          hasKey: function(key) {\n            return !!map[key];\n          },\n          keys: function() {\n            return Object.keys(map);\n          },\n          put: function(key, value) {\n            if (!map[key]) {\n              map[key] = [];\n            }\n\n            map[key].push(value);\n          },\n          remove: function(key, value) {\n            var values = map[key];\n\n            if (!values) {\n              return;\n            }\n\n            var idx = values.indexOf(value);\n\n            if (idx !== -1) {\n              values.splice(idx, 1);\n            }\n\n            if (!values.length) {\n              delete map[key];\n            }\n          }\n        };\n      }\n    };\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('uibModalBackdrop', [\n           '$animate', '$injector', '$uibModalStack',\n  function($animate ,  $injector,   $modalStack) {\n    var $animateCss = null;\n\n    if ($injector.has('$animateCss')) {\n      $animateCss = $injector.get('$animateCss');\n    }\n\n    return {\n      replace: true,\n      templateUrl: 'template/modal/backdrop.html',\n      compile: function(tElement, tAttrs) {\n        tElement.addClass(tAttrs.backdropClass);\n        return linkFn;\n      }\n    };\n\n    function linkFn(scope, element, attrs) {\n      // Temporary fix for prefixing\n      element.addClass('modal-backdrop');\n\n      if (attrs.modalInClass) {\n        if ($animateCss) {\n          $animateCss(element, {\n            addClass: attrs.modalInClass\n          }).start();\n        } else {\n          $animate.addClass(element, attrs.modalInClass);\n        }\n\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n          var done = setIsAsync();\n          if ($animateCss) {\n            $animateCss(element, {\n              removeClass: attrs.modalInClass\n            }).start().then(done);\n          } else {\n            $animate.removeClass(element, attrs.modalInClass).then(done);\n          }\n        });\n      }\n    }\n  }])\n\n  .directive('uibModalWindow', [\n           '$uibModalStack', '$q', '$animate', '$injector',\n  function($modalStack ,  $q ,  $animate,   $injector) {\n    var $animateCss = null;\n\n    if ($injector.has('$animateCss')) {\n      $animateCss = $injector.get('$animateCss');\n    }\n\n    return {\n      scope: {\n        index: '@'\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'template/modal/window.html';\n      },\n      link: function(scope, element, attrs) {\n        element.addClass(attrs.windowClass || '');\n        element.addClass(attrs.windowTopClass || '');\n        scope.size = attrs.size;\n\n        scope.close = function(evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n\n        // moved from template to fix issue #2280\n        element.on('click', scope.close);\n\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n        // We can detect that by using this property in the template associated with this directive and then use\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n        scope.$isRendered = true;\n\n        // Deferred object that will be resolved when this modal is render.\n        var modalRenderDeferObj = $q.defer();\n        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n        attrs.$observe('modalRender', function(value) {\n          if (value == 'true') {\n            modalRenderDeferObj.resolve();\n          }\n        });\n\n        modalRenderDeferObj.promise.then(function() {\n          var animationPromise = null;\n\n          if (attrs.modalInClass) {\n            if ($animateCss) {\n              animationPromise = $animateCss(element, {\n                addClass: attrs.modalInClass\n              }).start();\n            } else {\n              animationPromise = $animate.addClass(element, attrs.modalInClass);\n            }\n\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n              var done = setIsAsync();\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: attrs.modalInClass\n                }).start().then(done);\n              } else {\n                $animate.removeClass(element, attrs.modalInClass).then(done);\n              }\n            });\n          }\n\n\n          $q.when(animationPromise).then(function() {\n            var inputWithAutofocus = element[0].querySelector('[autofocus]');\n            /**\n             * Auto-focusing of a freshly-opened modal element causes any child elements\n             * with the autofocus attribute to lose focus. This is an issue on touch\n             * based devices which will show and then hide the onscreen keyboard.\n             * Attempts to refocus the autofocus element via JavaScript will not reopen\n             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n             * the modal element if the modal does not contain an autofocus element.\n             */\n            if (inputWithAutofocus) {\n              inputWithAutofocus.focus();\n            } else {\n              element[0].focus();\n            }\n          });\n\n          // Notify {@link $modalStack} that modal is rendered.\n          var modal = $modalStack.getTop();\n          if (modal) {\n            $modalStack.modalRendered(modal.key);\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('uibModalAnimationClass', function() {\n    return {\n      compile: function(tElement, tAttrs) {\n        if (tAttrs.modalAnimation) {\n          tElement.addClass(tAttrs.uibModalAnimationClass);\n        }\n      }\n    };\n  })\n\n  .directive('uibModalTransclude', function() {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  })\n\n  .factory('$uibModalStack', [\n             '$animate', '$timeout', '$document', '$compile', '$rootScope',\n             '$q',\n             '$injector',\n             '$$multiMap',\n             '$$stackedMap',\n    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n              $q,\n              $injector,\n              $$multiMap,\n              $$stackedMap) {\n      var $animateCss = null;\n\n      if ($injector.has('$animateCss')) {\n        $animateCss = $injector.get('$animateCss');\n      }\n\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var openedClasses = $$multiMap.createNew();\n      var $modalStack = {\n        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n      };\n\n      //Modal focus behavior\n      var focusableElementList;\n      var focusIndex = 0;\n      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n        var body = $document.find('body').eq(0);\n        var modalWindow = openedWindows.get(modalInstance).value;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n          openedClasses.remove(modalBodyClass, modalInstance);\n          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n          toggleTopWindowClass(true);\n        });\n        checkRemoveBackdrop();\n\n        //move focus to specified element if available, or else to body\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n          elementToReceiveFocus.focus();\n        } else {\n          body.focus();\n        }\n      }\n\n      // Add or remove \"windowTopClass\" from the top window in the stack\n      function toggleTopWindowClass(toggleSwitch) {\n        var modalWindow;\n\n        if (openedWindows.length() > 0) {\n          modalWindow = openedWindows.top().value;\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n        }\n      }\n\n      function checkRemoveBackdrop() {\n        //remove backdrop if no longer needed\n        if (backdropDomEl && backdropIndex() == -1) {\n          var backdropScopeRef = backdropScope;\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n            backdropScopeRef = null;\n          });\n          backdropDomEl = undefined;\n          backdropScope = undefined;\n        }\n      }\n\n      function removeAfterAnimate(domEl, scope, done) {\n        var asyncDeferred;\n        var asyncPromise = null;\n        var setIsAsync = function() {\n          if (!asyncDeferred) {\n            asyncDeferred = $q.defer();\n            asyncPromise = asyncDeferred.promise;\n          }\n\n          return function asyncDone() {\n            asyncDeferred.resolve();\n          };\n        };\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\n        // Note that it's intentional that asyncPromise might be null.\n        // That's when setIsAsync has not been called during the\n        // NOW_CLOSING_EVENT broadcast.\n        return $q.when(asyncPromise).then(afterAnimating);\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          if ($animateCss) {\n            $animateCss(domEl, {\n              event: 'leave'\n            }).start().then(function() {\n              domEl.remove();\n            });\n          } else {\n            $animate.leave(domEl);\n          }\n          scope.$destroy();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.bind('keydown', function(evt) {\n        if (evt.isDefaultPrevented()) {\n          return evt;\n        }\n\n        var modal = openedWindows.top();\n        if (modal && modal.value.keyboard) {\n          switch (evt.which) {\n            case 27: {\n              evt.preventDefault();\n              $rootScope.$apply(function() {\n                $modalStack.dismiss(modal.key, 'escape key press');\n              });\n              break;\n            }\n            case 9: {\n              $modalStack.loadFocusElementList(modal);\n              var focusChanged = false;\n              if (evt.shiftKey) {\n                if ($modalStack.isFocusInFirstItem(evt)) {\n                  focusChanged = $modalStack.focusLastFocusableElement();\n                }\n              } else {\n                if ($modalStack.isFocusInLastItem(evt)) {\n                  focusChanged = $modalStack.focusFirstFocusableElement();\n                }\n              }\n\n              if (focusChanged) {\n                evt.preventDefault();\n                evt.stopPropagation();\n              }\n              break;\n            }\n          }\n        }\n      });\n\n      $modalStack.open = function(modalInstance, modal) {\n        var modalOpener = $document[0].activeElement,\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\n        toggleTopWindowClass(false);\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          renderDeferred: modal.renderDeferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard,\n          openedClass: modal.openedClass,\n          windowTopClass: modal.windowTopClass\n        });\n\n        openedClasses.put(modalBodyClass, modalInstance);\n\n        var body = $document.find('body').eq(0),\n            currBackdropIndex = backdropIndex();\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.index = currBackdropIndex;\n          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n          if (modal.animation) {\n            angularBackgroundDomEl.attr('modal-animation', 'true');\n          }\n          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n          body.append(backdropDomEl);\n        }\n\n        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n        angularDomEl.attr({\n          'template-url': modal.windowTemplateUrl,\n          'window-class': modal.windowClass,\n          'window-top-class': modal.windowTopClass,\n          'size': modal.size,\n          'index': openedWindows.length() - 1,\n          'animate': 'animate'\n        }).html(modal.content);\n        if (modal.animation) {\n          angularDomEl.attr('modal-animation', 'true');\n        }\n\n        var modalDomEl = $compile(angularDomEl)(modal.scope);\n        openedWindows.top().value.modalDomEl = modalDomEl;\n        openedWindows.top().value.modalOpener = modalOpener;\n        body.append(modalDomEl);\n        body.addClass(modalBodyClass);\n\n        $modalStack.clearFocusListCache();\n      };\n\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\n        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n      }\n\n      $modalStack.close = function(modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismiss = function(modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismissAll = function(reason) {\n        var topModal = this.getTop();\n        while (topModal && this.dismiss(topModal.key, reason)) {\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function() {\n        return openedWindows.top();\n      };\n\n      $modalStack.modalRendered = function(modalInstance) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.renderDeferred.resolve();\n        }\n      };\n\n      $modalStack.focusFirstFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[0].focus();\n          return true;\n        }\n        return false;\n      };\n      $modalStack.focusLastFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[focusableElementList.length - 1].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInFirstItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) == focusableElementList[0];\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInLastItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];\n        }\n        return false;\n      };\n\n      $modalStack.clearFocusListCache = function() {\n        focusableElementList = [];\n        focusIndex = 0;\n      };\n\n      $modalStack.loadFocusElementList = function(modalWindow) {\n        if (focusableElementList === undefined || !focusableElementList.length) {\n          if (modalWindow) {\n            var modalDomE1 = modalWindow.value.modalDomEl;\n            if (modalDomE1 && modalDomE1.length) {\n              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n            }\n          }\n        }\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$uibModal', function() {\n    var $modalProvider = {\n      options: {\n        animation: true,\n        backdrop: true, //can also be false or 'static'\n        keyboard: true\n      },\n      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log',\n        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);\n          }\n\n          function getResolvePromises(resolves) {\n            var promisesArr = [];\n            angular.forEach(resolves, function(value) {\n              if (angular.isFunction(value) || angular.isArray(value)) {\n                promisesArr.push($q.when($injector.invoke(value)));\n              } else if (angular.isString(value)) {\n                promisesArr.push($q.when($injector.get(value)));\n              } else {\n                promisesArr.push($q.when(value));\n              }\n            });\n            return promisesArr;\n          }\n\n          var promiseChain = null;\n          $modal.getPromiseChain = function() {\n            return promiseChain;\n          };\n\n          $modal.open = function(modalOptions) {\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n            var modalRenderDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              rendered: modalRenderDeferred.promise,\n              close: function (result) {\n                return $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                return $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\n            function resolveWithTemplate() {\n              return templateAndResolvePromise;\n            }\n\n            // Wait for the resolution of the existing promise chain.\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n            // Then add to $modalStack and resolve opened.\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n            var samePromise;\n            samePromise = promiseChain = $q.all([promiseChain])\n              .then(resolveWithTemplate, resolveWithTemplate)\n              .then(function resolveSuccess(tplAndVars) {\n\n                var modalScope = (modalOptions.scope || $rootScope).$new();\n                modalScope.$close = modalInstance.close;\n                modalScope.$dismiss = modalInstance.dismiss;\n\n                modalScope.$on('$destroy', function() {\n                  if (!modalScope.$$uibDestructionScheduled) {\n                    modalScope.$dismiss('$uibUnscheduledDestruction');\n                  }\n                });\n\n                var ctrlInstance, ctrlLocals = {};\n                var resolveIter = 1;\n\n                //controllers\n                if (modalOptions.controller) {\n                  ctrlLocals.$scope = modalScope;\n                  ctrlLocals.$uibModalInstance = modalInstance;\n                  Object.defineProperty(ctrlLocals, '$modalInstance', {\n                    get: function() {\n                      if (!$modalSuppressWarning) {\n                        $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');\n                      }\n\n                      return modalInstance;\n                    }\n                  });\n                  angular.forEach(modalOptions.resolve, function(value, key) {\n                    ctrlLocals[key] = tplAndVars[resolveIter++];\n                  });\n\n                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n                  if (modalOptions.controllerAs) {\n                    if (modalOptions.bindToController) {\n                      angular.extend(ctrlInstance, modalScope);\n                    }\n\n                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n                  }\n                }\n\n                $modalStack.open(modalInstance, {\n                  scope: modalScope,\n                  deferred: modalResultDeferred,\n                  renderDeferred: modalRenderDeferred,\n                  content: tplAndVars[0],\n                  animation: modalOptions.animation,\n                  backdrop: modalOptions.backdrop,\n                  keyboard: modalOptions.keyboard,\n                  backdropClass: modalOptions.backdropClass,\n                  windowTopClass: modalOptions.windowTopClass,\n                  windowClass: modalOptions.windowClass,\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n                  size: modalOptions.size,\n                  openedClass: modalOptions.openedClass\n                });\n                modalOpenedDeferred.resolve(true);\n\n            }, function resolveError(reason) {\n              modalOpenedDeferred.reject(reason);\n              modalResultDeferred.reject(reason);\n            })\n            .finally(function() {\n              if (promiseChain === samePromise) {\n                promiseChain = null;\n              }\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }\n      ]\n    };\n\n    return $modalProvider;\n  });\n\n/* deprecated modal below */\n\nangular.module('ui.bootstrap.modal')\n\n  .value('$modalSuppressWarning', false)\n\n  /**\n   * A helper directive for the $modal service. It creates a backdrop element.\n   */\n  .directive('modalBackdrop', [\n    '$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning',\n    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {\n      var $animateCss = null;\n\n      if ($injector.has('$animateCss')) {\n        $animateCss = $injector.get('$animateCss');\n      }\n\n      return {\n        replace: true,\n        templateUrl: 'template/modal/backdrop.html',\n        compile: function(tElement, tAttrs) {\n          tElement.addClass(tAttrs.backdropClass);\n          return linkFn;\n        }\n      };\n\n      function linkFn(scope, element, attrs) {\n        if (!$modalSuppressWarning) {\n          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');\n        }\n        element.addClass('modal-backdrop');\n\n        if (attrs.modalInClass) {\n          if ($animateCss) {\n            $animateCss(element, {\n              addClass: attrs.modalInClass\n            }).start();\n          } else {\n            $animate.addClass(element, attrs.modalInClass);\n          }\n\n          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n            var done = setIsAsync();\n            if ($animateCss) {\n              $animateCss(element, {\n                removeClass: attrs.modalInClass\n              }).start().then(done);\n            } else {\n              $animate.removeClass(element, attrs.modalInClass).then(done);\n            }\n          });\n        }\n      }\n    }])\n\n  .directive('modalWindow', [\n    '$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning',\n    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {\n      var $animateCss = null;\n\n      if ($injector.has('$animateCss')) {\n        $animateCss = $injector.get('$animateCss');\n      }\n\n      return {\n        scope: {\n          index: '@'\n        },\n        replace: true,\n        transclude: true,\n        templateUrl: function(tElement, tAttrs) {\n          return tAttrs.templateUrl || 'template/modal/window.html';\n        },\n        link: function(scope, element, attrs) {\n          if (!$modalSuppressWarning) {\n            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');\n          }\n          element.addClass(attrs.windowClass || '');\n          element.addClass(attrs.windowTopClass || '');\n          scope.size = attrs.size;\n\n          scope.close = function(evt) {\n            var modal = $modalStack.getTop();\n            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n              evt.preventDefault();\n              evt.stopPropagation();\n              $modalStack.dismiss(modal.key, 'backdrop click');\n            }\n          };\n\n          // moved from template to fix issue #2280\n          element.on('click', scope.close);\n\n          // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n          // We can detect that by using this property in the template associated with this directive and then use\n          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n          scope.$isRendered = true;\n\n          // Deferred object that will be resolved when this modal is render.\n          var modalRenderDeferObj = $q.defer();\n          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n          attrs.$observe('modalRender', function(value) {\n            if (value == 'true') {\n              modalRenderDeferObj.resolve();\n            }\n          });\n\n          modalRenderDeferObj.promise.then(function() {\n            var animationPromise = null;\n\n            if (attrs.modalInClass) {\n              if ($animateCss) {\n                animationPromise = $animateCss(element, {\n                  addClass: attrs.modalInClass\n                }).start();\n              } else {\n                animationPromise = $animate.addClass(element, attrs.modalInClass);\n              }\n\n              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n                var done = setIsAsync();\n                if ($animateCss) {\n                  $animateCss(element, {\n                    removeClass: attrs.modalInClass\n                  }).start().then(done);\n                } else {\n                  $animate.removeClass(element, attrs.modalInClass).then(done);\n                }\n              });\n            }\n\n\n            $q.when(animationPromise).then(function() {\n              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n              /**\n               * Auto-focusing of a freshly-opened modal element causes any child elements\n               * with the autofocus attribute to lose focus. This is an issue on touch\n               * based devices which will show and then hide the onscreen keyboard.\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n               * the modal element if the modal does not contain an autofocus element.\n               */\n              if (inputWithAutofocus) {\n                inputWithAutofocus.focus();\n              } else {\n                element[0].focus();\n              }\n            });\n\n            // Notify {@link $modalStack} that modal is rendered.\n            var modal = $modalStack.getTop();\n            if (modal) {\n              $modalStack.modalRendered(modal.key);\n            }\n          });\n        }\n      };\n    }])\n\n  .directive('modalAnimationClass', [\n    '$log', '$modalSuppressWarning',\n    function ($log, $modalSuppressWarning) {\n      return {\n        compile: function(tElement, tAttrs) {\n          if (!$modalSuppressWarning) {\n            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');\n          }\n          if (tAttrs.modalAnimation) {\n            tElement.addClass(tAttrs.modalAnimationClass);\n          }\n        }\n      };\n    }])\n\n  .directive('modalTransclude', [\n    '$log', '$modalSuppressWarning',\n    function ($log, $modalSuppressWarning) {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        if (!$modalSuppressWarning) {\n          $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');\n        }\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  }])\n\n  .service('$modalStack', [\n    '$animate', '$timeout', '$document', '$compile', '$rootScope',\n    '$q',\n    '$injector',\n    '$$multiMap',\n    '$$stackedMap',\n    '$uibModalStack',\n    '$log',\n    '$modalSuppressWarning',\n    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n             $q,\n             $injector,\n             $$multiMap,\n             $$stackedMap,\n             $uibModalStack,\n             $log,\n             $modalSuppressWarning) {\n      if (!$modalSuppressWarning) {\n        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');\n      }\n\n      angular.extend(this, $uibModalStack);\n    }])\n\n  .provider('$modal', ['$uibModalProvider', function($uibModalProvider) {\n    angular.extend(this, $uibModalProvider);\n\n    this.$get = ['$injector', '$log', '$modalSuppressWarning',\n      function ($injector, $log, $modalSuppressWarning) {\n        if (!$modalSuppressWarning) {\n          $log.warn('$modal is now deprecated. Use $uibModal instead.');\n        }\n\n        return $injector.invoke($uibModalProvider.$get);\n      }];\n  }]);\n\nangular.module('ui.bootstrap.pagination', [])\n.controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n\n    $scope.$watch('totalItems', function() {\n      $scope.totalPages = self.calculateTotalPages();\n    });\n\n    $scope.$watch('totalPages', function(value) {\n      setNumPages($scope.$parent, value); // Readonly variable\n\n      if ( $scope.page > value ) {\n        $scope.selectPage(value);\n      } else {\n        ngModelCtrl.$render();\n      }\n    });\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page, evt) {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    var clickAllowed = !$scope.ngDisabled || !evt;\n    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      if (evt && evt.target) {\n        evt.target.blur();\n      }\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || self.config[key + 'Text'];\n  };\n\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n}])\n\n.constant('uibPaginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true\n})\n\n.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['uibPagination', '?ngModel'],\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pagination.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n        // recompute if maxSize\n        if (isMaxSized) {\n          if (rotate) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if (isMaxSized && ! rotate) {\n          if (startPage > 1) {\n            var previousPageSet = makePage(startPage - 1, '...', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if (endPage < totalPages) {\n            var nextPageSet = makePage(endPage + 1, '...', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.constant('uibPagerConfig', {\n  itemsPerPage: 10,\n  previousText: ' Previous',\n  nextText: 'Next ',\n  align: true\n})\n\n.directive('uibPager', ['uibPagerConfig', function(pagerConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['uibPager', '?ngModel'],\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pager.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/* Deprecated Pagination Below */\n\nangular.module('ui.bootstrap.pagination')\n.value('$paginationSuppressWarning', false)\n.controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {\n  if (!$paginationSuppressWarning) {\n    $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');\n  }\n\n  var self = this,\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n\n    $scope.$watch('totalItems', function() {\n      $scope.totalPages = self.calculateTotalPages();\n    });\n\n    $scope.$watch('totalPages', function(value) {\n      setNumPages($scope.$parent, value); // Readonly variable\n\n      if ( $scope.page > value ) {\n        $scope.selectPage(value);\n      } else {\n        ngModelCtrl.$render();\n      }\n    });\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page, evt) {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    var clickAllowed = !$scope.ngDisabled || !evt;\n    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      if (evt && evt.target) {\n        evt.target.blur();\n      }\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || self.config[key + 'Text'];\n  };\n\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n}])\n.directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['pagination', '?ngModel'],\n    controller: 'PaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pagination.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$paginationSuppressWarning) {\n        $log.warn('pagination is now deprecated. Use uib-pagination instead.');\n      }\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n        // recompute if maxSize\n        if (isMaxSized) {\n          if (rotate) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if (isMaxSized && ! rotate) {\n          if (startPage > 1) {\n            var previousPageSet = makePage(startPage - 1, '...', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if (endPage < totalPages) {\n            var nextPageSet = makePage(endPage + 1, '...', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['pager', '?ngModel'],\n    controller: 'PaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pager.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$paginationSuppressWarning) {\n        $log.warn('pager is now deprecated. Use uib-pager instead.');\n      }\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider('$uibTooltip', function() {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    animation: true,\n    popupDelay: 0,\n    popupCloseDelay: 0,\n    useContentExp: false\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'focus': 'blur',\n    'none': ''\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function(value) {\n\t\tangular.extend(globalOptions, value);\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n   */\n  this.setTriggers = function setTriggers(triggers) {\n    angular.extend(triggerMap, triggers);\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake-case.\n   */\n  function snake_case(name) {\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n    var openedTooltips = $$stackedMap.createNew();\n    $document.on('keypress', function(e) {\n      if (e.which === 27) {\n        var last = openedTooltips.top();\n        if (last) {\n          last.value.close();\n          openedTooltips.removeTop();\n          last = null;\n        }\n      }\n    });\n\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n      options = angular.extend({}, defaultOptions, globalOptions, options);\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers(trigger) {\n        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n        var hide = show.map(function(trigger) {\n          return triggerMap[trigger] || trigger;\n        });\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case(ttType);\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName + '-popup '+\n          'title=\"' + startSym + 'title' + endSym + '\" '+\n          (options.useContentExp ?\n            'content-exp=\"contentExp()\" ' :\n            'content=\"' + startSym + 'content' + endSym + '\" ') +\n          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n          'animation=\"animation\" ' +\n          'is-open=\"isOpen\"' +\n          'origin-scope=\"origScope\" ' +\n          'style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"' +\n          '>' +\n        '</div>';\n\n      return {\n        compile: function(tElem, tAttrs) {\n          var tooltipLinker = $compile(template);\n\n          return function link(scope, element, attrs, tooltipCtrl) {\n            var tooltip;\n            var tooltipLinkedScope;\n            var transitionTimeout;\n            var showTimeout;\n            var hideTimeout;\n            var positionTimeout;\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n            var triggers = getTriggers(undefined);\n            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n            var ttScope = scope.$new(true);\n            var repositionScheduled = false;\n            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n            var observers = [];\n\n            var positionTooltip = function() {\n              // check if tooltip exists and is not empty\n              if (!tooltip || !tooltip.html()) { return; }\n\n              if (!positionTimeout) {\n                positionTimeout = $timeout(function() {\n                  // Reset the positioning.\n                  tooltip.css({ top: 0, left: 0 });\n\n                  // Now set the calculated positioning.\n                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n                  ttCss.top += 'px';\n                  ttCss.left += 'px';\n                  ttCss.visibility = 'visible';\n                  tooltip.css(ttCss);\n\n                  positionTimeout = null;\n                }, 0, false);\n              }\n            };\n\n            // Set up the correct scope to allow transclusion later\n            ttScope.origScope = scope;\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            ttScope.isOpen = false;\n            openedTooltips.add(ttScope, {\n              close: hide\n            });\n\n            function toggleTooltipBind() {\n              if (!ttScope.isOpen) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n                return;\n              }\n\n              cancelHide();\n              prepareTooltip();\n\n              if (ttScope.popupDelay) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!showTimeout) {\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n                }\n              } else {\n                show();\n              }\n            }\n\n            function hideTooltipBind() {\n              cancelShow();\n\n              if (ttScope.popupCloseDelay) {\n                if (!hideTimeout) {\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n                }\n              } else {\n                hide();\n              }\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n              cancelShow();\n              cancelHide();\n\n              // Don't show empty tooltips.\n              if (!ttScope.content) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // And show the tooltip.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = true;\n                assignIsOpen(true);\n                positionTooltip();\n              });\n            }\n\n            function cancelShow() {\n              if (showTimeout) {\n                $timeout.cancel(showTimeout);\n                showTimeout = null;\n              }\n\n              if (positionTimeout) {\n                $timeout.cancel(positionTimeout);\n                positionTimeout = null;\n              }\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              cancelShow();\n              cancelHide();\n\n              if (!ttScope) {\n                return;\n              }\n\n              // First things first: we don't show it anymore.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = false;\n                assignIsOpen(false);\n                // And now we remove it from the DOM. However, if we have animation, we\n                // need to wait for it to expire beforehand.\n                // FIXME: this is a placeholder for a port of the transitions library.\n                // The fade transition in TWBS is 150ms.\n                if (ttScope.animation) {\n                  if (!transitionTimeout) {\n                    transitionTimeout = $timeout(removeTooltip, 150, false);\n                  }\n                } else {\n                  removeTooltip();\n                }\n              });\n            }\n\n            function cancelHide() {\n              if (hideTimeout) {\n                $timeout.cancel(hideTimeout);\n                hideTimeout = null;\n              }\n              if (transitionTimeout) {\n                $timeout.cancel(transitionTimeout);\n                transitionTimeout = null;\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                return;\n              }\n\n              tooltipLinkedScope = ttScope.$new();\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n                if (appendToBody) {\n                  $document.find('body').append(tooltip);\n                } else {\n                  element.after(tooltip);\n                }\n              });\n\n              prepObservers();\n            }\n\n            function removeTooltip() {\n              unregisterObservers();\n\n              transitionTimeout = null;\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n              if (tooltipLinkedScope) {\n                tooltipLinkedScope.$destroy();\n                tooltipLinkedScope = null;\n              }\n            }\n\n            /**\n             * Set the inital scope values. Once\n             * the tooltip is created, the observers\n             * will be added to keep things in synch.\n             */\n            function prepareTooltip() {\n              ttScope.title = attrs[prefix + 'Title'];\n              if (contentParse) {\n                ttScope.content = contentParse(scope);\n              } else {\n                ttScope.content = attrs[ttType];\n              }\n\n              ttScope.popupClass = attrs[prefix + 'Class'];\n              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\n              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n            }\n\n            function assignIsOpen(isOpen) {\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n                isOpenParse.assign(scope, isOpen);\n              }\n            }\n\n            ttScope.contentExp = function() {\n              return ttScope.content;\n            };\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe('disabled', function(val) {\n              if (val) {\n                cancelShow();\n              }\n\n              if (val && ttScope.isOpen) {\n                hide();\n              }\n            });\n\n            if (isOpenParse) {\n              scope.$watch(isOpenParse, function(val) {\n                /*jshint -W018 */\n                if (ttScope && !val === ttScope.isOpen) {\n                  toggleTooltipBind();\n                }\n                /*jshint +W018 */\n              });\n            }\n\n            function prepObservers() {\n              observers.length = 0;\n\n              if (contentParse) {\n                observers.push(\n                  scope.$watch(contentParse, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    }\n                  })\n                );\n\n                observers.push(\n                  tooltipLinkedScope.$watch(function() {\n                    if (!repositionScheduled) {\n                      repositionScheduled = true;\n                      tooltipLinkedScope.$$postDigest(function() {\n                        repositionScheduled = false;\n                        if (ttScope && ttScope.isOpen) {\n                          positionTooltip();\n                        }\n                      });\n                    }\n                  })\n                );\n              } else {\n                observers.push(\n                  attrs.$observe(ttType, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    } else {\n                      positionTooltip();\n                    }\n                  })\n                );\n              }\n\n              observers.push(\n                attrs.$observe(prefix + 'Title', function(val) {\n                  ttScope.title = val;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n\n              observers.push(\n                attrs.$observe(prefix + 'Placement', function(val) {\n                  ttScope.placement = val ? val : options.placement;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n            }\n\n            function unregisterObservers() {\n              if (observers.length) {\n                angular.forEach(observers, function(observer) {\n                  observer();\n                });\n                observers.length = 0;\n              }\n            }\n\n            var unregisterTriggers = function() {\n              triggers.show.forEach(function(trigger) {\n                element.unbind(trigger, showTooltipBind);\n              });\n              triggers.hide.forEach(function(trigger) {\n                trigger.split(' ').forEach(function(hideTrigger) {\n                  element[0].removeEventListener(hideTrigger, hideTooltipBind);\n                });\n              });\n            };\n\n            function prepTriggers() {\n              var val = attrs[prefix + 'Trigger'];\n              unregisterTriggers();\n\n              triggers = getTriggers(val);\n\n              if (triggers.show !== 'none') {\n                triggers.show.forEach(function(trigger, idx) {\n                  // Using raw addEventListener due to jqLite/jQuery bug - #4060\n                  if (trigger === triggers.hide[idx]) {\n                    element[0].addEventListener(trigger, toggleTooltipBind);\n                  } else if (trigger) {\n                    element[0].addEventListener(trigger, showTooltipBind);\n                    triggers.hide[idx].split(' ').forEach(function(trigger) {\n                      element[0].addEventListener(trigger, hideTooltipBind);\n                    });\n                  }\n\n                  element.on('keypress', function(e) {\n                    if (e.which === 27) {\n                      hideTooltipBind();\n                    }\n                  });\n                });\n              }\n            }\n\n            prepTriggers();\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\n            // if a tooltip is attached to <body> we need to remove it on\n            // location change as its parent scope will probably not be destroyed\n            // by the change.\n            if (appendToBody) {\n              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {\n                if (ttScope.isOpen) {\n                  hide();\n                }\n              });\n            }\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              cancelShow();\n              cancelHide();\n              unregisterTriggers();\n              removeTooltip();\n              openedTooltips.remove(ttScope);\n              ttScope = null;\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n// This is mostly ngInclude code but with a custom scope\n.directive('uibTooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest',\nfunction ($animate ,  $sce ,  $compile ,  $templateRequest) {\n  return {\n    link: function(scope, elem, attrs) {\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n/**\n * Note that it's intentional that these classes are *not* applied through $animate.\n * They must not be animated as they're expected to be present on the tooltip on\n * initialization.\n */\n.directive('uibTooltipClasses', function() {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      if (scope.placement) {\n        element.addClass(scope.placement);\n      }\n\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n})\n\n.directive('uibTooltipPopup', function() {\n  return {\n    replace: true,\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-popup.html',\n    link: function(scope, element) {\n      element.addClass('tooltip');\n    }\n  };\n})\n\n.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('uibTooltipTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n    link: function(scope, element) {\n      element.addClass('tooltip');\n    }\n  };\n})\n\n.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibTooltipHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n    link: function(scope, element) {\n      element.addClass('tooltip');\n    }\n  };\n})\n\n.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/* Deprecated tooltip below */\n\nangular.module('ui.bootstrap.tooltip')\n\n.value('$tooltipSuppressWarning', false)\n\n.provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {\n  angular.extend(this, $uibTooltipProvider);\n\n  this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {\n    if (!$tooltipSuppressWarning) {\n      $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');\n    }\n\n    return $injector.invoke($uibTooltipProvider.$get);\n  }];\n}])\n\n// This is mostly ngInclude code but with a custom scope\n.directive('tooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning',\nfunction ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {\n  return {\n    link: function(scope, elem, attrs) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');\n      }\n\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n.directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');\n      }\n\n      if (scope.placement) {\n        element.addClass(scope.placement);\n      }\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n}])\n\n.directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-popup.html',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');\n      }\n\n      element.addClass('tooltip');\n    }\n  };\n}])\n\n.directive('tooltip', ['$tooltip', function($tooltip) {\n  return $tooltip('tooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');\n      }\n\n      element.addClass('tooltip');\n    }\n  };\n}])\n\n.directive('tooltipTemplate', ['$tooltip', function($tooltip) {\n  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');\n      }\n\n      element.addClass('tooltip');\n    }\n  };\n}])\n\n.directive('tooltipHtml', ['$tooltip', function($tooltip) {\n  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, and selector delegatation.\n */\nangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\n.directive('uibPopoverTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/popover/popover-template.html',\n    link: function(scope, element) {\n      element.addClass('popover');\n    }\n  };\n})\n\n.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover-html.html',\n    link: function(scope, element) {\n      element.addClass('popover');\n    }\n  };\n})\n\n.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverPopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover.html',\n    link: function(scope, element) {\n      element.addClass('popover');\n    }\n  };\n})\n\n.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopover', 'popover', 'click');\n}]);\n\n/* Deprecated popover below */\n\nangular.module('ui.bootstrap.popover')\n\n.value('$popoverSuppressWarning', false)\n\n.directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/popover/popover-template.html',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');\n      }\n\n      element.addClass('popover');\n    }\n  };\n}])\n\n.directive('popoverTemplate', ['$tooltip', function($tooltip) {\n  return $tooltip('popoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover-html.html',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');\n      }\n\n      element.addClass('popover');\n    }\n  };\n}])\n\n.directive('popoverHtml', ['$tooltip', function($tooltip) {\n  return $tooltip('popoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover.html',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');\n      }\n\n      element.addClass('popover');\n    }\n  };\n}])\n\n.directive('popover', ['$tooltip', function($tooltip) {\n\n  return $tooltip('popover', 'popover', 'click');\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('uibProgressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n  var self = this,\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = $scope.max;\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n    this.bars.forEach(function (bar) {\n      bar.recalculatePercentage();\n    });\n  };\n\n  $scope.$watch('max', function(max) {\n    self.bars.forEach(function(bar) {\n      bar.max = $scope.max;\n      bar.recalculatePercentage();\n    });\n  });\n}])\n\n.directive('uibProgress', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    require: 'uibProgress',\n    scope: {\n      max: '=?'\n    },\n    templateUrl: 'template/progressbar/progress.html'\n  };\n})\n\n.directive('uibBar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^uibProgress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, element, attrs);\n    }\n  };\n})\n\n.directive('uibProgressbar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    scope: {\n      value: '=',\n      max: '=?',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n});\n\n/* Deprecated progressbar below */\n\nangular.module('ui.bootstrap.progressbar')\n\n.value('$progressSuppressWarning', false)\n\n.controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {\n  if (!$progressSuppressWarning) {\n    $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');\n  }\n\n  var self = this,\n    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = $scope.max;\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n  };\n\n  $scope.$watch('max', function(max) {\n    self.bars.forEach(function(bar) {\n      bar.max = $scope.max;\n      bar.recalculatePercentage();\n    });\n  });\n}])\n\n.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'ProgressController',\n    require: 'progress',\n    scope: {\n      max: '=?',\n      title: '@?'\n    },\n    templateUrl: 'template/progressbar/progress.html',\n    link: function() {\n      if (!$progressSuppressWarning) {\n        $log.warn('progress is now deprecated. Use uib-progress instead.');\n      }\n    }\n  };\n}])\n\n.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^progress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      if (!$progressSuppressWarning) {\n        $log.warn('bar is now deprecated. Use uib-bar instead.');\n      }\n      progressCtrl.addBar(scope, element);\n    }\n  };\n}])\n\n.directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'ProgressController',\n    scope: {\n      value: '=',\n      max: '=?',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      if (!$progressSuppressWarning) {\n        $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');\n      }\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.rating', [])\n\n.constant('uibRatingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null,\n  titles : ['one', 'two', 'three', 'four', 'five']\n})\n\n.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl  = { $setViewValue: angular.noop };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.push(function(value) {\n      if (angular.isNumber(value) && value << 0 !== value) {\n        value = Math.round(value);\n      }\n      return value;\n    });\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n      tmpTitles : ratingConfig.titles;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n      $scope.$parent.$eval($attrs.ratingStates) :\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n    }\n    return states;\n  };\n\n  this.getTitle = function(index) {\n    if (index >= this.titles.length) {\n      return index + 1;\n    } else {\n      return this.titles[index];\n    }\n  };\n\n  $scope.rate = function(value) {\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if (!$scope.readonly) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n  };\n}])\n\n.directive('uibRating', function() {\n  return {\n    require: ['uibRating', 'ngModel'],\n    scope: {\n      readonly: '=?',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'UibRatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n});\n\n/* Deprecated rating below */\n\nangular.module('ui.bootstrap.rating')\n\n.value('$ratingSuppressWarning', false)\n\n.controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {\n  if (!$ratingSuppressWarning) {\n    $log.warn('RatingController is now deprecated. Use UibRatingController instead.');\n  }\n\n  angular.extend(this, $controller('UibRatingController', {\n    $scope: $scope,\n    $attrs: $attrs\n  }));\n}])\n\n.directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {\n  return {\n    require: ['rating', 'ngModel'],\n    scope: {\n      readonly: '=?',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'RatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$ratingSuppressWarning) {\n        $log.warn('rating is now deprecated. Use uib-rating instead.');\n      }\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n}]);\n\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.tabs\n *\n * @description\n * AngularJS version of the tabs directive.\n */\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('UibTabsetController', ['$scope', function ($scope) {\n  var ctrl = this,\n      tabs = ctrl.tabs = $scope.tabs = [];\n\n  ctrl.select = function(selectedTab) {\n    angular.forEach(tabs, function(tab) {\n      if (tab.active && tab !== selectedTab) {\n        tab.active = false;\n        tab.onDeselect();\n        selectedTab.selectCalled = false;\n      }\n    });\n    selectedTab.active = true;\n    // only call select if it has not already been called\n    if (!selectedTab.selectCalled) {\n      selectedTab.onSelect();\n      selectedTab.selectCalled = true;\n    }\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    tabs.push(tab);\n    // we can't run the select function on the first tab\n    // since that would select it twice\n    if (tabs.length === 1 && tab.active !== false) {\n      tab.active = true;\n    } else if (tab.active) {\n      ctrl.select(tab);\n    } else {\n      tab.active = false;\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index = tabs.indexOf(tab);\n    //Select a new tab if the tab to be removed is selected and not destroyed\n    if (tab.active && tabs.length > 1 && !destroyed) {\n      //If this is the last tab, select the previous tab. else, the next tab.\n      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n      ctrl.select(tabs[newActiveIndex]);\n    }\n    tabs.splice(index, 1);\n  };\n\n  var destroyed;\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabset\n * @restrict EA\n *\n * @description\n * Tabset is the outer container for the tabs directive\n *\n * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <uib-tabset>\n      <uib-tab heading=\"Tab 1\"><b>First</b> Content!</uib-tab>\n      <uib-tab heading=\"Tab 2\"><i>Second</i> Content!</uib-tab>\n    </uib-tabset>\n    <hr />\n    <uib-tabset vertical=\"true\">\n      <uib-tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</uib-tab>\n      <uib-tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</uib-tab>\n    </uib-tabset>\n    <uib-tabset justified=\"true\">\n      <uib-tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</uib-tab>\n      <uib-tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</uib-tab>\n    </uib-tabset>\n  </file>\n</example>\n */\n.directive('uibTabset', function() {\n  return {\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@'\n    },\n    controller: 'UibTabsetController',\n    templateUrl: 'template/tabs/tabset.html',\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tab\n * @restrict EA\n *\n * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n * @param {string=} select An expression to evaluate when the tab is selected.\n * @param {boolean=} active A binding, telling whether or not this tab is selected.\n * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n *\n * @description\n * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <div ng-controller=\"TabsDemoCtrl\">\n      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n        Select item 1, using active binding\n      </button>\n      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n        Enable/disable item 2, using disabled binding\n      </button>\n      <br />\n      <uib-tabset>\n        <uib-tab heading=\"Tab 1\">First Tab</uib-tab>\n        <uib-tab select=\"alertMe()\">\n          <uib-tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n          Second Tab, with alert callback and html heading!\n        </uib-tab>\n        <uib-tab ng-repeat=\"item in items\"\n          heading=\"{{item.title}}\"\n          disabled=\"item.disabled\"\n          active=\"item.active\">\n          {{item.content}}\n        </uib-tab>\n      </uib-tabset>\n    </div>\n  </file>\n  <file name=\"script.js\">\n    function TabsDemoCtrl($scope) {\n      $scope.items = [\n        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n      ];\n\n      $scope.alertMe = function() {\n        setTimeout(function() {\n          alert(\"You've selected the alert tab!\");\n        });\n      };\n    };\n  </file>\n</example>\n */\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabHeading\n * @restrict EA\n *\n * @description\n * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <uib-tabset>\n      <uib-tab>\n        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>\n        And some content, too!\n      </uib-tab>\n      <uib-tab>\n        <uib-tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n        That's right.\n      </uib-tab>\n    </uib-tabset>\n  </file>\n</example>\n */\n.directive('uibTab', ['$parse', function($parse) {\n  return {\n    require: '^uibTabset',\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/tabs/tab.html',\n    transclude: true,\n    scope: {\n      active: '=?',\n      heading: '@',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n      scope.$watch('active', function(active) {\n        if (active) {\n          tabsetCtrl.select(scope);\n        }\n      });\n\n      scope.disabled = false;\n      if (attrs.disable) {\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\n          scope.disabled = !! value;\n        });\n      }\n\n      scope.select = function() {\n        if (!scope.disabled) {\n          scope.active = true;\n        }\n      };\n\n      tabsetCtrl.addTab(scope);\n      scope.$on('$destroy', function() {\n        tabsetCtrl.removeTab(scope);\n      });\n\n      //We need to transclude later, once the content container is ready.\n      //when this link happens, we're inside a tab heading.\n      scope.$transcludeFn = transclude;\n    }\n  };\n}])\n\n.directive('uibTabHeadingTransclude', function() {\n  return {\n    restrict: 'A',\n    require: ['?^uibTab', '?^tab'], // TODO: change to '^uibTab' after deprecation removal\n    link: function(scope, elm) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n})\n\n.directive('uibTabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: ['?^uibTabset', '?^tabset'], // TODO: change to '^uibTabset' after deprecation removal\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.uibTabContentTransclude);\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n\n  function isTabHeading(node) {\n    return node.tagName && (\n      node.hasAttribute('tab-heading') || // TODO: remove after deprecation removal\n      node.hasAttribute('data-tab-heading') || // TODO: remove after deprecation removal\n      node.hasAttribute('x-tab-heading') || // TODO: remove after deprecation removal\n      node.hasAttribute('uib-tab-heading') ||\n      node.hasAttribute('data-uib-tab-heading') ||\n      node.hasAttribute('x-uib-tab-heading') ||\n      node.tagName.toLowerCase() === 'tab-heading' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === 'data-tab-heading' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === 'x-tab-heading' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n    );\n  }\n});\n\n/* deprecated tabs below */\n\nangular.module('ui.bootstrap.tabs')\n\n  .value('$tabsSuppressWarning', false)\n\n  .controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {\n    if (!$tabsSuppressWarning) {\n      $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');\n    }\n\n    angular.extend(this, $controller('UibTabsetController', {\n      $scope: $scope\n    }));\n  }])\n\n  .directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: 'EA',\n      transclude: true,\n      replace: true,\n      scope: {\n        type: '@'\n      },\n      controller: 'TabsetController',\n      templateUrl: 'template/tabs/tabset.html',\n      link: function(scope, element, attrs) {\n\n        if (!$tabsSuppressWarning) {\n          $log.warn('tabset is now deprecated. Use uib-tabset instead.');\n        }\n        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n      }\n    };\n  }])\n\n  .directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {\n    return {\n      require: '^tabset',\n      restrict: 'EA',\n      replace: true,\n      templateUrl: 'template/tabs/tab.html',\n      transclude: true,\n      scope: {\n        active: '=?',\n        heading: '@',\n        onSelect: '&select', //This callback is called in contentHeadingTransclude\n        //once it inserts the tab's content into the dom\n        onDeselect: '&deselect'\n      },\n      controller: function() {\n        //Empty controller so other directives can require being 'under' a tab\n      },\n      link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n        if (!$tabsSuppressWarning) {\n          $log.warn('tab is now deprecated. Use uib-tab instead.');\n        }\n\n        scope.$watch('active', function(active) {\n          if (active) {\n            tabsetCtrl.select(scope);\n          }\n        });\n\n        scope.disabled = false;\n        if (attrs.disable) {\n          scope.$parent.$watch($parse(attrs.disable), function(value) {\n            scope.disabled = !!value;\n          });\n        }\n\n        scope.select = function() {\n          if (!scope.disabled) {\n            scope.active = true;\n          }\n        };\n\n        tabsetCtrl.addTab(scope);\n        scope.$on('$destroy', function() {\n          tabsetCtrl.removeTab(scope);\n        });\n\n        //We need to transclude later, once the content container is ready.\n        //when this link happens, we're inside a tab heading.\n        scope.$transcludeFn = transclude;\n      }\n    };\n  }])\n\n  .directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: 'A',\n      require: '^tab',\n      link: function(scope, elm) {\n        if (!$tabsSuppressWarning) {\n          $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');\n        }\n\n        scope.$watch('headingElement', function updateHeadingElement(heading) {\n          if (heading) {\n            elm.html('');\n            elm.append(heading);\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: 'A',\n      require: '^tabset',\n      link: function(scope, elm, attrs) {\n        if (!$tabsSuppressWarning) {\n          $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');\n        }\n\n        var tab = scope.$eval(attrs.tabContentTransclude);\n\n        //Now our tab is ready to be transcluded: both the tab heading area\n        //and the tab content area are loaded.  Transclude 'em both.\n        tab.$transcludeFn(tab.$parent, function(contents) {\n          angular.forEach(contents, function(node) {\n            if (isTabHeading(node)) {\n              //Let tabHeadingTransclude know.\n              tab.headingElement = node;\n            }\n            else {\n              elm.append(node);\n            }\n          });\n        });\n      }\n    };\n\n    function isTabHeading(node) {\n      return node.tagName && (\n          node.hasAttribute('tab-heading') ||\n          node.hasAttribute('data-tab-heading') ||\n          node.hasAttribute('x-tab-heading') ||\n          node.tagName.toLowerCase() === 'tab-heading' ||\n          node.tagName.toLowerCase() === 'data-tab-heading' ||\n          node.tagName.toLowerCase() === 'x-tab-heading'\n        );\n    }\n  }]);\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('uibTimepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  showMeridian: true,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true,\n  arrowkeys: true,\n  showSpinners: true\n})\n\n.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var selected = new Date(),\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n  $element.removeAttr('tabindex');\n\n  this.init = function(ngModelCtrl_, inputs) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\n      return modelValue ? new Date(modelValue) : null;\n    });\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1);\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n    if (mousewheel) {\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);\n    }\n\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n    if (arrowkeys) {\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents(hoursInputEl, minutesInputEl);\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = parseInt(value, 10);\n    });\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = parseInt(value, 10);\n    });\n  }\n\n  var min;\n  $scope.$parent.$watch($parse($attrs.min), function(value) {\n    var dt = new Date(value);\n    min = isNaN(dt) ? undefined : dt;\n  });\n\n  var max;\n  $scope.$parent.$watch($parse($attrs.max), function(value) {\n    var dt = new Date(value);\n    max = isNaN(dt) ? undefined : dt;\n  });\n\n  $scope.noIncrementHours = function() {\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\n    return incrementedSelected > max ||\n      (incrementedSelected < selected && incrementedSelected < min);\n  };\n\n  $scope.noDecrementHours = function() {\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n    return decrementedSelected < min ||\n      (decrementedSelected > selected && decrementedSelected > max);\n  };\n\n  $scope.noIncrementMinutes = function() {\n    var incrementedSelected = addMinutes(selected, minuteStep);\n    return incrementedSelected > max ||\n      (incrementedSelected < selected && incrementedSelected < min);\n  };\n\n  $scope.noDecrementMinutes = function() {\n    var decrementedSelected = addMinutes(selected, -minuteStep);\n    return decrementedSelected < min ||\n      (decrementedSelected > selected && decrementedSelected > max);\n  };\n\n  $scope.noToggleMeridian = function() {\n    if (selected.getHours() < 13) {\n      return addMinutes(selected, 12 * 60) > max;\n    } else {\n      return addMinutes(selected, -12 * 60) < min;\n    }\n  };\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if (ngModelCtrl.$error.time) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n          selected.setHours(hours);\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    });\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate() {\n    var hours = parseInt($scope.hours, 10);\n    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n    if (!valid) {\n      return undefined;\n    }\n\n    if ($scope.showMeridian) {\n      if (hours === 12) {\n        hours = 0;\n      }\n      if ($scope.meridian === meridians[1]) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = parseInt($scope.minutes, 10);\n    return (minutes >= 0 && minutes < 60) ? minutes : undefined;\n  }\n\n  function pad(value) {\n    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n      return (e.detail || delta > 0);\n    };\n\n    hoursInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n      e.preventDefault();\n    });\n\n    minutesInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n      e.preventDefault();\n    });\n\n  };\n\n  // Respond on up/down arrowkeys\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {\n    hoursInputEl.bind('keydown', function(e) {\n      if (e.which === 38) { // up\n        e.preventDefault();\n        $scope.incrementHours();\n        $scope.$apply();\n      } else if (e.which === 40) { // down\n        e.preventDefault();\n        $scope.decrementHours();\n        $scope.$apply();\n      }\n    });\n\n    minutesInputEl.bind('keydown', function(e) {\n      if (e.which === 38) { // up\n        e.preventDefault();\n        $scope.incrementMinutes();\n        $scope.$apply();\n      } else if (e.which === 40) { // down\n        e.preventDefault();\n        $scope.decrementMinutes();\n        $scope.$apply();\n      }\n    });\n  };\n\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {\n    if ($scope.readonlyInput) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes) {\n      ngModelCtrl.$setViewValue(null);\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n      }\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate(),\n        minutes = getMinutesFromTemplate();\n\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n        selected.setHours(hours);\n        if (selected < min || selected > max) {\n          invalidate(true);\n        } else {\n          refresh('h');\n        }\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.bind('blur', function(e) {\n      if (!$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply(function() {\n          $scope.hours = pad($scope.hours);\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(undefined, true);\n        } else {\n          refresh('m');\n        }\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.bind('blur', function(e) {\n      if (!$scope.invalidMinutes && $scope.minutes < 10) {\n        $scope.$apply(function() {\n          $scope.minutes = pad($scope.minutes);\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$viewValue;\n\n    if (isNaN(date)) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if (date) {\n        selected = date;\n      }\n\n      if (selected < min || selected > max) {\n        ngModelCtrl.$setValidity('time', false);\n        $scope.invalidHours = true;\n        $scope.invalidMinutes = true;\n      } else {\n        makeValid();\n      }\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh(keyboardChange) {\n    makeValid();\n    ngModelCtrl.$setViewValue(new Date(selected));\n    updateTemplate(keyboardChange);\n  }\n\n  function makeValid() {\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n  }\n\n  function updateTemplate(keyboardChange) {\n    var hours = selected.getHours(), minutes = selected.getMinutes();\n\n    if ($scope.showMeridian) {\n      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system\n    }\n\n    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n    if (keyboardChange !== 'm') {\n      $scope.minutes = pad(minutes);\n    }\n    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n  }\n\n  function addMinutes(date, minutes) {\n    var dt = new Date(date.getTime() + minutes * 60000);\n    var newDate = new Date(date);\n    newDate.setHours(dt.getHours(), dt.getMinutes());\n    return newDate;\n  }\n\n  function addMinutesToSelected(minutes) {\n    selected = addMinutes(selected, minutes);\n    refresh();\n  }\n\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\n  $scope.incrementHours = function() {\n    if (!$scope.noIncrementHours()) {\n      addMinutesToSelected(hourStep * 60);\n    }\n  };\n\n  $scope.decrementHours = function() {\n    if (!$scope.noDecrementHours()) {\n      addMinutesToSelected(-hourStep * 60);\n    }\n  };\n\n  $scope.incrementMinutes = function() {\n    if (!$scope.noIncrementMinutes()) {\n      addMinutesToSelected(minuteStep);\n    }\n  };\n\n  $scope.decrementMinutes = function() {\n    if (!$scope.noDecrementMinutes()) {\n      addMinutesToSelected(-minuteStep);\n    }\n  };\n\n  $scope.toggleMeridian = function() {\n    if (!$scope.noToggleMeridian()) {\n      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));\n    }\n  };\n}])\n\n.directive('uibTimepicker', function() {\n  return {\n    restrict: 'EA',\n    require: ['uibTimepicker', '?^ngModel'],\n    controller: 'UibTimepickerController',\n    controllerAs: 'timepicker',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n});\n\n/* Deprecated timepicker below */\n\nangular.module('ui.bootstrap.timepicker')\n\n.value('$timepickerSuppressWarning', false)\n\n.controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {\n  if (!$timepickerSuppressWarning) {\n    $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');\n  }\n\n  angular.extend(this, $controller('UibTimepickerController', {\n    $scope: $scope,\n    $element: $element,\n    $attrs: $attrs\n  }));\n}])\n\n.directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {\n  return {\n    restrict: 'EA',\n    require: ['timepicker', '?^ngModel'],\n    controller: 'TimepickerController',\n    controllerAs: 'timepicker',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      if (!$timepickerSuppressWarning) {\n        $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');\n      }\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n    return {\n      parse: function(input) {\n        var match = input.match(TYPEAHEAD_REGEXP);\n        if (!match) {\n          throw new Error(\n            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n              ' but got \"' + input + '\".');\n        }\n\n        return {\n          itemName: match[3],\n          source: $parse(match[4]),\n          viewMapper: $parse(match[2] || match[1]),\n          modelMapper: $parse(match[1])\n        };\n      }\n    };\n  }])\n\n  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser',\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    var modelCtrl, ngModelOptions;\n    //SUPPORTED ATTRIBUTES (OPTIONS)\n\n    //minimal no of characters that needs to be entered before typeahead kicks-in\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n    if (!minLength && minLength !== 0) {\n      minLength = 1;\n    }\n\n    //minimal wait time after last character typed before typeahead kicks-in\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n    //should it restrict model values to the ones selected from the popup only?\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n    //binding to a variable that indicates if matches are being retrieved asynchronously\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n    //a callback executed when a match is selected\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n    //should it select highlighted popup value when losing focus?\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n    //binding to a variable that indicates if there were no results after the query is completed\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n    var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n    //If input matches an item of the list exactly, select it automatically\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n    //INTERNAL VARIABLES\n\n    //model setter executed upon match selection\n    var parsedModel = $parse(attrs.ngModel);\n    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n    var $setModelValue = function(scope, newValue) {\n      if (angular.isFunction(parsedModel(originalScope)) &&\n        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n        return invokeModelSetter(scope, {$$$p: newValue});\n      } else {\n        return parsedModel.assign(scope, newValue);\n      }\n    };\n\n    //expressions used by typeahead\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\n    var hasFocus;\n\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n    //mousedown & mouseup events\n    //Issue #3699\n    var selected;\n\n    //create a child scope for the typeahead directive so we are not polluting original scope\n    //with typeahead-specific data (matches, query etc.)\n    var scope = originalScope.$new();\n    var offDestroy = originalScope.$on('$destroy', function() {\n      scope.$destroy();\n    });\n    scope.$on('$destroy', offDestroy);\n\n    // WAI-ARIA\n    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n    element.attr({\n      'aria-autocomplete': 'list',\n      'aria-expanded': false,\n      'aria-owns': popupId\n    });\n\n    //pop-up element used to display matches\n    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n    popUpEl.attr({\n      id: popupId,\n      matches: 'matches',\n      active: 'activeIdx',\n      select: 'select(activeIdx)',\n      'move-in-progress': 'moveInProgress',\n      query: 'query',\n      position: 'position'\n    });\n    //custom item template\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n    }\n\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n    }\n\n    var resetMatches = function() {\n      scope.matches = [];\n      scope.activeIdx = -1;\n      element.attr('aria-expanded', false);\n    };\n\n    var getMatchId = function(index) {\n      return popupId + '-option-' + index;\n    };\n\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n    // This attribute is added or removed automatically when the `activeIdx` changes.\n    scope.$watch('activeIdx', function(index) {\n      if (index < 0) {\n        element.removeAttr('aria-activedescendant');\n      } else {\n        element.attr('aria-activedescendant', getMatchId(index));\n      }\n    });\n\n    var inputIsExactMatch = function(inputValue, index) {\n      if (scope.matches.length > index && inputValue) {\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n      }\n\n      return false;\n    };\n\n    var getMatchesAsync = function(inputValue) {\n      var locals = {$viewValue: inputValue};\n      isLoadingSetter(originalScope, true);\n      isNoResultsSetter(originalScope, false);\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n        //it might happen that several async queries were in progress if a user were typing fast\n        //but we are interested only in responses that correspond to the current view value\n        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n        if (onCurrentRequest && hasFocus) {\n          if (matches && matches.length > 0) {\n            scope.activeIdx = focusFirst ? 0 : -1;\n            isNoResultsSetter(originalScope, false);\n            scope.matches.length = 0;\n\n            //transform labels\n            for (var i = 0; i < matches.length; i++) {\n              locals[parserResult.itemName] = matches[i];\n              scope.matches.push({\n                id: getMatchId(i),\n                label: parserResult.viewMapper(scope, locals),\n                model: matches[i]\n              });\n            }\n\n            scope.query = inputValue;\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n            //due to other elements being rendered\n            recalculatePosition();\n\n            element.attr('aria-expanded', true);\n\n            //Select the single remaining option if user input matches\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n              scope.select(0);\n            }\n          } else {\n            resetMatches();\n            isNoResultsSetter(originalScope, true);\n          }\n        }\n        if (onCurrentRequest) {\n          isLoadingSetter(originalScope, false);\n        }\n      }, function() {\n        resetMatches();\n        isLoadingSetter(originalScope, false);\n        isNoResultsSetter(originalScope, true);\n      });\n    };\n\n    // bind events only if appendToBody params exist - performance feature\n    if (appendToBody) {\n      angular.element($window).bind('resize', fireRecalculating);\n      $document.find('body').bind('scroll', fireRecalculating);\n    }\n\n    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutEventPromise;\n\n    // Default progress type\n    scope.moveInProgress = false;\n\n    function fireRecalculating() {\n      if (!scope.moveInProgress) {\n        scope.moveInProgress = true;\n        scope.$digest();\n      }\n\n      // Cancel previous timeout\n      if (timeoutEventPromise) {\n        $timeout.cancel(timeoutEventPromise);\n      }\n\n      // Debounced executing recalculate after events fired\n      timeoutEventPromise = $timeout(function() {\n        // if popup is visible\n        if (scope.matches.length) {\n          recalculatePosition();\n        }\n\n        scope.moveInProgress = false;\n      }, eventDebounceTime);\n    }\n\n    // recalculate actual position and set new values to scope\n    // after digest loop is popup in right position\n    function recalculatePosition() {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top += element.prop('offsetHeight');\n    }\n\n    //we need to propagate user's query so we can higlight matches\n    scope.query = undefined;\n\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutPromise;\n\n    var scheduleSearchWithTimeout = function(inputValue) {\n      timeoutPromise = $timeout(function() {\n        getMatchesAsync(inputValue);\n      }, waitTime);\n    };\n\n    var cancelPreviousTimeout = function() {\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n    };\n\n    resetMatches();\n\n    scope.select = function(activeIdx) {\n      //called from within the $digest() cycle\n      var locals = {};\n      var model, item;\n\n      selected = true;\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n      model = parserResult.modelMapper(originalScope, locals);\n      $setModelValue(originalScope, model);\n      modelCtrl.$setValidity('editable', true);\n      modelCtrl.$setValidity('parse', true);\n\n      onSelectCallback(originalScope, {\n        $item: item,\n        $model: model,\n        $label: parserResult.viewMapper(originalScope, locals)\n      });\n\n      resetMatches();\n\n      //return focus to the input element if a match was selected via a mouse click event\n      // use timeout to avoid $rootScope:inprog error\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n        $timeout(function() { element[0].focus(); }, 0, false);\n      }\n    };\n\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n    element.bind('keydown', function(evt) {\n      //typeahead is open and an \"interesting\" key was pressed\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n        return;\n      }\n\n      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n        resetMatches();\n        scope.$digest();\n        return;\n      }\n\n      evt.preventDefault();\n\n      if (evt.which === 40) {\n        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n        scope.$digest();\n      } else if (evt.which === 38) {\n        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n        scope.$digest();\n      } else if (evt.which === 13 || evt.which === 9) {\n        scope.$apply(function () {\n          scope.select(scope.activeIdx);\n        });\n      } else if (evt.which === 27) {\n        evt.stopPropagation();\n\n        resetMatches();\n        scope.$digest();\n      }\n    });\n\n    element.bind('blur', function() {\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n        selected = true;\n        scope.$apply(function() {\n          scope.select(scope.activeIdx);\n        });\n      }\n      hasFocus = false;\n      selected = false;\n    });\n\n    // Keep reference to click handler to unbind it.\n    var dismissClickHandler = function(evt) {\n      // Issue #3973\n      // Firefox treats right click as a click on document\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n        resetMatches();\n        if (!$rootScope.$$phase) {\n          scope.$digest();\n        }\n      }\n    };\n\n    $document.bind('click', dismissClickHandler);\n\n    originalScope.$on('$destroy', function() {\n      $document.unbind('click', dismissClickHandler);\n      if (appendToBody || appendToElementId) {\n        $popup.remove();\n      }\n\n      if (appendToBody) {\n        angular.element($window).unbind('resize', fireRecalculating);\n        $document.find('body').unbind('scroll', fireRecalculating);\n      }\n      // Prevent jQuery cache memory leak\n      popUpEl.remove();\n    });\n\n    var $popup = $compile(popUpEl)(scope);\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else if (appendToElementId !== false) {\n      angular.element($document[0].getElementById(appendToElementId)).append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    this.init = function(_modelCtrl, _ngModelOptions) {\n      modelCtrl = _modelCtrl;\n      ngModelOptions = _ngModelOptions;\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function(inputValue) {\n        hasFocus = true;\n\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        } else {\n          if (!inputValue) {\n            // Reset in case user had typed something previously.\n            modelCtrl.$setValidity('editable', true);\n            return null;\n          } else {\n            modelCtrl.$setValidity('editable', false);\n            return undefined;\n          }\n        }\n      });\n\n      modelCtrl.$formatters.push(function(modelValue) {\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        // The validity may be set to false via $parsers (see above) if\n        // the model is restricted to selected values. If the model\n        // is set manually it is considered to be valid.\n        if (!isEditable) {\n          modelCtrl.$setValidity('editable', true);\n        }\n\n        if (inputFormatter) {\n          locals.$model = modelValue;\n          return inputFormatter(originalScope, locals);\n        } else {\n          //it might happen that we don't have enough info to properly render input value\n          //we need to check for this situation and simply return model value if we can't apply custom formatting\n          locals[parserResult.itemName] = modelValue;\n          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n          locals[parserResult.itemName] = undefined;\n          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n        }\n      });\n    };\n  }])\n\n  .directive('uibTypeahead', function() {\n    return {\n      controller: 'UibTypeaheadController',\n      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n      link: function(originalScope, element, attrs, ctrls) {\n        ctrls[2].init(ctrls[0], ctrls[1]);\n      }\n    };\n  })\n\n  .directive('uibTypeaheadPopup', function() {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  })\n\n  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n    return {\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link:function(scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          $compile(tplContent.trim())(scope, function(clonedElement) {\n            element.replaceWith(clonedElement);\n          });\n        });\n      }\n    };\n  }])\n\n  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n      return matchItem;\n    };\n  }]);\n\n/* Deprecated typeahead below */\n  \nangular.module('ui.bootstrap.typeahead')\n  .value('$typeaheadSuppressWarning', false)\n  .service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {\n    if (!$typeaheadSuppressWarning) {\n      $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');\n    }\n\n    return uibTypeaheadParser;\n  }])\n\n  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning',\n    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    return {\n      require: ['ngModel', '^?ngModelOptions'],\n      link: function(originalScope, element, attrs, ctrls) {\n        if (!$typeaheadSuppressWarning) {\n          $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');\n        }\n        var modelCtrl = ctrls[0];\n        var ngModelOptions = ctrls[1];\n        //SUPPORTED ATTRIBUTES (OPTIONS)\n\n        //minimal no of characters that needs to be entered before typeahead kicks-in\n        var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n        if (!minLength && minLength !== 0) {\n          minLength = 1;\n        }\n\n        //minimal wait time after last character typed before typeahead kicks-in\n        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n        //should it restrict model values to the ones selected from the popup only?\n        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n        //binding to a variable that indicates if matches are being retrieved asynchronously\n        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n        //a callback executed when a match is selected\n        var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n        //should it select highlighted popup value when losing focus?\n        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n        //binding to a variable that indicates if there were no results after the query is completed\n        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n        var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\n        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n        //If input matches an item of the list exactly, select it automatically\n        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n        //INTERNAL VARIABLES\n\n        //model setter executed upon match selection\n        var parsedModel = $parse(attrs.ngModel);\n        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n        var $setModelValue = function(scope, newValue) {\n          if (angular.isFunction(parsedModel(originalScope)) &&\n            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n            return invokeModelSetter(scope, {$$$p: newValue});\n          } else {\n            return parsedModel.assign(scope, newValue);\n          }\n        };\n\n        //expressions used by typeahead\n        var parserResult = typeaheadParser.parse(attrs.typeahead);\n\n        var hasFocus;\n\n        //Used to avoid bug in iOS webview where iOS keyboard does not fire\n        //mousedown & mouseup events\n        //Issue #3699\n        var selected;\n\n        //create a child scope for the typeahead directive so we are not polluting original scope\n        //with typeahead-specific data (matches, query etc.)\n        var scope = originalScope.$new();\n        var offDestroy = originalScope.$on('$destroy', function() {\n\t\t\t    scope.$destroy();\n        });\n        scope.$on('$destroy', offDestroy);\n\n        // WAI-ARIA\n        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n        element.attr({\n          'aria-autocomplete': 'list',\n          'aria-expanded': false,\n          'aria-owns': popupId\n        });\n\n        //pop-up element used to display matches\n        var popUpEl = angular.element('<div typeahead-popup></div>');\n        popUpEl.attr({\n          id: popupId,\n          matches: 'matches',\n          active: 'activeIdx',\n          select: 'select(activeIdx)',\n          'move-in-progress': 'moveInProgress',\n          query: 'query',\n          position: 'position'\n        });\n        //custom item template\n        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n        }\n\n        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n        }\n\n        var resetMatches = function() {\n          scope.matches = [];\n          scope.activeIdx = -1;\n          element.attr('aria-expanded', false);\n        };\n\n        var getMatchId = function(index) {\n          return popupId + '-option-' + index;\n        };\n\n        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n        // This attribute is added or removed automatically when the `activeIdx` changes.\n        scope.$watch('activeIdx', function(index) {\n          if (index < 0) {\n            element.removeAttr('aria-activedescendant');\n          } else {\n            element.attr('aria-activedescendant', getMatchId(index));\n          }\n        });\n\n        var inputIsExactMatch = function(inputValue, index) {\n          if (scope.matches.length > index && inputValue) {\n            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n          }\n\n          return false;\n        };\n\n        var getMatchesAsync = function(inputValue) {\n          var locals = {$viewValue: inputValue};\n          isLoadingSetter(originalScope, true);\n          isNoResultsSetter(originalScope, false);\n          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n            //it might happen that several async queries were in progress if a user were typing fast\n            //but we are interested only in responses that correspond to the current view value\n            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n            if (onCurrentRequest && hasFocus) {\n              if (matches && matches.length > 0) {\n                scope.activeIdx = focusFirst ? 0 : -1;\n                isNoResultsSetter(originalScope, false);\n                scope.matches.length = 0;\n\n                //transform labels\n                for (var i = 0; i < matches.length; i++) {\n                  locals[parserResult.itemName] = matches[i];\n                  scope.matches.push({\n                    id: getMatchId(i),\n                    label: parserResult.viewMapper(scope, locals),\n                    model: matches[i]\n                  });\n                }\n\n                scope.query = inputValue;\n                //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n                //due to other elements being rendered\n                recalculatePosition();\n\n                element.attr('aria-expanded', true);\n\n                //Select the single remaining option if user input matches\n                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n                  scope.select(0);\n                }\n              } else {\n                resetMatches();\n                isNoResultsSetter(originalScope, true);\n              }\n            }\n            if (onCurrentRequest) {\n              isLoadingSetter(originalScope, false);\n            }\n          }, function() {\n            resetMatches();\n            isLoadingSetter(originalScope, false);\n            isNoResultsSetter(originalScope, true);\n          });\n        };\n\n        // bind events only if appendToBody params exist - performance feature\n        if (appendToBody) {\n          angular.element($window).bind('resize', fireRecalculating);\n          $document.find('body').bind('scroll', fireRecalculating);\n        }\n\n        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n        var timeoutEventPromise;\n\n        // Default progress type\n        scope.moveInProgress = false;\n\n        function fireRecalculating() {\n          if (!scope.moveInProgress) {\n            scope.moveInProgress = true;\n            scope.$digest();\n          }\n\n          // Cancel previous timeout\n          if (timeoutEventPromise) {\n            $timeout.cancel(timeoutEventPromise);\n          }\n\n          // Debounced executing recalculate after events fired\n          timeoutEventPromise = $timeout(function() {\n            // if popup is visible\n            if (scope.matches.length) {\n              recalculatePosition();\n            }\n\n            scope.moveInProgress = false;\n          }, eventDebounceTime);\n        }\n\n        // recalculate actual position and set new values to scope\n        // after digest loop is popup in right position\n        function recalculatePosition() {\n          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n          scope.position.top += element.prop('offsetHeight');\n        }\n\n        resetMatches();\n\n        //we need to propagate user's query so we can higlight matches\n        scope.query = undefined;\n\n        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n        var timeoutPromise;\n\n        var scheduleSearchWithTimeout = function(inputValue) {\n          timeoutPromise = $timeout(function() {\n            getMatchesAsync(inputValue);\n          }, waitTime);\n        };\n\n        var cancelPreviousTimeout = function() {\n          if (timeoutPromise) {\n            $timeout.cancel(timeoutPromise);\n          }\n        };\n\n        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n        modelCtrl.$parsers.unshift(function(inputValue) {\n          hasFocus = true;\n\n          if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n            if (waitTime > 0) {\n              cancelPreviousTimeout();\n              scheduleSearchWithTimeout(inputValue);\n            } else {\n              getMatchesAsync(inputValue);\n            }\n          } else {\n            isLoadingSetter(originalScope, false);\n            cancelPreviousTimeout();\n            resetMatches();\n          }\n\n          if (isEditable) {\n            return inputValue;\n          } else {\n            if (!inputValue) {\n              // Reset in case user had typed something previously.\n              modelCtrl.$setValidity('editable', true);\n              return null;\n            } else {\n              modelCtrl.$setValidity('editable', false);\n              return undefined;\n            }\n          }\n        });\n\n        modelCtrl.$formatters.push(function(modelValue) {\n          var candidateViewValue, emptyViewValue;\n          var locals = {};\n\n          // The validity may be set to false via $parsers (see above) if\n          // the model is restricted to selected values. If the model\n          // is set manually it is considered to be valid.\n          if (!isEditable) {\n            modelCtrl.$setValidity('editable', true);\n          }\n\n          if (inputFormatter) {\n            locals.$model = modelValue;\n            return inputFormatter(originalScope, locals);\n          } else {\n            //it might happen that we don't have enough info to properly render input value\n            //we need to check for this situation and simply return model value if we can't apply custom formatting\n            locals[parserResult.itemName] = modelValue;\n            candidateViewValue = parserResult.viewMapper(originalScope, locals);\n            locals[parserResult.itemName] = undefined;\n            emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n          }\n        });\n\n        scope.select = function(activeIdx) {\n          //called from within the $digest() cycle\n          var locals = {};\n          var model, item;\n\n          selected = true;\n          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n          model = parserResult.modelMapper(originalScope, locals);\n          $setModelValue(originalScope, model);\n          modelCtrl.$setValidity('editable', true);\n          modelCtrl.$setValidity('parse', true);\n\n          onSelectCallback(originalScope, {\n            $item: item,\n            $model: model,\n            $label: parserResult.viewMapper(originalScope, locals)\n          });\n\n          resetMatches();\n\n          //return focus to the input element if a match was selected via a mouse click event\n          // use timeout to avoid $rootScope:inprog error\n          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n            $timeout(function() { element[0].focus(); }, 0, false);\n          }\n        };\n\n        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n        element.bind('keydown', function(evt) {\n          //typeahead is open and an \"interesting\" key was pressed\n          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n            return;\n          }\n\n          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n            resetMatches();\n            scope.$digest();\n            return;\n          }\n\n          evt.preventDefault();\n\n          if (evt.which === 40) {\n            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n            scope.$digest();\n          } else if (evt.which === 38) {\n            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n            scope.$digest();\n          } else if (evt.which === 13 || evt.which === 9) {\n            scope.$apply(function () {\n              scope.select(scope.activeIdx);\n            });\n          } else if (evt.which === 27) {\n            evt.stopPropagation();\n\n            resetMatches();\n            scope.$digest();\n          }\n        });\n\n        element.bind('blur', function() {\n          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n            selected = true;\n            scope.$apply(function() {\n              scope.select(scope.activeIdx);\n            });\n          }\n          hasFocus = false;\n          selected = false;\n        });\n\n        // Keep reference to click handler to unbind it.\n        var dismissClickHandler = function(evt) {\n          // Issue #3973\n          // Firefox treats right click as a click on document\n          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n            resetMatches();\n            if (!$rootScope.$$phase) {\n              scope.$digest();\n            }\n          }\n        };\n\n        $document.bind('click', dismissClickHandler);\n\n        originalScope.$on('$destroy', function() {\n          $document.unbind('click', dismissClickHandler);\n          if (appendToBody || appendToElementId) {\n            $popup.remove();\n          }\n\n          if (appendToBody) {\n            angular.element($window).unbind('resize', fireRecalculating);\n            $document.find('body').unbind('scroll', fireRecalculating);\n          }\n          // Prevent jQuery cache memory leak\n          popUpEl.remove();\n        });\n\n        var $popup = $compile(popUpEl)(scope);\n\n        if (appendToBody) {\n          $document.find('body').append($popup);\n        } else if (appendToElementId !== false) {\n          angular.element($document[0].getElementById(appendToElementId)).append($popup);\n        } else {\n          element.after($popup);\n        }\n      }\n    };\n  }])\n  \n  .directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        \n        if (!$typeaheadSuppressWarning) {\n          $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');\n        }\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  }])\n  \n  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {\n    return {\n      restrict: 'EA',\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link:function(scope, element, attrs) {\n        if (!$typeaheadSuppressWarning) {\n          $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');\n        }\n\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          $compile(tplContent.trim())(scope, function(clonedElement) {\n            element.replaceWith(clonedElement);\n          });\n        });\n      }\n    };\n  }])\n  \n  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!$typeaheadSuppressWarning) {\n        $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');\n      }\n\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n\n      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n\n      return matchItem;\n    };\n  }]);\n\nangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion-group.html\",\n    \"<div class=\\\"panel {{panelClass || 'panel-default'}}\\\">\\n\" +\n    \"  <div class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n    \"      <a href tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n    \"    </h4>\\n\" +\n    \"  </div>\\n\" +\n    \"  <div class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n    \"\t  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion.html\",\n    \"<div class=\\\"panel-group\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/alert/alert.html\",\n    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n    \"    </button>\\n\" +\n    \"    <div ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/carousel/carousel.html\",\n    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ol>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/carousel/slide.html\",\n    \"<div ng-class=\\\"{\\n\" +\n    \"    'active': active\\n\" +\n    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/datepicker.html\",\n    \"<div ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/day.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default btn-sm\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/month.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" dropdown-nested ng-if=\\\"isOpen\\\" style=\\\"display: block\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"\t<li ng-transclude></li>\\n\" +\n    \"\t<li ng-if=\\\"showButtonBar\\\" style=\\\"padding:10px 9px 2px\\\">\\n\" +\n    \"\t\t<span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-info\\\" ng-click=\\\"select('today')\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"\t\t</span>\\n\" +\n    \"\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n    \"\t</li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/year.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"3\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/backdrop.html\",\n    \"<div uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"     modal-in-class=\\\"in\\\"\\n\" +\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n    \"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/window.html\",\n    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"    modal-in-class=\\\"in\\\"\\n\" +\n    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n    \"    <div class=\\\"modal-dialog\\\" ng-class=\\\"size ? 'modal-' + size : ''\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pagination.html\",\n    \"<ul class=\\\"pagination\\\">\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-html-popup.html\",\n    \"<div\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\n    \"<div\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-template-popup.html\",\n    \"<div\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover-html.html\",\n    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover-template.html\",\n    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\"\\n\" +\n    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover.html\",\n    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/bar.html\",\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n}]);\n\nangular.module(\"template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\">\\n\" +\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tab.html\",\n    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\">\\n\" +\n    \"  <a href ng-click=\\\"select()\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tabset.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n    \"  <div class=\\\"tab-content\\\">\\n\" +\n    \"    <div class=\\\"tab-pane\\\" \\n\" +\n    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/timepicker/timepicker.html\",\n    \"<table>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td>:</td>\\n\" +\n    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-match.html\",\n    \"<a href tabindex=\\\"-1\\\" ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"></a>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" style=\\\"display: block;\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n!angular.$$csp() && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/ui-bootstrap-tpls.js\n ** module id = 31\n ** module chunks = 2\n **/"],"sourceRoot":""}