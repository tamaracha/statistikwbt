{"version":3,"sources":["webpack:///vendors.js","webpack:///webpack/bootstrap 8cfa1d3139ee92e72f0c","webpack:///external \"angular\"","webpack:///./~/api-check/dist/api-check.js","webpack:///./~/angular-formly/dist/formly.js","webpack:///./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js","webpack:///./~/angular-permission/dist/angular-permission.js","webpack:///./~/angular-ui-bootstrap/index.js","webpack:///./~/angular-ui-router.statehelper/statehelper.js","webpack:///./~/angular-ui-router/release/angular-ui-router.js","webpack:///./~/ngstorage/ngStorage.js","webpack:///./~/oclazyload/dist/ocLazyLoad.js","webpack:///./~/angular-ui-bootstrap/ui-bootstrap-tpls.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift",1,"e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","angular","root","factory","this","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_apiCheck","_apiCheck2","getApiCheckInstance","apiCheck","api","args","output","config","disabled","globalConfig","apiTypes","argTypes","passed","message","failed","checkApiCheckApi","arguments","Array","isArray","prototype","slice","messages","checkEnoughArgs","checkApiWithArgs","returnObject","getTypes","getErrorMessage","checkApiArgs","isArrayOrArgs","Error","prefix","errors","apiCheckApis","handleErrorMessage","getApiCheck","shouldThrow","result","console","warn","getPrefix","onlyPrefix","gOut","trim","getSuffix","s","onlySuffix","suffix","getUrl","u","url","docsBaseUrl","urlSuffix","join","passedAndShouldHavePassed","buildMessageFromApiAndArgs","replaceFunctionWithName","each","val","name","replacedItems","indexOf","displayName","getObjectString","types","stringify","generateMessage","n","useS","keys","newLine","passedArgs","_getTypes","copy","arrayify","map","checker","index","specified","hasOwnProperty","getCheckerDisplay","terse","verbose","addHelpers","arg","getArgDisplay","extraCheckers","apiCheckApiCheck","getApiCheckInstanceCheckers","additionalProperties","throw","utils","apiCheckUtil","wrapper","checkers","getCheckers","checkerIndex","argIndex","res","lastChecker","argName","argFailed","skipPreviousChecker","isOptional","isError","getCheckerErrorMessage","t","checkerTypeType","checkerType","location","apiCheckDataChecker","shape","string","optional","bool","asFunc","func","withProperties","__apiCheckData","asShape","wrongShape","oneOfType","getError","checkerHelp","getCheckerHelp","_ref","help","requiredArgs","filter","a","gottenArgs","hasKeys","getDisplayIfNotGotten","getDisplay","cName","constructor","typeOf","properties","argDisplay","v","k","getApiCheckApis","os","checkerFnChecker","shortType","notOptional","notRequired","strict","objectOf","typeOrArrayOf","any","VERSION","internalChecker","getSerialize","fn","decycle","seen","key","getPath","ret","path","unshift","spaces","JSON","_defineProperty","enumerable","configurable","writable","daCopy","RegExp","options","display","short","getCheckerType","typeTypes","iterator","context","eachArry","eachObj","hasOwn","list","arry","finalJoin","last","pop","stringType","nAtL","tName","tLocation","thing","undef","setupChecker","getNoop","isNoop","prop","getRequiredVersion","notNullable","addNullable","addOptional","requiredChecker","copyProps","originalChecker","optionalCheck","fixType","nullableCheck","isNullable","nullable","checkerCopy","dest","noop","checkerHelpers","typeOfCheckGetter","lType","toLowerCase","funcCheckGetter","functionChecker","apiError","shapeChecker","notFunction","objectCheckGetter","nullType","objectNullOkChecker","objectChecker","nullOk","instanceCheckGetter","classToCheck","oneOfCheckGetter","enums","enum","enm","some","oneOfTypeCheckGetter","typeCheckers","checkersDisplay","arrayOfCheckGetter","shortCheckerDisplay","array","every","item","objectOfCheckGetter","checkerDisplay","notObject","object","allTypesSuccess","typeOrArrayOfCheckGetter","arrayOf","getShapeCheckGetter","shapeCheckGetter","nonObject","modifyTypeDisplayToHelpOut","theRet","required","addHelper","property","objectMessage","stringMessage","error","toUpperCase","parentRequired","strictType","shapeTypes","isObject","shapePropError","shapeError","allowedProperties","extraProps","getRequiredIfNotChecker","all","otherProps","propChecker","props","ifProps","description","getTypeForShapeChild","propName","propExists","iteration","otherPropsExist","otherProp","ifNot","onlyIf","othersPresent","requiredIfNot","argumentsCheckerGetter","number","anyCheckGetter","nullCheckGetter","rangeCheckGetter","min","max","lessThanCheckGetter","greaterThanCheckGetter","emptyObjectCheckGetter","emptyObject","instanceOf","oneOf","range","lessThan","greaterThan","null","_require","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_5__","_indexCommon","_indexCommon2","_angularFix","_angularFix2","_providersFormlyApiCheck","_providersFormlyApiCheck2","_otherDocsBaseUrl","_otherDocsBaseUrl2","_providersFormlyUsability","_providersFormlyUsability2","_providersFormlyConfig","_providersFormlyConfig2","_providersFormlyValidationMessages","_providersFormlyValidationMessages2","_servicesFormlyUtil","_servicesFormlyUtil2","_servicesFormlyWarn","_servicesFormlyWarn2","_directivesFormlyCustomValidation","_directivesFormlyCustomValidation2","_directivesFormlyField","_directivesFormlyField2","_directivesFormlyFocus","_directivesFormlyFocus2","_directivesFormlyForm","_directivesFormlyForm2","_runFormlyNgModelAttrsManipulator","_runFormlyNgModelAttrsManipulator2","_runFormlyCustomTags","_runFormlyCustomTags2","ngModuleName","ngModule","constant","provider","directive","run","version","shapeRequiredIfNot","shapeRequiredIfNotDefinition","formlyExpression","specifyWrapperType","apiCheckProperty","apiCheckInstanceProperty","apiCheckFunctionProperty","formlyWrapperType","template","templateUrl","overwriteOk","apiCheckInstance","apiCheckFunction","apiCheckOptions","expressionProperties","expression","modelChecker","templateManipulators","preWrapper","postWrapper","validatorChecker","fieldOptionsApiShape","$$hashKey","model","originalModel","className","extras","validateOnModelChange","skipNgModelAttrsManipulator","data","templateOptions","modelOptions","updateOn","debounce","allowInvalid","getterSetter","timezone","watcher","listener","validators","asyncValidators","parsers","formatters","noFormControl","hide","hideExpression","ngModelElAttrs","ngModelAttrs","statement","attribute","bound","boolean","elementAttributes","optionsTypes","link","controller","validation","show","errorExistsAndShouldBeVisible","formControl","runExpressions","resetModel","updateInitialValue","initialValue","defaultValue","formlyFieldOptions","formOptionsApi","formState","removeChromeAutoComplete","fieldTransform","fieldGroup","form","typeOptionsDefaultOptions","formlyTypeOptions","defaultOptions","extends","extend","formlyUsability","formlyApiCheck","formlyErrorAndWarningsUrlPrefix","getFieldError","errorInfoSlug","field","toJson","getFormlyError","checkWrapper","checkWrapperTemplate","additionalInfo","formlyTransclude","_this","$get","$inject","_toConsumableArray","arr","arr2","from","formlyConfig","formlyUsabilityProvider","setType","checkType","extendTypeOptions","typeMap","_ret","allTypes","forEach","checkOverwrite","extendsType","getType","extendTypeControllerFunction","extendTypeLinkFunction","extendTypeDefaultOptions","_otherUtils2","reverseDeepMerge","extendTemplate","extendsCtrl","isDefined","optionsCtrl","$scope","$controller","extendsFn","optionsFn","extendsDO","optionsDO","optionsDOIsFn","isFunction","extendsDOIsFn","opts","scope","extendsDefaultOptions","mergedDefaultOptions","extenderOptionsDefaultOptions","newDefaultOptions","throwError","errorContext","getTypeHeritage","parent","heritage","isString","setWrapper","_x","_x2","_again","wrapperOptions","getOptionsTypes","getOptionsName","checkWrapperAPI","templateWrappersMap","defaultWrapperName","checkWrapperTypes","newValue","objectName","getWrapper","getWrapperByType","wrappers","_name","removeWrapperByName","removeWrappersForType","disableWarnings","warnInfoSlug","_this2","disableNgModelAttrsManipulator","ngModelAttrsManipulatorPreferUnbound","defaultHideDirective","getFieldId","_otherUtils","formlyEval","$modelValue","$viewValue","extraLocals","$eval","formId","objAndSameType","obj1","obj2","getPrototypeOf","findByNodeName","el","nodeName","element","children","node","extendFunction","_len","fns","_key","extendArray","primary","secondary","startsWith","str","search","substring","contains","formlyValidationMessages","addTemplateOptionValueMessage","alternate","validationMessages","templateOptionValue","addStringMessage","viewValue","modelValue","formlyUtil","formlyWarn","$log","formlyCustomValidation","restrict","require","attrs","ctrl","addValidatorToPipeline","isAsync","validator","setupMessage","useNewValidatorsApi","setupWithValidators","setupWithParsers","validatorCollection","inFlightValidator","$parsers","isValid","$pending","then","$setValidity","bind","formlyField","$http","$q","$compile","$templateCache","$interpolate","FormlyFieldController","$timeout","$parse","currentValue","valueGetterSetter","setter","assign","promise","when","newVal","simplifyLife","to","formOptions","setFieldIdAndName","formName","$name","setDefaultValue","setInitialValue","mergeFieldOptionsWithTypeDefaults","mergeOptions","properOrder","reverse","typeName","extraOptions","extendOptionsWithDefaults","resetFormControl","isMultiNgModel","$setViewValue","$render","$setUntouched","$setPristine","$root","$$phase","$digest","addValidationMessages","invokeControllers","setupFieldGroup","fieldType","getFieldType","checkApi","fieldLink","formlyFormCtrl","setFieldGroupTemplate","checkFieldGroupApi","addClass","extraAttributes","setElementTemplate","addAttributes","attr","addClasses","templateString","html","asHtml","contents","watchFormControl","watchFieldNameOrExistence","nameExpressionRegex","nameExpression","exec","watchFieldExistence","$watch","fieldCount","fc","stopWatchingShowError","addShowMessagesWatcher","addParsers","addFormatters","customExpression","errorExistsAndShouldBeVisibleExpression","$invalid","noTouchedButDirty","isUndefined","$touched","$dirty","showError","setParsersOrFormatters","formWasPristine","$pristine","$formatters","formatter","which","getThingsFromType","theType","typeThings","getDefaultOptionsProperty","getThingsFromOptionsTypes","getDefaultOptionsOptionsTypes","optionsTypesThings","optionsTypeName","getFormlyExpressionThing","formlyExpressionParserOrFormatterFunction","originalThingProp","things","ngModelCtrls","ngModelCtrl","_ngModelCtrl","concat","templateEl","ngModelNodes","querySelectorAll","ngModelNode","getAttribute","callLinkFunctions","thusly","runManipulators","manipulators","templateToManipulate","chain","manipulator","newTemplate","fieldManipulators","getManipulators","getFieldTemplate","transcludeInWrappers","append","addManipulators","_ref$preWrapper","pre","_ref$postWrapper","post","fromOptionsOrType","getTemplate","isUrl","templatePromise","_ret2","httpOptions","cache","get","response","getWrapperOption","aWrapper","runApiCheck","promises","w","wrappersTemplates","wrapperTemplate","totalWrapper","doTransclusion","superWrapper","transcludeEl","find","replaceWith","typeWrappers","formWrappers","defaultWrapper","_ref2","forType","runApiCheckForType","instance","checkerObjects","checkOptions","transclude","fields","formlyFocus","$document","previousEl","doc","$observe","activeElement","focus","focusWait","blur","formlyForm","formlyFormGetTemplate","getRootEl","rootEl","getFieldRootEl","fieldRootEl","getHideDirective","hideDirective","getTrackBy","trackBy","getFormName","bindName","minor","startSymbol","endSymbol","getTranscludeClass","transcludeClass","copyAttributes","attributes","excluded","arrayAttrs","toKebabCase","currentFormId","parentFormAttributes","hasClass","FormlyFormController","onModelOrFormStateChange","evalCloseToFormlyExpression","validate","$validate","setupFields","checkDeprecatedOptions","fieldTransforms","setupModels","attachKey","setupWatchers","setupOptions","isFieldGroup","watchedModels","isNewModel","initModel","refrencesCurrentlyWatchedModel","watchers","watchExpression","getWatchExpression","watchListener","getWatchListener","stopWatching","watchDeep","originalExpression","modifyArgs","_slice","originalListener","originalArgs","getFormlyFieldLikeLocals","formlyFormLink","setFormController","theFormlyForm","getter","parentForm","$parent","$removeControl","removeData","fixChromeAutocomplete","global","offInstance","onInstance","input","setAttribute","replace","$1","addFormlyNgModelAttrsManipulator","ngModelAttrsManipulator","addValidation","addIfNotPresent","modelNodes","alterNgModelAttr","isPropertyAccessor","addRegardlessOfPresence","addModelOptions","addTemplateOptionsAttrs","ep","ngModelAttributes","getBuiltInAttributes","attrVal","attrName","ref","toVal","epVal","getEpValue","inTo","inEp","addNgModelElAttrs","skip","innerHTML","getNgModelNodes","selectorNot","skipNot","query","getNgModelNodesFallback","allNgModelNodes","matchingNgModelNodes","hasAttribute","nodeMatches","selector","div","outerHTML","querySelector","boundOnly","bothBooleanAndBound","bothAttributeAndBound","statementOnly","attributeOnly","substr","nodes","addCustomTags","isIeLessThan9","customElements","__WEBPACK_EXTERNAL_MODULE_4__","addWrappers","formlyConfigProvider","check","label","labelSrOnly","addCheckboxType","labelProp","valueProp","checkValidity","expressionValue","valid","setModel","multiCheckbox","checked","checkbox","$setTouched","change","newModelValue","newOptionsValues","unwatchFormControl","addInputType","addRadioType","addSelectType","ngOptions","optionsAttr","groupProp","addTextareaType","rows","cols","_addons","_addons2","_description","_description2","addAddonsManipulator","formlyBootstrapApiCheck","addonTemplate","addonChecker","class","text","onClick","addonLeft","addonRight","addDescriptionManipulator","modelEls","$rootScope","Permission","$state","$on","event","toState","toParams","fromState","fromParams","$$finishAuthorize","permissions","log","preventDefault","$broadcast","defaultPrevented","authorize","go","notify","redirectTo","newState","roleValidationConfig","validateRoleDefinitionParams","roleName","validationFunction","validateManyRolesDefinitionParams","roles","defineRole","_promiseify","deferred","defer","resolve","reject","_validateRoleMap","roleMap","only","except","_findMatchingRole","rolesArray","currentRole","roleValidations","validatingRole","defineManyRoles","definedPermissions","resolveIfMatch","rejectIfMatch","authorizing","$stateProvider","fixStateName","state","addSiblings","childState","idx","nextSibling","previousSibling","self","keepOriginalNames","siblingTraversal","setNestedState","inherit","extra","merge","dst","ancestors","first","second","objectKeys","Number","len","Math","ceil","floor","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","j","equalForKeys","b","filterByKeys","values","filtered","pick","omit","collection","$Resolve","$injector","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","$$promises","$$values","study","invocables","visit","visited","cycle","splice","plan","annotate","param","isResolve","invocableKeys","locals","done","wait","merged","$$inheritedValues","resolution","fail","reason","$$failure","invoke","invocable","onfailure","invocation","proceed","waitParams","dep","ii","$TemplateFactory","fromConfig","fromString","fromUrl","templateProvider","fromProvider","headers","Accept","UrlMatcher","pattern","parentMatcher","addParameter","paramNames","test","$$UMFP","Param","quoteRegExp","squash","surroundPattern","matchDetails","isSearch","regexp","segment","cfg","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","lastIndex","sourceSearch","sourcePath","$$paramNames","Type","$UrlMatcherFactory","valToString","toString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","parseInt","date","getFullYear","getMonth","getDate","match","capture","Date","isNaN","valueOf","equals","toISOString","json","fromJson","identity","$$getDefaultValue","strictMode","compile","isMatcher","o","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","ignore","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","handler","$match","$location","$browser","appendBasePath","isHtml5","absolute","baseHref","update","evt","rule","handled","lastPushedUrl","rules","otherwise","listen","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","href","validates","html5Mode","enabled","hashPrefix","slash","port","protocol","host","redirect","handlerIsString","strategies","matcher","regex","sticky","deferIntercept","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","split","pathLength","current","states","queueState","parentName","queue","flushQueuedChildren","queued","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","l","MAX_VALUE","decorator","$view","$resolve","$urlRouter","handleRedirect","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","resolveState","paramsAreFiltered","resolveViews","viewsPromises","views","view","injectables","$template","load","globals","controllerProvider","injectLocals","$$controller","$$state","$$controllerAs","controllerAs","TransitionPrevented","reload","relative","fromPath","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","resolved","entering","exiting","onExit","onEnter","includes","lossy","nav","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","charAt","abstract","$ViewProvider","$templateFactory","defaults","$ViewScrollProvider","useAnchorScroll","$anchorScroll","$element","scrollIntoView","$ViewDirective","$uiViewScroll","getService","service","has","getRenderer","statics","enter","target","cb","after","leave","remove","$animate","$animator","animate","terminal","priority","tElement","tAttrs","$transclude","cleanupLastView","currentScope","$destroy","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","clone","$emit","autoScrollExp","onloadExp","onload","autoscroll","$ViewDirectiveFill","initial","uiView","inheritedData","parseStateRef","parsed","preparsed","paramExpr","stateContext","stateData","$StateRefDirective","allowedOptions","uiSrefActive","uiSref","hrefKind","newHref","isAnchor","isForm","optionsOverride","uiSrefOpts","option","activeDirective","$$addStateInfo","$set","oldVal","button","ctrlKey","metaKey","shiftKey","ignorePreventDefaultCount","cancel","$StateRefActiveDirective","$attrs","anyMatch","activeClass","removeClass","isMatch","uiSrefActiveEq","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","charCodeAt","isPathParam","isDefaultValue","nextSegment","$subPattern","sub","mode","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_storageProvider","storageType","storageKeyPrefix","setKeyPrefix","TypeError","serializer","deserializer","setSerializer","setDeserializer","d","getItem","set","setItem","$window","isStorageSupported","supported","err","round","random","localStorage","removeItem","_last$storage","_debounce","prefixLength","webStorage","$storage","$default","items","$sync","$reset","$apply","temp$storage","addEventListener","regModules","regInvokes","regConfigs","modulesToLoad","realModules","recordDeclarations","broadcast","runBlocks","justLoaded","ocLazyLoad","$controllerProvider","$provide","$compileProvider","$filterProvider","$animateProvider","_register","providers","registerModules","moduleName","moduleFn","tempRunBlocks","getModuleName","newModule","ngModuleFct","requires","_runBlocks","rerun","_invokeQueue","reconfig","_configBlocks","instanceInjector","getInstanceInjector","_registerInvokeList","checkHashes","potentialNew","invokes","newHash","isNew","signature","hashCode","invokeList","newInvoke","onInvoke","invokeName","callInvoke","fct","invoked","jlen","moduleExists","debug","events","moduleCache","modulePromises","moduleConfig","_init","elements","names","NG_APP_CLASS_REGEXP","elm","getElementById","jasmine","mocha","mock","addReg","mainModule","chr","$rootElement","$cacheFactory","filesCache","eventName","info","_broadcast","_$log","_getFilesCache","toggleWatch","watch","getModuleConfig","setModuleConfig","getModules","isLoaded","modulesNames","moduleLoaded","_getModuleName","_getModule","_loadDependencies","localParams","loadedModule","diff","promisesList","getRequires","requireEntry","files","filesLoader","entry","inject","real","_addToLoadList","loadNext","requireModule","bootstrapFct","bootstrap","force","configFn","$ocLazyLoad","content","$attr","$delegate","$interval","uaCssChecked","useCssLoadPatch","anchor","buildElement","cacheBuster","dc","getTime","put","onerror","serie","insertBeforeElem","lastChild","insertBefore","jQuery","parentNode","ua","navigator","userAgent","platform","appVersion","iOSVersion","parseFloat","androidVersion","versionMatch","tries","interval","sheet","cssRules","cssFiles","templatesFiles","jsFiles","cachePromise","pushFile","file_type","jsLoader","cssDeferred","cssLoader","templatesDeferred","templatesLoader","jsDeferred","originalModule","errText","originalParams","deferredList","paths","ocLazyLoadLoader","success","searchElement","fromIndex","O","abs","Infinity","$animateCss","expand","easing","height","scrollHeight","start","expandDone","css","collapse","collapseDone","uibCollapse","shouldCollapse","$collapseSuppressWarning","closeOthers","accordionConfig","groups","openGroup","group","isOpen","addGroup","groupScope","that","removeGroup","heading","isDisabled","setHeading","accordionCtrl","openClass","panelClass","toggleClass","toggleOpen","$event","accordionGroupCtrl","uibAccordionTransclude","$accordionSuppressWarning","accordionTransclude","closeable","close","dismissOnTimeout","$alertSuppressWarning","toggleEvent","buttonConfig","ctrls","buttonsCtrl","uibBtnRadio","on","isActive","uncheckable","getTrueValue","getCheckboxValue","btnCheckboxTrue","getFalseValue","btnCheckboxFalse","$buttonsSuppressWarning","btnRadio","attributeValue","goNext","slide","direction","destroyed","active","currentSlide","noTransition","$currentTransition","slides","SLIDE_DIRECTION","NEW_ANIMATE","phase","off","one","currentIndex","restartTimer","getSlideByIndex","resetTimer","currentInterval","timerFn","isPlaying","next","pause","resetTransition","NO_TRANSITION","select","nextSlide","nextIndex","indexOfSlide","getCurrentIndex","newIndex","noWrap","prev","$watchCollection","play","noPause","addSlide","removeSlide","sort","actual","carouselCtrl","animation","beforeAddClass","stopped","directionClass","removeClassFn","beforeRemoveClass","$carouselSuppressWarning","$locale","orderByFilter","createParser","formatCodeToRegex","code","year","month","localeId","SPECIAL_CHARACTERS_REGEXP","init","yyyy","yy","y","MMMM","DATETIME_FORMATS","MONTH","MMM","SHORTMONTH","MM","M","dd","EEEE","DAY","EEE","SHORTDAY","HH","hours","hh","H","h","mm","minutes","sss","milliseconds","ss","seconds","AMPMS","parse","baseDate","parser","results","dt","isDate","getHours","getMinutes","getSeconds","getMilliseconds","mapper","setFullYear","$dateParserSuppressWarning","uibDateParser","getStyle","cssprop","currentStyle","getComputedStyle","style","isStaticPositioned","parentOffsetEl","docDomEl","offsetParent","position","elBCR","offset","offsetParentBCR","top","offsetParentEl","clientTop","scrollTop","clientLeft","scrollLeft","boundingClientRect","getBoundingClientRect","width","pageYOffset","documentElement","pageXOffset","positionElements","hostEl","targetEl","positionStr","appendToBody","hostElPos","targetElWidth","targetElHeight","targetElPos","positionStrParts","pos0","pos1","shiftWidth","center","shiftHeight","bottom","$positionSuppressWarning","$uibPosition","formatDay","formatMonth","formatYear","formatDayHeader","formatDayTitle","formatMonthTitle","datepickerMode","minMode","maxMode","showWeeks","startingDay","yearRange","minDate","maxDate","shortcutPropagation","dateFilter","datepickerConfig","$datepickerSuppressError","modes","refreshView","uniqueId","$id","initDate","activeDate","$isEmpty","dateObject","compare","activeDateId","uid","ngModelCtrl_","render","_refreshView","createDateObject","selected","customClass","dateDisabled","size","arrays","move","step","years","months","toggleMode",13,32,33,34,35,36,37,38,39,40,"focusElement","keydown","altKey","stopPropagation","handleKeyDown","getDaysInMonth","DAYS_IN_MONTH","getISO8601WeekNumber","checkDate","setDate","getDay","time","setMonth","getDates","startDate","dates","firstDayOfMonth","difference","numDisplayedFromPreviousMonth","firstDate","days","labels","abbr","full","title","weekNumbers","thursdayIndex","numWeeks","curWeek","date1","date2","getStartingYear","yearpickerInit","datepickerCtrl","daypickerCtrl","monthpickerCtrl","datepickerPopup","datepickerPopupTemplateUrl","datepickerTemplateUrl","html5Types","datetime-local","currentText","clearText","closeText","closeOnDateSelection","showButtonBar","onOpenFocus","$position","dateParser","datepickerPopupConfig","cameltoDash","parseDate","isNumber","dateFormat","ngRequired","documentClickBind","popup","$popup","dpContainsTarget","popupContainsTarget","inputKeydownBind","popupEl","datepickerEl","ngModel","isHtml5DateInput","watchData","_ngModel_","datepickerAppendToBody","uibDatepickerPopup","oldValue","newDateFormat","ng-model","ng-change","template-url","datepickerOptions","oldvalue","$$parserName","$validators","$viewChangeListeners","unbind","getText","dateSelection","today","setHours","$datepickerSuppressWarning","fixTimeZone","openScope","open","dropdownScope","closeDropdown","keybindFilter","getAutoClose","toggleElement","getToggleElement","dropdownElement","getDropdownElement","focusToggleElement","isKeynavEnabled","focusDropdownEntry","dropdownConfig","uibDropdownService","$templateRequest","templateScope","getIsOpen","setIsOpen","toggleInvoker","onToggle","keynavEnabled","dropdownAppendToBody","uibKeyboardNav","dropdownMenu","toggle","autoClose","getElement","keyCode","elems","eq","selectedOption","wasOpen","pos","rightalign","innerWidth","dropdownMenuTemplateUrl","tplContent","newEl","offDestroy","dropdownCtrl","dropdownNested","tplUrl","toggleDropdown","aria-haspopup","aria-expanded","$dropdownSuppressWarning","createNew","stack","add","removeTop","entries","hasKey","$modalStack","linkFn","modalInClass","NOW_CLOSING_EVENT","setIsAsync","backdropClass","windowClass","windowTopClass","modal","getTop","backdrop","currentTarget","dismiss","$isRendered","modalRenderDeferObj","animationPromise","inputWithAutofocus","modalRendered","modalAnimation","uibModalAnimationClass","empty","$$multiMap","$$stackedMap","backdropIndex","topBackdropIndex","opened","openedWindows","removeModalWindow","modalInstance","elementToReceiveFocus","body","modalWindow","removeAfterAnimate","modalDomEl","modalScope","modalBodyClass","openedClass","OPENED_MODAL_CLASS","openedClasses","toggleTopWindowClass","checkRemoveBackdrop","toggleSwitch","backdropDomEl","backdropScopeRef","backdropScope","domEl","afterAnimating","asyncDeferred","asyncPromise","broadcastClosing","resultOrReason","closing","focusableElementList","focusIndex","tababbleSelector","newBackdropIndex","isDefaultPrevented","keyboard","loadFocusElementList","focusChanged","isFocusInFirstItem","focusLastFocusableElement","isFocusInLastItem","focusFirstFocusableElement","modalOpener","renderDeferred","currBackdropIndex","angularBackgroundDomEl","angularDomEl","windowTemplateUrl","window-class","window-top-class","clearFocusListCache","$$uibDestructionScheduled","dismissAll","topModal","srcElement","modalDomE1","$modalProvider","$modalSuppressWarning","getTemplatePromise","getResolvePromises","resolves","promisesArr","$modal","promiseChain","getPromiseChain","modalOptions","resolveWithTemplate","templateAndResolvePromise","modalResultDeferred","modalOpenedDeferred","modalRenderDeferred","rendered","samePromise","tplAndVars","$close","$dismiss","ctrlInstance","ctrlLocals","resolveIter","$uibModalInstance","bindToController","modalAnimationClass","$uibModalStack","$uibModalProvider","setNumPages","numPages","itemsPerPage","totalPages","calculateTotalPages","page","selectPage","totalItems","clickAllowed","ngDisabled","noPrevious","noNext","boundaryLinks","directionLinks","firstText","previousText","nextText","lastText","rotate","paginationConfig","makePage","getPages","currentPage","pages","startPage","endPage","isMaxSized","maxSize","previousPageSet","nextPageSet","paginationCtrl","originalRender","align","pagerConfig","$paginationSuppressWarning","snake_case","separator","letter","placement","popupDelay","popupCloseDelay","useContentExp","triggerMap","mouseenter","click","none","globalOptions","setTriggers","triggers","openedTooltips","ttType","defaultTriggerShow","getTriggers","trigger","directiveName","startSym","endSym","tElem","tooltipLinker","tooltipCtrl","toggleTooltipBind","ttScope","hideTooltipBind","showTooltipBind","hasEnableExp","cancelHide","prepareTooltip","showTimeout","cancelShow","hideTimeout","createTooltip","$evalAsync","assignIsOpen","positionTooltip","positionTimeout","transitionTimeout","removeTooltip","tooltip","tooltipLinkedScope","prepObservers","unregisterObservers","contentParse","popupClass","delay","closeDelay","isOpenParse","observers","repositionScheduled","$$postDigest","observer","prepTriggers","unregisterTriggers","ttCss","visibility","origScope","contentExp","hideTrigger","removeEventListener","appendToBodyVal","$sce","elem","previousElement","currentElement","tooltipTemplateTranscludeScope","changeCounter","cleanupLastIncludeContent","parseAsResourceUrl","uibTooltipTemplateTransclude","thisChangeId","tooltipAnimationClass","$uibTooltip","originScope","$uibTooltipProvider","$tooltipSuppressWarning","tooltipTemplateTransclude","$tooltip","$popoverSuppressWarning","progressConfig","bars","addBar","bar","recalculatePercentage","totalPercentage","reduce","total","percent","toFixed","removeBar","progressCtrl","$progressSuppressWarning","stateOn","stateOff","titles","ratingConfig","tmpTitles","ratingStates","buildTemplateObjects","getTitle","rate","readonly","onHover","reset","onLeave","onKeydown","ratingCtrl","$ratingSuppressWarning","tabs","selectedTab","tab","onDeselect","selectCalled","onSelect","addTab","removeTab","newActiveIndex","vertical","justified","tabsetCtrl","disable","$transcludeFn","isTabHeading","tagName","uibTabContentTransclude","headingElement","$tabsSuppressWarning","tabContentTransclude","hourStep","minuteStep","showMeridian","meridians","readonlyInput","mousewheel","arrowkeys","showSpinners","timepickerConfig","getHoursFromTemplate","meridian","getMinutesFromTemplate","pad","refresh","keyboardChange","makeValid","updateTemplate","invalidHours","invalidMinutes","addMinutes","newDate","addMinutesToSelected","tabindex","removeAttr","inputs","hoursInputEl","minutesInputEl","setupMousewheelEvents","setupArrowkeyEvents","setupInputEvents","noIncrementHours","incrementedSelected","noDecrementHours","decrementedSelected","noIncrementMinutes","noDecrementMinutes","noToggleMeridian","$error","isScrollingUp","originalEvent","delta","wheelDelta","deltaY","detail","incrementHours","decrementHours","incrementMinutes","decrementMinutes","updateHours","updateMinutes","invalidate","setMinutes","toggleMeridian","timepickerCtrl","$timepickerSuppressWarning","TYPEAHEAD_REGEXP","itemName","viewMapper","modelMapper","originalScope","typeaheadParser","fireRecalculating","moveInProgress","timeoutEventPromise","matches","recalculatePosition","eventDebounceTime","modelCtrl","ngModelOptions","HOT_KEYS","minLength","typeaheadMinLength","hasFocus","waitTime","typeaheadWaitMs","isEditable","typeaheadEditable","isLoadingSetter","typeaheadLoading","onSelectCallback","typeaheadOnSelect","isSelectOnBlur","typeaheadSelectOnBlur","isNoResultsSetter","typeaheadNoResults","inputFormatter","typeaheadInputFormatter","typeaheadAppendToBody","appendToElementId","typeaheadAppendToElementId","focusFirst","typeaheadFocusFirst","selectOnExact","typeaheadSelectOnExact","parsedModel","invokeModelSetter","$setModelValue","$options","$$$p","parserResult","uibTypeahead","popupId","aria-autocomplete","aria-owns","popUpEl","move-in-progress","typeaheadTemplateUrl","typeaheadPopupTemplateUrl","resetMatches","activeIdx","getMatchId","inputIsExactMatch","inputValue","getMatchesAsync","onCurrentRequest","timeoutPromise","scheduleSearchWithTimeout","cancelPreviousTimeout","$item","$model","$label","typeaheadFocusOnSelect","dismissClickHandler","_modelCtrl","_ngModelOptions","candidateViewValue","emptyViewValue","popupTemplateUrl","matchIdx","selectActive","selectMatch","clonedElement","escapeRegexp","queryToEscape","containsHtml","matchItem","isSanitizePresent","trustAsHtml","uibTypeaheadParser","$typeaheadSuppressWarning","typeahead","$$csp","prepend"],"mappings":"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","file":"vendors.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t1:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".app.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/statistikwbt/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(10);\n\t__webpack_require__(9);\n\t__webpack_require__(8);\n\t__webpack_require__(12);\n\t__webpack_require__(3);\n\t__webpack_require__(4);\n\t__webpack_require__(6);\n\t__webpack_require__(7);\n\tmodule.exports = __webpack_require__(11);\n\n\n/***/ },\n/* 1 */,\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = angular;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! api-check version 7.5.5 built with  by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) ( _)==(_ )\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"apiCheck\"] = factory();\n\t\telse\n\t\t\troot[\"apiCheck\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _apiCheck = __webpack_require__(1);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = _apiCheck2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar apiCheckUtil = __webpack_require__(3);\n\t\tvar each = apiCheckUtil.each;\n\t\tvar isError = apiCheckUtil.isError;\n\t\tvar t = apiCheckUtil.t;\n\t\tvar arrayify = apiCheckUtil.arrayify;\n\t\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\t\tvar typeOf = apiCheckUtil.typeOf;\n\t\tvar getError = apiCheckUtil.getError;\n\t\n\t\tvar checkers = __webpack_require__(4);\n\t\tvar apiCheckApis = getApiCheckApis();\n\t\n\t\tmodule.exports = getApiCheckInstance;\n\t\tmodule.exports.VERSION = (\"7.5.5\");\n\t\tmodule.exports.utils = apiCheckUtil;\n\t\tmodule.exports.globalConfig = {\n\t\t  verbose: false,\n\t\t  disabled: false\n\t\t};\n\t\n\t\tvar apiCheckApiCheck = getApiCheckInstance({\n\t\t  output: { prefix: 'apiCheck' }\n\t\t});\n\t\tmodule.exports.internalChecker = apiCheckApiCheck;\n\t\n\t\teach(checkers, function (checker, name) {\n\t\t  return module.exports[name] = checker;\n\t\t});\n\t\n\t\tfunction getApiCheckInstance() {\n\t\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t\t  /* eslint complexity:[2, 6] */\n\t\t  if (apiCheckApiCheck && arguments.length) {\n\t\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t\t      prefix: 'creating an apiCheck instance'\n\t\t    });\n\t\t  }\n\t\n\t\t  var additionalProperties = {\n\t\t    'throw': getApiCheck(true),\n\t\t    warn: getApiCheck(false),\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    handleErrorMessage: handleErrorMessage,\n\t\t    config: {\n\t\t      output: config.output || {\n\t\t        prefix: '',\n\t\t        suffix: '',\n\t\t        docsBaseUrl: ''\n\t\t      },\n\t\t      verbose: config.verbose || false,\n\t\t      disabled: config.disabled || false\n\t\t    },\n\t\t    utils: apiCheckUtil\n\t\t  };\n\t\n\t\t  each(additionalProperties, function (wrapper, name) {\n\t\t    return apiCheck[name] = wrapper;\n\t\t  });\n\t\n\t\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\t  each(extraCheckers, function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\n\t\t  return apiCheck;\n\t\n\t\t  /**\n\t\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t\t   * @param {Array} api - the checkers to check with\n\t\t   * @param {Array} args - the args to check\n\t\t   * @param {Object} output - output options\n\t\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t\t   */\n\t\t  function apiCheck(api, args, output) {\n\t\t    /* eslint complexity:[2, 8] */\n\t\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t\t      return {\n\t\t        apiTypes: {}, argTypes: {},\n\t\t        passed: true, message: '',\n\t\t        failed: false\n\t\t      }; // empty version of what is normally returned\n\t\t    }\n\t\t    checkApiCheckApi(arguments);\n\t\t    if (!Array.isArray(api)) {\n\t\t      api = [api];\n\t\t      args = [args];\n\t\t    } else {\n\t\t      // turn arguments into an array\n\t\t      args = Array.prototype.slice.call(args);\n\t\t    }\n\t\t    var messages = checkEnoughArgs(api, args);\n\t\t    if (!messages.length) {\n\t\t      // this is where we actually go perform the checks.\n\t\t      messages = checkApiWithArgs(api, args);\n\t\t    }\n\t\n\t\t    var returnObject = getTypes(api, args);\n\t\t    returnObject.args = args;\n\t\t    if (messages.length) {\n\t\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t\t      returnObject.failed = true;\n\t\t      returnObject.passed = false;\n\t\t    } else {\n\t\t      returnObject.message = '';\n\t\t      returnObject.failed = false;\n\t\t      returnObject.passed = true;\n\t\t    }\n\t\t    return returnObject;\n\t\t  }\n\t\n\t\t  /**\n\t\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t\t   */\n\t\t  function checkApiCheckApi(checkApiArgs) {\n\t\t    var api = checkApiArgs[0];\n\t\t    var args = checkApiArgs[1];\n\t\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\t\n\t\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t\t    }\n\t\t    // dog fooding here\n\t\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t\t    if (errors.length) {\n\t\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t\t        prefix: 'apiCheck'\n\t\t      });\n\t\t      apiCheck.handleErrorMessage(message, true);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getApiCheck(shouldThrow) {\n\t\t    return function apiCheckWrapper(api, args, output) {\n\t\t      var result = apiCheck(api, args, output);\n\t\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t\t      return result; // wont get here if an error is thrown\n\t\t    };\n\t\t  }\n\t\n\t\t  function handleErrorMessage(message, shouldThrow) {\n\t\t    if (shouldThrow && message) {\n\t\t      throw new Error(message);\n\t\t    } else if (message) {\n\t\t      /* eslint no-console:0 */\n\t\t      console.warn(message);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getErrorMessage(api, args) {\n\t\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t\n\t\t    var gOut = apiCheck.config.output || {};\n\t\t    var prefix = getPrefix();\n\t\t    var suffix = getSuffix();\n\t\t    var url = getUrl();\n\t\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\t\n\t\t    function getPrefix() {\n\t\t      var p = output.onlyPrefix;\n\t\t      if (!p) {\n\t\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t\t      }\n\t\t      return p;\n\t\t    }\n\t\n\t\t    function getSuffix() {\n\t\t      var s = output.onlySuffix;\n\t\t      if (!s) {\n\t\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t\t      }\n\t\t      return s;\n\t\t    }\n\t\n\t\t    function getUrl() {\n\t\t      var u = output.url;\n\t\t      if (!u) {\n\t\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t\t      }\n\t\t      return u;\n\t\t    }\n\t\t  }\n\t\n\t\t  function buildMessageFromApiAndArgs(api, args) {\n\t\t    var _getTypes = getTypes(api, args);\n\t\n\t\t    var apiTypes = _getTypes.apiTypes;\n\t\t    var argTypes = _getTypes.argTypes;\n\t\n\t\t    var copy = Array.prototype.slice.call(args || []);\n\t\t    var replacedItems = [];\n\t\t    replaceFunctionWithName(copy);\n\t\t    var passedArgs = getObjectString(copy);\n\t\t    argTypes = getObjectString(argTypes);\n\t\t    apiTypes = getObjectString(apiTypes);\n\t\n\t\t    return generateMessage();\n\t\n\t\t    // functions\n\t\n\t\t    function replaceFunctionWithName(obj) {\n\t\t      each(obj, function (val, name) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        if (replacedItems.indexOf(val) === -1) {\n\t\t          // avoid recursive problems\n\t\t          replacedItems.push(val);\n\t\t          if (typeof val === 'object') {\n\t\t            replaceFunctionWithName(obj);\n\t\t          } else if (typeof val === 'function') {\n\t\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function getObjectString(types) {\n\t\t      if (!types || !types.length) {\n\t\t        return 'nothing';\n\t\t      } else if (types && types.length === 1) {\n\t\t        types = types[0];\n\t\t      }\n\t\t      return stringify(types, null, 2);\n\t\t    }\n\t\n\t\t    function generateMessage() {\n\t\t      var n = '\\n';\n\t\t      var useS = true;\n\t\t      if (args && args.length === 1) {\n\t\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t\t          useS = !!Object.keys(args[0]).length;\n\t\t        } else {\n\t\t          useS = false;\n\t\t        }\n\t\t      }\n\t\t      var types = 'type' + (useS ? 's' : '');\n\t\t      var newLine = n + n;\n\t\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypes(api, args) {\n\t\t    api = arrayify(api);\n\t\t    args = arrayify(args);\n\t\t    var apiTypes = api.map(function (checker, index) {\n\t\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t\t      return getCheckerDisplay(checker, {\n\t\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t\t        obj: args[index],\n\t\t        addHelpers: true\n\t\t      });\n\t\t    });\n\t\t    var argTypes = args.map(function (arg) {\n\t\t      return getArgDisplay(arg, []);\n\t\t    });\n\t\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t\t  }\n\t\t}\n\t\n\t\t// STATELESS FUNCTIONS\n\t\n\t\t/**\n\t\t * This is where the magic happens for actually checking the arguments with the api.\n\t\t * @param {Array} api - checkers\n\t\t * @param  {Array} args - and arguments object\n\t\t * @returns {Array} - the error messages\n\t\t */\n\t\tfunction checkApiWithArgs(api, args) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var messages = [];\n\t\t  var failed = false;\n\t\t  var checkerIndex = 0;\n\t\t  var argIndex = 0;\n\t\t  var arg = undefined,\n\t\t      checker = undefined,\n\t\t      res = undefined,\n\t\t      lastChecker = undefined,\n\t\t      argName = undefined,\n\t\t      argFailed = undefined,\n\t\t      skipPreviousChecker = undefined;\n\t\t  /* jshint -W084 */\n\t\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t\t    arg = args[argIndex++];\n\t\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t\t    res = checker(arg, 'value', argName);\n\t\t    argFailed = isError(res);\n\t\t    lastChecker = checkerIndex >= api.length;\n\t\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t\t      failed = true;\n\t\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t\t    } else if (argFailed && checker.isOptional) {\n\t\t      argIndex--;\n\t\t    } else {\n\t\t      messages.push(t(argName) + ' passed');\n\t\t    }\n\t\t  }\n\t\t  return failed ? messages : [];\n\t\t}\n\t\n\t\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\t\tfunction checkerTypeType(checkerType, name, location) {\n\t\t  var apiCheckDataChecker = checkers.shape({\n\t\t    type: checkers.string,\n\t\t    optional: checkers.bool\n\t\t  });\n\t\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t\t  if (isError(wrongShape)) {\n\t\t    return wrongShape;\n\t\t  }\n\t\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t\t    return getError(name, location, checkerTypeType.type);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerErrorMessage(res, checker, val) {\n\t\t  var checkerHelp = getCheckerHelp(checker, val);\n\t\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t\t  return res.message + checkerHelp;\n\t\t}\n\t\n\t\tfunction getCheckerHelp(_ref, val) {\n\t\t  var help = _ref.help;\n\t\n\t\t  if (!help) {\n\t\t    return '';\n\t\t  }\n\t\t  if (typeof help === 'function') {\n\t\t    help = help(val);\n\t\t  }\n\t\t  return help;\n\t\t}\n\t\n\t\tfunction checkEnoughArgs(api, args) {\n\t\t  var requiredArgs = api.filter(function (a) {\n\t\t    return !a.isOptional;\n\t\t  });\n\t\t  if (args.length < requiredArgs.length) {\n\t\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t\t  } else {\n\t\t    return [];\n\t\t  }\n\t\t}\n\t\n\t\tfunction getArgDisplay(arg, gottenArgs) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t\t  var type = typeOf(arg);\n\t\t  if (type === 'function') {\n\t\t    if (hasKeys()) {\n\t\t      var properties = stringify(getDisplayIfNotGotten());\n\t\t      return cName + ' (with properties: ' + properties + ')';\n\t\t    }\n\t\t    return cName;\n\t\t  }\n\t\n\t\t  if (arg === null) {\n\t\t    return 'null';\n\t\t  }\n\t\n\t\t  if (type !== 'array' && type !== 'object') {\n\t\t    return type;\n\t\t  }\n\t\n\t\t  if (hasKeys()) {\n\t\t    return getDisplayIfNotGotten();\n\t\t  }\n\t\n\t\t  return cName;\n\t\n\t\t  // utility functions\n\t\t  function hasKeys() {\n\t\t    return arg && Object.keys(arg).length;\n\t\t  }\n\t\n\t\t  function getDisplayIfNotGotten() {\n\t\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t\t      return '[Circular]';\n\t\t    }\n\t\t    gottenArgs.push(arg);\n\t\t    return getDisplay(arg, gottenArgs);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getDisplay(obj, gottenArgs) {\n\t\t  var argDisplay = {};\n\t\t  each(obj, function (v, k) {\n\t\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t\t  });\n\t\t  return argDisplay;\n\t\t}\n\t\n\t\tfunction getApiCheckApis() {\n\t\t  var os = checkers.string.optional;\n\t\n\t\t  var checkerFnChecker = checkers.func.withProperties({\n\t\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t\t    displayName: checkers.string.optional,\n\t\t    shortType: checkers.string.optional,\n\t\t    notOptional: checkers.bool.optional,\n\t\t    notRequired: checkers.bool.optional\n\t\t  });\n\t\n\t\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t\t    output: checkers.shape({\n\t\t      prefix: checkers.string.optional,\n\t\t      suffix: checkers.string.optional,\n\t\t      docsBaseUrl: checkers.string.optional\n\t\t    }).strict.optional,\n\t\t    verbose: checkers.bool.optional,\n\t\t    disabled: checkers.bool.optional\n\t\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\t\n\t\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t\t  }).strict.optional];\n\t\n\t\t  return {\n\t\t    checkerFnChecker: checkerFnChecker,\n\t\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t\t    checkApiCheckApi: checkApiCheckApi\n\t\t  };\n\t\t}\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = stringify;\n\t\n\t\tfunction getSerialize (fn, decycle) {\n\t\t  var seen = [], keys = [];\n\t\t  decycle = decycle || function(key, value) {\n\t\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t\t  };\n\t\t  return function(key, value) {\n\t\t    var ret = value;\n\t\t    if (typeof value === 'object' && value) {\n\t\t      if (seen.indexOf(value) !== -1)\n\t\t        ret = decycle(key, value);\n\t\t      else {\n\t\t        seen.push(value);\n\t\t        keys.push(key);\n\t\t      }\n\t\t    }\n\t\t    if (fn) ret = fn(key, ret);\n\t\t    return ret;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getPath (value, seen, keys) {\n\t\t  var index = seen.indexOf(value);\n\t\t  var path = [ keys[index] ];\n\t\t  for (index--; index >= 0; index--) {\n\t\t    if (seen[index][ path[0] ] === value) {\n\t\t      value = seen[index];\n\t\t      path.unshift(keys[index]);\n\t\t    }\n\t\t  }\n\t\t  return '~' + path.join('.');\n\t\t}\n\t\n\t\tfunction stringify(obj, fn, spaces, decycle) {\n\t\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t\t}\n\t\n\t\tstringify.getSerialize = getSerialize;\n\t\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar checkerHelpers = {\n\t\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t\t};\n\t\n\t\tmodule.exports = {\n\t\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t\t  noop: noop\n\t\t};\n\t\n\t\tfunction copy(obj) {\n\t\t  var type = typeOf(obj);\n\t\t  var daCopy = undefined;\n\t\t  if (type === 'array') {\n\t\t    daCopy = [];\n\t\t  } else if (type === 'object') {\n\t\t    daCopy = {};\n\t\t  } else {\n\t\t    return obj;\n\t\t  }\n\t\t  each(obj, function (val, key) {\n\t\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t\t  });\n\t\t  return daCopy;\n\t\t}\n\t\n\t\tfunction typeOf(obj) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return 'array';\n\t\t  } else if (obj instanceof RegExp) {\n\t\t    return 'object';\n\t\t  } else {\n\t\t    return typeof obj;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerDisplay(checker, options) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var display = undefined;\n\t\t  var short = options && options.short;\n\t\t  if (short && checker.shortType) {\n\t\t    display = checker.shortType;\n\t\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t\t    display = getCheckerType(checker, options);\n\t\t  } else {\n\t\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t\t  }\n\t\t  return display;\n\t\t}\n\t\n\t\tfunction getCheckerType(_ref, options) {\n\t\t  var type = _ref.type;\n\t\n\t\t  if (typeof type === 'function') {\n\t\t    var __apiCheckData = type.__apiCheckData;\n\t\t    var typeTypes = type(options);\n\t\t    type = _defineProperty({\n\t\t      __apiCheckData: __apiCheckData\n\t\t    }, __apiCheckData.type, typeTypes);\n\t\t  }\n\t\t  return type;\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (!obj) {\n\t\t    return [];\n\t\t  } else if (Array.isArray(obj)) {\n\t\t    return obj;\n\t\t  } else {\n\t\t    return [obj];\n\t\t  }\n\t\t}\n\t\n\t\tfunction each(obj, iterator, context) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return eachArry(obj, iterator, context);\n\t\t  } else {\n\t\t    return eachObj(obj, iterator, context);\n\t\t  }\n\t\t}\n\t\n\t\tfunction eachObj(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t\t  for (var key in obj) {\n\t\t    if (hasOwn.call(obj, key)) {\n\t\t      ret = iterator.call(context, obj[key], key, obj);\n\t\t      if (ret === false) {\n\t\t        return ret;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction eachArry(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var length = obj.length;\n\t\t  for (var i = 0; i < length; i++) {\n\t\t    ret = iterator.call(context, obj[i], i, obj);\n\t\t    if (ret === false) {\n\t\t      return ret;\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction isError(obj) {\n\t\t  return obj instanceof Error;\n\t\t}\n\t\n\t\tfunction list(arry, join, finalJoin) {\n\t\t  arry = arrayify(arry);\n\t\t  var copy = arry.slice();\n\t\t  var last = copy.pop();\n\t\t  if (copy.length === 1) {\n\t\t    join = ' ';\n\t\t  }\n\t\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t\t}\n\t\n\t\tfunction getError(name, location, checkerType) {\n\t\t  if (typeof checkerType === 'function') {\n\t\t    checkerType = checkerType({ short: true });\n\t\t  }\n\t\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t\t}\n\t\n\t\tfunction nAtL(name, location) {\n\t\t  var tName = t(name || 'value');\n\t\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t\t  return '' + tName + tLocation;\n\t\t}\n\t\n\t\tfunction t(thing) {\n\t\t  return '`' + thing + '`';\n\t\t}\n\t\n\t\tfunction undef(thing) {\n\t\t  return typeof thing === 'undefined';\n\t\t}\n\t\n\t\t/**\n\t\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t\t * optional version\n\t\t *\n\t\t * @param {Function} checker - the checker to setup with properties\n\t\t * @param {Object} properties - properties to add to the checker\n\t\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t\t * @returns {Function} checker - the setup checker\n\t\t */\n\t\tfunction setupChecker(checker, properties, disabled) {\n\t\t  /* eslint complexity:[2, 9] */\n\t\t  if (disabled) {\n\t\t    // swap out the checker for its own copy of noop\n\t\t    checker = getNoop();\n\t\t    checker.isNoop = true;\n\t\t  }\n\t\n\t\t  if (typeof checker.type === 'string') {\n\t\t    checker.shortType = checker.type;\n\t\t  }\n\t\n\t\t  // assign all properties given\n\t\t  each(properties, function (prop, name) {\n\t\t    return checker[name] = prop;\n\t\t  });\n\t\n\t\t  if (!checker.displayName) {\n\t\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t\t  }\n\t\n\t\t  if (!checker.notRequired) {\n\t\t    checker = getRequiredVersion(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notNullable) {\n\t\t    addNullable(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker, disabled);\n\t\t  }\n\t\n\t\t  return checker;\n\t\t}\n\t\n\t\tfunction getRequiredVersion(checker, disabled) {\n\t\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t\t    if (undef(val) && !checker.isOptional) {\n\t\t      var tLocation = location ? ' in ' + t(location) : '';\n\t\t      var type = getCheckerDisplay(checker, { short: true });\n\t\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t\t    } else {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  copyProps(checker, requiredChecker);\n\t\t  requiredChecker.originalChecker = checker;\n\t\t  return requiredChecker;\n\t\t}\n\t\n\t\tfunction addOptional(checker, disabled) {\n\t\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t\t    if (!undef(val)) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, optionalCheck);\n\t\n\t\t  optionalCheck.isOptional = true;\n\t\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t\t  optionalCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .optional to the end of the checkers\n\t\t  checker.optional = optionalCheck;\n\t\n\t\t  fixType(checker, checker.optional);\n\t\t}\n\t\n\t\tfunction addNullable(checker, disabled) {\n\t\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t\t    if (val !== null) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, nullableCheck);\n\t\n\t\t  nullableCheck.isNullable = true;\n\t\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t\t  nullableCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t\t  checker.nullable = nullableCheck;\n\t\n\t\t  fixType(checker, checker.nullable);\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker.nullable, disabled);\n\t\t  }\n\t\t}\n\t\n\t\tfunction fixType(checker, checkerCopy) {\n\t\t  // fix type, because it's not a straight copy...\n\t\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t\t  // we also want to add \"(optional)\" to the types with a string\n\t\t  if (typeof checkerCopy.type === 'object') {\n\t\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t\t  } else if (typeof checkerCopy.type === 'function') {\n\t\t      checkerCopy.type = function () {\n\t\t        return checker.type.apply(checker, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      checkerCopy.type += ' (optional)';\n\t\t      return;\n\t\t    }\n\t\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t\t  checkerCopy.type.__apiCheckData.optional = true;\n\t\t}\n\t\n\t\t// UTILS\n\t\n\t\tfunction copyProps(src, dest) {\n\t\t  each(Object.keys(src), function (key) {\n\t\t    return dest[key] = src[key];\n\t\t  });\n\t\t}\n\t\n\t\tfunction noop() {}\n\t\n\t\tfunction getNoop() {\n\t\t  /* eslint no-shadow:0 */\n\t\t  /* istanbul ignore next */\n\t\t  return function noop() {};\n\t\t}\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\n\t\tvar _require = __webpack_require__(3);\n\t\n\t\tvar typeOf = _require.typeOf;\n\t\tvar each = _require.each;\n\t\tvar copy = _require.copy;\n\t\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\t\tvar isError = _require.isError;\n\t\tvar arrayify = _require.arrayify;\n\t\tvar list = _require.list;\n\t\tvar getError = _require.getError;\n\t\tvar nAtL = _require.nAtL;\n\t\tvar t = _require.t;\n\t\tvar checkerHelpers = _require.checkerHelpers;\n\t\tvar undef = _require.undef;\n\t\tvar setupChecker = checkerHelpers.setupChecker;\n\t\n\t\tvar checkers = module.exports = getCheckers();\n\t\tmodule.exports.getCheckers = getCheckers;\n\t\n\t\tfunction getCheckers(disabled) {\n\t\t  return {\n\t\t    array: typeOfCheckGetter('Array'),\n\t\t    bool: typeOfCheckGetter('Boolean'),\n\t\t    number: typeOfCheckGetter('Number'),\n\t\t    string: typeOfCheckGetter('String'),\n\t\t    func: funcCheckGetter(),\n\t\t    object: objectCheckGetter(),\n\t\n\t\t    emptyObject: emptyObjectCheckGetter(),\n\t\n\t\t    instanceOf: instanceCheckGetter,\n\t\t    oneOf: oneOfCheckGetter,\n\t\t    oneOfType: oneOfTypeCheckGetter,\n\t\n\t\t    arrayOf: arrayOfCheckGetter,\n\t\t    objectOf: objectOfCheckGetter,\n\t\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\t\n\t\t    range: rangeCheckGetter,\n\t\t    lessThan: lessThanCheckGetter,\n\t\t    greaterThan: greaterThanCheckGetter,\n\t\n\t\t    shape: getShapeCheckGetter(),\n\t\t    args: argumentsCheckerGetter(),\n\t\n\t\t    any: anyCheckGetter(),\n\t\t    'null': nullCheckGetter()\n\t\n\t\t  };\n\t\n\t\t  function typeOfCheckGetter(type) {\n\t\t    var lType = type.toLowerCase();\n\t\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== lType) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function funcCheckGetter() {\n\t\t    var type = 'Function';\n\t\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'function') {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\n\t\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t\t      if (isError(apiError)) {\n\t\t        throw apiError;\n\t\t      }\n\t\t      var shapeChecker = checkers.shape(properties, true);\n\t\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\t\n\t\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t\t        var notFunction = checkers.func(val, name, location);\n\t\t        if (isError(notFunction)) {\n\t\t          return notFunction;\n\t\t        }\n\t\t        return shapeChecker(val, name, location);\n\t\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t\t    };\n\t\t    return functionChecker;\n\t\t  }\n\t\n\t\t  function objectCheckGetter() {\n\t\t    var type = 'Object';\n\t\t    var nullType = 'Object (null ok)';\n\t\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'object') {\n\t\t        return getError(name, location, nullType);\n\t\t      }\n\t\t    }, { type: nullType }, disabled);\n\t\n\t\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t\t        return getError(name, location, objectChecker.type);\n\t\t      }\n\t\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\t\n\t\t    return objectChecker;\n\t\t  }\n\t\n\t\t  function instanceCheckGetter(classToCheck) {\n\t\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t\t      if (!(val instanceof classToCheck)) {\n\t\t        return getError(name, location, classToCheck.name);\n\t\t      }\n\t\t    }, { type: classToCheck.name }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfCheckGetter(enums) {\n\t\t    var type = {\n\t\t      __apiCheckData: { optional: false, type: 'enum' },\n\t\t      'enum': enums\n\t\t    };\n\t\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t\t      return stringify(enm);\n\t\t    }).join(', ') + ']';\n\t\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t\t      if (!enums.some(function (enm) {\n\t\t        return enm === val;\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t\t      return getCheckerDisplay(checker, { short: true });\n\t\t    });\n\t\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return typeCheckers.map(function (checker) {\n\t\t        return getCheckerDisplay(checker, options);\n\t\t      });\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t\t      if (!typeCheckers.some(function (checker) {\n\t\t        return !isError(checker(val, name, location));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function arrayOfCheckGetter(checker) {\n\t\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\t\n\t\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t\t        return !isError(checker(item));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function objectOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\t\n\t\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t\t      var notObject = checkers.object(val, name, location);\n\t\t      if (isError(notObject)) {\n\t\t        return notObject;\n\t\t      }\n\t\t      var allTypesSuccess = each(val, function (item, key) {\n\t\t        if (isError(checker(item, key, name))) {\n\t\t          return false;\n\t\t        }\n\t\t      });\n\t\t      if (!allTypesSuccess) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function typeOrArrayOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\n\t\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function getShapeCheckGetter() {\n\t\t    function shapeCheckGetter(shape, nonObject) {\n\t\t      var shapeTypes = {};\n\t\t      each(shape, function (checker, prop) {\n\t\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t\t      });\n\t\t      function type() {\n\t\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t\t        var ret = {};\n\t\t        var terse = options.terse;\n\t\t        var obj = options.obj;\n\t\t        var addHelpers = options.addHelpers;\n\t\n\t\t        var parentRequired = options.required;\n\t\t        each(shape, function (checker, prop) {\n\t\t          /* eslint complexity:[2, 6] */\n\t\t          var specified = obj && obj.hasOwnProperty(prop);\n\t\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t\t          if (!terse || (specified || !checker.isOptional)) {\n\t\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t\t          }\n\t\t          if (addHelpers) {\n\t\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t\t          }\n\t\t        });\n\t\t        return ret;\n\t\n\t\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t\t          if (!specified && required && !checker.isOptional) {\n\t\t            var item = 'ITEM';\n\t\t            if (checker.type && checker.type.__apiCheckData) {\n\t\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t\t            }\n\t\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t\t          } else if (specified) {\n\t\t            var error = checker(obj[prop], prop, null, obj);\n\t\t            if (isError(error)) {\n\t\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t\t            }\n\t\t          }\n\t\n\t\t          function addHelper(property, objectMessage, stringMessage) {\n\t\t            if (typeof theRet[prop] === 'string') {\n\t\t              theRet[prop] += stringMessage;\n\t\t            } else {\n\t\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\n\t\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t\t        if (isError(isObject)) {\n\t\t          return isObject;\n\t\t        }\n\t\t        var shapePropError = undefined;\n\t\t        location = location ? location + (name ? '/' : '') : '';\n\t\t        name = name || '';\n\t\t        each(shape, function (checker, prop) {\n\t\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t\t            return !isError(shapePropError);\n\t\t          }\n\t\t        });\n\t\t        if (isError(shapePropError)) {\n\t\t          return shapePropError;\n\t\t        }\n\t\t      }, { type: type, shortType: 'shape' }, disabled);\n\t\n\t\t      function strictType() {\n\t\t        return type.apply(undefined, arguments);\n\t\t      }\n\t\n\t\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t\t      strictType.__apiCheckData.strict = true;\n\t\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t\t        var shapeError = shapeChecker(val, name, location);\n\t\t        if (isError(shapeError)) {\n\t\t          return shapeError;\n\t\t        }\n\t\t        var allowedProperties = Object.keys(shape);\n\t\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t\t          return allowedProperties.indexOf(prop) === -1;\n\t\t        });\n\t\t        if (extraProps.length) {\n\t\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t\t        }\n\t\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\t\n\t\t      return shapeChecker;\n\t\t    }\n\t\n\t\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t\t      } else {\n\t\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (propExists === otherPropsExist) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t\t      otherProps = arrayify(otherProps);\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t\t      } else {\n\t\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t\t        var othersPresent = otherProps.every(function (property) {\n\t\t          return obj.hasOwnProperty(property);\n\t\t        });\n\t\t        if (!othersPresent) {\n\t\t          return getError(propName, location, type);\n\t\t        } else {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        throw new Error('requiredIfNot.all must be passed an array');\n\t\t      }\n\t\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t\t      var props = t(otherProps.join(', '));\n\t\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var iteration = all ? 'every' : 'some';\n\t\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (!otherPropsExist && !propExists) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, notRequired: true }, disabled);\n\t\t    }\n\t\n\t\t    return shapeCheckGetter;\n\t\n\t\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t\t      function type(options) {\n\t\t        if (options && options.short) {\n\t\t          return shortType;\n\t\t        }\n\t\t        return getCheckerDisplay(propChecker);\n\t\t      }\n\t\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function argumentsCheckerGetter() {\n\t\t    var type = 'function arguments';\n\t\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function anyCheckGetter() {\n\t\t    return setupChecker(function anyCheckerDefinition() {\n\t\t      // don't do anything\n\t\t    }, { type: 'any' }, disabled);\n\t\t  }\n\t\n\t\t  function nullCheckGetter() {\n\t\t    var type = 'null';\n\t\t    return setupChecker(function nullChecker(val, name, location) {\n\t\t      if (val !== null) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function rangeCheckGetter(min, max) {\n\t\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t\t    return setupChecker(function rangeChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < min || val > max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function lessThanCheckGetter(min) {\n\t\t    var type = 'lessThan[' + min + ']';\n\t\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val > min) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function greaterThanCheckGetter(max) {\n\t\t    var type = 'greaterThan[' + max + ']';\n\t\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function emptyObjectCheckGetter() {\n\t\t    var type = 'empty object';\n\t\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\t}\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t* angular-formly JavaScript Library v7.2.3\n\t*\n\t* @license MIT (http://license.angular-formly.com)\n\t*\n\t* built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n\t* ( _)==(_ )\n\t*/\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _indexCommon = __webpack_require__(1);\n\t\n\t\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\t\n\t\texports['default'] = _indexCommon2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\t\n\t\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\t\n\t\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\t\n\t\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\t\n\t\tvar _providersFormlyUsability = __webpack_require__(7);\n\t\n\t\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\t\n\t\tvar _providersFormlyConfig = __webpack_require__(8);\n\t\n\t\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\t\n\t\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\t\n\t\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\t\n\t\tvar _servicesFormlyUtil = __webpack_require__(11);\n\t\n\t\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\t\n\t\tvar _servicesFormlyWarn = __webpack_require__(12);\n\t\n\t\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\t\n\t\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\t\n\t\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\t\n\t\tvar _directivesFormlyField = __webpack_require__(14);\n\t\n\t\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\t\n\t\tvar _directivesFormlyFocus = __webpack_require__(15);\n\t\n\t\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\t\n\t\tvar _directivesFormlyForm = __webpack_require__(16);\n\t\n\t\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\t\n\t\tvar _runFormlyCustomTags = __webpack_require__(18);\n\t\n\t\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\t\n\t\tvar ngModuleName = 'formly';\n\t\n\t\texports['default'] = ngModuleName;\n\t\n\t\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\t\n\t\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\t\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\t\tngModule.constant('formlyVersion', (\"7.2.3\")); // <-- webpack variable\n\t\n\t\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\t\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\t\n\t\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\t\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\t\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\t\n\t\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\t\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\t\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\t\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\t\n\t\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\t\tngModule.run(_runFormlyCustomTags2['default']);\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar angular = __webpack_require__(3);\n\t\n\t\t/* istanbul ignore next */\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\texports['default'] = angular;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\tvar apiCheck = (0, _apiCheck2['default'])({\n\t\t  output: {\n\t\t    prefix: 'angular-formly:',\n\t\t    docsBaseUrl: __webpack_require__(6)\n\t\t  }\n\t\t});\n\t\n\t\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t\t    otherProps = [otherProps];\n\t\t  }\n\t\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\t\n\t\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t      return obj && obj.hasOwnProperty(otherProp);\n\t\t    });\n\t\t    if (!otherPropsExist && !propExists) {\n\t\t      return apiCheck.utils.getError(propName, location, type);\n\t\t    } else if (propExists) {\n\t\t      return propChecker(prop, propName, location, obj);\n\t\t    }\n\t\t  }\n\t\n\t\t  shapeRequiredIfNotDefinition.type = type;\n\t\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t\t}\n\t\n\t\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\t\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\t\n\t\tvar apiCheckProperty = apiCheck.func;\n\t\n\t\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t\t  warn: apiCheck.func,\n\t\t  'throw': apiCheck.func,\n\t\t  shape: apiCheck.func\n\t\t}));\n\t\n\t\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\t\n\t\tvar formlyWrapperType = apiCheck.shape({\n\t\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  overwriteOk: apiCheck.bool.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\t\n\t\tvar templateManipulators = apiCheck.shape({\n\t\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t\t}).strict.nullable;\n\t\n\t\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar fieldOptionsApiShape = {\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  model: modelChecker.optional,\n\t\t  originalModel: modelChecker.optional,\n\t\t  className: apiCheck.string.optional,\n\t\t  id: apiCheck.string.optional,\n\t\t  name: apiCheck.string.optional,\n\t\t  expressionProperties: expressionProperties.optional,\n\t\t  extras: apiCheck.shape({\n\t\t    validateOnModelChange: apiCheck.bool.optional,\n\t\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t\t  }).strict.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  templateOptions: apiCheck.object.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  modelOptions: apiCheck.shape({\n\t\t    updateOn: apiCheck.string.optional,\n\t\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t\t    allowInvalid: apiCheck.bool.optional,\n\t\t    getterSetter: apiCheck.bool.optional,\n\t\t    timezone: apiCheck.string.optional\n\t\t  }).optional,\n\t\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t\t    expression: formlyExpression.optional,\n\t\t    listener: formlyExpression\n\t\t  })).optional,\n\t\t  validators: validatorChecker.optional,\n\t\t  asyncValidators: validatorChecker.optional,\n\t\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  noFormControl: apiCheck.bool.optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t\t  }).strict).optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t\t  validation: apiCheck.shape({\n\t\t    show: apiCheck.bool.nullable.optional,\n\t\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t\t  }).optional,\n\t\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t\t  value: apiCheck.func.optional,\n\t\t  runExpressions: apiCheck.func.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  initialValue: apiCheck.any.optional,\n\t\t  defaultValue: apiCheck.any.optional\n\t\t};\n\t\n\t\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\t\n\t\tvar formOptionsApi = apiCheck.shape({\n\t\t  formState: apiCheck.object.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t\t  data: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar fieldGroup = apiCheck.shape({\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  // danger. Nested field groups wont get api-checked...\n\t\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t\t  className: apiCheck.string.optional,\n\t\t  options: formOptionsApi.optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  model: modelChecker.optional,\n\t\t  form: apiCheck.object.optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t\t}).strict;\n\t\n\t\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\t\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\t\n\t\tvar formlyTypeOptions = apiCheck.shape({\n\t\t  name: apiCheck.string,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t\t  'extends': apiCheck.string.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional,\n\t\t  overwriteOk: apiCheck.bool.optional\n\t\t}).strict;\n\t\n\t\t_angularFix2['default'].extend(apiCheck, {\n\t\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t\t});\n\t\n\t\texports['default'] = apiCheck;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.2.3\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\t\tmodule.exports = exports[\"default\"];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyUsability;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t\t  var _this = this;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    getFormlyError: getFormlyError,\n\t\t    getFieldError: getFieldError,\n\t\t    checkWrapper: checkWrapper,\n\t\t    checkWrapperTemplate: checkWrapperTemplate,\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    $get: function $get() {\n\t\t      return _this;\n\t\t    }\n\t\t  });\n\t\n\t\t  function getFieldError(errorInfoSlug, message, field) {\n\t\t    if (arguments.length < 3) {\n\t\t      field = message;\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t\t  }\n\t\n\t\t  function getFormlyError(errorInfoSlug, message) {\n\t\t    if (!message) {\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t\t  }\n\t\n\t\t  function getErrorMessage(errorInfoSlug, message) {\n\t\t    var url = '';\n\t\t    if (errorInfoSlug !== null) {\n\t\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t\t    }\n\t\t    return 'Formly Error: ' + message + '. ' + url;\n\t\t  }\n\t\n\t\t  function checkWrapper(wrapper) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t\t      prefix: 'formlyConfig.setWrapper',\n\t\t      urlSuffix: 'setwrapper-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function checkWrapperTemplate(template, additionalInfo) {\n\t\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t\t    if (template.indexOf(formlyTransclude) === -1) {\n\t\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyConfig;\n\t\n\t\t// @ngInject\n\t\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t\t  var _this2 = this;\n\t\n\t\t  var typeMap = {};\n\t\t  var templateWrappersMap = {};\n\t\t  var defaultWrapperName = 'default';\n\t\t  var _this = this;\n\t\t  var getError = formlyUsabilityProvider.getFormlyError;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    setType: setType,\n\t\t    getType: getType,\n\t\t    getTypeHeritage: getTypeHeritage,\n\t\t    setWrapper: setWrapper,\n\t\t    getWrapper: getWrapper,\n\t\t    getWrapperByType: getWrapperByType,\n\t\t    removeWrapperByName: removeWrapperByName,\n\t\t    removeWrappersForType: removeWrappersForType,\n\t\t    disableWarnings: false,\n\t\t    extras: {\n\t\t      disableNgModelAttrsManipulator: false,\n\t\t      fieldTransform: [],\n\t\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t\t      removeChromeAutoComplete: false,\n\t\t      defaultHideDirective: 'ng-if',\n\t\t      getFieldId: null\n\t\t    },\n\t\t    templateManipulators: {\n\t\t      preWrapper: [],\n\t\t      postWrapper: []\n\t\t    },\n\t\t    $get: function $get() {\n\t\t      return _this2;\n\t\t    }\n\t\t  });\n\t\n\t\t  function setType(options) {\n\t\t    if (_angularFix2['default'].isArray(options)) {\n\t\t      var _ret = (function () {\n\t\t        var allTypes = [];\n\t\t        _angularFix2['default'].forEach(options, function (item) {\n\t\t          allTypes.push(setType(item));\n\t\t        });\n\t\t        return {\n\t\t          v: allTypes\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret === 'object') return _ret.v;\n\t\t    } else if (_angularFix2['default'].isObject(options)) {\n\t\t      checkType(options);\n\t\t      if (options['extends']) {\n\t\t        extendTypeOptions(options);\n\t\t      }\n\t\t      typeMap[options.name] = options;\n\t\t      return typeMap[options.name];\n\t\t    } else {\n\t\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkType(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t\t      prefix: 'formlyConfig.setType',\n\t\t      url: 'settype-validation-failed'\n\t\t    });\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t\t    } else {\n\t\t      options.overwriteOk = undefined;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeOptions(options) {\n\t\t    var extendsType = getType(options['extends'], true, options);\n\t\t    extendTypeControllerFunction(options, extendsType);\n\t\t    extendTypeLinkFunction(options, extendsType);\n\t\t    extendTypeDefaultOptions(options, extendsType);\n\t\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t\t    extendTemplate(options, extendsType);\n\t\t  }\n\t\n\t\t  function extendTemplate(options, extendsType) {\n\t\t    if (options.template && extendsType.templateUrl) {\n\t\t      delete options.templateUrl;\n\t\t    } else if (options.templateUrl && extendsType.template) {\n\t\t      delete options.template;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeControllerFunction(options, extendsType) {\n\t\t    var extendsCtrl = extendsType.controller;\n\t\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsCtrl = options.controller;\n\t\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t\t      options.controller = function ($scope, $controller) {\n\t\t        $controller(extendsCtrl, { $scope: $scope });\n\t\t        $controller(optionsCtrl, { $scope: $scope });\n\t\t      };\n\t\t      options.controller.$inject = ['$scope', '$controller'];\n\t\t    } else {\n\t\t      options.controller = extendsCtrl;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeLinkFunction(options, extendsType) {\n\t\t    var extendsFn = extendsType.link;\n\t\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsFn = options.link;\n\t\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t\t      options.link = function () {\n\t\t        extendsFn.apply(undefined, arguments);\n\t\t        optionsFn.apply(undefined, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      options.link = extendsFn;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeDefaultOptions(options, extendsType) {\n\t\t    var extendsDO = extendsType.defaultOptions;\n\t\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsDO = options.defaultOptions;\n\t\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t\t    if (extendsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t\t        var mergedDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t\t        var extenderOptionsDefaultOptions = optionsDO;\n\t\t        if (optionsDOIsFn) {\n\t\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t\t        }\n\t\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t\t        return extendsDefaultOptions;\n\t\t      };\n\t\t    } else if (optionsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var newDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t\t        return optionsDO(newDefaultOptions, scope);\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function getType(name, throwError, errorContext) {\n\t\t    if (!name) {\n\t\t      return undefined;\n\t\t    }\n\t\t    var type = typeMap[name];\n\t\t    if (!type && throwError === true) {\n\t\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t\t    } else {\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypeHeritage(parent) {\n\t\t    var heritage = [];\n\t\t    var type = parent;\n\t\t    if (_angularFix2['default'].isString(type)) {\n\t\t      type = getType(parent);\n\t\t    }\n\t\t    parent = type['extends'];\n\t\t    while (parent) {\n\t\t      type = getType(parent);\n\t\t      heritage.push(type);\n\t\t      parent = type['extends'];\n\t\t    }\n\t\t    return heritage;\n\t\t  }\n\t\n\t\t  function setWrapper(_x, _x2) {\n\t\t    var _again = true;\n\t\n\t\t    _function: while (_again) {\n\t\t      var options = _x,\n\t\t          name = _x2;\n\t\t      _again = false;\n\t\n\t\t      if (_angularFix2['default'].isArray(options)) {\n\t\t        return options.map(function (wrapperOptions) {\n\t\t          return setWrapper(wrapperOptions);\n\t\t        });\n\t\t      } else if (_angularFix2['default'].isObject(options)) {\n\t\t        options.types = getOptionsTypes(options);\n\t\t        options.name = getOptionsName(options, name);\n\t\t        checkWrapperAPI(options);\n\t\t        templateWrappersMap[options.name] = options;\n\t\t        return options;\n\t\t      } else if (_angularFix2['default'].isString(options)) {\n\t\t        _x = {\n\t\t          template: options,\n\t\t          name: name\n\t\t        };\n\t\t        _x2 = undefined;\n\t\t        _again = true;\n\t\t        continue _function;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsTypes(options) {\n\t\t    if (_angularFix2['default'].isString(options.types)) {\n\t\t      return [options.types];\n\t\t    }\n\t\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t\t      return [];\n\t\t    } else {\n\t\t      return options.types;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsName(options, name) {\n\t\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t\t  }\n\t\n\t\t  function checkWrapperAPI(options) {\n\t\t    formlyUsabilityProvider.checkWrapper(options);\n\t\t    if (options.template) {\n\t\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t\t    }\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t\t    } else {\n\t\t      delete options.overwriteOk;\n\t\t    }\n\t\t    checkWrapperTypes(options);\n\t\t  }\n\t\n\t\t  function checkWrapperTypes(options) {\n\t\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t\t    if (shouldThrow) {\n\t\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkOverwrite(property, object, newValue, objectName) {\n\t\t    if (object.hasOwnProperty(property)) {\n\t\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t\t    }\n\t\t  }\n\t\n\t\t  function getWrapper(name) {\n\t\t    return templateWrappersMap[name || defaultWrapperName];\n\t\t  }\n\t\n\t\t  function getWrapperByType(type) {\n\t\t    /* eslint prefer-const:0 */\n\t\t    var wrappers = [];\n\t\t    for (var _name in templateWrappersMap) {\n\t\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t\t          wrappers.push(templateWrappersMap[_name]);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return wrappers;\n\t\t  }\n\t\n\t\t  function removeWrapperByName(name) {\n\t\t    var wrapper = templateWrappersMap[name];\n\t\t    delete templateWrappersMap[name];\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function removeWrappersForType(type) {\n\t\t    var wrappers = getWrapperByType(type);\n\t\t    if (!wrappers) {\n\t\t      return undefined;\n\t\t    }\n\t\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t\t      return removeWrapperByName(wrappers.name);\n\t\t    } else {\n\t\t      wrappers.forEach(function (wrapper) {\n\t\t        return removeWrapperByName(wrapper.name);\n\t\t      });\n\t\t      return wrappers;\n\t\t    }\n\t\t  }\n\t\n\t\t  function warn() {\n\t\t    if (!_this.disableWarnings && console.warn) {\n\t\t      /* eslint no-console:0 */\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      console.warn.apply(console, _toConsumableArray(args));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = {\n\t\t  formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName, arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t\t};\n\t\n\t\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t\t  if (_angularFix2['default'].isFunction(expression)) {\n\t\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t\t  } else {\n\t\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t\t  }\n\t\t}\n\t\n\t\tfunction getFieldId(formId, options, index) {\n\t\t  if (options.id) {\n\t\t    return options.id;\n\t\t  }\n\t\t  var type = options.type;\n\t\t  if (!type && options.template) {\n\t\t    type = 'template';\n\t\t  } else if (!type && options.templateUrl) {\n\t\t    type = 'templateUrl';\n\t\t  }\n\t\n\t\t  return [formId, type, options.key, index].join('_');\n\t\t}\n\t\n\t\tfunction reverseDeepMerge(dest) {\n\t\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t\t    if (!index) {\n\t\t      return;\n\t\t    }\n\t\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t\t        dest[prop] = _angularFix2['default'].copy(val);\n\t\t      } else if (objAndSameType(dest[prop], val)) {\n\t\t        reverseDeepMerge(dest[prop], val);\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t  return dest;\n\t\t}\n\t\n\t\tfunction objAndSameType(obj1, obj2) {\n\t\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t\t}\n\t\n\t\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\t\tfunction findByNodeName(el, nodeName) {\n\t\t  if (!el.prop) {\n\t\t    // not a jQuery or jqLite object -> wrap it\n\t\t    el = _angularFix2['default'].element(el);\n\t\t  }\n\t\n\t\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t\t    return el;\n\t\t  }\n\t\n\t\t  var c = el.children();\n\t\t  for (var i = 0; c && i < c.length; i++) {\n\t\t    var node = findByNodeName(c[i], nodeName);\n\t\t    if (node) {\n\t\t      return node;\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t\t    obj = [obj];\n\t\t  } else if (!obj) {\n\t\t    obj = [];\n\t\t  }\n\t\t  return obj;\n\t\t}\n\t\n\t\tfunction extendFunction() {\n\t\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t    fns[_key] = arguments[_key];\n\t\t  }\n\t\n\t\t  return function extendedFunction() {\n\t\t    var args = arguments;\n\t\t    fns.forEach(function (fn) {\n\t\t      return fn.apply(null, args);\n\t\t    });\n\t\t  };\n\t\t}\n\t\n\t\tfunction extendArray(primary, secondary, property) {\n\t\t  if (property) {\n\t\t    primary = primary[property];\n\t\t    secondary = secondary[property];\n\t\t  }\n\t\t  if (secondary && primary) {\n\t\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t\t      if (primary.indexOf(item) === -1) {\n\t\t        primary.push(item);\n\t\t      }\n\t\t    });\n\t\t    return primary;\n\t\t  } else if (secondary) {\n\t\t    return secondary;\n\t\t  } else {\n\t\t    return primary;\n\t\t  }\n\t\t}\n\t\n\t\tfunction startsWith(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\n\t\tfunction contains(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\texports[\"default\"] = formlyValidationMessages;\n\t\n\t\t// @ngInject\n\t\tfunction formlyValidationMessages() {\n\t\n\t\t  var validationMessages = {\n\t\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t\t    addStringMessage: addStringMessage,\n\t\t    messages: {}\n\t\t  };\n\t\n\t\t  return validationMessages;\n\t\n\t\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t\t  }\n\t\n\t\t  function addStringMessage(name, string) {\n\t\t    validationMessages.messages[name] = function () {\n\t\t      return string;\n\t\t    };\n\t\t  }\n\t\n\t\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t\t      if (scope.options.templateOptions[prop]) {\n\t\t        return prefix + \" \" + scope.options.templateOptions[prop] + \" \" + suffix;\n\t\t      } else {\n\t\t        return alternate;\n\t\t      }\n\t\t    };\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports[\"default\"];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyUtil;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUtil() {\n\t\t  return _otherUtils2['default'];\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\texports['default'] = formlyWarn;\n\t\n\t\t// @ngInject\n\t\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t\t  return function warn() {\n\t\t    if (!formlyConfig.disableWarnings) {\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      $log.warn.apply($log, _toConsumableArray(args));\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyCustomValidation;\n\t\n\t\t// @ngInject\n\t\tfunction formlyCustomValidation(formlyUtil) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    require: 'ngModel',\n\t\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t\t      var opts = scope.options;\n\t\t      opts.validation.messages = opts.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t\t        opts.validation.messages[key] = function () {\n\t\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t        };\n\t\t      });\n\t\n\t\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\t\n\t\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t\t        setupMessage(validator, name);\n\t\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t\t        if (useNewValidatorsApi) {\n\t\t          setupWithValidators(validator, name, isAsync);\n\t\t        } else {\n\t\t          setupWithParsers(validator, name, isAsync);\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupMessage(validator, name) {\n\t\t        var message = validator.message;\n\t\t        if (message) {\n\t\t          opts.validation.messages[name] = function () {\n\t\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t          };\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupWithValidators(validator, name, isAsync) {\n\t\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\t\n\t\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t\t        };\n\t\t      }\n\t\n\t\t      function setupWithParsers(validator, name, isAsync) {\n\t\t        var inFlightValidator = undefined;\n\t\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t\t          if (isAsync) {\n\t\t            ctrl.$pending = ctrl.$pending || {};\n\t\t            ctrl.$pending[name] = true;\n\t\t            inFlightValidator = isValid;\n\t\t            isValid.then(function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, true);\n\t\t              }\n\t\t            })['catch'](function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, false);\n\t\t              }\n\t\t            })['finally'](function () {\n\t\t              var $pending = ctrl.$pending || {};\n\t\t              if (Object.keys($pending).length === 1) {\n\t\t                delete ctrl.$pending;\n\t\t              } else {\n\t\t                delete ctrl.$pending[name];\n\t\t              }\n\t\t            });\n\t\t          } else {\n\t\t            ctrl.$setValidity(name, isValid);\n\t\t          }\n\t\t          return viewValue;\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = formlyField;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyField\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t\t  var arrayify = formlyUtil.arrayify;\n\t\n\t\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    transclude: true,\n\t\t    require: '?^formlyForm',\n\t\t    scope: {\n\t\t      options: '=',\n\t\t      model: '=',\n\t\t      originalModel: '=?',\n\t\t      formId: '@', // TODO remove formId in a breaking release\n\t\t      index: '=?',\n\t\t      fields: '=?',\n\t\t      formState: '=?',\n\t\t      formOptions: '=?',\n\t\t      form: '=?' // TODO require form in a breaking release\n\t\t    },\n\t\t    controller: FormlyFieldController,\n\t\t    link: fieldLink\n\t\t  };\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t\t    /* eslint max-statements:[2, 31] */\n\t\t    if ($scope.options.fieldGroup) {\n\t\t      setupFieldGroup();\n\t\t      return;\n\t\t    }\n\t\n\t\t    var fieldType = getFieldType($scope.options);\n\t\t    simplifyLife($scope.options);\n\t\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t\t    checkApi($scope.options);\n\t\t    // set field id to link labels and fields\n\t\n\t\t    // initalization\n\t\t    setFieldIdAndName();\n\t\t    setDefaultValue();\n\t\t    setInitialValue();\n\t\t    runExpressions();\n\t\t    addValidationMessages($scope.options);\n\t\t    invokeControllers($scope, $scope.options, fieldType);\n\t\n\t\t    // function definitions\n\t\t    function runExpressions() {\n\t\t      // must run on next tick to make sure that the current value is correct.\n\t\t      return $timeout(function runExpressionsOnNextTick() {\n\t\t        var field = $scope.options;\n\t\t        var currentValue = valueGetterSetter();\n\t\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t\t          var setter = $parse(prop).assign;\n\t\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t\t          promise.then(function setFieldValue(value) {\n\t\t            setter(field, value);\n\t\t          });\n\t\t        });\n\t\t      }, 0, false);\n\t\t    }\n\t\n\t\t    function valueGetterSetter(newVal) {\n\t\t      if (!$scope.model || !$scope.options.key) {\n\t\t        return undefined;\n\t\t      }\n\t\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t\t        $scope.model[$scope.options.key] = newVal;\n\t\t      }\n\t\t      return $scope.model[$scope.options.key];\n\t\t    }\n\t\n\t\t    function simplifyLife(options) {\n\t\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t\t      formlyUtil.reverseDeepMerge(options, {\n\t\t        originalModel: options.model,\n\t\t        extras: {},\n\t\t        data: {},\n\t\t        templateOptions: {},\n\t\t        validation: {}\n\t\t      });\n\t\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t\t      $scope.to = $scope.options.templateOptions;\n\t\t      $scope.formOptions = $scope.formOptions || {};\n\t\t    }\n\t\n\t\t    function setFieldIdAndName() {\n\t\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t\t      } else {\n\t\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t\t      }\n\t\t      $scope.options.id = $scope.id;\n\t\t      $scope.name = $scope.options.name || $scope.options.id;\n\t\t      $scope.options.name = $scope.name;\n\t\t    }\n\t\n\t\t    function setDefaultValue() {\n\t\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined($scope.model[$scope.options.key])) {\n\t\t        var setter = $parse($scope.options.key).assign;\n\t\t        setter($scope.model, $scope.options.defaultValue);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setInitialValue() {\n\t\t      $scope.options.initialValue = $scope.model && $scope.model[$scope.options.key];\n\t\t    }\n\t\n\t\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t\t      if (type) {\n\t\t        mergeOptions(options, type.defaultOptions);\n\t\t      }\n\t\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t\t      });\n\t\t    }\n\t\n\t\t    function mergeOptions(options, extraOptions) {\n\t\t      if (extraOptions) {\n\t\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t\t          extraOptions = extraOptions(options, $scope);\n\t\t        }\n\t\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t\t      }\n\t\t    }\n\t\n\t\t    function extendOptionsWithDefaults(options, index) {\n\t\t      var key = options.key || index || 0;\n\t\t      _angularFix2['default'].extend(options, {\n\t\t        // attach the key in case the formly-field directive is used directly\n\t\t        key: key,\n\t\t        value: options.value || valueGetterSetter,\n\t\t        runExpressions: runExpressions,\n\t\t        resetModel: resetModel,\n\t\t        updateInitialValue: updateInitialValue\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      $scope.model[$scope.options.key] = $scope.options.initialValue;\n\t\t      if ($scope.options.formControl) {\n\t\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t\t            resetFormControl(formControl, true);\n\t\t          });\n\t\t        } else {\n\t\t          resetFormControl($scope.options.formControl);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function resetFormControl(formControl, isMultiNgModel) {\n\t\t      if (!isMultiNgModel) {\n\t\t        formControl.$setViewValue($scope.model[$scope.options.key]);\n\t\t      }\n\t\n\t\t      formControl.$render();\n\t\t      formControl.$setUntouched && formControl.$setUntouched();\n\t\t      formControl.$setPristine();\n\t\n\t\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t\t      if (!$scope.$root.$$phase) {\n\t\t        $scope.$digest();\n\t\t      }\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      $scope.options.initialValue = $scope.model[$scope.options.key];\n\t\t    }\n\t\n\t\t    function addValidationMessages(options) {\n\t\t      options.validation.messages = options.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t\t        if (!options.validation.messages[name]) {\n\t\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t\t          };\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function invokeControllers(scope) {\n\t\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t\t        if (controller) {\n\t\t          $controller(controller, { $scope: scope });\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupFieldGroup() {\n\t\t      $scope.options.options = $scope.options.options || {};\n\t\t      $scope.options.options.formState = $scope.formState;\n\t\t    }\n\t\t  }\n\t\n\t\t  // link function\n\t\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t\t    if (scope.options.fieldGroup) {\n\t\t      setFieldGroupTemplate();\n\t\t      return;\n\t\t    }\n\t\n\t\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t\t    if (!formlyFormCtrl && scope.options.model) {\n\t\t      scope.$watch('options.model', function () {\n\t\t        return scope.options.runExpressions();\n\t\t      }, true);\n\t\t    }\n\t\n\t\t    addAttributes();\n\t\t    addClasses();\n\t\n\t\t    var type = getFieldType(scope.options);\n\t\t    var args = arguments;\n\t\t    var thusly = this;\n\t\t    var fieldCount = 0;\n\t\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t\t    });\n\t\n\t\t    function setFieldGroupTemplate() {\n\t\t      checkFieldGroupApi(scope.options);\n\t\t      el.addClass('formly-field-group');\n\t\t      var extraAttributes = '';\n\t\t      if (scope.options.elementAttributes) {\n\t\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t\t        }).join(' ');\n\t\t      }\n\t\t      var modelValue = 'model';\n\t\t      scope.options.form = scope.form;\n\t\t      if (scope.options.key) {\n\t\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t\t      }\n\t\t      setElementTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ');\n\t\t    }\n\t\n\t\t    function addAttributes() {\n\t\t      if (scope.options.elementAttributes) {\n\t\t        el.attr(scope.options.elementAttributes);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addClasses() {\n\t\t      if (scope.options.className) {\n\t\t        el.addClass(scope.options.className);\n\t\t      }\n\t\t      if (scope.options.type) {\n\t\t        el.addClass('formly-field-' + scope.options.type);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setElementTemplate(templateString) {\n\t\t      el.html(asHtml(templateString));\n\t\t      $compile(el.contents())(scope);\n\t\t      return templateString;\n\t\t    }\n\t\n\t\t    function watchFormControl(templateString) {\n\t\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t\t      if (scope.options.noFormControl) {\n\t\t        return;\n\t\t      }\n\t\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\t\n\t\t      if (ngModelNodes.length) {\n\t\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t\t          fieldCount++;\n\t\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t\t        });\n\t\t      }\n\t\n\t\t      function watchFieldNameOrExistence(name) {\n\t\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t\t        var nameExpression = nameExpressionRegex.exec(name);\n\t\t        if (nameExpression) {\n\t\t          name = $interpolate(name)(scope);\n\t\t        }\n\t\t        watchFieldExistence(name);\n\t\t      }\n\t\n\t\t      function watchFieldExistence(name) {\n\t\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t\t          if (formControl) {\n\t\t            if (fieldCount > 1) {\n\t\t              if (!scope.options.formControl) {\n\t\t                scope.options.formControl = [];\n\t\t              }\n\t\t              scope.options.formControl.push(formControl);\n\t\t            } else {\n\t\t              scope.options.formControl = formControl;\n\t\t            }\n\t\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t\t            stopWatchingShowError();\n\t\t            addShowMessagesWatcher();\n\t\t            addParsers();\n\t\t            addFormatters();\n\t\t          }\n\t\t        });\n\t\t      }\n\t\n\t\t      function addShowMessagesWatcher() {\n\t\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t\t          var options = scope.options;\n\t\t          var fc = scope.fc;\n\t\n\t\t          if (!fc.$invalid) {\n\t\t            return false;\n\t\t          } else if (typeof options.validation.show === 'boolean') {\n\t\t            return options.validation.show;\n\t\t          } else if (customExpression) {\n\t\t            return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t\t          } else {\n\t\t            var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t\t            return scope.fc.$touched || noTouchedButDirty;\n\t\t          }\n\t\t        }, function onShowValidationChange(show) {\n\t\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t\t          scope.showError = show; // shortcut for template authors\n\t\t        });\n\t\t      }\n\t\n\t\t      function addParsers() {\n\t\t        setParsersOrFormatters('parsers');\n\t\t      }\n\t\n\t\t      function addFormatters() {\n\t\t        setParsersOrFormatters('formatters');\n\t\t        var ctrl = scope.fc;\n\t\t        var formWasPristine = scope.form.$pristine;\n\t\t        if (scope.options.formatters) {\n\t\t          (function () {\n\t\t            var value = ctrl.$modelValue;\n\t\t            ctrl.$formatters.forEach(function (formatter) {\n\t\t              value = formatter(value);\n\t\t            });\n\t\n\t\t            ctrl.$setViewValue(value);\n\t\t            ctrl.$render();\n\t\t            ctrl.$setPristine();\n\t\t            if (formWasPristine) {\n\t\t              scope.form.$setPristine();\n\t\t            }\n\t\t          })();\n\t\t        }\n\t\t      }\n\t\n\t\t      function setParsersOrFormatters(which) {\n\t\t        var originalThingProp = 'originalParser';\n\t\t        if (which === 'formatters') {\n\t\t          originalThingProp = 'originalFormatter';\n\t\t        }\n\t\n\t\t        // init with type's parsers\n\t\t        var things = getThingsFromType(type);\n\t\n\t\t        // get optionsTypes things\n\t\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\t\n\t\t        // get field's things\n\t\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\t\n\t\t        // convert things into formlyExpression things\n\t\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t\t          things[index] = getFormlyExpressionThing(thing);\n\t\t        });\n\t\n\t\t        var ngModelCtrls = scope.fc;\n\t\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t\t          ngModelCtrls = [ngModelCtrls];\n\t\t        }\n\t\n\t\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t\t          var _ngModelCtrl;\n\t\n\t\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t\t        });\n\t\n\t\t        function getThingsFromType(theType) {\n\t\t          if (!theType) {\n\t\t            return [];\n\t\t          }\n\t\t          if (_angularFix2['default'].isString(theType)) {\n\t\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t\t          }\n\t\t          var typeThings = [];\n\t\n\t\t          // get things from parent\n\t\t          if (theType['extends']) {\n\t\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t\t          }\n\t\n\t\t          // get own type's things\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\t\n\t\t          // get things from optionsTypes\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\t\n\t\t          return typeThings;\n\t\t        }\n\t\n\t\t        function getThingsFromOptionsTypes() {\n\t\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t\t          var optionsTypesThings = [];\n\t\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t\t          });\n\t\t          return optionsTypesThings;\n\t\t        }\n\t\n\t\t        function getFormlyExpressionThing(thing) {\n\t\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t\t          return formlyExpressionParserOrFormatterFunction;\n\t\n\t\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t\t            var $modelValue = scope.options.value();\n\t\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function callLinkFunctions() {\n\t\t      if (type && type.link) {\n\t\t        type.link.apply(thusly, args);\n\t\t      }\n\t\t      if (scope.options.link) {\n\t\t        scope.options.link.apply(thusly, args);\n\t\t      }\n\t\t    }\n\t\n\t\t    function runManipulators(manipulators) {\n\t\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t\t        var chain = $q.when(templateToManipulate);\n\t\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t\t          chain = chain.then(function (template) {\n\t\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t\t            });\n\t\t          });\n\t\t        });\n\t\t        return chain;\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  // sort-of stateless util functions\n\t\t  function asHtml(el) {\n\t\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t\t    return wrapper.append(el).html();\n\t\t  }\n\t\n\t\t  function getFieldType(options) {\n\t\t    return options.type && formlyConfig.getType(options.type);\n\t\t  }\n\t\n\t\t  function getManipulators(options, formOptions) {\n\t\t    var preWrapper = [];\n\t\t    var postWrapper = [];\n\t\t    addManipulators(options.templateManipulators);\n\t\t    addManipulators(formOptions.templateManipulators);\n\t\t    addManipulators(formlyConfig.templateManipulators);\n\t\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\t\n\t\t    function addManipulators(manipulators) {\n\t\t      /* eslint-disable */ // it doesn't understand this :-(\n\t\n\t\t      var _ref = manipulators || {};\n\t\n\t\t      var _ref$preWrapper = _ref.preWrapper;\n\t\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t\t      var _ref$postWrapper = _ref.postWrapper;\n\t\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\t\n\t\t      preWrapper = preWrapper.concat(pre);\n\t\t      postWrapper = postWrapper.concat(post);\n\t\t      /* eslint-enable */\n\t\t    }\n\t\t  }\n\t\n\t\t  function getFieldTemplate(options) {\n\t\t    function fromOptionsOrType(key, fieldType) {\n\t\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t\t        return options[key];\n\t\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t\t        return fieldType[key];\n\t\t      }\n\t\t    }\n\t\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    var template = fromOptionsOrType('template', type);\n\t\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t\t    }\n\t\n\t\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t\t  }\n\t\n\t\t  function getTemplate(template, isUrl, options) {\n\t\t    var templatePromise = undefined;\n\t\t    if (_angularFix2['default'].isFunction(template)) {\n\t\t      templatePromise = $q.when(template(options));\n\t\t    } else {\n\t\t      templatePromise = $q.when(template);\n\t\t    }\n\t\n\t\t    if (!isUrl) {\n\t\t      return templatePromise;\n\t\t    } else {\n\t\t      var _ret2 = (function () {\n\t\t        var httpOptions = { cache: $templateCache };\n\t\t        return {\n\t\t          v: templatePromise.then(function (url) {\n\t\t            return $http.get(url, httpOptions);\n\t\t          }).then(function (response) {\n\t\t            return response.data;\n\t\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t\t          })\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret2 === 'object') return _ret2.v;\n\t\t    }\n\t\t  }\n\t\n\t\t  function transcludeInWrappers(options, formOptions) {\n\t\t    var wrapper = getWrapperOption(options, formOptions);\n\t\n\t\t    return function transcludeTemplate(template) {\n\t\t      if (!wrapper.length) {\n\t\t        return $q.when(template);\n\t\t      }\n\t\n\t\t      wrapper.forEach(function (aWrapper) {\n\t\t        formlyUsability.checkWrapper(aWrapper, options);\n\t\t        runApiCheck(aWrapper, options);\n\t\t      });\n\t\t      var promises = wrapper.map(function (w) {\n\t\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t\t      });\n\t\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t\t        });\n\t\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t\t        var totalWrapper = wrappersTemplates.shift();\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t\t        });\n\t\t        return doTransclusion(totalWrapper, template);\n\t\t      });\n\t\t    };\n\t\t  }\n\t\n\t\t  function doTransclusion(wrapper, template) {\n\t\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t\t    superWrapper.append(wrapper);\n\t\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t\t    if (!transcludeEl.length) {\n\t\t      // try it using our custom find function\n\t\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t\t    }\n\t\t    transcludeEl.replaceWith(template);\n\t\t    return superWrapper.html();\n\t\t  }\n\t\n\t\t  function getWrapperOption(options, formOptions) {\n\t\t    /* eslint complexity:[2, 6] */\n\t\t    var wrapper = options.wrapper;\n\t\t    // explicit null means no wrapper\n\t\t    if (wrapper === null) {\n\t\t      return [];\n\t\t    }\n\t\n\t\t    // nothing specified means use the default wrapper for the type\n\t\t    if (!wrapper) {\n\t\t      // get all wrappers that specify they apply to this type\n\t\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t\t    } else {\n\t\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t\t    }\n\t\n\t\t    // get all wrappers for that the type specified that it uses.\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    if (type && type.wrapper) {\n\t\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(typeWrappers);\n\t\t    }\n\t\n\t\t    // add form wrappers\n\t\t    if (formOptions.wrapper) {\n\t\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(formWrappers);\n\t\t    }\n\t\n\t\t    // add the default wrapper last\n\t\t    var defaultWrapper = formlyConfig.getWrapper();\n\t\t    if (defaultWrapper) {\n\t\t      wrapper.push(defaultWrapper);\n\t\t    }\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function checkApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t    // validate with the type\n\t\t    var type = options.type && formlyConfig.getType(options.type);\n\t\t    if (type) {\n\t\t      runApiCheck(type, options, true);\n\t\t    }\n\t\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkFieldGroupApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function runApiCheck(_ref2, options, forType) {\n\t\t    var apiCheck = _ref2.apiCheck;\n\t\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\t\n\t\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t\t    if (forType && options.type) {\n\t\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t\t    /* eslint complexity:[2, 9] */\n\t\t    if (!apiCheck) {\n\t\t      return;\n\t\t    }\n\t\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t\t      return;\n\t\t    }\n\t\t    var fn = apiCheckFunction || 'warn';\n\t\t    // this is the new API\n\t\t    var checkerObjects = apiCheck(instance);\n\t\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t\t      var checker = instance.shape(shape);\n\t\t      var checkOptions = _angularFix2['default'].extend({\n\t\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t\t      }, apiCheckOptions);\n\t\t      instance[fn](checker, options[name], checkOptions);\n\t\t    });\n\t\t  }\n\t\t}\n\t\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\t\n\t\t// Stateless util functions\n\t\tfunction getDefaultOptionsOptionsTypes(type) {\n\t\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t\t}\n\t\n\t\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\texports['default'] = formlyFocus;\n\t\n\t\t// @ngInject\n\t\tfunction formlyFocus($timeout, $document) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    link: function formlyFocusLink(scope, element, attrs) {\n\t\t      var previousEl = null;\n\t\t      var el = element[0];\n\t\t      var doc = $document[0];\n\t\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t\t        if (value === 'true') {\n\t\t          $timeout(function setElementFocus() {\n\t\t            previousEl = doc.activeElement;\n\t\t            el.focus();\n\t\t          }, ~ ~attrs.focusWait);\n\t\t        } else if (value === 'false') {\n\t\t          if (doc.activeElement === el) {\n\t\t            el.blur();\n\t\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t\t              previousEl.focus();\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar _slice = Array.prototype.slice;\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyForm;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyForm\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t\t  var currentFormId = 1;\n\t\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    template: formlyFormGetTemplate,\n\t\t    replace: true,\n\t\t    transclude: true,\n\t\t    scope: {\n\t\t      fields: '=',\n\t\t      model: '=',\n\t\t      form: '=?',\n\t\t      options: '=?'\n\t\t    },\n\t\t    controller: FormlyFormController,\n\t\t    link: formlyFormLink\n\t\t  };\n\t\n\t\t  function formlyFormGetTemplate(el, attrs) {\n\t\t    var rootEl = getRootEl();\n\t\t    var fieldRootEl = getFieldRootEl();\n\t\t    var formId = 'formly_' + currentFormId++;\n\t\t    var parentFormAttributes = '';\n\t\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t\t    }\n\t\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\t\n\t\t    function getRootEl() {\n\t\t      return attrs.rootEl || 'ng-form';\n\t\t    }\n\t\n\t\t    function getFieldRootEl() {\n\t\t      return attrs.fieldRootEl || 'div';\n\t\t    }\n\t\n\t\t    function getHideDirective() {\n\t\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t\t    }\n\t\n\t\t    function getTrackBy() {\n\t\t      if (!attrs.trackBy) {\n\t\t        return '';\n\t\t      } else {\n\t\t        return 'track by ' + attrs.trackBy;\n\t\t      }\n\t\t    }\n\t\n\t\t    function getFormName() {\n\t\t      var formName = formId;\n\t\t      var bindName = attrs.bindName;\n\t\t      if (bindName) {\n\t\t        if (_angularFix2['default'].version.minor < 3) {\n\t\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t\t        }\n\t\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t\t      }\n\t\t      return formName;\n\t\t    }\n\t\n\t\t    function getTranscludeClass() {\n\t\t      return attrs.transcludeClass || '';\n\t\t    }\n\t\n\t\t    function copyAttributes(attributes) {\n\t\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t\t      var arrayAttrs = [];\n\t\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t\t        var nodeName = _ref.nodeName;\n\t\t        var value = _ref.value;\n\t\n\t\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t\t        }\n\t\t      });\n\t\t      return arrayAttrs.join(' ');\n\t\t    }\n\t\t  }\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t\t    setupOptions();\n\t\t    $scope.model = $scope.model || {};\n\t\t    setupFields();\n\t\n\t\t    // watch the model and evaluate watch expressions that depend on it.\n\t\t    $scope.$watch('model', onModelOrFormStateChange, true);\n\t\t    if ($scope.options.formState) {\n\t\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t\t    }\n\t\n\t\t    function onModelOrFormStateChange() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function runFieldExpressionProperties(field, index) {\n\t\t        var model = field.model || $scope.model;\n\t\t        var promise = field.runExpressions && field.runExpressions();\n\t\t        if (field.hideExpression) {\n\t\t          // can't use hide with expressionProperties reliably\n\t\t          var val = model[field.key];\n\t\t          field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t\t        }\n\t\t        if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t\t          var validate = field.formControl.$validate;\n\t\t          if (promise) {\n\t\t            promise.then(validate);\n\t\t          } else {\n\t\t            validate();\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupFields() {\n\t\t      $scope.fields = $scope.fields || [];\n\t\n\t\t      checkDeprecatedOptions($scope.options);\n\t\n\t\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\t\n\t\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t\t        fieldTransforms = [fieldTransforms];\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t\t        if (fieldTransform) {\n\t\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t\t          if (!$scope.fields) {\n\t\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t\t          }\n\t\t        }\n\t\t      });\n\t\n\t\t      setupModels();\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t\t    }\n\t\n\t\t    function checkDeprecatedOptions(options) {\n\t\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupOptions() {\n\t\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t\t      $scope.options = $scope.options || {};\n\t\t      $scope.options.formState = $scope.options.formState || {};\n\t\n\t\t      _angularFix2['default'].extend($scope.options, {\n\t\t        updateInitialValue: updateInitialValue,\n\t\t        resetModel: resetModel\n\t\t      });\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.updateInitialValue();\n\t\t        } else {\n\t\t          field.updateInitialValue();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.resetModel();\n\t\t        } else if (field.resetModel) {\n\t\t          field.resetModel();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupModels() {\n\t\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t\t      var watchedModels = [$scope.model];\n\t\n\t\t      if ($scope.options.formState) {\n\t\t        // $scope.options.formState will have its own watcher\n\t\t        watchedModels.push($scope.options.formState);\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        var isNewModel = initModel(field);\n\t\n\t\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1) {\n\t\t          $scope.$watch(function () {\n\t\t            return field.model;\n\t\t          }, onModelOrFormStateChange, true);\n\t\t          watchedModels.push(field.model);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function initModel(field) {\n\t\t      var isNewModel = true;\n\t\n\t\t      if (_angularFix2['default'].isString(field.model)) {\n\t\t        var expression = field.model;\n\t\t        var index = $scope.fields.indexOf(field);\n\t\n\t\t        isNewModel = !refrencesCurrentlyWatchedModel(expression);\n\t\n\t\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t\t        if (!field.model) {\n\t\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t\t        }\n\t\t      }\n\t\t      return isNewModel;\n\t\t    }\n\t\n\t\t    function refrencesCurrentlyWatchedModel(expression) {\n\t\t      return ['model', 'formState'].some(function (item) {\n\t\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t\t      });\n\t\t    }\n\t\n\t\t    function attachKey(field, index) {\n\t\t      if (!isFieldGroup(field)) {\n\t\t        field.key = field.key || index || 0;\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupWatchers(field, index) {\n\t\t      if (isFieldGroup(field) || !_angularFix2['default'].isDefined(field.watcher)) {\n\t\t        return;\n\t\t      }\n\t\t      var watchers = field.watcher;\n\t\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t\t        watchers = [watchers];\n\t\t      }\n\t\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t\t        if (!_angularFix2['default'].isDefined(watcher.listener)) {\n\t\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t\t        }\n\t\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t\t        var watchListener = getWatchListener(watcher, field, index);\n\t\n\t\t        var type = watcher.type || '$watch';\n\t\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t\t      });\n\t\t    }\n\t\n\t\t    function getWatchExpression(watcher, field, index) {\n\t\t      var watchExpression = watcher.expression || 'model[\\'' + field.key + '\\']';\n\t\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t\t        (function () {\n\t\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalExpression = watchExpression;\n\t\t          watchExpression = function formlyWatchExpression() {\n\t\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t\t          };\n\t\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchExpression;\n\t\t    }\n\t\n\t\t    function getWatchListener(watcher, field, index) {\n\t\t      var watchListener = watcher.listener;\n\t\t      if (_angularFix2['default'].isFunction(watchListener)) {\n\t\t        (function () {\n\t\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalListener = watchListener;\n\t\t          watchListener = function formlyWatchListener() {\n\t\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t            return originalListener.apply(undefined, _toConsumableArray(args));\n\t\t          };\n\t\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchListener;\n\t\t    }\n\t\n\t\t    function modifyArgs(watcher, index) {\n\t\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\t        originalArgs[_key - 2] = arguments[_key];\n\t\t      }\n\t\n\t\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t\t    }\n\t\n\t\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t\t    }\n\t\n\t\t    function getFormlyFieldLikeLocals(field, index) {\n\t\t      // this makes it closer to what a regular formlyExpression would be\n\t\t      return {\n\t\t        options: field,\n\t\t        index: index,\n\t\t        formState: $scope.options.formState,\n\t\t        formId: $scope.formId\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function formlyFormLink(scope, el, attrs) {\n\t\t    setFormController();\n\t\t    fixChromeAutocomplete();\n\t\n\t\t    function setFormController() {\n\t\t      var formId = attrs.name;\n\t\t      scope.formId = formId;\n\t\t      scope.theFormlyForm = scope[formId];\n\t\t      if (attrs.form) {\n\t\t        var getter = $parse(attrs.form);\n\t\t        var setter = getter.assign;\n\t\t        var parentForm = getter(scope.$parent);\n\t\t        if (parentForm) {\n\t\t          scope.theFormlyForm = parentForm;\n\t\t          if (scope[formId]) {\n\t\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t\t          }\n\t\n\t\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t\t          // to children forms :-( This line was added to solve this issue:\n\t\t          // https://github.com/formly-js/angular-formly/issues/287\n\t\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t\t          // so I expect it will remain this way for the life of angular 1.x\n\t\t          el.removeData('$formController');\n\t\t        } else {\n\t\t          setter(scope.$parent, scope[formId]);\n\t\t        }\n\t\t      }\n\t\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t\t        /* eslint no-console:0 */\n\t\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t\t      }\n\t\t    }\n\t\n\t\t    /*\n\t\t     * chrome autocomplete lameness\n\t\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t\t     * ()   ()     ()\n\t\t     */\n\t\t    function fixChromeAutocomplete() {\n\t\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t\t      if (global && !offInstance || onInstance) {\n\t\t        var input = document.createElement('input');\n\t\t        input.setAttribute('autocomplete', 'address-level4');\n\t\t        input.setAttribute('hidden', 'true');\n\t\t        el[0].appendChild(input);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  // stateless util functions\n\t\t  function toKebabCase(string) {\n\t\t    if (string) {\n\t\t      return string.replace(/([A-Z])/g, function ($1) {\n\t\t        return '-' + $1.toLowerCase();\n\t\t      });\n\t\t    } else {\n\t\t      return '';\n\t\t    }\n\t\t  }\n\t\n\t\t  function isFieldGroup(field) {\n\t\t    return field && !!field.fieldGroup;\n\t\t  }\n\t\t}\n\t\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\texports['default'] = addFormlyNgModelAttrsManipulator;\n\t\n\t\t// @ngInject\n\t\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t\t    return;\n\t\t  }\n\t\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\t\n\t\t  function ngModelAttrsManipulator(template, options, scope) {\n\t\t    var node = document.createElement('div');\n\t\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t\t    if (skip === true) {\n\t\t      return template;\n\t\t    }\n\t\t    node.innerHTML = template;\n\t\n\t\t    var modelNodes = getNgModelNodes(node, skip);\n\t\t    if (!modelNodes || !modelNodes.length) {\n\t\t      return template;\n\t\t    }\n\t\n\t\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\t\n\t\t    addValidation();\n\t\t    alterNgModelAttr();\n\t\t    addModelOptions();\n\t\t    addTemplateOptionsAttrs();\n\t\t    addNgModelElAttrs();\n\t\n\t\t    return node.innerHTML;\n\t\n\t\t    function addValidation() {\n\t\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t\t      }\n\t\t    }\n\t\n\t\t    function alterNgModelAttr() {\n\t\t      if (isPropertyAccessor(options.key)) {\n\t\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addModelOptions() {\n\t\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t\t        if (options.modelOptions.getterSetter) {\n\t\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function addTemplateOptionsAttrs() {\n\t\t      if (!options.templateOptions && !options.expressionProperties) {\n\t\t        // no need to run these if there are no templateOptions or expressionProperties\n\t\t        return;\n\t\t      }\n\t\t      var to = options.templateOptions || {};\n\t\t      var ep = options.expressionProperties || {};\n\t\n\t\t      var ngModelAttributes = getBuiltInAttributes();\n\t\n\t\t      // extend with the user's specifications winning\n\t\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\t\n\t\t      // Feel free to make this more simple :-)\n\t\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t\t        /* eslint complexity:[2, 14] */\n\t\t        var attrVal = undefined,\n\t\t            attrName = undefined;\n\t\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t\t        var toVal = to[name];\n\t\t        var epVal = getEpValue(ep, name);\n\t\n\t\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t\t        if (val.value) {\n\t\t          // I realize this looks backwards, but it's right, trust me...\n\t\t          attrName = val.value;\n\t\t          attrVal = name;\n\t\t        } else if (val.statement && inTo) {\n\t\t          attrName = val.statement;\n\t\t          if (_angularFix2['default'].isString(to[name])) {\n\t\t            attrVal = '$eval(' + ref + ')';\n\t\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t\t          } else {\n\t\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t\t          }\n\t\t        } else if (val.bound && inEp) {\n\t\t          attrName = val.bound;\n\t\t          attrVal = ref;\n\t\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t\t          attrName = val.attribute || val.boolean;\n\t\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t\t        } else if (val.attribute && inTo) {\n\t\t          attrName = val.attribute;\n\t\t          attrVal = toVal;\n\t\t        } else if (val.boolean) {\n\t\t          if (inTo && !inEp && toVal) {\n\t\t            attrName = val.boolean;\n\t\t            attrVal = true;\n\t\t          } else {\n\t\t            /* eslint no-empty:0 */\n\t\t            // empty to illustrate that a boolean will not be added via val.bound\n\t\t            // if you want it added via val.bound, then put it in expressionProperties\n\t\t          }\n\t\t        } else if (val.bound && inTo) {\n\t\t            attrName = val.bound;\n\t\t            attrVal = ref;\n\t\t          }\n\t\n\t\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function addNgModelElAttrs() {\n\t\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t\t        addRegardlessOfPresence(modelNodes, name, val);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  // Utility functions\n\t\t  function getNgModelNodes(node, skip) {\n\t\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t\t    try {\n\t\t      return node.querySelectorAll(query);\n\t\t    } catch (e) {\n\t\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t\t      //it should be removed when IE8 support is dropped\n\t\t      return getNgModelNodesFallback(node, skip);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getNgModelNodesFallback(node, skip) {\n\t\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t\t    var matchingNgModelNodes = [];\n\t\n\t\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t\t    matchingNgModelNodes.item = function (i) {\n\t\t      return this[i];\n\t\t    };\n\t\n\t\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t\t      var ngModelNode = allNgModelNodes[i];\n\t\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t\t        matchingNgModelNodes.push(ngModelNode);\n\t\t      }\n\t\t    }\n\t\n\t\t    return matchingNgModelNodes;\n\t\t  }\n\t\n\t\t  function nodeMatches(node, selector) {\n\t\t    var div = document.createElement('div');\n\t\t    div.innerHTML = node.outerHTML;\n\t\t    return div.querySelector(selector);\n\t\t  }\n\t\n\t\t  function getBuiltInAttributes() {\n\t\t    var ngModelAttributes = {\n\t\t      focus: {\n\t\t        attribute: 'formly-focus'\n\t\t      }\n\t\t    };\n\t\t    var boundOnly = [];\n\t\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t\t    var attributeOnly = ['placeholder', 'min', 'max', 'tabindex', 'type'];\n\t\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t\t      bothAttributeAndBound.push('maxlength');\n\t\t    } else {\n\t\t      boundOnly.push('maxlength');\n\t\t    }\n\t\n\t\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item };\n\t\t    });\n\t\t    return ngModelAttributes;\n\t\t  }\n\t\n\t\t  function getEpValue(ep, name) {\n\t\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t\t  }\n\t\n\t\t  function addIfNotPresent(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      if (!node.getAttribute(attr)) {\n\t\t        node.setAttribute(attr, val);\n\t\t      }\n\t\t    });\n\t\t  }\n\t\n\t\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      node.setAttribute(attr, val);\n\t\t    });\n\t\t  }\n\t\n\t\t  function isPropertyAccessor(key) {\n\t\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t\t  }\n\t\t}\n\t\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = addCustomTags;\n\t\n\t\t// @ngInject\n\t\tfunction addCustomTags($document) {\n\t\t  if ($document && $document.get) {\n\t\t    (function () {\n\t\t      // IE8 check ->\n\t\t      // http://stackoverflow.com/questions/10964966/detect-ie-version-prior-to-v9-in-javascript/10965203#10965203\n\t\t      var document = $document.get(0);\n\t\t      var div = document.createElement('div');\n\t\t      div.innerHTML = '<!--[if lt IE 9]><i></i><![endif]-->';\n\t\t      var isIeLessThan9 = div.getElementsByTagName('i').length === 1;\n\t\n\t\t      if (isIeLessThan9) {\n\t\t        // add the custom elements that we need for formly\n\t\t        var customElements = ['formly-field', 'formly-form', 'formly-custom-validation', 'formly-focus', 'formly-transpose'];\n\t\t        _angularFix2['default'].forEach(customElements, function (el) {\n\t\t          document.createElement(el);\n\t\t        });\n\t\t      }\n\t\t    })();\n\t\t  }\n\t\t}\n\t\taddCustomTags.$inject = [\"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 5 */,\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! angular-formly-templates-bootstrap version 6.1.5 built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> ( _)==(_ )\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(2), __webpack_require__(4), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar ngModuleName = 'formlyBootstrap';\n\t\tvar angular = __webpack_require__(2);\n\t\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\t\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t\t  output: {\n\t\t    prefix: 'angular-formly-bootstrap'\n\t\t  }\n\t\t}));\n\t\tngModule.constant('formlyBootstrapVersion', (\"6.1.5\"));\n\t\n\t\t__webpack_require__(6)(ngModule);\n\t\t__webpack_require__(9)(ngModule);\n\t\t__webpack_require__(19)(ngModule);\n\t\n\t\texports['default'] = ngModuleName;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tvar angular = __webpack_require__(3);\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\tmodule.exports = angular;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addWrappers);\n\t\n\t\t  function addWrappers(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setWrapper([{\n\t\t      name: 'bootstrapLabel',\n\t\t      template: __webpack_require__(7),\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string,\n\t\t            required: check.bool.optional,\n\t\t            labelSrOnly: check.bool.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t\t  }\n\t\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  __webpack_require__(10)(ngModule);\n\t\t  __webpack_require__(12)(ngModule);\n\t\t  __webpack_require__(14)(ngModule);\n\t\t  __webpack_require__(15)(ngModule);\n\t\t  __webpack_require__(17)(ngModule);\n\t\t  __webpack_require__(18)(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'checkbox',\n\t\t      template: __webpack_require__(11),\n\t\t      wrapper: ['bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'multiCheckbox',\n\t\t      template: __webpack_require__(13),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      },\n\t\t      defaultOptions: {\n\t\t        noFormControl: false,\n\t\t        ngModelAttrs: {\n\t\t          required: {\n\t\t            attribute: '',\n\t\t            bound: ''\n\t\t          }\n\t\t        }\n\t\t      },\n\t\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t\t        var to = $scope.to;\n\t\t        var opts = $scope.options;\n\t\t        $scope.multiCheckbox = {\n\t\t          checked: [],\n\t\t          change: setModel\n\t\t        };\n\t\n\t\t        // initialize the checkboxes check property\n\t\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t\t          var modelValue, valueProp;\n\t\n\t\t          if (Object.keys(newModelValue).length) {\n\t\t            modelValue = newModelValue[opts.key];\n\t\n\t\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t\t                valueProp = to.valueProp || 'value';\n\t\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t\t                }\n\t\t              }\n\t\t            });\n\t\t          }\n\t\t        }, true);\n\t\n\t\t        function checkValidity(expressionValue) {\n\t\t          var valid;\n\t\n\t\t          if ($scope.to.required) {\n\t\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\t\n\t\t            $scope.fc.$setValidity('required', valid);\n\t\t          }\n\t\t        }\n\t\n\t\t        function setModel() {\n\t\t          $scope.model[opts.key] = [];\n\t\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t\t            if (checkbox) {\n\t\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t\t            }\n\t\t          });\n\t\n\t\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t\t          $scope.fc.$setTouched();\n\t\t          checkValidity(true);\n\t\t        }\n\t\n\t\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t\t          $scope.$watch(function () {\n\t\t            return $scope.to.required;\n\t\t          }, function (newValue) {\n\t\t            checkValidity(newValue);\n\t\t          });\n\t\t        }\n\t\n\t\t        if ($scope.to.required) {\n\t\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t\t            if (!newValue) {\n\t\t              return;\n\t\t            }\n\t\t            checkValidity(true);\n\t\t            unwatchFormControl();\n\t\t          });\n\t\t        }\n\t\t      }]\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addInputType);\n\t\n\t\t  function addInputType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'input',\n\t\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t\t    });\n\t\t  }\n\t\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addRadioType);\n\t\n\t\t  function addRadioType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'radio',\n\t\t      template: __webpack_require__(16),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        noFormControl: false\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addSelectType);\n\t\n\t\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\t\n\t\t  function addSelectType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'select',\n\t\t      template: template,\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: function defaultOptions(options) {\n\t\t        /* jshint maxlen:195 */\n\t\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t\t        return {\n\t\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t\t          })\n\t\t        };\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            optionsAttr: check.string.optional,\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional,\n\t\t            groupProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addTextareaType);\n\t\n\t\t  function addTextareaType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'textarea',\n\t\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        ngModelAttrs: {\n\t\t          rows: { attribute: 'rows' },\n\t\t          cols: { attribute: 'cols' }\n\t\t        }\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            rows: check.number.optional,\n\t\t            cols: check.number.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 19 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _addons = __webpack_require__(20);\n\t\n\t\tvar _addons2 = _interopRequireDefault(_addons);\n\t\n\t\tvar _description = __webpack_require__(22);\n\t\n\t\tvar _description2 = _interopRequireDefault(_description);\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  (0, _addons2['default'])(ngModule);\n\t\t  (0, _description2['default'])(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 20 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addAddonsManipulator);\n\t\n\t\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t\t    var addonTemplate = __webpack_require__(21);\n\t\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t\t      'class': formlyBootstrapApiCheck.string.optional,\n\t\t      text: formlyBootstrapApiCheck.string.optional,\n\t\t      onClick: formlyBootstrapApiCheck.func.optional\n\t\t    }).strict.optional;\n\t\t    var api = formlyBootstrapApiCheck.shape({\n\t\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t\t        addonLeft: addonChecker,\n\t\t        addonRight: addonChecker\n\t\t      })\n\t\t    });\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t\t        return template;\n\t\t      }\n\t\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t\t    });\n\t\t  }\n\t\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 21 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 22 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addDescriptionManipulator);\n\t\n\t\t  function addDescriptionManipulator(formlyConfig) {\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t\t      if (angular.isDefined(options.templateOptions.description)) {\n\t\t        var el = document.createElement('div');\n\t\t        el.appendChild(angular.element(template)[0]);\n\t\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t\t        if (modelEls) {\n\t\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t\t        }\n\t\t        return el.innerHTML;\n\t\t      } else {\n\t\t        return template;\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * angular-permission\n\t * Route permission and access control as simple as it can get\n\t * @version v0.3.1 - 2015-07-07\n\t * @link http://www.rafaelvidaurre.com\n\t * @author Rafael Vidaurre <narzerus@gmail.com>\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular.module('permission', ['ui.router'])\n\t    .run(['$rootScope', 'Permission', '$state', '$q',\n\t    function ($rootScope, Permission, $state, $q) {\n\t      $rootScope.$on('$stateChangeStart',\n\t      function (event, toState, toParams, fromState, fromParams) {\n\t        if (toState.$$finishAuthorize) {\n\t          return;\n\t        }\n\t\n\t        // If there are permissions set then prevent default and attempt to authorize\n\t        var permissions;\n\t        if (toState.data && toState.data.permissions) {\n\t          permissions = toState.data.permissions;\n\t        } else if (toState.permissions) {\n\t          /**\n\t          * This way of defining permissions will be depracated in v1. Should use\n\t          * `data` key instead\n\t          */\n\t          console.log('Deprecation Warning: permissions should be set inside the `data` key ');\n\t          console.log('Setting permissions for a state outside `data` will be depracated in' +\n\t            ' version 1');\n\t          permissions = toState.permissions;\n\t        }\n\t\n\t        if (permissions) {\n\t          event.preventDefault();\n\t          toState = angular.extend({'$$finishAuthorize': true}, toState);\n\t\n\t          if ($rootScope.$broadcast('$stateChangePermissionStart', toState, toParams).defaultPrevented) {\n\t            return;\n\t          }\n\t\n\t          Permission.authorize(permissions, toParams).then(function () {\n\t            // If authorized, use call state.go without triggering the event.\n\t            // Then trigger $stateChangeSuccess manually to resume the rest of the process\n\t            // Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n\t            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n\t              $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams);\n\t\n\t              $state.go(toState.name, toParams, {notify: false}).then(function() {\n\t                $rootScope\n\t                  .$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams);\n\t              });\n\t            }\n\t          }, function () {\n\t            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n\t              $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams);\n\t\n\t              var redirectTo = permissions.redirectTo;\n\t              var result;\n\t\n\t              if (angular.isFunction(redirectTo)) {\n\t                redirectTo = redirectTo();\n\t\n\t                $q.when(redirectTo).then(function (newState) {\n\t                  if (newState) {\n\t                    $state.go(newState, toParams);\n\t                  }\n\t                });\n\t\n\t              } else {\n\t                if (redirectTo) {\n\t                  $state.go(redirectTo, toParams);\n\t                }\n\t              }\n\t            }\n\t          });\n\t        }\n\t      });\n\t    }]);\n\t}());\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular.module('permission')\n\t    .provider('Permission', function () {\n\t      var roleValidationConfig = {};\n\t      var validateRoleDefinitionParams = function (roleName, validationFunction) {\n\t        if (!angular.isString(roleName)) {\n\t          throw new Error('Role name must be a string');\n\t        }\n\t        if (!angular.isFunction(validationFunction)) {\n\t          throw new Error('Validation function not provided correctly');\n\t        }\n\t      };\n\t\n\t      var validateManyRolesDefinitionParams = function(roles, validationFunction) {\n\t        if (!angular.isArray(roles)) {\n\t          throw new Error('Roles must be an array');\n\t        } else {\n\t          for(var i = 0; i < roles.length; i++) {\n\t            validateRoleDefinitionParams(roles[i], validationFunction);\n\t          }\n\t        }\n\t      };\n\t\n\t      this.defineRole = function (roleName, validationFunction) {\n\t        /**\n\t          This method is only available in config-time, and cannot access services, as they are\n\t          not yet injected anywere which makes this kinda useless.\n\t          Should remove if we cannot find a use for it.\n\t        **/\n\t        validateRoleDefinitionParams(roleName, validationFunction);\n\t        roleValidationConfig[roleName] = validationFunction;\n\t\n\t        return this;\n\t      };\n\t\n\t      this.$get = ['$q', function ($q) {\n\t        var Permission = {\n\t          _promiseify: function (value) {\n\t            /**\n\t              Converts a value into a promise, if the value is truthy it resolves it, otherwise\n\t              it rejects it\n\t            **/\n\t            if (value && angular.isFunction(value.then)) {\n\t              return value;\n\t            }\n\t\n\t            var deferred = $q.defer();\n\t            if (value) {\n\t              deferred.resolve();\n\t            } else {\n\t              deferred.reject();\n\t            }\n\t            return deferred.promise;\n\t          },\n\t          _validateRoleMap: function (roleMap) {\n\t            if (typeof(roleMap) !== 'object' || roleMap instanceof Array) {\n\t              throw new Error('Role map has to be an object');\n\t            }\n\t            if (roleMap.only === undefined && roleMap.except === undefined) {\n\t              throw new Error('Either \"only\" or \"except\" keys must me defined');\n\t            }\n\t            if (roleMap.only) {\n\t              if (!(roleMap.only instanceof Array)) {\n\t                throw new Error('Array of roles expected');\n\t              }\n\t            } else if (roleMap.except) {\n\t              if (!(roleMap.except instanceof Array)) {\n\t                throw new Error('Array of roles expected');\n\t              }\n\t            }\n\t          },\n\t          _findMatchingRole: function (rolesArray, toParams) {\n\t            var roles = angular.copy(rolesArray);\n\t            var deferred = $q.defer();\n\t            var currentRole = roles.shift();\n\t\n\t            // If no roles left to validate reject promise\n\t            if (!currentRole) {\n\t              deferred.reject();\n\t              return deferred.promise;\n\t            }\n\t            // Validate role definition exists\n\t            if (!angular.isFunction(Permission.roleValidations[currentRole])) {\n\t              throw new Error('undefined role or invalid role validation');\n\t            }\n\t\n\t            var validatingRole = Permission.roleValidations[currentRole](toParams, currentRole);\n\t            validatingRole = Permission._promiseify(validatingRole);\n\t\n\t            validatingRole.then(function () {\n\t              deferred.resolve();\n\t            }, function () {\n\t              Permission._findMatchingRole(roles, toParams).then(function () {\n\t                deferred.resolve();\n\t              }, function () {\n\t                deferred.reject();\n\t              });\n\t            });\n\t\n\t            return deferred.promise;\n\t          },\n\t          defineRole: function (roleName, validationFunction) {\n\t            /**\n\t              Service-available version of defineRole, the callback passed here lives in the\n\t              scope where it is defined and therefore can interact with other modules\n\t            **/\n\t            validateRoleDefinitionParams(roleName, validationFunction);\n\t            roleValidationConfig[roleName] = validationFunction;\n\t\n\t            return Permission;\n\t          },\n\t          defineManyRoles: function(roles, validationFunction) {\n\t            validateManyRolesDefinitionParams(roles, validationFunction);\n\t\n\t            var definedPermissions = Permission;\n\t            for(var i = 0; i < roles.length; i++) {\n\t               definedPermissions = definedPermissions.defineRole(roles[i], validationFunction);\n\t            }\n\t\n\t            return definedPermissions;\n\t          },\n\t          resolveIfMatch: function (rolesArray, toParams) {\n\t            var roles = angular.copy(rolesArray);\n\t            var deferred = $q.defer();\n\t            Permission._findMatchingRole(roles, toParams).then(function () {\n\t              // Found role match\n\t              deferred.resolve();\n\t            }, function () {\n\t              // No match\n\t              deferred.reject();\n\t            });\n\t            return deferred.promise;\n\t          },\n\t          rejectIfMatch: function (roles, toParams) {\n\t            var deferred = $q.defer();\n\t            Permission._findMatchingRole(roles, toParams).then(function () {\n\t              // Role found\n\t              deferred.reject();\n\t            }, function () {\n\t              // Role not found\n\t              deferred.resolve();\n\t            });\n\t            return deferred.promise;\n\t          },\n\t          roleValidations: roleValidationConfig,\n\t          authorize: function (roleMap, toParams) {\n\t            // Validate input\n\t            Permission._validateRoleMap(roleMap);\n\t\n\t            var authorizing;\n\t\n\t            if (roleMap.only) {\n\t              authorizing = Permission.resolveIfMatch(roleMap.only, toParams);\n\t            } else {\n\t              authorizing = Permission.rejectIfMatch(roleMap.except, toParams);\n\t            }\n\t\n\t            return authorizing;\n\t          }\n\t        };\n\t\n\t        return Permission;\n\t      }];\n\t    });\n\t\n\t}());\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15);\n\tmodule.exports = 'ui.bootstrap';\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n\t * @author Mark Lagendijk <mark@lagendijk.info>\r\n\t * @license MIT\r\n\t */\r\n\tangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n\t    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n\t        var self = this;\r\n\t\r\n\t        /**\r\n\t         * Recursively sets the states using $stateProvider.state.\r\n\t         * Child states are defined via a `children` property.\r\n\t         *\r\n\t         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n\t         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n\t         * 3. Sets `parent` property of the descendant states.\r\n\t         *\r\n\t         * @param {Object} state - A regular ui.router state object.\r\n\t         * @param {Array} [state.children] - An optional array of child states.\r\n\t         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n\t         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n\t         * @param {Object} [options] - An optional options object.\r\n\t         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n\t         *     prevents conversion of names to dot notation if true.\r\n\t         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n\t         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n\t         */\r\n\t        this.state = function(state){\r\n\t            var args = Array.prototype.slice.apply(arguments);\r\n\t            var options = {\r\n\t                keepOriginalNames: false,\r\n\t                siblingTraversal: false\r\n\t            };  \r\n\t\r\n\t            if (typeof args[1] === 'boolean') {\r\n\t                options.keepOriginalNames = args[1];\r\n\t            } \r\n\t            else if (typeof args[1] === 'object') {\r\n\t                angular.extend(options, args[1]);\r\n\t            }\r\n\t\r\n\t            if (!options.keepOriginalNames) {\r\n\t                fixStateName(state);\r\n\t            }\r\n\t\r\n\t            $stateProvider.state(state);\r\n\t\r\n\t            if(state.children && state.children.length){\r\n\t                state.children.forEach(function(childState){\r\n\t                    childState.parent = state;\r\n\t                    self.state(childState, options);\r\n\t                });\r\n\t\r\n\t                if (options.siblingTraversal) {\r\n\t                    addSiblings(state);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return self;\r\n\t        };\r\n\t\r\n\t        this.setNestedState = this.state;\r\n\t\r\n\t        self.$get = angular.noop;\r\n\t\r\n\t        /**\r\n\t         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n\t         * @param state\r\n\t         */\r\n\t        function fixStateName(state){\r\n\t            if(state.parent){\r\n\t                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        function addSiblings(state) {\r\n\t            state.children.forEach(function (childState, idx, array) {\r\n\t                if (array[idx + 1]) {\r\n\t                    childState.nextSibling = array[idx + 1].name;\r\n\t                }\r\n\t                if (array[idx - 1]) {\r\n\t                    childState.previousSibling = array[idx - 1].name;\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t    }]);\r\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * State-based routing for AngularJS\n\t * @version v0.2.15\n\t * @link http://angular-ui.github.com/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n\t  module.exports = 'ui.router';\n\t}\n\t\n\t(function (window, angular, undefined) {\n\t/*jshint globalstrict:true*/\n\t/*global angular:false*/\n\t'use strict';\n\t\n\tvar isDefined = angular.isDefined,\n\t    isFunction = angular.isFunction,\n\t    isString = angular.isString,\n\t    isObject = angular.isObject,\n\t    isArray = angular.isArray,\n\t    forEach = angular.forEach,\n\t    extend = angular.extend,\n\t    copy = angular.copy;\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n\t}\n\t\n\tfunction merge(dst) {\n\t  forEach(arguments, function(obj) {\n\t    if (obj !== dst) {\n\t      forEach(obj, function(value, key) {\n\t        if (!dst.hasOwnProperty(key)) dst[key] = value;\n\t      });\n\t    }\n\t  });\n\t  return dst;\n\t}\n\t\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Object.keys()`.\n\t *\n\t * @param {Object} object A JavaScript object.\n\t * @return {Array} Returns the keys of the object as an array.\n\t */\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  forEach(object, function(val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Array.prototype.indexOf()`.\n\t *\n\t * @param {Array} array A JavaScript array.\n\t * @param {*} value A value to search the array for.\n\t * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n\t */\n\tfunction indexOf(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Merges a set of parameters with all parameters inherited between the common parents of the\n\t * current state and a given destination state.\n\t *\n\t * @param {Object} currentParams The value of the current state parameters ($stateParams).\n\t * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t * @param {Object} $current Internal definition of object representing the current state.\n\t * @param {Object} $to Internal definition of object representing state to transition to.\n\t */\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i].params) continue;\n\t    parentParams = objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t  if (!keys) {\n\t    keys = [];\n\t    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t  }\n\t\n\t  for (var i=0; i<keys.length; i++) {\n\t    var k = keys[i];\n\t    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Returns the subset of an object, based on a list of keys.\n\t *\n\t * @param {Array} keys\n\t * @param {Object} values\n\t * @return {Boolean} Returns a subset of `values`.\n\t */\n\tfunction filterByKeys(keys, values) {\n\t  var filtered = {};\n\t\n\t  forEach(keys, function (name) {\n\t    filtered[name] = values[name];\n\t  });\n\t  return filtered;\n\t}\n\t\n\t// like _.indexBy\n\t// when you know that your index values will be unique, or you want last-one-in to win\n\tfunction indexBy(array, propName) {\n\t  var result = {};\n\t  forEach(array, function(item) {\n\t    result[item[propName]] = item;\n\t  });\n\t  return result;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object only containing the whitelisted properties.\n\tfunction pick(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  forEach(keys, function(key) {\n\t    if (key in obj) copy[key] = obj[key];\n\t  });\n\t  return copy;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object omitting the blacklisted properties.\n\tfunction omit(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  for (var key in obj) {\n\t    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n\t  }\n\t  return copy;\n\t}\n\t\n\tfunction pluck(collection, key) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = isFunction(key) ? key(val) : val[key];\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction filter(collection, callback) {\n\t  var array = isArray(collection);\n\t  var result = array ? [] : {};\n\t  forEach(collection, function(val, i) {\n\t    if (callback(val, i)) {\n\t      result[array ? result.length : i] = val;\n\t    }\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction map(collection, callback) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = callback(val, i);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t * \n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t * \n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t * \n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t * \n\t * ## The main module for ui.router \n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes. \n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router - \n\t * \n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t * \n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.state']);\n\t\n\tangular.module('ui.router.compat', ['ui.router']);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$resolve\n\t *\n\t * @requires $q\n\t * @requires $injector\n\t *\n\t * @description\n\t * Manages resolution of (acyclic) graphs of promises.\n\t */\n\t$Resolve.$inject = ['$q', '$injector'];\n\tfunction $Resolve(  $q,    $injector) {\n\t  \n\t  var VISIT_IN_PROGRESS = 1,\n\t      VISIT_DONE = 2,\n\t      NOTHING = {},\n\t      NO_DEPENDENCIES = [],\n\t      NO_LOCALS = NOTHING,\n\t      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\t  \n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#study\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Studies a set of invocables that are likely to be used multiple times.\n\t   * <pre>\n\t   * $resolve.study(invocables)(locals, parent, self)\n\t   * </pre>\n\t   * is equivalent to\n\t   * <pre>\n\t   * $resolve.resolve(invocables, locals, parent, self)\n\t   * </pre>\n\t   * but the former is more efficient (in fact `resolve` just calls `study` \n\t   * internally).\n\t   *\n\t   * @param {object} invocables Invocable objects\n\t   * @return {function} a function to pass in locals, parent and self\n\t   */\n\t  this.study = function (invocables) {\n\t    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\t    var invocableKeys = objectKeys(invocables || {});\n\t    \n\t    // Perform a topological sort of invocables to build an ordered plan\n\t    var plan = [], cycle = [], visited = {};\n\t    function visit(value, key) {\n\t      if (visited[key] === VISIT_DONE) return;\n\t      \n\t      cycle.push(key);\n\t      if (visited[key] === VISIT_IN_PROGRESS) {\n\t        cycle.splice(0, indexOf(cycle, key));\n\t        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n\t      }\n\t      visited[key] = VISIT_IN_PROGRESS;\n\t      \n\t      if (isString(value)) {\n\t        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n\t      } else {\n\t        var params = $injector.annotate(value);\n\t        forEach(params, function (param) {\n\t          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n\t        });\n\t        plan.push(key, value, params);\n\t      }\n\t      \n\t      cycle.pop();\n\t      visited[key] = VISIT_DONE;\n\t    }\n\t    forEach(invocables, visit);\n\t    invocables = cycle = visited = null; // plan is all that's required\n\t    \n\t    function isResolve(value) {\n\t      return isObject(value) && value.then && value.$$promises;\n\t    }\n\t    \n\t    return function (locals, parent, self) {\n\t      if (isResolve(locals) && self === undefined) {\n\t        self = parent; parent = locals; locals = null;\n\t      }\n\t      if (!locals) locals = NO_LOCALS;\n\t      else if (!isObject(locals)) {\n\t        throw new Error(\"'locals' must be an object\");\n\t      }       \n\t      if (!parent) parent = NO_PARENT;\n\t      else if (!isResolve(parent)) {\n\t        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n\t      }\n\t      \n\t      // To complete the overall resolution, we have to wait for the parent\n\t      // promise and for the promise for each invokable in our plan.\n\t      var resolution = $q.defer(),\n\t          result = resolution.promise,\n\t          promises = result.$$promises = {},\n\t          values = extend({}, locals),\n\t          wait = 1 + plan.length/3,\n\t          merged = false;\n\t          \n\t      function done() {\n\t        // Merge parent values we haven't got yet and publish our own $$values\n\t        if (!--wait) {\n\t          if (!merged) merge(values, parent.$$values); \n\t          result.$$values = values;\n\t          result.$$promises = result.$$promises || true; // keep for isResolve()\n\t          delete result.$$inheritedValues;\n\t          resolution.resolve(values);\n\t        }\n\t      }\n\t      \n\t      function fail(reason) {\n\t        result.$$failure = reason;\n\t        resolution.reject(reason);\n\t      }\n\t\n\t      // Short-circuit if parent has already failed\n\t      if (isDefined(parent.$$failure)) {\n\t        fail(parent.$$failure);\n\t        return result;\n\t      }\n\t      \n\t      if (parent.$$inheritedValues) {\n\t        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n\t      }\n\t\n\t      // Merge parent values if the parent has already resolved, or merge\n\t      // parent promises and wait if the parent resolve is still in progress.\n\t      extend(promises, parent.$$promises);\n\t      if (parent.$$values) {\n\t        merged = merge(values, omit(parent.$$values, invocableKeys));\n\t        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n\t        done();\n\t      } else {\n\t        if (parent.$$inheritedValues) {\n\t          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n\t        }        \n\t        parent.then(done, fail);\n\t      }\n\t      \n\t      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n\t      for (var i=0, ii=plan.length; i<ii; i+=3) {\n\t        if (locals.hasOwnProperty(plan[i])) done();\n\t        else invoke(plan[i], plan[i+1], plan[i+2]);\n\t      }\n\t      \n\t      function invoke(key, invocable, params) {\n\t        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n\t        var invocation = $q.defer(), waitParams = 0;\n\t        function onfailure(reason) {\n\t          invocation.reject(reason);\n\t          fail(reason);\n\t        }\n\t        // Wait for any parameter that we have a promise for (either from parent or from this\n\t        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n\t        forEach(params, function (dep) {\n\t          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n\t            waitParams++;\n\t            promises[dep].then(function (result) {\n\t              values[dep] = result;\n\t              if (!(--waitParams)) proceed();\n\t            }, onfailure);\n\t          }\n\t        });\n\t        if (!waitParams) proceed();\n\t        function proceed() {\n\t          if (isDefined(result.$$failure)) return;\n\t          try {\n\t            invocation.resolve($injector.invoke(invocable, self, values));\n\t            invocation.promise.then(function (result) {\n\t              values[key] = result;\n\t              done();\n\t            }, onfailure);\n\t          } catch (e) {\n\t            onfailure(e);\n\t          }\n\t        }\n\t        // Publish promise synchronously; invocations further down in the plan may depend on it.\n\t        promises[key] = invocation.promise;\n\t      }\n\t      \n\t      return result;\n\t    };\n\t  };\n\t  \n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#resolve\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Resolves a set of invocables. An invocable is a function to be invoked via \n\t   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n\t   * An invocable can either return a value directly,\n\t   * or a `$q` promise. If a promise is returned it will be resolved and the \n\t   * resulting value will be used instead. Dependencies of invocables are resolved \n\t   * (in this order of precedence)\n\t   *\n\t   * - from the specified `locals`\n\t   * - from another invocable that is part of this `$resolve` call\n\t   * - from an invocable that is inherited from a `parent` call to `$resolve` \n\t   *   (or recursively\n\t   * - from any ancestor `$resolve` of that parent).\n\t   *\n\t   * The return value of `$resolve` is a promise for an object that contains \n\t   * (in this order of precedence)\n\t   *\n\t   * - any `locals` (if specified)\n\t   * - the resolved return values of all injectables\n\t   * - any values inherited from a `parent` call to `$resolve` (if specified)\n\t   *\n\t   * The promise will resolve after the `parent` promise (if any) and all promises \n\t   * returned by injectables have been resolved. If any invocable \n\t   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n\t   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n\t   * same error. A rejection of a `parent` promise (if specified) will likewise be \n\t   * propagated immediately. Once the `$resolve` promise has been rejected, no \n\t   * further invocables will be called.\n\t   * \n\t   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n\t   * to throw an error. As a special case, an injectable can depend on a parameter \n\t   * with the same name as the injectable, which will be fulfilled from the `parent` \n\t   * injectable of the same name. This allows inherited values to be decorated. \n\t   * Note that in this case any other injectable in the same `$resolve` with the same\n\t   * dependency would see the decorated value, not the inherited value.\n\t   *\n\t   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n\t   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n\t   * exception.\n\t   *\n\t   * Invocables are invoked eagerly as soon as all dependencies are available. \n\t   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n\t   *\n\t   * As a special case, an invocable can be a string, in which case it is taken to \n\t   * be a service name to be passed to `$injector.get()`. This is supported primarily \n\t   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n\t   * routes.\n\t   *\n\t   * @param {object} invocables functions to invoke or \n\t   * `$injector` services to fetch.\n\t   * @param {object} locals  values to make available to the injectables\n\t   * @param {object} parent  a promise returned by another call to `$resolve`.\n\t   * @param {object} self  the `this` for the invoked methods\n\t   * @return {object} Promise for an object that contains the resolved return value\n\t   * of all invocables, as well as any inherited and local values.\n\t   */\n\t  this.resolve = function (invocables, locals, parent, self) {\n\t    return this.study(invocables)(locals, parent, self);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$resolve', $Resolve);\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$templateFactory\n\t *\n\t * @requires $http\n\t * @requires $templateCache\n\t * @requires $injector\n\t *\n\t * @description\n\t * Service. Manages loading of templates.\n\t */\n\t$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n\tfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromConfig\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a configuration object. \n\t   *\n\t   * @param {object} config Configuration object for which to load a template. \n\t   * The following properties are search in the specified order, and the first one \n\t   * that is defined is used to create the template:\n\t   *\n\t   * @param {string|object} config.template html string template or function to \n\t   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n\t   * @param {string|object} config.templateUrl url to load or a function returning \n\t   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n\t   * @param {Function} config.templateProvider function to invoke via \n\t   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n\t   * @param {object} params  Parameters to pass to the template function.\n\t   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n\t   * via a `templateProvider`. Defaults to `{ params: params }`.\n\t   *\n\t   * @return {string|object}  The template html as a string, or a promise for \n\t   * that string,or `null` if no template is configured.\n\t   */\n\t  this.fromConfig = function (config, params, locals) {\n\t    return (\n\t      isDefined(config.template) ? this.fromString(config.template, params) :\n\t      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n\t      null\n\t    );\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromString\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a string or a function returning a string.\n\t   *\n\t   * @param {string|object} template html template as a string or function that \n\t   * returns an html template as a string.\n\t   * @param {object} params Parameters to pass to the template function.\n\t   *\n\t   * @return {string|object} The template html as a string, or a promise for that \n\t   * string.\n\t   */\n\t  this.fromString = function (template, params) {\n\t    return isFunction(template) ? template(params) : template;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromUrl\n\t   * @methodOf ui.router.util.$templateFactory\n\t   * \n\t   * @description\n\t   * Loads a template from the a URL via `$http` and `$templateCache`.\n\t   *\n\t   * @param {string|Function} url url of the template to load, or a function \n\t   * that returns a url.\n\t   * @param {Object} params Parameters to pass to the url function.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromUrl = function (url, params) {\n\t    if (isFunction(url)) url = url(params);\n\t    if (url == null) return null;\n\t    else return $http\n\t        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n\t        .then(function(response) { return response.data; });\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromProvider\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template by invoking an injectable provider function.\n\t   *\n\t   * @param {Function} provider Function to invoke via `$injector.invoke`\n\t   * @param {Object} params Parameters for the template.\n\t   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n\t   * `{ params: params }`.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromProvider = function (provider, params, locals) {\n\t    return $injector.invoke(provider, null, locals || { params: params });\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\t\n\tvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t *\n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon\n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash:\n\t * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n\t *   an existing UrlMatcher\n\t *\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} source  The pattern that was passed into the constructor\n\t *\n\t * @property {string} sourcePath  The path portion of the source property\n\t *\n\t * @property {string} sourceSearch  The search portion of the source property\n\t *\n\t * @property {string} regex  The constructed regex that will be used to match against the url when\n\t *   it is time to determine which url will match.\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tfunction UrlMatcher(pattern, config, parentMatcher) {\n\t  config = extend({ params: {} }, isObject(config) ? config : {});\n\t\n\t  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t  //   '*' name\n\t  //   ':' name\n\t  //   '{' name '}'\n\t  //   '{' name ':' regexp '}'\n\t  // The regular expression is somewhat complicated due to the need to allow curly braces\n\t  // inside the regular expression. The placeholder regexp breaks down as follows:\n\t  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t  //    \\{([\\w\\[\\]]+)(?:\\:( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t  //    \\\\.                            - a backslash escape\n\t  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      searchPlaceholder = /([:]?)([\\w\\[\\]-]+)|\\{([\\w\\[\\]-]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      compiled = '^', last = 0, m,\n\t      segments = this.segments = [],\n\t      parentParams = parentMatcher ? parentMatcher.params : {},\n\t      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n\t      paramNames = [];\n\t\n\t  function addParameter(id, type, config, location) {\n\t    paramNames.push(id);\n\t    if (parentParams[id]) return parentParams[id];\n\t    if (!/^\\w+(-+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    params[id] = new $$UMFP.Param(id, type, config, location);\n\t    return params[id];\n\t  }\n\t\n\t  function quoteRegExp(string, pattern, squash, optional) {\n\t    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!pattern) return result;\n\t    switch(squash) {\n\t      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n\t      case true:  surroundPattern = ['?(', ')?']; break;\n\t      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n\t    }\n\t    return result + surroundPattern[0] + pattern + surroundPattern[1];\n\t  }\n\t\n\t  this.source = pattern;\n\t\n\t  // Split into static segments separated by path parameter placeholders.\n\t  // The number of segments is always 1 more than the number of parameters.\n\t  function matchDetails(m, isSearch) {\n\t    var id, regexp, segment, type, cfg, arrayMode;\n\t    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n\t    cfg         = config.params[id];\n\t    segment     = pattern.substring(last, m.index);\n\t    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\t    type        = $$UMFP.type(regexp || \"string\") || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n\t    return {\n\t      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n\t    };\n\t  }\n\t\n\t  var p, param, segment;\n\t  while ((m = placeholder.exec(pattern))) {\n\t    p = matchDetails(m, false);\n\t    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\t\n\t    param = addParameter(p.id, p.type, p.cfg, \"path\");\n\t    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n\t    segments.push(p.segment);\n\t    last = placeholder.lastIndex;\n\t  }\n\t  segment = pattern.substring(last);\n\t\n\t  // Find any search parameter names and remove them from the last segment\n\t  var i = segment.indexOf('?');\n\t\n\t  if (i >= 0) {\n\t    var search = this.sourceSearch = segment.substring(i);\n\t    segment = segment.substring(0, i);\n\t    this.sourcePath = pattern.substring(0, last + i);\n\t\n\t    if (search.length > 0) {\n\t      last = 0;\n\t      while ((m = searchPlaceholder.exec(search))) {\n\t        p = matchDetails(m, true);\n\t        param = addParameter(p.id, p.type, p.cfg, \"search\");\n\t        last = placeholder.lastIndex;\n\t        // check if ?&\n\t      }\n\t    }\n\t  } else {\n\t    this.sourcePath = pattern;\n\t    this.sourceSearch = '';\n\t  }\n\t\n\t  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n\t  segments.push(segment);\n\t\n\t  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n\t  this.prefix = segments[0];\n\t  this.$$paramNames = paramNames;\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#concat\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns a new matcher for a pattern constructed by appending the path part and adding the\n\t * search parameters of the specified pattern to this pattern. The current pattern is not\n\t * modified. This can be understood as creating a pattern for URLs that are relative to (or\n\t * suffixes of) the current pattern.\n\t *\n\t * @example\n\t * The following two matchers are equivalent:\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').concat('/details?date');\n\t * new UrlMatcher('/user/{id}/details?q&date');\n\t * </pre>\n\t *\n\t * @param {string} pattern  The pattern to append.\n\t * @param {Object} config  An object hash of the configuration for the matcher.\n\t * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n\t */\n\tUrlMatcher.prototype.concat = function (pattern, config) {\n\t  // Because order of search parameters is irrelevant, we can add our own search\n\t  // parameters to the end of the new pattern. Parse the new pattern by itself\n\t  // and then join the bits together, but it's much easier to do this on a string level.\n\t  var defaultConfig = {\n\t    caseInsensitive: $$UMFP.caseInsensitive(),\n\t    strict: $$UMFP.strictMode(),\n\t    squash: $$UMFP.defaultSquashPolicy()\n\t  };\n\t  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n\t};\n\t\n\tUrlMatcher.prototype.toString = function () {\n\t  return this.source;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#exec\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Tests the specified path against this matcher, and returns an object containing the captured\n\t * parameter values, or null if the path does not match. The returned object contains the values\n\t * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t * they are not present in `searchParams`. This means that search parameters are always treated\n\t * as optional.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t *   x: '1', q: 'hello'\n\t * });\n\t * // returns { id: 'bob', q: 'hello', r: null }\n\t * </pre>\n\t *\n\t * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n\t * @returns {Object}  The captured parameter values.\n\t */\n\tUrlMatcher.prototype.exec = function (path, searchParams) {\n\t  var m = this.regexp.exec(path);\n\t  if (!m) return null;\n\t  searchParams = searchParams || {};\n\t\n\t  var paramNames = this.parameters(), nTotal = paramNames.length,\n\t    nPath = this.segments.length - 1,\n\t    values = {}, i, j, cfg, paramName;\n\t\n\t  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\t\n\t  function decodePathArray(string) {\n\t    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n\t    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\t\n\t    var split = reverseString(string).split(/-(?!\\\\)/);\n\t    var allReversed = map(split, reverseString);\n\t    return map(allReversed, unquoteDashes).reverse();\n\t  }\n\t\n\t  for (i = 0; i < nPath; i++) {\n\t    paramName = paramNames[i];\n\t    var param = this.params[paramName];\n\t    var paramVal = m[i+1];\n\t    // if the param value matches a pre-replace pair, replace the value before decoding.\n\t    for (j = 0; j < param.replace; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t  for (/**/; i < nTotal; i++) {\n\t    paramName = paramNames[i];\n\t    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n\t  }\n\t\n\t  return values;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#parameters\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns the names of all path and search parameters of this pattern in an unspecified order.\n\t *\n\t * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n\t *    pattern has no parameters, an empty array is returned.\n\t */\n\tUrlMatcher.prototype.parameters = function (param) {\n\t  if (!isDefined(param)) return this.$$paramNames;\n\t  return this.params[param] || null;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#validate\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Checks an object hash of parameters to validate their correctness according to the parameter\n\t * types of this `UrlMatcher`.\n\t *\n\t * @param {Object} params The object hash of parameters to validate.\n\t * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t */\n\tUrlMatcher.prototype.validates = function (params) {\n\t  return this.params.$$validates(params);\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#format\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Creates a URL that matches this pattern by substituting the specified values\n\t * for the path and search parameters. Null values for path parameters are\n\t * treated as empty strings.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t * // returns '/user/bob?q=yes'\n\t * </pre>\n\t *\n\t * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t * @returns {string}  the formatted URL (path and optionally search part).\n\t */\n\tUrlMatcher.prototype.format = function (values) {\n\t  values = values || {};\n\t  var segments = this.segments, params = this.parameters(), paramset = this.params;\n\t  if (!this.validates(values)) return null;\n\t\n\t  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\t\n\t  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n\t    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t  }\n\t\n\t  for (i = 0; i < nTotal; i++) {\n\t    var isPathParam = i < nPath;\n\t    var name = params[i], param = paramset[name], value = param.value(values[name]);\n\t    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n\t    var squash = isDefaultValue ? param.squash : false;\n\t    var encoded = param.type.encode(value);\n\t\n\t    if (isPathParam) {\n\t      var nextSegment = segments[i + 1];\n\t      if (squash === false) {\n\t        if (encoded != null) {\n\t          if (isArray(encoded)) {\n\t            result += map(encoded, encodeDashes).join(\"-\");\n\t          } else {\n\t            result += encodeURIComponent(encoded);\n\t          }\n\t        }\n\t        result += nextSegment;\n\t      } else if (squash === true) {\n\t        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n\t        result += nextSegment.match(capture)[1];\n\t      } else if (isString(squash)) {\n\t        result += squash + nextSegment;\n\t      }\n\t    } else {\n\t      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n\t      if (!isArray(encoded)) encoded = [ encoded ];\n\t      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n\t      result += (search ? '&' : '?') + (name + '=' + encoded);\n\t      search = true;\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:Type\n\t *\n\t * @description\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n\t * information on registering custom types.\n\t *\n\t * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n\t *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t * @example\n\t * <pre>\n\t * {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t * </pre>\n\t *\n\t * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n\t *           coming from a substring of a URL.\n\t *\n\t * @returns {Object}  Returns a new `Type` object.\n\t */\n\tfunction Type(config) {\n\t  extend(this, config);\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#is\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Detects whether a value is of a particular type. Accepts a native (decoded) value\n\t * and determines whether it matches the current `Type` object.\n\t *\n\t * @param {*} val  The value to check.\n\t * @param {string} key  Optional. If the type check is happening in the context of a specific\n\t *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n\t *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n\t * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n\t */\n\tType.prototype.is = function(val, key) {\n\t  return true;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#encode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n\t * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n\t * only needs to be a representation of `val` that has been coerced to a string.\n\t *\n\t * @param {*} val  The value to encode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n\t */\n\tType.prototype.encode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#decode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Converts a parameter value (from URL string or transition param) to a custom/native value.\n\t *\n\t * @param {string} val  The URL parameter value to decode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {*}  Returns a custom representation of the URL parameter value.\n\t */\n\tType.prototype.decode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#equals\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Determines whether two decoded values are equivalent.\n\t *\n\t * @param {*} a  A value to compare against.\n\t * @param {*} b  A value to compare against.\n\t * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n\t */\n\tType.prototype.equals = function(a, b) {\n\t  return a == b;\n\t};\n\t\n\tType.prototype.$subPattern = function() {\n\t  var sub = this.pattern.toString();\n\t  return sub.substr(1, sub.length - 2);\n\t};\n\t\n\tType.prototype.pattern = /.*/;\n\t\n\tType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\t\n\t/** Given an encoded string, or a decoded object, returns a decoded object */\n\tType.prototype.$normalize = function(val) {\n\t  return this.is(val) ? val : this.decode(val);\n\t};\n\t\n\t/*\n\t * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t * e.g.:\n\t * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t * - url: \"/path?queryParam=1&queryParam=2\n\t * - $stateParams.queryParam will be [1, 2]\n\t * if `mode` is \"auto\", then\n\t * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t */\n\tType.prototype.$asArray = function(mode, isSearch) {\n\t  if (!mode) return this;\n\t  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\t\n\t  function ArrayType(type, mode) {\n\t    function bindTo(type, callbackName) {\n\t      return function() {\n\t        return type[callbackName].apply(type, arguments);\n\t      };\n\t    }\n\t\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t      switch(val.length) {\n\t        case 0: return undefined;\n\t        case 1: return mode === \"auto\" ? val[0] : val;\n\t        default: return val;\n\t      }\n\t    }\n\t    function falsey(val) { return !val; }\n\t\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t      return function handleArray(val) {\n\t        val = arrayWrap(val);\n\t        var result = map(val, callback);\n\t        if (allTruthyMode === true)\n\t          return filter(result, falsey).length === 0;\n\t        return arrayUnwrap(result);\n\t      };\n\t    }\n\t\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t      return function handleArray(val1, val2) {\n\t        var left = arrayWrap(val1), right = arrayWrap(val2);\n\t        if (left.length !== right.length) return false;\n\t        for (var i = 0; i < left.length; i++) {\n\t          if (!callback(left[i], right[i])) return false;\n\t        }\n\t        return true;\n\t      };\n\t    }\n\t\n\t    this.encode = arrayHandler(bindTo(type, 'encode'));\n\t    this.decode = arrayHandler(bindTo(type, 'decode'));\n\t    this.is     = arrayHandler(bindTo(type, 'is'), true);\n\t    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n\t    this.pattern = type.pattern;\n\t    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n\t    this.name = type.name;\n\t    this.$arrayMode = mode;\n\t  }\n\t\n\t  return new ArrayType(this, mode);\n\t};\n\t\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$urlMatcherFactory\n\t *\n\t * @description\n\t * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n\t * is also available to providers under the name `$urlMatcherFactoryProvider`.\n\t */\n\tfunction $UrlMatcherFactory() {\n\t  $$UMFP = this;\n\t\n\t  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\t\n\t  function valToString(val) { return val != null ? val.toString().replace(/\\//g, \"%2F\") : val; }\n\t  function valFromString(val) { return val != null ? val.toString().replace(/%2F/g, \"/\") : val; }\n\t\n\t  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n\t    string: {\n\t      encode: valToString,\n\t      decode: valFromString,\n\t      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n\t      // In 0.2.x, string params are optional by default for backwards compat\n\t      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n\t      pattern: /[^/]*/\n\t    },\n\t    int: {\n\t      encode: valToString,\n\t      decode: function(val) { return parseInt(val, 10); },\n\t      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n\t      pattern: /\\d+/\n\t    },\n\t    bool: {\n\t      encode: function(val) { return val ? 1 : 0; },\n\t      decode: function(val) { return parseInt(val, 10) !== 0; },\n\t      is: function(val) { return val === true || val === false; },\n\t      pattern: /0|1/\n\t    },\n\t    date: {\n\t      encode: function (val) {\n\t        if (!this.is(val))\n\t          return undefined;\n\t        return [ val.getFullYear(),\n\t          ('0' + (val.getMonth() + 1)).slice(-2),\n\t          ('0' + val.getDate()).slice(-2)\n\t        ].join(\"-\");\n\t      },\n\t      decode: function (val) {\n\t        if (this.is(val)) return val;\n\t        var match = this.capture.exec(val);\n\t        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t      },\n\t      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n\t      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t    },\n\t    json: {\n\t      encode: angular.toJson,\n\t      decode: angular.fromJson,\n\t      is: angular.isObject,\n\t      equals: angular.equals,\n\t      pattern: /[^/]*/\n\t    },\n\t    any: { // does not encode/decode\n\t      encode: angular.identity,\n\t      decode: angular.identity,\n\t      equals: angular.equals,\n\t      pattern: /.*/\n\t    }\n\t  };\n\t\n\t  function getDefaultConfig() {\n\t    return {\n\t      strict: isStrictMode,\n\t      caseInsensitive: isCaseInsensitive\n\t    };\n\t  }\n\t\n\t  function isInjectable(value) {\n\t    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n\t  }\n\t\n\t  /**\n\t   * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t   */\n\t  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n\t    if (!isInjectable(config.value)) return config.value;\n\t    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t    return injector.invoke(config.value);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t   *\n\t   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t   * @returns {boolean} the current value of caseInsensitive\n\t   */\n\t  this.caseInsensitive = function(value) {\n\t    if (isDefined(value))\n\t      isCaseInsensitive = value;\n\t    return isCaseInsensitive;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#strictMode\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t   *\n\t   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n\t   * @returns {boolean} the current value of strictMode\n\t   */\n\t  this.strictMode = function(value) {\n\t    if (isDefined(value))\n\t      isStrictMode = value;\n\t    return isStrictMode;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Sets the default behavior when generating or matching URLs with default parameter values.\n\t   *\n\t   * @param {string} value A string that defines the default parameter URL squashing behavior.\n\t   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t   *             the parameter value from the URL and replace it with this string.\n\t   */\n\t  this.defaultSquashPolicy = function(value) {\n\t    if (!isDefined(value)) return defaultSquashPolicy;\n\t    if (value !== true && value !== false && !isString(value))\n\t      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t    defaultSquashPolicy = value;\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#compile\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n\t   *\n\t   * @param {string} pattern  The URL pattern.\n\t   * @param {Object} config  The config object hash.\n\t   * @returns {UrlMatcher}  The UrlMatcher.\n\t   */\n\t  this.compile = function (pattern, config) {\n\t    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#isMatcher\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n\t   *\n\t   * @param {Object} object  The object to perform the type check against.\n\t   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n\t   *          implementing all the same methods.\n\t   */\n\t  this.isMatcher = function (o) {\n\t    if (!isObject(o)) return false;\n\t    var result = true;\n\t\n\t    forEach(UrlMatcher.prototype, function(val, name) {\n\t      if (isFunction(val)) {\n\t        result = result && (isDefined(o[name]) && isFunction(o[name]));\n\t      }\n\t    });\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#type\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n\t   * generate URLs with typed parameters.\n\t   *\n\t   * @param {string} name  The type name.\n\t   * @param {Object|Function} definition   The type definition. See\n\t   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n\t   *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   *\n\t   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n\t   *\n\t   * @example\n\t   * This is a simple example of a custom type that encodes and decodes items from an\n\t   * array, using the array index as the URL-encoded value:\n\t   *\n\t   * <pre>\n\t   * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t   *\n\t   * $urlMatcherFactoryProvider.type('listItem', {\n\t   *   encode: function(item) {\n\t   *     // Represent the list item in the URL using its corresponding index\n\t   *     return list.indexOf(item);\n\t   *   },\n\t   *   decode: function(item) {\n\t   *     // Look up the list item by index\n\t   *     return list[parseInt(item, 10)];\n\t   *   },\n\t   *   is: function(item) {\n\t   *     // Ensure the item is valid by checking to see that it appears\n\t   *     // in the list\n\t   *     return list.indexOf(item) > -1;\n\t   *   }\n\t   * });\n\t   *\n\t   * $stateProvider.state('list', {\n\t   *   url: \"/list/{item:listItem}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     console.log($stateParams.item);\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t   * $state.go('list', { item: \"Ringo\" });\n\t   * </pre>\n\t   *\n\t   * This is a more complex example of a type that relies on dependency injection to\n\t   * interact with services, and uses the parameter name from the URL to infer how to\n\t   * handle encoding and decoding parameter values:\n\t   *\n\t   * <pre>\n\t   * // Defines a custom type that gets a value from a service,\n\t   * // where each service gets different types of values from\n\t   * // a backend API:\n\t   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n\t   *\n\t   *   // Matches up services to URL parameter names\n\t   *   var services = {\n\t   *     user: Users,\n\t   *     post: Posts\n\t   *   };\n\t   *\n\t   *   return {\n\t   *     encode: function(object) {\n\t   *       // Represent the object in the URL using its unique ID\n\t   *       return object.id;\n\t   *     },\n\t   *     decode: function(value, key) {\n\t   *       // Look up the object by ID, using the parameter\n\t   *       // name (key) to call the correct service\n\t   *       return services[key].findById(value);\n\t   *     },\n\t   *     is: function(object, key) {\n\t   *       // Check that object is a valid dbObject\n\t   *       return angular.isObject(object) && object.id && services[key];\n\t   *     }\n\t   *     equals: function(a, b) {\n\t   *       // Check the equality of decoded objects by comparing\n\t   *       // their unique IDs\n\t   *       return a.id === b.id;\n\t   *     }\n\t   *   };\n\t   * });\n\t   *\n\t   * // In a config() block, you can then attach URLs with\n\t   * // type-annotated parameters:\n\t   * $stateProvider.state('users', {\n\t   *   url: \"/users\",\n\t   *   // ...\n\t   * }).state('users.item', {\n\t   *   url: \"/{user:dbObject}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     // $stateParams.user will now be an object returned from\n\t   *     // the Users service\n\t   *   },\n\t   *   // ...\n\t   * });\n\t   * </pre>\n\t   */\n\t  this.type = function (name, definition, definitionFn) {\n\t    if (!isDefined(definition)) return $types[name];\n\t    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t\n\t    $types[name] = new Type(extend({ name: name }, definition));\n\t    if (definitionFn) {\n\t      typeQueue.push({ name: name, def: definitionFn });\n\t      if (!enqueue) flushTypeQueue();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n\t  function flushTypeQueue() {\n\t    while(typeQueue.length) {\n\t      var type = typeQueue.shift();\n\t      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t      angular.extend($types[type.name], injector.invoke(type.def));\n\t    }\n\t  }\n\t\n\t  // Register default types. Store them in the prototype of $types.\n\t  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n\t  $types = inherit($types, {});\n\t\n\t  /* No need to document $get, since it returns this */\n\t  this.$get = ['$injector', function ($injector) {\n\t    injector = $injector;\n\t    enqueue = false;\n\t    flushTypeQueue();\n\t\n\t    forEach(defaultTypes, function(type, name) {\n\t      if (!$types[name]) $types[name] = new Type(type);\n\t    });\n\t    return this;\n\t  }];\n\t\n\t  this.Param = function Param(id, type, config, location) {\n\t    var self = this;\n\t    config = unwrapShorthand(config);\n\t    type = getType(config, type, location);\n\t    var arrayMode = getArrayMode();\n\t    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n\t    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n\t      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n\t    var isOptional = config.value !== undefined;\n\t    var squash = getSquashPolicy(config, isOptional);\n\t    var replace = getReplace(config, arrayMode, isOptional, squash);\n\t\n\t    function unwrapShorthand(config) {\n\t      var keys = isObject(config) ? objectKeys(config) : [];\n\t      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n\t                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n\t      if (isShorthand) config = { value: config };\n\t      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n\t      return config;\n\t    }\n\t\n\t    function getType(config, urlType, location) {\n\t      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n\t      if (urlType) return urlType;\n\t      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\t      return config.type instanceof Type ? config.type : new Type(config.type);\n\t    }\n\t\n\t    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t    function getArrayMode() {\n\t      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n\t      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t    }\n\t\n\t    /**\n\t     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t     */\n\t    function getSquashPolicy(config, isOptional) {\n\t      var squash = config.squash;\n\t      if (!isOptional || squash === false) return false;\n\t      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n\t      if (squash === true || isString(squash)) return squash;\n\t      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t    }\n\t\n\t    function getReplace(config, arrayMode, isOptional, squash) {\n\t      var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t      ];\n\t      replace = isArray(config.replace) ? config.replace : [];\n\t      if (isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t      configuredKeys = map(replace, function(item) { return item.from; } );\n\t      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n\t    }\n\t\n\t    /**\n\t     * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t     */\n\t    function $$getDefaultValue() {\n\t      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t      var defaultValue = injector.invoke(config.$$fn);\n\t      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n\t        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n\t      return defaultValue;\n\t    }\n\t\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    function $value(value) {\n\t      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n\t      function $replace(value) {\n\t        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n\t        return replacement.length ? replacement[0] : value;\n\t      }\n\t      value = $replace(value);\n\t      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n\t    }\n\t\n\t    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\t\n\t    extend(this, {\n\t      id: id,\n\t      type: type,\n\t      location: location,\n\t      array: arrayMode,\n\t      squash: squash,\n\t      replace: replace,\n\t      isOptional: isOptional,\n\t      value: $value,\n\t      dynamic: undefined,\n\t      config: config,\n\t      toString: toString\n\t    });\n\t  };\n\t\n\t  function ParamSet(params) {\n\t    extend(this, params || {});\n\t  }\n\t\n\t  ParamSet.prototype = {\n\t    $$new: function() {\n\t      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n\t    },\n\t    $$keys: function () {\n\t      var keys = [], chain = [], parent = this,\n\t        ignore = objectKeys(ParamSet.prototype);\n\t      while (parent) { chain.push(parent); parent = parent.$$parent; }\n\t      chain.reverse();\n\t      forEach(chain, function(paramset) {\n\t        forEach(objectKeys(paramset), function(key) {\n\t            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n\t        });\n\t      });\n\t      return keys;\n\t    },\n\t    $$values: function(paramValues) {\n\t      var values = {}, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        values[key] = self[key].value(paramValues && paramValues[key]);\n\t      });\n\t      return values;\n\t    },\n\t    $$equals: function(paramValues1, paramValues2) {\n\t      var equal = true, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n\t        if (!self[key].type.equals(left, right)) equal = false;\n\t      });\n\t      return equal;\n\t    },\n\t    $$validates: function $$validate(paramValues) {\n\t      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n\t      for (i = 0; i < keys.length; i++) {\n\t        param = this[keys[i]];\n\t        rawVal = paramValues[keys[i]];\n\t        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n\t          break; // There was no parameter value, but the param is optional\n\t        normalized = param.type.$normalize(rawVal);\n\t        if (!param.type.is(normalized))\n\t          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n\t        encoded = param.type.encode(normalized);\n\t        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n\t          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t      }\n\t      return true;\n\t    },\n\t    $$parent: undefined\n\t  };\n\t\n\t  this.ParamSet = ParamSet;\n\t}\n\t\n\t// Register as a provider so it's available to other providers\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\tangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`. \n\t * When `$location` changes it runs through a list of rules one by one until a \n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\t$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n\tfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n\t  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\t\n\t  // Returns a string that is a prefix of all strings matching the RegExp\n\t  function regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t  }\n\t\n\t  // Interpolates matched values into a String.replace()-style pattern\n\t  function interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t      return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#rule\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t   * specific URLs.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // Here's an example of how you might allow case insensitive urls\n\t   *   $urlRouterProvider.rule(function ($injector, $location) {\n\t   *     var path = $location.path(),\n\t   *         normalized = path.toLowerCase();\n\t   *\n\t   *     if (path !== normalized) {\n\t   *       return normalized;\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {object} rule Handler function that takes `$injector` and `$location`\n\t   * services as arguments. You can use them to return a valid path as a string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.rule = function (rule) {\n\t    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    rules.push(rule);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouterProvider#otherwise\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines a path that is used when an invalid route is requested.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // if the path doesn't match any of the urls you configured\n\t   *   // otherwise will take care of routing the user to the\n\t   *   // specified url\n\t   *   $urlRouterProvider.otherwise('/index');\n\t   *\n\t   *   // Example of using function rule as param\n\t   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t   *     return '/a/valid/url';\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} rule The url path you want to redirect to or a function \n\t   * rule that returns the url path. The function version is passed two params: \n\t   * `$injector` and `$location` services, and must return a url string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.otherwise = function (rule) {\n\t    if (isString(rule)) {\n\t      var redirect = rule;\n\t      rule = function () { return redirect; };\n\t    }\n\t    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    otherwise = rule;\n\t    return this;\n\t  };\n\t\n\t\n\t  function handleIfMatch($injector, handler, match) {\n\t    if (!match) return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match });\n\t    return isDefined(result) ? result : true;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#when\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Registers a handler for a given url matching. if handle is a string, it is\n\t   * treated as a redirect, and is interpolated according to the syntax of match\n\t   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t   *\n\t   * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t   * matches. You have the option of inject the match object as `$match`.\n\t   *\n\t   * The handler can return\n\t   *\n\t   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t   *   will continue trying to find another one that matches.\n\t   * - **string** which is treated as a redirect and passed to `$location.url()`\n\t   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t   *     if ($state.$current.navigable !== state ||\n\t   *         !equalForKeys($match, $stateParams) {\n\t   *      $state.transitionTo(state, $match, false);\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} what The incoming path that you want to redirect.\n\t   * @param {string|object} handler The path you want to redirect your user to.\n\t   */\n\t  this.when = function (what, handler) {\n\t    var redirect, handlerIsString = isString(handler);\n\t    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\t\n\t    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n\t      throw new Error(\"invalid 'handler' in when()\");\n\t\n\t    var strategies = {\n\t      matcher: function (what, handler) {\n\t        if (handlerIsString) {\n\t          redirect = $urlMatcherFactory.compile(handler);\n\t          handler = ['$match', function ($match) { return redirect.format($match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n\t        }, {\n\t          prefix: isString(what.prefix) ? what.prefix : ''\n\t        });\n\t      },\n\t      regex: function (what, handler) {\n\t        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\t\n\t        if (handlerIsString) {\n\t          redirect = handler;\n\t          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path()));\n\t        }, {\n\t          prefix: regExpPrefix(what)\n\t        });\n\t      }\n\t    };\n\t\n\t    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\t\n\t    for (var n in check) {\n\t      if (check[n]) return this.rule(strategies[n](what, handler));\n\t    }\n\t\n\t    throw new Error(\"invalid 'what' in when()\");\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Disables (or enables) deferring location change interception.\n\t   *\n\t   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t   * defer a transition but maintain the current URL), call this method at configuration time.\n\t   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t   * `$locationChangeSuccess` event handler.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *\n\t   *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t   *   // this allows you to configure custom behavior in between\n\t   *   // location changes and route synchronization:\n\t   *   $urlRouterProvider.deferIntercept();\n\t   *\n\t   * }).run(function ($rootScope, $urlRouter, UserService) {\n\t   *\n\t   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t   *     // UserService is an example service for managing user state\n\t   *     if (UserService.isLoggedIn()) return;\n\t   *\n\t   *     // Prevent $urlRouter's default handler from firing\n\t   *     e.preventDefault();\n\t   *\n\t   *     UserService.handleLogin().then(function() {\n\t   *       // Once the user has logged in, sync the current URL\n\t   *       // to the router:\n\t   *       $urlRouter.sync();\n\t   *     });\n\t   *   });\n\t   *\n\t   *   // Configures $urlRouter's listener *after* your custom listener\n\t   *   $urlRouter.listen();\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t            no parameter is equivalent to `true`.\n\t   */\n\t  this.deferIntercept = function (defer) {\n\t    if (defer === undefined) defer = true;\n\t    interceptDeferred = defer;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouter\n\t   *\n\t   * @requires $location\n\t   * @requires $rootScope\n\t   * @requires $injector\n\t   * @requires $browser\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n\t  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\t\n\t    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\t\n\t    function appendBasePath(url, isHtml5, absolute) {\n\t      if (baseHref === '/') return url;\n\t      if (isHtml5) return baseHref.slice(0, -1) + url;\n\t      if (absolute) return baseHref.slice(1) + url;\n\t      return url;\n\t    }\n\t\n\t    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t    function update(evt) {\n\t      if (evt && evt.defaultPrevented) return;\n\t      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n\t      lastPushedUrl = undefined;\n\t      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n\t      //if (ignoreUpdate) return true;\n\t\n\t      function check(rule) {\n\t        var handled = rule($injector, $location);\n\t\n\t        if (!handled) return false;\n\t        if (isString(handled)) $location.replace().url(handled);\n\t        return true;\n\t      }\n\t      var n = rules.length, i;\n\t\n\t      for (i = 0; i < n; i++) {\n\t        if (check(rules[i])) return;\n\t      }\n\t      // always check otherwise last to allow dynamic updates to the set of rules\n\t      if (otherwise) check(otherwise);\n\t    }\n\t\n\t    function listen() {\n\t      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n\t      return listener;\n\t    }\n\t\n\t    if (!interceptDeferred) listen();\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#sync\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t       * with the transition by calling `$urlRouter.sync()`.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * angular.module('app', ['ui.router'])\n\t       *   .run(function($rootScope, $urlRouter) {\n\t       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t       *       // Halt state change from even starting\n\t       *       evt.preventDefault();\n\t       *       // Perform custom logic\n\t       *       var meetsRequirement = ...\n\t       *       // Continue with the update and state transition if logic allows\n\t       *       if (meetsRequirement) $urlRouter.sync();\n\t       *     });\n\t       * });\n\t       * </pre>\n\t       */\n\t      sync: function() {\n\t        update();\n\t      },\n\t\n\t      listen: function() {\n\t        return listen();\n\t      },\n\t\n\t      update: function(read) {\n\t        if (read) {\n\t          location = $location.url();\n\t          return;\n\t        }\n\t        if ($location.url() === location) return;\n\t\n\t        $location.url(location);\n\t        $location.replace();\n\t      },\n\t\n\t      push: function(urlMatcher, params, options) {\n\t         var url = urlMatcher.format(params || {});\n\t\n\t        // Handle the special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t            url += '#' + params['#'];\n\t        }\n\t\n\t        $location.url(url);\n\t        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n\t        if (options && options.replace) $location.replace();\n\t      },\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#href\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * A URL generation method that returns the compiled URL for a given\n\t       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t       *   person: \"bob\"\n\t       * });\n\t       * // $bob == \"/about/bob\";\n\t       * </pre>\n\t       *\n\t       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t       * @param {object=} options Options object. The options are:\n\t       *\n\t       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t       *\n\t       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t       */\n\t      href: function(urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params)) return null;\n\t\n\t        var isHtml5 = $locationProvider.html5Mode();\n\t        if (angular.isObject(isHtml5)) {\n\t          isHtml5 = isHtml5.enabled;\n\t        }\n\t        \n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t\n\t        if (!isHtml5 && url !== null) {\n\t          url = \"#\" + $locationProvider.hashPrefix() + url;\n\t        }\n\t\n\t        // Handle special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t          url += '#' + params['#'];\n\t        }\n\t\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\n\t        if (!options.absolute || !url) {\n\t          return url;\n\t        }\n\t\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\n\t        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\t$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n\tfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\t\n\t  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\t\n\t  // Builds state properties from definition passed to registerState()\n\t  var stateBuilder = {\n\t\n\t    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n\t    // state.children = [];\n\t    // if (parent) parent.children.push(state);\n\t    parent: function(state) {\n\t      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n\t      // regex matches any valid composite state name\n\t      // would match \"contact.list\" but not \"contacts\"\n\t      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n\t      return compositeName ? findState(compositeName[1]) : root;\n\t    },\n\t\n\t    // inherit 'data' from parent and override by own values (if any)\n\t    data: function(state) {\n\t      if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = extend({}, state.parent.data, state.data);\n\t      }\n\t      return state.data;\n\t    },\n\t\n\t    // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t    url: function(state) {\n\t      var url = state.url, config = { params: state.params || {} };\n\t\n\t      if (isString(url)) {\n\t        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n\t        return (state.parent.navigable || root).url.concat(url, config);\n\t      }\n\t\n\t      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n\t      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t    },\n\t\n\t    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t    navigable: function(state) {\n\t      return state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    },\n\t\n\t    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n\t    ownParams: function(state) {\n\t      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n\t      forEach(state.params || {}, function(config, id) {\n\t        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n\t      });\n\t      return params;\n\t    },\n\t\n\t    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n\t    params: function(state) {\n\t      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();\n\t    },\n\t\n\t    // If there is no explicit multi-view configuration, make one up so we don't have\n\t    // to handle both cases in the view directive later. Note that having an explicit\n\t    // 'views' property will mean the default unnamed view properties are ignored. This\n\t    // is also a good time to resolve view names to absolute names, so everything is a\n\t    // straight lookup at link time.\n\t    views: function(state) {\n\t      var views = {};\n\t\n\t      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n\t        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n\t        views[name] = view;\n\t      });\n\t      return views;\n\t    },\n\t\n\t    // Keep a full path from the root down to this state as this is needed for state activation.\n\t    path: function(state) {\n\t      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n\t    },\n\t\n\t    // Speed up $state.contains() as it's used a lot\n\t    includes: function(state) {\n\t      var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t      includes[state.name] = true;\n\t      return includes;\n\t    },\n\t\n\t    $delegates: {}\n\t  };\n\t\n\t  function isRelative(stateName) {\n\t    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t  }\n\t\n\t  function findState(stateOrName, base) {\n\t    if (!stateOrName) return undefined;\n\t\n\t    var isStr = isString(stateOrName),\n\t        name  = isStr ? stateOrName : stateOrName.name,\n\t        path  = isRelative(name);\n\t\n\t    if (path) {\n\t      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n\t      base = findState(base);\n\t      \n\t      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\t\n\t      for (; i < pathLength; i++) {\n\t        if (rel[i] === \"\" && i === 0) {\n\t          current = base;\n\t          continue;\n\t        }\n\t        if (rel[i] === \"^\") {\n\t          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n\t          current = current.parent;\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t      rel = rel.slice(i).join(\".\");\n\t      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n\t    }\n\t    var state = states[name];\n\t\n\t    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t      return state;\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function queueState(parentName, state) {\n\t    if (!queue[parentName]) {\n\t      queue[parentName] = [];\n\t    }\n\t    queue[parentName].push(state);\n\t  }\n\t\n\t  function flushQueuedChildren(parentName) {\n\t    var queued = queue[parentName] || [];\n\t    while(queued.length) {\n\t      registerState(queued.shift());\n\t    }\n\t  }\n\t\n\t  function registerState(state) {\n\t    // Wrap a new object around the state so we can store our private details easily.\n\t    state = inherit(state, {\n\t      self: state,\n\t      resolve: state.resolve || {},\n\t      toString: function() { return this.name; }\n\t    });\n\t\n\t    var name = state.name;\n\t    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n\t    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\t\n\t    // Get parent name\n\t    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n\t        : (isString(state.parent)) ? state.parent\n\t        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n\t        : '';\n\t\n\t    // If parent is not registered yet, add state to queue and register later\n\t    if (parentName && !states[parentName]) {\n\t      return queueState(parentName, state.self);\n\t    }\n\t\n\t    for (var key in stateBuilder) {\n\t      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n\t    }\n\t    states[name] = state;\n\t\n\t    // Register the state in the global state list and with $urlRouter if necessary.\n\t    if (!state[abstractKey] && state.url) {\n\t      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n\t          $state.transitionTo(state, $match, { inherit: true, location: false });\n\t        }\n\t      }]);\n\t    }\n\t\n\t    // Register any queued children\n\t    flushQueuedChildren(name);\n\t\n\t    return state;\n\t  }\n\t\n\t  // Checks text to see if it looks like a glob.\n\t  function isGlob (text) {\n\t    return text.indexOf('*') > -1;\n\t  }\n\t\n\t  // Returns true if glob matches current $state name.\n\t  function doesStateMatchGlob (glob) {\n\t    var globSegments = glob.split('.'),\n\t        segments = $state.$current.name.split('.');\n\t\n\t    //match single stars\n\t    for (var i = 0, l = globSegments.length; i < l; i++) {\n\t      if (globSegments[i] === '*') {\n\t        segments[i] = '*';\n\t      }\n\t    }\n\t\n\t    //match greedy starts\n\t    if (globSegments[0] === '**') {\n\t       segments = segments.slice(indexOf(segments, globSegments[1]));\n\t       segments.unshift('**');\n\t    }\n\t    //match greedy ends\n\t    if (globSegments[globSegments.length - 1] === '**') {\n\t       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n\t       segments.push('**');\n\t    }\n\t\n\t    if (globSegments.length != segments.length) {\n\t      return false;\n\t    }\n\t\n\t    return segments.join('') === globSegments.join('');\n\t  }\n\t\n\t\n\t  // Implicit root state that is always active\n\t  root = registerState({\n\t    name: '',\n\t    url: '^',\n\t    views: null,\n\t    'abstract': true\n\t  });\n\t  root.navigable = null;\n\t\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#decorator\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Allows you to extend (carefully) or override (at your own peril) the \n\t   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n\t   * to add custom functionality to ui-router, for example inferring templateUrl \n\t   * based on the state name.\n\t   *\n\t   * When passing only a name, it returns the current (original or decorated) builder\n\t   * function that matches `name`.\n\t   *\n\t   * The builder functions that can be decorated are listed below. Though not all\n\t   * necessarily have a good use case for decoration, that is up to you to decide.\n\t   *\n\t   * In addition, users can attach custom decorators, which will generate new \n\t   * properties within the state's internal definition. There is currently no clear \n\t   * use-case for this beyond accessing internal states (i.e. $state.$current), \n\t   * however, expect this to become increasingly relevant as we introduce additional \n\t   * meta-programming features.\n\t   *\n\t   * **Warning**: Decorators should not be interdependent because the order of \n\t   * execution of the builder functions in non-deterministic. Builder functions \n\t   * should only be dependent on the state definition object and super function.\n\t   *\n\t   *\n\t   * Existing builder functions and current return values:\n\t   *\n\t   * - **parent** `{object}` - returns the parent state object.\n\t   * - **data** `{object}` - returns state data, including any inherited data that is not\n\t   *   overridden by own values (if any).\n\t   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t   *   or `null`.\n\t   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n\t   *   navigable).\n\t   * - **params** `{object}` - returns an array of state params that are ensured to \n\t   *   be a super-set of parent's params.\n\t   * - **views** `{object}` - returns a views object where each key is an absolute view \n\t   *   name (i.e. \"viewName@stateName\") and each value is the config object \n\t   *   (template, controller) for the view. Even when you don't use the views object \n\t   *   explicitly on a state config, one is still created for you internally.\n\t   *   So by decorating this builder function you have access to decorating template \n\t   *   and controller properties.\n\t   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n\t   *   not including any params defined by ancestor states.\n\t   * - **path** `{string}` - returns the full path from the root down to this state. \n\t   *   Needed for state activation.\n\t   * - **includes** `{object}` - returns an object that includes every state that \n\t   *   would pass a `$state.includes()` test.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Override the internal 'views' builder with a function that takes the state\n\t   * // definition, and a reference to the internal function being overridden:\n\t   * $stateProvider.decorator('views', function (state, parent) {\n\t   *   var result = {},\n\t   *       views = parent(state);\n\t   *\n\t   *   angular.forEach(views, function (config, name) {\n\t   *     var autoName = (state.name + '.' + name).replace('.', '/');\n\t   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t   *     result[name] = config;\n\t   *   });\n\t   *   return result;\n\t   * });\n\t   *\n\t   * $stateProvider.state('home', {\n\t   *   views: {\n\t   *     'contact.list': { controller: 'ListController' },\n\t   *     'contact.item': { controller: 'ItemController' }\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * $state.go('home');\n\t   * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t   * // and /partials/home/contact/item.html, respectively.\n\t   * </pre>\n\t   *\n\t   * @param {string} name The name of the builder function to decorate. \n\t   * @param {object} func A function that is responsible for decorating the original \n\t   * builder function. The function receives two parameters:\n\t   *\n\t   *   - `{object}` - state - The state config object.\n\t   *   - `{object}` - super - The original builder function.\n\t   *\n\t   * @return {object} $stateProvider - $stateProvider instance\n\t   */\n\t  this.decorator = decorator;\n\t  function decorator(name, func) {\n\t    /*jshint validthis: true */\n\t    if (isString(name) && !isDefined(func)) {\n\t      return stateBuilder[name];\n\t    }\n\t    if (!isFunction(func) || !isString(name)) {\n\t      return this;\n\t    }\n\t    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n\t      stateBuilder.$delegates[name] = stateBuilder[name];\n\t    }\n\t    stateBuilder[name] = func;\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#state\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Registers a state configuration under a given state name. The stateConfig object\n\t   * has the following acceptable properties.\n\t   *\n\t   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t   * @param {object} stateConfig State configuration object.\n\t   * @param {string|function=} stateConfig.template\n\t   * <a id='template'></a>\n\t   *   html template as a string or a function that returns\n\t   *   an html template as a string which should be used by the uiView directives. This property \n\t   *   takes precedence over templateUrl.\n\t   *   \n\t   *   If `template` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t   *     applying the current state\n\t   *\n\t   * <pre>template:\n\t   *   \"<h1>inline template definition</h1>\" +\n\t   *   \"<div ui-view></div>\"</pre>\n\t   * <pre>template: function(params) {\n\t   *       return \"<h1>generated template</h1>\"; }</pre>\n\t   * </div>\n\t   *\n\t   * @param {string|function=} stateConfig.templateUrl\n\t   * <a id='templateUrl'></a>\n\t   *\n\t   *   path or function that returns a path to an html\n\t   *   template that should be used by uiView.\n\t   *   \n\t   *   If `templateUrl` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n\t   *     applying the current state\n\t   *\n\t   * <pre>templateUrl: \"home.html\"</pre>\n\t   * <pre>templateUrl: function(params) {\n\t   *     return myTemplates[params.pageId]; }</pre>\n\t   *\n\t   * @param {function=} stateConfig.templateProvider\n\t   * <a id='templateProvider'></a>\n\t   *    Provider function that returns HTML content string.\n\t   * <pre> templateProvider:\n\t   *       function(MyTemplateService, params) {\n\t   *         return MyTemplateService.getTemplate(params.pageId);\n\t   *       }</pre>\n\t   *\n\t   * @param {string|function=} stateConfig.controller\n\t   * <a id='controller'></a>\n\t   *\n\t   *  Controller fn that should be associated with newly\n\t   *   related scope or the name of a registered controller if passed as a string.\n\t   *   Optionally, the ControllerAs may be declared here.\n\t   * <pre>controller: \"MyRegisteredController\"</pre>\n\t   * <pre>controller:\n\t   *     \"MyRegisteredController as fooCtrl\"}</pre>\n\t   * <pre>controller: function($scope, MyService) {\n\t   *     $scope.data = MyService.getData(); }</pre>\n\t   *\n\t   * @param {function=} stateConfig.controllerProvider\n\t   * <a id='controllerProvider'></a>\n\t   *\n\t   * Injectable provider function that returns the actual controller or string.\n\t   * <pre>controllerProvider:\n\t   *   function(MyResolveData) {\n\t   *     if (MyResolveData.foo)\n\t   *       return \"FooCtrl\"\n\t   *     else if (MyResolveData.bar)\n\t   *       return \"BarCtrl\";\n\t   *     else return function($scope) {\n\t   *       $scope.baz = \"Qux\";\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {string=} stateConfig.controllerAs\n\t   * <a id='controllerAs'></a>\n\t   * \n\t   * A controller alias name. If present the controller will be\n\t   *   published to scope under the controllerAs name.\n\t   * <pre>controllerAs: \"myCtrl\"</pre>\n\t   *\n\t   * @param {string|object=} stateConfig.parent\n\t   * <a id='parent'></a>\n\t   * Optionally specifies the parent state of this state.\n\t   *\n\t   * <pre>parent: 'parentState'</pre>\n\t   * <pre>parent: parentState // JS variable</pre>\n\t   *\n\t   * @param {object=} stateConfig.resolve\n\t   * <a id='resolve'></a>\n\t   *\n\t   * An optional map&lt;string, function&gt; of dependencies which\n\t   *   should be injected into the controller. If any of these dependencies are promises, \n\t   *   the router will wait for them all to be resolved before the controller is instantiated.\n\t   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n\t   *   and the values of the resolved promises are injected into any controllers that reference them.\n\t   *   If any  of the promises are rejected the $stateChangeError event is fired.\n\t   *\n\t   *   The map object is:\n\t   *   \n\t   *   - key - {string}: name of dependency to be injected into controller\n\t   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n\t   *     it is injected and return value it treated as dependency. If result is a promise, it is \n\t   *     resolved before its value is injected into controller.\n\t   *\n\t   * <pre>resolve: {\n\t   *     myResolve1:\n\t   *       function($http, $stateParams) {\n\t   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n\t   *       }\n\t   *     }</pre>\n\t   *\n\t   * @param {string=} stateConfig.url\n\t   * <a id='url'></a>\n\t   *\n\t   *   A url fragment with optional parameters. When a state is navigated or\n\t   *   transitioned to, the `$stateParams` service will be populated with any \n\t   *   parameters that were passed.\n\t   *\n\t   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n\t   *   more details on acceptable patterns )\n\t   *\n\t   * examples:\n\t   * <pre>url: \"/home\"\n\t   * url: \"/users/:userid\"\n\t   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n\t   * url: \"/books/{categoryid:int}\"\n\t   * url: \"/books/{publishername:string}/{categoryid:int}\"\n\t   * url: \"/messages?before&after\"\n\t   * url: \"/messages?{before:date}&{after:date}\"\n\t   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n\t   * </pre>\n\t   *\n\t   * @param {object=} stateConfig.views\n\t   * <a id='views'></a>\n\t   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n\t   * manually/explicitly.\n\t   *\n\t   * Examples:\n\t   *\n\t   * Targets three named `ui-view`s in the parent state's template\n\t   * <pre>views: {\n\t   *     header: {\n\t   *       controller: \"headerCtrl\",\n\t   *       templateUrl: \"header.html\"\n\t   *     }, body: {\n\t   *       controller: \"bodyCtrl\",\n\t   *       templateUrl: \"body.html\"\n\t   *     }, footer: {\n\t   *       controller: \"footCtrl\",\n\t   *       templateUrl: \"footer.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n\t   * <pre>views: {\n\t   *     'header@top': {\n\t   *       controller: \"msgHeaderCtrl\",\n\t   *       templateUrl: \"msgHeader.html\"\n\t   *     }, 'body': {\n\t   *       controller: \"messagesCtrl\",\n\t   *       templateUrl: \"messages.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.abstract=false]\n\t   * <a id='abstract'></a>\n\t   * An abstract state will never be directly activated,\n\t   *   but can provide inherited properties to its common children states.\n\t   * <pre>abstract: true</pre>\n\t   *\n\t   * @param {function=} stateConfig.onEnter\n\t   * <a id='onEnter'></a>\n\t   *\n\t   * Callback function for when a state is entered. Good way\n\t   *   to trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explictly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onEnter: function(MyService, $stateParams) {\n\t   *     MyService.foo($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {function=} stateConfig.onExit\n\t   * <a id='onExit'></a>\n\t   *\n\t   * Callback function for when a state is exited. Good way to\n\t   *   trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explictly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onExit: function(MyService, $stateParams) {\n\t   *     MyService.cleanup($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n\t   * <a id='reloadOnSearch'></a>\n\t   *\n\t   * If `false`, will not retrigger the same state\n\t   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n\t   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t   * <pre>reloadOnSearch: false</pre>\n\t   *\n\t   * @param {object=} stateConfig.data\n\t   * <a id='data'></a>\n\t   *\n\t   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n\t   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n\t   *   the entire subtree via prototypal inheritance.\n\t   *\n\t   * <pre>data: {\n\t   *     requiredRole: 'foo'\n\t   * } </pre>\n\t   *\n\t   * @param {object=} stateConfig.params\n\t   * <a id='params'></a>\n\t   *\n\t   * A map which optionally configures parameters declared in the `url`, or\n\t   *   defines additional non-url parameters.  For each parameter being\n\t   *   configured, add a configuration object keyed to the name of the parameter.\n\t   *\n\t   *   Each parameter configuration object may contain the following properties:\n\t   *\n\t   *   - ** value ** - {object|function=}: specifies the default value for this\n\t   *     parameter.  This implicitly sets this parameter as optional.\n\t   *\n\t   *     When UI-Router routes to a state and no value is\n\t   *     specified for this parameter in the URL or transition, the\n\t   *     default value will be used instead.  If `value` is a function,\n\t   *     it will be injected and invoked, and the return value used.\n\t   *\n\t   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n\t   *     is treated as \"the default value is `null`\".\n\t   *\n\t   *     *Shorthand*: If you only need to configure the default value of the\n\t   *     parameter, you may use a shorthand syntax.   In the **`params`**\n\t   *     map, instead mapping the param name to a full parameter configuration\n\t   *     object, simply set map it to the default parameter value, e.g.:\n\t   *\n\t   * <pre>// define a parameter's default value\n\t   * params: {\n\t   *     param1: { value: \"defaultValue\" }\n\t   * }\n\t   * // shorthand default values\n\t   * params: {\n\t   *     param1: \"defaultValue\",\n\t   *     param2: \"param2Default\"\n\t   * }</pre>\n\t   *\n\t   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n\t   *     treated as an array of values.  If you specified a Type, the value will be\n\t   *     treated as an array of the specified Type.  Note: query parameter values\n\t   *     default to a special `\"auto\"` mode.\n\t   *\n\t   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n\t   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n\t   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n\t   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n\t   *     value (e.g.: `{ foo: '1' }`).\n\t   *\n\t   * <pre>params: {\n\t   *     param1: { array: true }\n\t   * }</pre>\n\t   *\n\t   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n\t   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n\t   *     configured default squash policy.\n\t   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n\t   *\n\t   *   There are three squash settings:\n\t   *\n\t   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n\t   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n\t   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n\t   *       This can allow for cleaner looking URLs.\n\t   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n\t   *\n\t   * <pre>params: {\n\t   *     param1: {\n\t   *       value: \"defaultId\",\n\t   *       squash: true\n\t   * } }\n\t   * // squash \"defaultValue\" to \"~\"\n\t   * params: {\n\t   *     param1: {\n\t   *       value: \"defaultValue\",\n\t   *       squash: \"~\"\n\t   * } }\n\t   * </pre>\n\t   *\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Some state name examples\n\t   *\n\t   * // stateName can be a single top-level name (must be unique).\n\t   * $stateProvider.state(\"home\", {});\n\t   *\n\t   * // Or it can be a nested state name. This state is a child of the\n\t   * // above \"home\" state.\n\t   * $stateProvider.state(\"home.newest\", {});\n\t   *\n\t   * // Nest states as deeply as needed.\n\t   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t   *\n\t   * // state() returns $stateProvider, so you can chain state declarations.\n\t   * $stateProvider\n\t   *   .state(\"home\", {})\n\t   *   .state(\"about\", {})\n\t   *   .state(\"contacts\", {});\n\t   * </pre>\n\t   *\n\t   */\n\t  this.state = state;\n\t  function state(name, definition) {\n\t    /*jshint validthis: true */\n\t    if (isObject(name)) definition = name;\n\t    else definition.name = name;\n\t    registerState(definition);\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$state\n\t   *\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires ui.router.state.$view\n\t   * @requires $injector\n\t   * @requires ui.router.util.$resolve\n\t   * @requires ui.router.state.$stateParams\n\t   * @requires ui.router.router.$urlRouter\n\t   *\n\t   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n\t   * you'd like to test against the current active state.\n\t   * @property {object} current A reference to the state's config object. However \n\t   * you passed it in. Useful for accessing custom data.\n\t   * @property {object} transition Currently pending transition. A promise that'll \n\t   * resolve or reject.\n\t   *\n\t   * @description\n\t   * `$state` service is responsible for representing states as well as transitioning\n\t   * between them. It also provides interfaces to ask for current state or even states\n\t   * you're coming from.\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n\t  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\t\n\t    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n\t    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n\t    var TransitionAborted = $q.reject(new Error('transition aborted'));\n\t    var TransitionFailed = $q.reject(new Error('transition failed'));\n\t\n\t    // Handles the case where a state which is the target of a transition is not found, and the user\n\t    // can optionally retry or defer the transition\n\t    function handleRedirect(redirect, state, params, options) {\n\t      /**\n\t       * @ngdoc event\n\t       * @name ui.router.state.$state#$stateNotFound\n\t       * @eventOf ui.router.state.$state\n\t       * @eventType broadcast on root scope\n\t       * @description\n\t       * Fired when a requested state **cannot be found** using the provided state name during transition.\n\t       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n\t       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n\t       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n\t       *\n\t       * @param {Object} event Event object.\n\t       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n\t       * @param {State} fromState Current state object.\n\t       * @param {Object} fromParams Current state params.\n\t       *\n\t       * @example\n\t       *\n\t       * <pre>\n\t       * // somewhere, assume lazy.state has not been defined\n\t       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n\t       *\n\t       * // somewhere else\n\t       * $scope.$on('$stateNotFound',\n\t       * function(event, unfoundState, fromState, fromParams){\n\t       *     console.log(unfoundState.to); // \"lazy.state\"\n\t       *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t       *     console.log(unfoundState.options); // {inherit:false} + default options\n\t       * })\n\t       * </pre>\n\t       */\n\t      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\t\n\t      if (evt.defaultPrevented) {\n\t        $urlRouter.update();\n\t        return TransitionAborted;\n\t      }\n\t\n\t      if (!evt.retry) {\n\t        return null;\n\t      }\n\t\n\t      // Allow the handler to return a promise to defer state lookup retry\n\t      if (options.$retry) {\n\t        $urlRouter.update();\n\t        return TransitionFailed;\n\t      }\n\t      var retryTransition = $state.transition = $q.when(evt.retry);\n\t\n\t      retryTransition.then(function() {\n\t        if (retryTransition !== $state.transition) return TransitionSuperseded;\n\t        redirect.options.$retry = true;\n\t        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n\t      }, function() {\n\t        return TransitionAborted;\n\t      });\n\t      $urlRouter.update();\n\t\n\t      return retryTransition;\n\t    }\n\t\n\t    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\t\n\t    $state = {\n\t      params: {},\n\t      current: root.self,\n\t      $current: root,\n\t      transition: null\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state. All resolves are re-resolved,\n\t     * controllers reinstantiated, and events re-fired.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t     * @example\n\t     * <pre>\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n\t     * //and current state is 'contacts.detail.item'\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.reload = function reload(state) {\n\t      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls \n\t     * `$state.transitionTo` internally but automatically sets options to \n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n\t     * This allows you to easily use an absolute or relative to path and specify \n\t     * only the parameters you'd like to update (while letting unspecified parameters \n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state, \n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n\t     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    $state.go = function go(to, params, options) {\n\t      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *    if String, then will reload the state with the name given in reload, and any children.\n\t     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.transitionTo = function transitionTo(to, toParams, options) {\n\t      toParams = toParams || {};\n\t      options = extend({\n\t        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n\t      }, options || {});\n\t\n\t      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n\t      var evt, toState = findState(to, options.relative);\n\t\n\t      // Store the hash param for later (since it will be stripped out by various methods)\n\t      var hash = toParams['#'];\n\t\n\t      if (!isDefined(toState)) {\n\t        var redirect = { to: to, toParams: toParams, options: options };\n\t        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\t\n\t        if (redirectResult) {\n\t          return redirectResult;\n\t        }\n\t\n\t        // Always retry once if the $stateNotFound was not prevented\n\t        // (handles either redirect changed or state lazy-definition)\n\t        to = redirect.to;\n\t        toParams = redirect.toParams;\n\t        options = redirect.options;\n\t        toState = findState(to, options.relative);\n\t\n\t        if (!isDefined(toState)) {\n\t          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n\t          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n\t        }\n\t      }\n\t      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n\t      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n\t      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\t\n\t      toParams = toState.params.$$values(toParams);\n\t      to = toState;\n\t\n\t      var toPath = to.path;\n\t\n\t      // Starting from the root of the path, keep all levels that haven't changed\n\t      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\t\n\t      if (!options.reload) {\n\t        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      } else if (isString(options.reload) || isObject(options.reload)) {\n\t        if (isObject(options.reload) && !options.reload.name) {\n\t          throw new Error('Invalid reload state object');\n\t        }\n\t        \n\t        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n\t        if (options.reload && !reloadState) {\n\t          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        }\n\t\n\t        while (state && state === fromPath[keep] && state !== reloadState) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      }\n\t\n\t      // If we're going to the same state and all locals are kept, we've got nothing to do.\n\t      // But clear 'transition', as we still want to cancel any other pending transitions.\n\t      // TODO: We may not want to bump 'transition' if we're called from a location change\n\t      // that we've initiated ourselves, because we might accidentally abort a legitimate\n\t      // transition initiated from code?\n\t      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n\t        if (hash) toParams['#'] = hash;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        if (options.location && to.navigable && to.navigable.url) {\n\t          $urlRouter.push(to.navigable.url, toParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t          $urlRouter.update(true);\n\t        }\n\t        $state.transition = null;\n\t        return $q.when($state.current);\n\t      }\n\t\n\t      // Filter parameters before we pass them to event handlers etc.\n\t      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\t\n\t      // Broadcast start event and cancel the transition if requested\n\t      if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeStart\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n\t         * to prevent the transition from happening and then the transition promise will be\n\t         * rejected with a `'transition prevented'` value.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $rootScope.$on('$stateChangeStart',\n\t         * function(event, toState, toParams, fromState, fromParams){\n\t         *     event.preventDefault();\n\t         *     // transitionTo() promise will be rejected with\n\t         *     // a 'transition prevented' error\n\t         * })\n\t         * </pre>\n\t         */\n\t        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n\t          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n\t          $urlRouter.update();\n\t          return TransitionPrevented;\n\t        }\n\t      }\n\t\n\t      // Resolve locals for the remaining states, but don't update any global state just\n\t      // yet -- if anything fails to resolve the current state needs to remain untouched.\n\t      // We also set up an inheritance chain for the locals here. This allows the view directive\n\t      // to quickly look up the correct definition for each view in the current state. Even\n\t      // though we create the locals object itself outside resolveState(), it is initially\n\t      // empty and gets filled asynchronously. We need to keep track of the promise for the\n\t      // (fully resolved) current locals, and pass this down the chain.\n\t      var resolved = $q.when(locals);\n\t\n\t      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n\t        locals = toLocals[l] = inherit(locals);\n\t        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n\t      }\n\t\n\t      // Once everything is resolved, we are ready to perform the actual transition\n\t      // and return a promise for the new state. We also keep track of what the\n\t      // current promise is, so that we can detect overlapping transitions and\n\t      // keep only the outcome of the last transition.\n\t      var transition = $state.transition = resolved.then(function () {\n\t        var l, entering, exiting;\n\t\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Exit 'from' states not kept\n\t        for (l = fromPath.length - 1; l >= keep; l--) {\n\t          exiting = fromPath[l];\n\t          if (exiting.self.onExit) {\n\t            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n\t          }\n\t          exiting.locals = null;\n\t        }\n\t\n\t        // Enter 'to' states not kept\n\t        for (l = keep; l < toPath.length; l++) {\n\t          entering = toPath[l];\n\t          entering.locals = toLocals[l];\n\t          if (entering.self.onEnter) {\n\t            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n\t          }\n\t        }\n\t\n\t        // Re-add the saved hash before we start returning things\n\t        if (hash) toParams['#'] = hash;\n\t\n\t        // Run it again, to catch any transitions in callbacks\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Update globals in $state\n\t        $state.$current = to;\n\t        $state.current = to.self;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        $state.transition = null;\n\t\n\t        if (options.location && to.navigable) {\n\t          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t        }\n\t\n\t        if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeSuccess\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired once the state transition is **complete**.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         */\n\t          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n\t        }\n\t        $urlRouter.update(true);\n\t\n\t        return $state.current;\n\t      }, function (error) {\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        $state.transition = null;\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeError\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when an **error occurs** during transition. It's important to note that if you\n\t         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t         * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t         * catch **ALL** errors.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         * @param {Error} error The resolve error object.\n\t         */\n\t        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\t\n\t        if (!evt.defaultPrevented) {\n\t            $urlRouter.update();\n\t        }\n\t\n\t        return $q.reject(error);\n\t      });\n\t\n\t      return transition;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be\n\t     * tested for strict equality against the current active params object, so all params\n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     * test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    $state.is = function is(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) { return undefined; }\n\t      if ($state.$current !== state) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t     * .includes will test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    $state.includes = function includes(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      if (isString(stateOrName) && isGlob(stateOrName)) {\n\t        if (!doesStateMatchGlob(stateOrName)) {\n\t          return false;\n\t        }\n\t        stateOrName = $state.$current.name;\n\t      }\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t      if (!isDefined(state)) { return undefined; }\n\t      if (!isDefined($state.$current.includes[state.name])) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n\t    };\n\t\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     * \n\t     * @returns {string} compiled state url\n\t     */\n\t    $state.href = function href(stateOrName, params, options) {\n\t      options = extend({\n\t        lossy:    true,\n\t        inherit:  true,\n\t        absolute: false,\n\t        relative: $state.$current\n\t      }, options || {});\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) return null;\n\t      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\t      \n\t      var nav = (state && options.lossy) ? state.navigable : state;\n\t\n\t      if (!nav || nav.url === undefined || nav.url === null) {\n\t        return null;\n\t      }\n\t      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n\t        absolute: options.absolute\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#get\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Returns the state configuration object for any specific state or all states.\n\t     *\n\t     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n\t     * the requested state. If not provided, returns an array of ALL state configs.\n\t     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n\t     * @returns {Object|Array} State configuration object or array of all objects.\n\t     */\n\t    $state.get = function (stateOrName, context) {\n\t      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n\t      var state = findState(stateOrName, context || $state.$current);\n\t      return (state && state.self) ? state.self : null;\n\t    };\n\t\n\t    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n\t      // Make a restricted $stateParams with only the parameters that apply to this state if\n\t      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n\t      // we also need $stateParams to be available for any $injector calls we make during the\n\t      // dependency resolution process.\n\t      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n\t      var locals = { $stateParams: $stateParams };\n\t\n\t      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n\t      // We're also including $stateParams in this; that way the parameters are restricted\n\t      // to the set that should be visible to the state, and are independent of when we update\n\t      // the global $state and $stateParams values.\n\t      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n\t      var promises = [dst.resolve.then(function (globals) {\n\t        dst.globals = globals;\n\t      })];\n\t      if (inherited) promises.push(inherited);\n\t\n\t      function resolveViews() {\n\t        var viewsPromises = [];\n\t\n\t        // Resolve template and dependencies for all views.\n\t        forEach(state.views, function (view, name) {\n\t          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n\t          injectables.$template = [ function () {\n\t            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n\t          }];\n\t\n\t          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n\t            // References to the controller (only instantiated at link time)\n\t            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n\t              var injectLocals = angular.extend({}, injectables, dst.globals);\n\t              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n\t            } else {\n\t              result.$$controller = view.controller;\n\t            }\n\t            // Provide access to the state itself for internal use\n\t            result.$$state = state;\n\t            result.$$controllerAs = view.controllerAs;\n\t            dst[name] = result;\n\t          }));\n\t        });\n\t\n\t        return $q.all(viewsPromises).then(function(){\n\t          return dst.globals;\n\t        });\n\t      }\n\t\n\t      // Wait for all the promises and then return the activation object\n\t      return $q.all(promises).then(resolveViews).then(function (values) {\n\t        return dst;\n\t      });\n\t    }\n\t\n\t    return $state;\n\t  }\n\t\n\t  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n\t    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n\t    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n\t      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n\t      function notSearchParam(key) {\n\t        return fromAndToState.params[key].location != \"search\";\n\t      }\n\t      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n\t      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n\t      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n\t      return nonQueryParamSet.$$equals(fromParams, toParams);\n\t    }\n\t\n\t    // If reload was not explicitly requested\n\t    // and we're transitioning to the same state we're already in\n\t    // and    the locals didn't change\n\t    //     or they changed in a way that doesn't merit reloading\n\t    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n\t    // Then return true.\n\t    if (!options.reload && to === from &&\n\t      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .value('$stateParams', {})\n\t  .provider('$state', $StateProvider);\n\t\n\t\n\t$ViewProvider.$inject = [];\n\tfunction $ViewProvider() {\n\t\n\t  this.$get = $get;\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$view\n\t   *\n\t   * @requires ui.router.util.$templateFactory\n\t   * @requires $rootScope\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  $get.$inject = ['$rootScope', '$templateFactory'];\n\t  function $get(   $rootScope,   $templateFactory) {\n\t    return {\n\t      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.state.$view#load\n\t       * @methodOf ui.router.state.$view\n\t       *\n\t       * @description\n\t       *\n\t       * @param {string} name name\n\t       * @param {object} options option object.\n\t       */\n\t      load: function load(name, options) {\n\t        var result, defaults = {\n\t          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n\t        };\n\t        options = extend(defaults, options);\n\t\n\t        if (options.view) {\n\t          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n\t        }\n\t        if (result && options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$viewContentLoading\n\t         * @eventOf ui.router.state.$view\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         *\n\t         * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {Object} viewConfig The view config properties (template, controller, etc).\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $scope.$on('$viewContentLoading',\n\t         * function(event, viewConfig){\n\t         *     // Access to all the view config properties.\n\t         *     // and one special property 'targetView'\n\t         *     // viewConfig.targetView\n\t         * });\n\t         * </pre>\n\t         */\n\t          $rootScope.$broadcast('$viewContentLoading', options);\n\t        }\n\t        return result;\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state').provider('$view', $ViewProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t\n\t  var useAnchorScroll = false;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t   * @methodOf ui.router.state.$uiViewScrollProvider\n\t   *\n\t   * @description\n\t   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t   * scrolling based on the url anchor.\n\t   */\n\t  this.useAnchorScroll = function () {\n\t    useAnchorScroll = true;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$uiViewScroll\n\t   *\n\t   * @requires $anchorScroll\n\t   * @requires $timeout\n\t   *\n\t   * @description\n\t   * When called with a jqLite element, it scrolls the element into view (after a\n\t   * `$timeout` so the DOM has time to refresh).\n\t   *\n\t   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t   */\n\t  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t    if (useAnchorScroll) {\n\t      return $anchorScroll;\n\t    }\n\t\n\t    return function ($element) {\n\t      return $timeout(function () {\n\t        $element[0].scrollIntoView();\n\t      }, 0, false);\n\t    };\n\t  }];\n\t}\n\t\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-view\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $compile\n\t * @requires $controller\n\t * @requires $injector\n\t * @requires ui.router.state.$uiViewScroll\n\t * @requires $document\n\t *\n\t * @restrict ECA\n\t *\n\t * @description\n\t * The ui-view directive tells $state where to place your templates.\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t * \n\t * @example\n\t * A view can be unnamed or named. \n\t * <pre>\n\t * <!-- Unnamed -->\n\t * <div ui-view></div> \n\t * \n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * </pre>\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a \n\t * single view and it is unnamed then you can populate it like so:\n\t * <pre>\n\t * <div ui-view></div> \n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * </pre>\n\t * \n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n\t * config property, by name, in this case an empty name:\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * But typically you'll only use the views property if you name your view or have more than one view \n\t * in the same template. There's not really a compelling reason to name a view if its the only one, \n\t * but you could if you wanted, like so:\n\t * <pre>\n\t * <div ui-view=\"main\"></div>\n\t * </pre> \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * Really though, you'll use views to set up multiple views:\n\t * <pre>\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div> \n\t * <div ui-view=\"data\"></div> \n\t * </pre>\n\t * \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * <pre>\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * </pre>\n\t */\n\t$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\n\tfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\t\n\t  function getService() {\n\t    return ($injector.has) ? function(service) {\n\t      return $injector.has(service) ? $injector.get(service) : null;\n\t    } : function(service) {\n\t      try {\n\t        return $injector.get(service);\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var service = getService(),\n\t      $animator = service('$animator'),\n\t      $animate = service('$animate');\n\t\n\t  // Returns a set of DOM manipulation functions based on which Angular version\n\t  // it should use\n\t  function getRenderer(attrs, scope) {\n\t    var statics = function() {\n\t      return {\n\t        enter: function (element, target, cb) { target.after(element); cb(); },\n\t        leave: function (element, cb) { element.remove(); cb(); }\n\t      };\n\t    };\n\t\n\t    if ($animate) {\n\t      return {\n\t        enter: function(element, target, cb) {\n\t          var promise = $animate.enter(element, null, target, cb);\n\t          if (promise && promise.then) promise.then(cb);\n\t        },\n\t        leave: function(element, cb) {\n\t          var promise = $animate.leave(element, cb);\n\t          if (promise && promise.then) promise.then(cb);\n\t        }\n\t      };\n\t    }\n\t\n\t    if ($animator) {\n\t      var animate = $animator && $animator(scope, attrs);\n\t\n\t      return {\n\t        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n\t        leave: function(element, cb) { animate.leave(element); cb(); }\n\t      };\n\t    }\n\t\n\t    return statics();\n\t  }\n\t\n\t  var directive = {\n\t    restrict: 'ECA',\n\t    terminal: true,\n\t    priority: 400,\n\t    transclude: 'element',\n\t    compile: function (tElement, tAttrs, $transclude) {\n\t      return function (scope, $element, attrs) {\n\t        var previousEl, currentEl, currentScope, latestLocals,\n\t            onloadExp     = attrs.onload || '',\n\t            autoScrollExp = attrs.autoscroll,\n\t            renderer      = getRenderer(attrs, scope);\n\t\n\t        scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t        scope.$on('$viewContentLoading', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        updateView(true);\n\t\n\t        function cleanupLastView() {\n\t          if (previousEl) {\n\t            previousEl.remove();\n\t            previousEl = null;\n\t          }\n\t\n\t          if (currentScope) {\n\t            currentScope.$destroy();\n\t            currentScope = null;\n\t          }\n\t\n\t          if (currentEl) {\n\t            renderer.leave(currentEl, function() {\n\t              previousEl = null;\n\t            });\n\t\n\t            previousEl = currentEl;\n\t            currentEl = null;\n\t          }\n\t        }\n\t\n\t        function updateView(firstTime) {\n\t          var newScope,\n\t              name            = getUiViewName(scope, attrs, $element, $interpolate),\n\t              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\t\n\t          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n\t          newScope = scope.$new();\n\t          latestLocals = $state.$current.locals[name];\n\t\n\t          var clone = $transclude(newScope, function(clone) {\n\t            renderer.enter(clone, $element, function onUiViewEnter() {\n\t              if(currentScope) {\n\t                currentScope.$emit('$viewContentAnimationEnded');\n\t              }\n\t\n\t              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                $uiViewScroll(clone);\n\t              }\n\t            });\n\t            cleanupLastView();\n\t          });\n\t\n\t          currentEl = clone;\n\t          currentScope = newScope;\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description           *\n\t           * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           */\n\t          currentScope.$emit('$viewContentLoaded');\n\t          currentScope.$eval(onloadExp);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  return directive;\n\t}\n\t\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\n\tfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n\t  return {\n\t    restrict: 'ECA',\n\t    priority: -400,\n\t    compile: function (tElement) {\n\t      var initial = tElement.html();\n\t      return function (scope, $element, attrs) {\n\t        var current = $state.$current,\n\t            name = getUiViewName(scope, attrs, $element, $interpolate),\n\t            locals  = current && current.locals[name];\n\t\n\t        if (! locals) {\n\t          return;\n\t        }\n\t\n\t        $element.data('$uiView', { name: name, state: locals.$$state });\n\t        $element.html(locals.$template ? locals.$template : initial);\n\t\n\t        var link = $compile($element.contents());\n\t\n\t        if (locals.$$controller) {\n\t          locals.$scope = scope;\n\t          locals.$element = $element;\n\t          var controller = $controller(locals.$$controller, locals);\n\t          if (locals.$$controllerAs) {\n\t            scope[locals.$$controllerAs] = controller;\n\t          }\n\t          $element.data('$ngControllerController', controller);\n\t          $element.children().data('$ngControllerController', controller);\n\t        }\n\t\n\t        link(scope);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Shared ui-view code for both directives:\n\t * Given scope, element, and its attributes, return the view's name\n\t */\n\tfunction getUiViewName(scope, attrs, element, $interpolate) {\n\t  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n\t  var inherited = element.inheritedData('$uiView');\n\t  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n\t}\n\t\n\tangular.module('ui.router.state').directive('uiView', $ViewDirective);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\tfunction parseStateRef(ref, current) {\n\t  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n\t  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t  return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t\n\tfunction stateContext(el) {\n\t  var stateData = el.parent().inheritedData('$uiView');\n\t\n\t  if (stateData && stateData.state && stateData.state.name) {\n\t    return stateData.state;\n\t  }\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $timeout\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n\t * URL, the directive will automatically generate & update the `href` attribute via \n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n\t * the link will trigger a state transition with optional parameters. \n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative \n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the \n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * @example\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n\t * following template:\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t * \n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t * \n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t * \n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n\t */\n\t$StateRefDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDirective($state, $timeout) {\n\t  var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];\n\t\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n\t      var params = null, url = null, base = stateContext(element) || $state.$current;\n\t      // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t      var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?\n\t                 'xlink:href' : 'href';\n\t      var newHref = null, isAnchor = element.prop(\"tagName\").toUpperCase() === \"A\";\n\t      var isForm = element[0].nodeName === \"FORM\";\n\t      var attr = isForm ? \"action\" : hrefKind, nav = true;\n\t\n\t      var options = { relative: base, inherit: true };\n\t      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\t\n\t      angular.forEach(allowedOptions, function(option) {\n\t        if (option in optionsOverride) {\n\t          options[option] = optionsOverride[option];\n\t        }\n\t      });\n\t\n\t      var update = function(newVal) {\n\t        if (newVal) params = angular.copy(newVal);\n\t        if (!nav) return;\n\t\n\t        newHref = $state.href(ref.state, params, options);\n\t\n\t        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n\t        if (activeDirective) {\n\t          activeDirective.$$addStateInfo(ref.state, params);\n\t        }\n\t        if (newHref === null) {\n\t          nav = false;\n\t          return false;\n\t        }\n\t        attrs.$set(attr, newHref);\n\t      };\n\t\n\t      if (ref.paramExpr) {\n\t        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n\t          if (newVal !== params) update(newVal);\n\t        }, true);\n\t        params = angular.copy(scope.$eval(ref.paramExpr));\n\t      }\n\t      update();\n\t\n\t      if (isForm) return;\n\t\n\t      element.bind(\"click\", function(e) {\n\t        var button = e.which || e.button;\n\t        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n\t          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t          var transition = $timeout(function() {\n\t            $state.go(ref.state, params, options);\n\t          });\n\t          e.preventDefault();\n\t\n\t          // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t          var ignorePreventDefaultCount = isAnchor && !newHref ? 1: 0;\n\t          e.preventDefault = function() {\n\t            if (ignorePreventDefaultCount-- <= 0)\n\t              $timeout.cancel(transition);\n\t          };\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use\n\t * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n\t *\n\t * @example\n\t * Given the following template:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active-eq\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n\t * when the exact target state used in the `ui-sref` is active; no child states.\n\t *\n\t */\n\t$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n\tfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n\t  return  {\n\t    restrict: \"A\",\n\t    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n\t      var states = [], activeClass;\n\t\n\t      // There probably isn't much point in $observing this\n\t      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t      // slight difference in logic routing\n\t      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\t\n\t      // Allow uiSref to communicate with uiSrefActive[Equals]\n\t      this.$$addStateInfo = function (newState, newParams) {\n\t        var state = $state.get(newState, stateContext($element));\n\t\n\t        states.push({\n\t          state: state || { name: newState },\n\t          params: newParams\n\t        });\n\t\n\t        update();\n\t      };\n\t\n\t      $scope.$on('$stateChangeSuccess', update);\n\t\n\t      // Update route state\n\t      function update() {\n\t        if (anyMatch()) {\n\t          $element.addClass(activeClass);\n\t        } else {\n\t          $element.removeClass(activeClass);\n\t        }\n\t      }\n\t\n\t      function anyMatch() {\n\t        for (var i = 0; i < states.length; i++) {\n\t          if (isMatch(states[i].state, states[i].params)) {\n\t            return true;\n\t          }\n\t        }\n\t        return false;\n\t      }\n\t\n\t      function isMatch(state, params) {\n\t        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n\t          return $state.is(state.name, params);\n\t        } else {\n\t          return $state.includes(state.name, params);\n\t        }\n\t      }\n\t    }]\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .directive('uiSref', $StateRefDirective)\n\t  .directive('uiSrefActive', $StateRefActiveDirective)\n\t  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t  var isFilter = function (state) {\n\t    return $state.is(state);\n\t  };\n\t  isFilter.$stateful = true;\n\t  return isFilter;\n\t}\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t  var includesFilter = function (state) {\n\t    return $state.includes(state);\n\t  };\n\t  includesFilter.$stateful = true;\n\t  return  includesFilter;\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .filter('isState', $IsStateFilter)\n\t  .filter('includedByState', $IncludedByStateFilter);\n\t})(window, window.angular);\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t  'use strict';\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = factory(require('angular'));\n\t  } else {\n\t    // Browser globals (root is window), we don't register it.\n\t    factory(root.angular);\n\t  }\n\t}(this , function (angular) {\n\t    'use strict';\n\t\n\t    // RequireJS does not pass in Angular to us (will be undefined).\n\t    // Fallback to window which should mostly be there.\n\t    angular = (angular && angular.module ) ? angular : window.angular;\n\t\n\t    /**\n\t     * @ngdoc overview\n\t     * @name ngStorage\n\t     */\n\t\n\t    return angular.module('ngStorage', [])\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$localStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$localStorage', _storageProvider('localStorage'))\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$sessionStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\t\n\t    function _storageProvider(storageType) {\n\t        return function () {\n\t          var storageKeyPrefix = 'ngStorage-';\n\t\n\t          this.setKeyPrefix = function (prefix) {\n\t            if (typeof prefix !== 'string') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n\t            }\n\t            storageKeyPrefix = prefix;\n\t          };\n\t\n\t          var serializer = angular.toJson;\n\t          var deserializer = angular.fromJson;\n\t\n\t          this.setSerializer = function (s) {\n\t            if (typeof s !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n\t            }\n\t\n\t            serializer = s;\n\t          };\n\t\n\t          this.setDeserializer = function (d) {\n\t            if (typeof d !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n\t            }\n\t\n\t            deserializer = d;\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.get = function (key) {\n\t            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.set = function (key, value) {\n\t            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n\t          };\n\t\n\t          this.$get = [\n\t              '$rootScope',\n\t              '$window',\n\t              '$log',\n\t              '$timeout',\n\t\n\t              function(\n\t                  $rootScope,\n\t                  $window,\n\t                  $log,\n\t                  $timeout\n\t              ){\n\t                function isStorageSupported(storageType) {\n\t\n\t                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n\t                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n\t                    // that error and allow execution to continue.\n\t\n\t                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n\t                    // when \"Block cookies\": \"Always block\" is turned on\n\t                    var supported;\n\t                    try {\n\t                        supported = $window[storageType];\n\t                    }\n\t                    catch (err) {\n\t                        supported = false;\n\t                    }\n\t\n\t                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n\t                    // is available, but trying to call .setItem throws an exception below:\n\t                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n\t                    if (supported && storageType === 'localStorage') {\n\t                        var key = '__' + Math.round(Math.random() * 1e7);\n\t\n\t                        try {\n\t                            localStorage.setItem(key, key);\n\t                            localStorage.removeItem(key);\n\t                        }\n\t                        catch (err) {\n\t                            supported = false;\n\t                        }\n\t                    }\n\t\n\t                    return supported;\n\t                }\n\t\n\t                // The magic number 10 is used which only works for some keyPrefixes...\n\t                // See https://github.com/gsklee/ngStorage/issues/137\n\t                var prefixLength = storageKeyPrefix.length;\n\t\n\t                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n\t                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop}),\n\t                    $storage = {\n\t                        $default: function(items) {\n\t                            for (var k in items) {\n\t                                angular.isDefined($storage[k]) || ($storage[k] = items[k]);\n\t                            }\n\t\n\t                            $storage.$sync();\n\t                            return $storage;\n\t                        },\n\t                        $reset: function(items) {\n\t                            for (var k in $storage) {\n\t                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n\t                            }\n\t\n\t                            return $storage.$default(items);\n\t                        },\n\t                        $sync: function () {\n\t                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n\t                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n\t                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n\t                            }\n\t                        },\n\t                        $apply: function() {\n\t                            var temp$storage;\n\t\n\t                            _debounce = null;\n\t\n\t                            if (!angular.equals($storage, _last$storage)) {\n\t                                temp$storage = angular.copy(_last$storage);\n\t                                angular.forEach($storage, function(v, k) {\n\t                                    if (angular.isDefined(v) && '$' !== k[0]) {\n\t                                        webStorage.setItem(storageKeyPrefix + k, serializer(v))\n\t                                        delete temp$storage[k];\n\t                                    }\n\t                                });\n\t\n\t                                for (var k in temp$storage) {\n\t                                    webStorage.removeItem(storageKeyPrefix + k);\n\t                                }\n\t\n\t                                _last$storage = angular.copy($storage);\n\t                            }\n\t                        },\n\t                    },\n\t                    _last$storage,\n\t                    _debounce;\n\t\n\t                $storage.$sync();\n\t\n\t                _last$storage = angular.copy($storage);\n\t\n\t                $rootScope.$watch(function() {\n\t                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n\t                });\n\t\n\t                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n\t                $window.addEventListener && $window.addEventListener('storage', function(event) {\n\t                    if (storageKeyPrefix === event.key.slice(0, prefixLength)) {\n\t                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\t\n\t                        _last$storage = angular.copy($storage);\n\t\n\t                        $rootScope.$apply();\n\t                    }\n\t                });\n\t\n\t                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n\t                    $storage.$apply();\n\t                });\n\t\n\t                return $storage;\n\t            }\n\t        ];\n\t      };\n\t    }\n\t\n\t}));\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/**\n\t * oclazyload - Load modules on demand (lazy load) with angularJS\n\t * @version v1.0.6\n\t * @link https://github.com/ocombe/ocLazyLoad\n\t * @license MIT\n\t * @author Olivier Combe <olivier.combe@gmail.com>\n\t */\n\t(function (angular, window) {\n\t    'use strict';\n\t\n\t    var regModules = ['ng', 'oc.lazyLoad'],\n\t        regInvokes = {},\n\t        regConfigs = [],\n\t        modulesToLoad = [],\n\t        // modules to load from angular.module or other sources\n\t    realModules = [],\n\t        // real modules called from angular.module\n\t    recordDeclarations = [],\n\t        broadcast = angular.noop,\n\t        runBlocks = {},\n\t        justLoaded = [];\n\t\n\t    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\t\n\t    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n\t        var modules = {},\n\t            providers = {\n\t            $controllerProvider: $controllerProvider,\n\t            $compileProvider: $compileProvider,\n\t            $filterProvider: $filterProvider,\n\t            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n\t            $injector: $injector,\n\t            $animateProvider: $animateProvider\n\t        },\n\t            debug = false,\n\t            events = false,\n\t            moduleCache = [],\n\t            modulePromises = {};\n\t\n\t        moduleCache.push = function (value) {\n\t            if (this.indexOf(value) === -1) {\n\t                Array.prototype.push.apply(this, arguments);\n\t            }\n\t        };\n\t\n\t        this.config = function (config) {\n\t            // If we want to define modules configs\n\t            if (angular.isDefined(config.modules)) {\n\t                if (angular.isArray(config.modules)) {\n\t                    angular.forEach(config.modules, function (moduleConfig) {\n\t                        modules[moduleConfig.name] = moduleConfig;\n\t                    });\n\t                } else {\n\t                    modules[config.modules.name] = config.modules;\n\t                }\n\t            }\n\t\n\t            if (angular.isDefined(config.debug)) {\n\t                debug = config.debug;\n\t            }\n\t\n\t            if (angular.isDefined(config.events)) {\n\t                events = config.events;\n\t            }\n\t        };\n\t\n\t        /**\r\n\t         * Get the list of existing registered modules\r\n\t         * @param element\r\n\t         */\n\t        this._init = function _init(element) {\n\t            // this is probably useless now because we override angular.bootstrap\n\t            if (modulesToLoad.length === 0) {\n\t                var elements = [element],\n\t                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n\t                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n\t                    append = function append(elm) {\n\t                    return elm && elements.push(elm);\n\t                };\n\t\n\t                angular.forEach(names, function (name) {\n\t                    names[name] = true;\n\t                    append(document.getElementById(name));\n\t                    name = name.replace(':', '\\\\:');\n\t                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n\t                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n\t                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n\t                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n\t                    }\n\t                });\n\t\n\t                angular.forEach(elements, function (elm) {\n\t                    if (modulesToLoad.length === 0) {\n\t                        var className = ' ' + element.className + ' ';\n\t                        var match = NG_APP_CLASS_REGEXP.exec(className);\n\t                        if (match) {\n\t                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n\t                        } else {\n\t                            angular.forEach(elm.attributes, function (attr) {\n\t                                if (modulesToLoad.length === 0 && names[attr.name]) {\n\t                                    modulesToLoad.push(attr.value);\n\t                                }\n\t                            });\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t\n\t            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n\t                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n\t            }\n\t\n\t            var addReg = function addReg(moduleName) {\n\t                if (regModules.indexOf(moduleName) === -1) {\n\t                    // register existing modules\n\t                    regModules.push(moduleName);\n\t                    var mainModule = angular.module(moduleName);\n\t\n\t                    // register existing components (directives, services, ...)\n\t                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n\t                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\t\n\t                    angular.forEach(mainModule.requires, addReg);\n\t                }\n\t            };\n\t\n\t            angular.forEach(modulesToLoad, function (moduleName) {\n\t                addReg(moduleName);\n\t            });\n\t\n\t            modulesToLoad = []; // reset for next bootstrap\n\t            recordDeclarations.pop(); // wait for the next lazy load\n\t        };\n\t\n\t        /**\r\n\t         * Like JSON.stringify but that doesn't throw on circular references\r\n\t         * @param obj\r\n\t         */\n\t        var stringify = function stringify(obj) {\n\t            try {\n\t                return JSON.stringify(obj);\n\t            } catch (e) {\n\t                var cache = [];\n\t                return JSON.stringify(obj, function (key, value) {\n\t                    if (angular.isObject(value) && value !== null) {\n\t                        if (cache.indexOf(value) !== -1) {\n\t                            // Circular reference found, discard key\n\t                            return;\n\t                        }\n\t                        // Store value in our collection\n\t                        cache.push(value);\n\t                    }\n\t                    return value;\n\t                });\n\t            }\n\t        };\n\t\n\t        var hashCode = function hashCode(str) {\n\t            var hash = 0,\n\t                i,\n\t                chr,\n\t                len;\n\t            if (str.length == 0) {\n\t                return hash;\n\t            }\n\t            for (i = 0, len = str.length; i < len; i++) {\n\t                chr = str.charCodeAt(i);\n\t                hash = (hash << 5) - hash + chr;\n\t                hash |= 0; // Convert to 32bit integer\n\t            }\n\t            return hash;\n\t        };\n\t\n\t        function _register(providers, registerModules, params) {\n\t            if (registerModules) {\n\t                var k,\n\t                    moduleName,\n\t                    moduleFn,\n\t                    tempRunBlocks = [];\n\t                for (k = registerModules.length - 1; k >= 0; k--) {\n\t                    moduleName = registerModules[k];\n\t                    if (!angular.isString(moduleName)) {\n\t                        moduleName = getModuleName(moduleName);\n\t                    }\n\t                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n\t                        continue;\n\t                    }\n\t                    // new if not registered\n\t                    var newModule = regModules.indexOf(moduleName) === -1;\n\t                    moduleFn = ngModuleFct(moduleName);\n\t                    if (newModule) {\n\t                        regModules.push(moduleName);\n\t                        _register(providers, moduleFn.requires, params);\n\t                    }\n\t                    if (moduleFn._runBlocks.length > 0) {\n\t                        // new run blocks detected! Replace the old ones (if existing)\n\t                        runBlocks[moduleName] = [];\n\t                        while (moduleFn._runBlocks.length > 0) {\n\t                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n\t                        }\n\t                    }\n\t                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n\t                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n\t                    }\n\t                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n\t                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n\t                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n\t                    registerModules.pop();\n\t                    justLoaded.push(moduleName);\n\t                }\n\t                // execute the run blocks at the end\n\t                var instanceInjector = providers.getInstanceInjector();\n\t                angular.forEach(tempRunBlocks, function (fn) {\n\t                    instanceInjector.invoke(fn);\n\t                });\n\t            }\n\t        }\n\t\n\t        function _registerInvokeList(args, moduleName) {\n\t            var invokeList = args[2][0],\n\t                type = args[1],\n\t                newInvoke = false;\n\t            if (angular.isUndefined(regInvokes[moduleName])) {\n\t                regInvokes[moduleName] = {};\n\t            }\n\t            if (angular.isUndefined(regInvokes[moduleName][type])) {\n\t                regInvokes[moduleName][type] = {};\n\t            }\n\t            var onInvoke = function onInvoke(invokeName, invoke) {\n\t                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n\t                    regInvokes[moduleName][type][invokeName] = [];\n\t                }\n\t                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n\t                    newInvoke = true;\n\t                    regInvokes[moduleName][type][invokeName].push(invoke);\n\t                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n\t                }\n\t            };\n\t\n\t            function checkHashes(potentialNew, invokes) {\n\t                var isNew = true,\n\t                    newHash;\n\t                if (invokes.length) {\n\t                    newHash = signature(potentialNew);\n\t                    angular.forEach(invokes, function (invoke) {\n\t                        isNew = isNew && signature(invoke) !== newHash;\n\t                    });\n\t                }\n\t                return isNew;\n\t            }\n\t\n\t            function signature(data) {\n\t                if (angular.isArray(data)) {\n\t                    // arrays are objects, we need to test for it first\n\t                    return hashCode(data.toString());\n\t                } else if (angular.isObject(data)) {\n\t                    // constants & values for example\n\t                    return hashCode(stringify(data));\n\t                } else {\n\t                    if (angular.isDefined(data) && data !== null) {\n\t                        return hashCode(data.toString());\n\t                    } else {\n\t                        // null & undefined constants\n\t                        return data;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (angular.isString(invokeList)) {\n\t                onInvoke(invokeList, args[2][1]);\n\t            } else if (angular.isObject(invokeList)) {\n\t                angular.forEach(invokeList, function (invoke, key) {\n\t                    if (angular.isString(invoke)) {\n\t                        // decorators for example\n\t                        onInvoke(invoke, invokeList[1]);\n\t                    } else {\n\t                        // components registered as object lists {\"componentName\": function() {}}\n\t                        onInvoke(key, invoke);\n\t                    }\n\t                });\n\t            } else {\n\t                return false;\n\t            }\n\t            return newInvoke;\n\t        }\n\t\n\t        function _invokeQueue(providers, queue, moduleName, reconfig) {\n\t            if (!queue) {\n\t                return;\n\t            }\n\t\n\t            var i, len, args, provider;\n\t            for (i = 0, len = queue.length; i < len; i++) {\n\t                args = queue[i];\n\t                if (angular.isArray(args)) {\n\t                    if (providers !== null) {\n\t                        if (providers.hasOwnProperty(args[0])) {\n\t                            provider = providers[args[0]];\n\t                        } else {\n\t                            throw new Error('unsupported provider ' + args[0]);\n\t                        }\n\t                    }\n\t                    var isNew = _registerInvokeList(args, moduleName);\n\t                    if (args[1] !== 'invoke') {\n\t                        if (isNew && angular.isDefined(provider)) {\n\t                            provider[args[1]].apply(provider, args[2]);\n\t                        }\n\t                    } else {\n\t                        // config block\n\t                        var callInvoke = function callInvoke(fct) {\n\t                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n\t                            if (invoked === -1 || reconfig) {\n\t                                if (invoked === -1) {\n\t                                    regConfigs.push(moduleName + '-' + fct);\n\t                                }\n\t                                if (angular.isDefined(provider)) {\n\t                                    provider[args[1]].apply(provider, args[2]);\n\t                                }\n\t                            }\n\t                        };\n\t                        if (angular.isFunction(args[2][0])) {\n\t                            callInvoke(args[2][0]);\n\t                        } else if (angular.isArray(args[2][0])) {\n\t                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n\t                                if (angular.isFunction(args[2][0][j])) {\n\t                                    callInvoke(args[2][0][j]);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function getModuleName(module) {\n\t            var moduleName = null;\n\t            if (angular.isString(module)) {\n\t                moduleName = module;\n\t            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n\t                moduleName = module.name;\n\t            }\n\t            return moduleName;\n\t        }\n\t\n\t        function moduleExists(moduleName) {\n\t            if (!angular.isString(moduleName)) {\n\t                return false;\n\t            }\n\t            try {\n\t                return ngModuleFct(moduleName);\n\t            } catch (e) {\n\t                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t\n\t        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n\t            var instanceInjector,\n\t                filesCache = $cacheFactory('ocLazyLoad');\n\t\n\t            if (!debug) {\n\t                $log = {};\n\t                $log['error'] = angular.noop;\n\t                $log['warn'] = angular.noop;\n\t                $log['info'] = angular.noop;\n\t            }\n\t\n\t            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n\t            providers.getInstanceInjector = function () {\n\t                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n\t            };\n\t\n\t            broadcast = function broadcast(eventName, params) {\n\t                if (events) {\n\t                    $rootScope.$broadcast(eventName, params);\n\t                }\n\t                if (debug) {\n\t                    $log.info(eventName, params);\n\t                }\n\t            };\n\t\n\t            function reject(e) {\n\t                var deferred = $q.defer();\n\t                $log.error(e.message);\n\t                deferred.reject(e);\n\t                return deferred.promise;\n\t            }\n\t\n\t            return {\n\t                _broadcast: broadcast,\n\t\n\t                _$log: $log,\n\t\n\t                /**\r\n\t                 * Returns the files cache used by the loaders to store the files currently loading\r\n\t                 * @returns {*}\r\n\t                 */\n\t                _getFilesCache: function getFilesCache() {\n\t                    return filesCache;\n\t                },\n\t\n\t                /**\r\n\t                 * Let the service know that it should monitor angular.module because files are loading\r\n\t                 * @param watch boolean\r\n\t                 */\n\t                toggleWatch: function toggleWatch(watch) {\n\t                    if (watch) {\n\t                        recordDeclarations.push(true);\n\t                    } else {\n\t                        recordDeclarations.pop();\n\t                    }\n\t                },\n\t\n\t                /**\r\n\t                 * Let you get a module config object\r\n\t                 * @param moduleName String the name of the module\r\n\t                 * @returns {*}\r\n\t                 */\n\t                getModuleConfig: function getModuleConfig(moduleName) {\n\t                    if (!angular.isString(moduleName)) {\n\t                        throw new Error('You need to give the name of the module to get');\n\t                    }\n\t                    if (!modules[moduleName]) {\n\t                        return null;\n\t                    }\n\t                    return angular.copy(modules[moduleName]);\n\t                },\n\t\n\t                /**\r\n\t                 * Let you define a module config object\r\n\t                 * @param moduleConfig Object the module config object\r\n\t                 * @returns {*}\r\n\t                 */\n\t                setModuleConfig: function setModuleConfig(moduleConfig) {\n\t                    if (!angular.isObject(moduleConfig)) {\n\t                        throw new Error('You need to give the module config object to set');\n\t                    }\n\t                    modules[moduleConfig.name] = moduleConfig;\n\t                    return moduleConfig;\n\t                },\n\t\n\t                /**\r\n\t                 * Returns the list of loaded modules\r\n\t                 * @returns {string[]}\r\n\t                 */\n\t                getModules: function getModules() {\n\t                    return regModules;\n\t                },\n\t\n\t                /**\r\n\t                 * Let you check if a module has been loaded into Angular or not\r\n\t                 * @param modulesNames String/Object a module name, or a list of module names\r\n\t                 * @returns {boolean}\r\n\t                 */\n\t                isLoaded: function isLoaded(modulesNames) {\n\t                    var moduleLoaded = function moduleLoaded(module) {\n\t                        var isLoaded = regModules.indexOf(module) > -1;\n\t                        if (!isLoaded) {\n\t                            isLoaded = !!moduleExists(module);\n\t                        }\n\t                        return isLoaded;\n\t                    };\n\t                    if (angular.isString(modulesNames)) {\n\t                        modulesNames = [modulesNames];\n\t                    }\n\t                    if (angular.isArray(modulesNames)) {\n\t                        var i, len;\n\t                        for (i = 0, len = modulesNames.length; i < len; i++) {\n\t                            if (!moduleLoaded(modulesNames[i])) {\n\t                                return false;\n\t                            }\n\t                        }\n\t                        return true;\n\t                    } else {\n\t                        throw new Error('You need to define the module(s) name(s)');\n\t                    }\n\t                },\n\t\n\t                /**\r\n\t                 * Given a module, return its name\r\n\t                 * @param module\r\n\t                 * @returns {String}\r\n\t                 */\n\t                _getModuleName: getModuleName,\n\t\n\t                /**\r\n\t                 * Returns a module if it exists\r\n\t                 * @param moduleName\r\n\t                 * @returns {module}\r\n\t                 */\n\t                _getModule: function getModule(moduleName) {\n\t                    try {\n\t                        return ngModuleFct(moduleName);\n\t                    } catch (e) {\n\t                        // this error message really suxx\n\t                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n\t                        }\n\t                        throw e;\n\t                    }\n\t                },\n\t\n\t                /**\r\n\t                 * Check if a module exists and returns it if it does\r\n\t                 * @param moduleName\r\n\t                 * @returns {boolean}\r\n\t                 */\n\t                moduleExists: moduleExists,\n\t\n\t                /**\r\n\t                 * Load the dependencies, and might try to load new files depending on the config\r\n\t                 * @param moduleName (String or Array of Strings)\r\n\t                 * @param localParams\r\n\t                 * @returns {*}\r\n\t                 * @private\r\n\t                 */\n\t                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n\t                    var loadedModule,\n\t                        requires,\n\t                        diff,\n\t                        promisesList = [],\n\t                        self = this;\n\t\n\t                    moduleName = self._getModuleName(moduleName);\n\t\n\t                    if (moduleName === null) {\n\t                        return $q.when();\n\t                    } else {\n\t                        try {\n\t                            loadedModule = self._getModule(moduleName);\n\t                        } catch (e) {\n\t                            return reject(e);\n\t                        }\n\t                        // get unloaded requires\n\t                        requires = self.getRequires(loadedModule);\n\t                    }\n\t\n\t                    angular.forEach(requires, function (requireEntry) {\n\t                        // If no configuration is provided, try and find one from a previous load.\n\t                        // If there isn't one, bail and let the normal flow run\n\t                        if (angular.isString(requireEntry)) {\n\t                            var config = self.getModuleConfig(requireEntry);\n\t                            if (config === null) {\n\t                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n\t                                return;\n\t                            }\n\t                            requireEntry = config;\n\t                            // ignore the name because it's probably not a real module name\n\t                            config.name = undefined;\n\t                        }\n\t\n\t                        // Check if this dependency has been loaded previously\n\t                        if (self.moduleExists(requireEntry.name)) {\n\t                            // compare against the already loaded module to see if the new definition adds any new files\n\t                            diff = requireEntry.files.filter(function (n) {\n\t                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n\t                            });\n\t\n\t                            // If the module was redefined, advise via the console\n\t                            if (diff.length !== 0) {\n\t                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n\t                            }\n\t\n\t                            // Push everything to the file loader, it will weed out the duplicates.\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                            return;\n\t                        } else if (angular.isArray(requireEntry)) {\n\t                            var files = [];\n\t                            angular.forEach(requireEntry, function (entry) {\n\t                                // let's check if the entry is a file name or a config name\n\t                                var config = self.getModuleConfig(entry);\n\t                                if (config === null) {\n\t                                    files.push(entry);\n\t                                } else if (config.files) {\n\t                                    files = files.concat(config.files);\n\t                                }\n\t                            });\n\t                            if (files.length > 0) {\n\t                                requireEntry = {\n\t                                    files: files\n\t                                };\n\t                            }\n\t                        } else if (angular.isObject(requireEntry)) {\n\t                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n\t                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n\t                                self.setModuleConfig(requireEntry);\n\t                                moduleCache.push(requireEntry['name']);\n\t                            }\n\t                        }\n\t\n\t                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n\t                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                        }\n\t                    });\n\t\n\t                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n\t                    return $q.all(promisesList);\n\t                },\n\t\n\t                /**\r\n\t                 * Inject new modules into Angular\r\n\t                 * @param moduleName\r\n\t                 * @param localParams\r\n\t                 * @param real\r\n\t                 */\n\t                inject: function inject(moduleName) {\n\t                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\t\n\t                    var self = this,\n\t                        deferred = $q.defer();\n\t                    if (angular.isDefined(moduleName) && moduleName !== null) {\n\t                        if (angular.isArray(moduleName)) {\n\t                            var promisesList = [];\n\t                            angular.forEach(moduleName, function (module) {\n\t                                promisesList.push(self.inject(moduleName, localParams, real));\n\t                            });\n\t                            return $q.all(promisesList);\n\t                        } else {\n\t                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n\t                        }\n\t                    }\n\t                    if (modulesToLoad.length > 0) {\n\t                        var res = modulesToLoad.slice(); // clean copy\n\t                        var loadNext = function loadNext(moduleName) {\n\t                            moduleCache.push(moduleName);\n\t                            modulePromises[moduleName] = deferred.promise;\n\t                            self._loadDependencies(moduleName, localParams).then(function success() {\n\t                                try {\n\t                                    justLoaded = [];\n\t                                    _register(providers, moduleCache, localParams);\n\t                                } catch (e) {\n\t                                    self._$log.error(e.message);\n\t                                    deferred.reject(e);\n\t                                    return;\n\t                                }\n\t\n\t                                if (modulesToLoad.length > 0) {\n\t                                    loadNext(modulesToLoad.shift()); // load the next in list\n\t                                } else {\n\t                                        deferred.resolve(res); // everything has been loaded, resolve\n\t                                    }\n\t                            }, function error(err) {\n\t                                deferred.reject(err);\n\t                            });\n\t                        };\n\t\n\t                        // load the first in list\n\t                        loadNext(modulesToLoad.shift());\n\t                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n\t                        return modulePromises[localParams.name];\n\t                    } else {\n\t                        deferred.resolve();\n\t                    }\n\t                    return deferred.promise;\n\t                },\n\t\n\t                /**\r\n\t                 * Get the list of required modules/services/... for this module\r\n\t                 * @param module\r\n\t                 * @returns {Array}\r\n\t                 */\n\t                getRequires: function getRequires(module) {\n\t                    var requires = [];\n\t                    angular.forEach(module.requires, function (requireModule) {\n\t                        if (regModules.indexOf(requireModule) === -1) {\n\t                            requires.push(requireModule);\n\t                        }\n\t                    });\n\t                    return requires;\n\t                },\n\t\n\t                /**\r\n\t                 * Invoke the new modules & component by their providers\r\n\t                 * @param providers\r\n\t                 * @param queue\r\n\t                 * @param moduleName\r\n\t                 * @param reconfig\r\n\t                 * @private\r\n\t                 */\n\t                _invokeQueue: _invokeQueue,\n\t\n\t                /**\r\n\t                 * Check if a module has been invoked and registers it if not\r\n\t                 * @param args\r\n\t                 * @param moduleName\r\n\t                 * @returns {boolean} is new\r\n\t                 */\n\t                _registerInvokeList: _registerInvokeList,\n\t\n\t                /**\r\n\t                 * Register a new module and loads it, executing the run/config blocks if needed\r\n\t                 * @param providers\r\n\t                 * @param registerModules\r\n\t                 * @param params\r\n\t                 * @private\r\n\t                 */\n\t                _register: _register,\n\t\n\t                /**\r\n\t                 * Add a module name to the list of modules that will be loaded in the next inject\r\n\t                 * @param name\r\n\t                 * @param force\r\n\t                 * @private\r\n\t                 */\n\t                _addToLoadList: _addToLoadList\n\t            };\n\t        }];\n\t\n\t        // Let's get the list of loaded modules & components\n\t        this._init(angular.element(window.document));\n\t    }]);\n\t\n\t    var bootstrapFct = angular.bootstrap;\n\t    angular.bootstrap = function (element, modules, config) {\n\t        // we use slice to make a clean copy\n\t        angular.forEach(modules.slice(), function (module) {\n\t            _addToLoadList(module, true, true);\n\t        });\n\t        return bootstrapFct(element, modules, config);\n\t    };\n\t\n\t    var _addToLoadList = function _addToLoadList(name, force, real) {\n\t        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n\t            modulesToLoad.push(name);\n\t            if (real) {\n\t                realModules.push(name);\n\t            }\n\t        }\n\t    };\n\t\n\t    var ngModuleFct = angular.module;\n\t    angular.module = function (name, requires, configFn) {\n\t        _addToLoadList(name, false, true);\n\t        return ngModuleFct(name, requires, configFn);\n\t    };\n\t\n\t    // CommonJS package manager support:\n\t    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n\t        module.exports = 'oc.lazyLoad';\n\t    }\n\t})(angular, window);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", function ($ocLazyLoad, $compile, $animate, $parse) {\n\t        return {\n\t            restrict: 'A',\n\t            terminal: true,\n\t            priority: 1000,\n\t            compile: function compile(element, attrs) {\n\t                // we store the content and remove it before compilation\n\t                var content = element.contents();\n\t                element.html('');\n\t\n\t                return function ($scope, $element, $attr) {\n\t                    var model = $parse($attr.ocLazyLoad);\n\t                    $scope.$watch(function () {\n\t                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n\t                    }, function (moduleName) {\n\t                        if (angular.isDefined(moduleName)) {\n\t                            $ocLazyLoad.load(moduleName).then(function () {\n\t                                $animate.enter($compile(content)($scope), $element);\n\t                            });\n\t                        }\n\t                    }, true);\n\t                };\n\t            }\n\t        };\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n\t            var uaCssChecked = false,\n\t                useCssLoadPatch = false,\n\t                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\t\n\t            /**\r\n\t             * Load a js/css file\r\n\t             * @param type\r\n\t             * @param path\r\n\t             * @param params\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.buildElement = function buildElement(type, path, params) {\n\t                var deferred = $q.defer(),\n\t                    el,\n\t                    loaded,\n\t                    filesCache = $delegate._getFilesCache(),\n\t                    cacheBuster = function cacheBuster(url) {\n\t                    var dc = new Date().getTime();\n\t                    if (url.indexOf('?') >= 0) {\n\t                        if (url.substring(0, url.length - 1) === '&') {\n\t                            return url + '_dc=' + dc;\n\t                        }\n\t                        return url + '&_dc=' + dc;\n\t                    } else {\n\t                        return url + '?_dc=' + dc;\n\t                    }\n\t                };\n\t\n\t                // Store the promise early so the file load can be detected by other parallel lazy loads\n\t                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n\t                // as it causes false positive load results.\n\t                if (angular.isUndefined(filesCache.get(path))) {\n\t                    filesCache.put(path, deferred.promise);\n\t                }\n\t\n\t                // Switch in case more content types are added later\n\t                switch (type) {\n\t                    case 'css':\n\t                        el = $window.document.createElement('link');\n\t                        el.type = 'text/css';\n\t                        el.rel = 'stylesheet';\n\t                        el.href = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    case 'js':\n\t                        el = $window.document.createElement('script');\n\t                        el.src = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    default:\n\t                        filesCache.remove(path);\n\t                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n\t                        break;\n\t                }\n\t                el.onload = el['onreadystatechange'] = function (e) {\n\t                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n\t                    el.onload = el['onreadystatechange'] = null;\n\t                    loaded = 1;\n\t                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n\t                    deferred.resolve();\n\t                };\n\t                el.onerror = function () {\n\t                    filesCache.remove(path);\n\t                    deferred.reject(new Error('Unable to load ' + path));\n\t                };\n\t                el.async = params.serie ? 0 : 1;\n\t\n\t                var insertBeforeElem = anchor.lastChild;\n\t                if (params.insertBefore) {\n\t                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n\t                    if (element && element.length > 0) {\n\t                        insertBeforeElem = element[0];\n\t                    }\n\t                }\n\t                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\t\n\t                /*\r\n\t                 The event load or readystatechange doesn't fire in:\r\n\t                 - iOS < 6       (default mobile browser)\r\n\t                 - Android < 4.4 (default mobile browser)\r\n\t                 - Safari < 6    (desktop browser)\r\n\t                 */\n\t                if (type == 'css') {\n\t                    if (!uaCssChecked) {\n\t                        var ua = $window.navigator.userAgent.toLowerCase();\n\t\n\t                        // iOS < 6\n\t                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n\t                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n\t                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n\t                            useCssLoadPatch = iOSVersion < 6;\n\t                        } else if (ua.indexOf(\"android\") > -1) {\n\t                            // Android < 4.4\n\t                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n\t                            useCssLoadPatch = androidVersion < 4.4;\n\t                        } else if (ua.indexOf('safari') > -1) {\n\t                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n\t                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n\t                        }\n\t                    }\n\t\n\t                    if (useCssLoadPatch) {\n\t                        var tries = 1000; // * 20 = 20000 miliseconds\n\t                        var interval = $interval(function () {\n\t                            try {\n\t                                el.sheet.cssRules;\n\t                                $interval.cancel(interval);\n\t                                el.onload();\n\t                            } catch (e) {\n\t                                if (--tries <= 0) {\n\t                                    el.onerror();\n\t                                }\n\t                            }\n\t                        }, 20);\n\t                    }\n\t                }\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\r\n\t             * The function that loads new files\r\n\t             * @param config\r\n\t             * @param params\r\n\t             * @returns {*}\r\n\t             */\n\t            $delegate.filesLoader = function filesLoader(config) {\n\t                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var cssFiles = [],\n\t                    templatesFiles = [],\n\t                    jsFiles = [],\n\t                    promises = [],\n\t                    cachePromise = null,\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                $delegate.toggleWatch(true); // start watching angular.module calls\n\t\n\t                angular.extend(params, config);\n\t\n\t                var pushFile = function pushFile(path) {\n\t                    var file_type = null,\n\t                        m;\n\t                    if (angular.isObject(path)) {\n\t                        file_type = path.type;\n\t                        path = path.path;\n\t                    }\n\t                    cachePromise = filesCache.get(path);\n\t                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\t\n\t                        // always check for requirejs syntax just in case\n\t                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n\t                            // Detect file type using preceding type declaration (ala requireJS)\n\t                            file_type = m[1];\n\t                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n\t                        }\n\t\n\t                        if (!file_type) {\n\t                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n\t                                // Detect file type via file extension\n\t                                file_type = m[1];\n\t                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('load')) {\n\t                                // requirejs\n\t                                file_type = 'js';\n\t                            } else {\n\t                                $delegate._$log.error('File type could not be determined. ' + path);\n\t                                return;\n\t                            }\n\t                        }\n\t\n\t                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n\t                            cssFiles.push(path);\n\t                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n\t                            templatesFiles.push(path);\n\t                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n\t                            jsFiles.push(path);\n\t                        } else {\n\t                            $delegate._$log.error('File type is not valid. ' + path);\n\t                        }\n\t                    } else if (cachePromise) {\n\t                        promises.push(cachePromise);\n\t                    }\n\t                };\n\t\n\t                if (params.serie) {\n\t                    pushFile(params.files.shift());\n\t                } else {\n\t                    angular.forEach(params.files, function (path) {\n\t                        pushFile(path);\n\t                    });\n\t                }\n\t\n\t                if (cssFiles.length > 0) {\n\t                    var cssDeferred = $q.defer();\n\t                    $delegate.cssLoader(cssFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            cssDeferred.reject(err);\n\t                        } else {\n\t                            cssDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(cssDeferred.promise);\n\t                }\n\t\n\t                if (templatesFiles.length > 0) {\n\t                    var templatesDeferred = $q.defer();\n\t                    $delegate.templatesLoader(templatesFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            templatesDeferred.reject(err);\n\t                        } else {\n\t                            templatesDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(templatesDeferred.promise);\n\t                }\n\t\n\t                if (jsFiles.length > 0) {\n\t                    var jsDeferred = $q.defer();\n\t                    $delegate.jsLoader(jsFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            jsDeferred.reject(err);\n\t                        } else {\n\t                            jsDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(jsDeferred.promise);\n\t                }\n\t\n\t                if (promises.length === 0) {\n\t                    var deferred = $q.defer(),\n\t                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n\t                    $delegate._$log.error(err);\n\t                    deferred.reject(err);\n\t                    return deferred.promise;\n\t                } else if (params.serie && params.files.length > 0) {\n\t                    return $q.all(promises).then(function () {\n\t                        return $delegate.filesLoader(config, params);\n\t                    });\n\t                } else {\n\t                    return $q.all(promises)['finally'](function (res) {\n\t                        $delegate.toggleWatch(false); // stop watching angular.module calls\n\t                        return res;\n\t                    });\n\t                }\n\t            };\n\t\n\t            /**\r\n\t             * Load a module or a list of modules into Angular\r\n\t             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n\t             * @param params Object optional parameters\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.load = function (originalModule) {\n\t                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var self = this,\n\t                    config = null,\n\t                    deferredList = [],\n\t                    deferred = $q.defer(),\n\t                    errText;\n\t\n\t                // clean copy\n\t                var module = angular.copy(originalModule);\n\t                var params = angular.copy(originalParams);\n\t\n\t                // If module is an array, break it down\n\t                if (angular.isArray(module)) {\n\t                    // Resubmit each entry as a single module\n\t                    angular.forEach(module, function (m) {\n\t                        deferredList.push(self.load(m, params));\n\t                    });\n\t\n\t                    // Resolve the promise once everything has loaded\n\t                    $q.all(deferredList).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t\n\t                    return deferred.promise;\n\t                }\n\t\n\t                // Get or Set a configuration depending on what was passed in\n\t                if (angular.isString(module)) {\n\t                    config = self.getModuleConfig(module);\n\t                    if (!config) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    }\n\t                } else if (angular.isObject(module)) {\n\t                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n\t                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    } else {\n\t                        config = self.setModuleConfig(module);\n\t                    }\n\t                }\n\t\n\t                if (config === null) {\n\t                    var moduleName = self._getModuleName(module);\n\t                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n\t                    $delegate._$log.error(errText);\n\t                    deferred.reject(new Error(errText));\n\t                    return deferred.promise;\n\t                } else {\n\t                    // deprecated\n\t                    if (angular.isDefined(config.template)) {\n\t                        if (angular.isUndefined(config.files)) {\n\t                            config.files = [];\n\t                        }\n\t                        if (angular.isString(config.template)) {\n\t                            config.files.push(config.template);\n\t                        } else if (angular.isArray(config.template)) {\n\t                            config.files.concat(config.template);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                var localParams = angular.extend({}, params, config);\n\t\n\t                // if someone used an external loader and called the load function with just the module name\n\t                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n\t                    return $delegate.inject(config.name, localParams, true);\n\t                }\n\t\n\t                $delegate.filesLoader(config, localParams).then(function () {\n\t                    $delegate.inject(null, localParams).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t                }, function (err) {\n\t                    deferred.reject(err);\n\t                });\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            // return the patched service\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * cssLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite cssLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.cssLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('css', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.cssLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * jsLoader function\n\t             * @type Function\n\t             * @param paths array list of js files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite jsLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.jsLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('js', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.jsLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n\t            /**\n\t             * templatesLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters for $http\n\t             * because the user can overwrite templatesLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.templatesLoader = function (paths, callback, params) {\n\t                var promises = [],\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                angular.forEach(paths, function (url) {\n\t                    var deferred = $q.defer();\n\t                    promises.push(deferred.promise);\n\t                    $http.get(url, params).success(function (data) {\n\t                        if (angular.isString(data) && data.length > 0) {\n\t                            angular.forEach(angular.element(data), function (node) {\n\t                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n\t                                    $templateCache.put(node.id, node.innerHTML);\n\t                                }\n\t                            });\n\t                        }\n\t                        if (angular.isUndefined(filesCache.get(url))) {\n\t                            filesCache.put(url, true);\n\t                        }\n\t                        deferred.resolve();\n\t                    }).error(function (err) {\n\t                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n\t                    });\n\t                });\n\t                return $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t// Array.indexOf polyfill for IE8\n\tif (!Array.prototype.indexOf) {\n\t    Array.prototype.indexOf = function (searchElement, fromIndex) {\n\t        var k;\n\t\n\t        // 1. Let O be the result of calling ToObject passing\n\t        //    the this value as the argument.\n\t        if (this == null) {\n\t            throw new TypeError('\"this\" is null or not defined');\n\t        }\n\t\n\t        var O = Object(this);\n\t\n\t        // 2. Let lenValue be the result of calling the Get\n\t        //    internal method of O with the argument \"length\".\n\t        // 3. Let len be ToUint32(lenValue).\n\t        var len = O.length >>> 0;\n\t\n\t        // 4. If len is 0, return -1.\n\t        if (len === 0) {\n\t            return -1;\n\t        }\n\t\n\t        // 5. If argument fromIndex was passed let n be\n\t        //    ToInteger(fromIndex); else let n be 0.\n\t        var n = +fromIndex || 0;\n\t\n\t        if (Math.abs(n) === Infinity) {\n\t            n = 0;\n\t        }\n\t\n\t        // 6. If n >= len, return -1.\n\t        if (n >= len) {\n\t            return -1;\n\t        }\n\t\n\t        // 7. If n >= 0, then Let k be n.\n\t        // 8. Else, n<0, Let k be len - abs(n).\n\t        //    If k is less than 0, then let k be 0.\n\t        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\t\n\t        // 9. Repeat, while k < len\n\t        while (k < len) {\n\t            // a. Let Pk be ToString(k).\n\t            //   This is implicit for LHS operands of the in operator\n\t            // b. Let kPresent be the result of calling the\n\t            //    HasProperty internal method of O with argument Pk.\n\t            //   This step can be combined with c\n\t            // c. If kPresent is true, then\n\t            //    i.  Let elementK be the result of calling the Get\n\t            //        internal method of O with the argument ToString(k).\n\t            //   ii.  Let same be the result of applying the\n\t            //        Strict Equality Comparison Algorithm to\n\t            //        searchElement and elementK.\n\t            //  iii.  If same is true, return k.\n\t            if (k in O && O[k] === searchElement) {\n\t                return k;\n\t            }\n\t            k++;\n\t        }\n\t        return -1;\n\t    };\n\t}\n\n/***/ },\n/* 13 */,\n/* 14 */,\n/* 15 */\n/***/ function(module, exports) {\n\n\t/*\n\t * angular-ui-bootstrap\n\t * http://angular-ui.github.io/bootstrap/\n\t\n\t * Version: 0.14.3 - 2015-10-23\n\t * License: MIT\n\t */\n\tangular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\n\tangular.module(\"ui.bootstrap.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/carousel/carousel.html\",\"template/carousel/slide.html\",\"template/datepicker/datepicker.html\",\"template/datepicker/day.html\",\"template/datepicker/month.html\",\"template/datepicker/popup.html\",\"template/datepicker/year.html\",\"template/modal/backdrop.html\",\"template/modal/window.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/tooltip/tooltip-template-popup.html\",\"template/popover/popover-html.html\",\"template/popover/popover-template.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/progressbar/progressbar.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/timepicker/timepicker.html\",\"template/typeahead/typeahead-match.html\",\"template/typeahead/typeahead-popup.html\"]);\n\tangular.module('ui.bootstrap.collapse', [])\n\t\n\t  .directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {\n\t    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n\t    return {\n\t      link: function(scope, element, attrs) {\n\t        function expand() {\n\t          element.removeClass('collapse')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', true)\n\t            .attr('aria-hidden', false);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              addClass: 'in',\n\t              easing: 'ease',\n\t              to: { height: element[0].scrollHeight + 'px' }\n\t            }).start().finally(expandDone);\n\t          } else {\n\t            $animate.addClass(element, 'in', {\n\t              to: { height: element[0].scrollHeight + 'px' }\n\t            }).then(expandDone);\n\t          }\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse')\n\t            .css({height: 'auto'});\n\t        }\n\t\n\t        function collapse() {\n\t          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n\t            return collapseDone();\n\t          }\n\t\n\t          element\n\t            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n\t            // Otherwise, the browser attempts to animate from height 0 (in\n\t            // collapsing class) to the given height here.\n\t            .css({height: element[0].scrollHeight + 'px'})\n\t            // initially all panel collapse have the collapse class, this removal\n\t            // prevents the animation from jumping to collapsed state\n\t            .removeClass('collapse')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', false)\n\t            .attr('aria-hidden', true);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              removeClass: 'in',\n\t              to: {height: '0'}\n\t            }).start().finally(collapseDone);\n\t          } else {\n\t            $animate.removeClass(element, 'in', {\n\t              to: {height: '0'}\n\t            }).then(collapseDone);\n\t          }\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse');\n\t        }\n\t\n\t        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\t/* Deprecated collapse below */\n\t\n\tangular.module('ui.bootstrap.collapse')\n\t\n\t  .value('$collapseSuppressWarning', false)\n\t\n\t  .directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {\n\t    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n\t    return {\n\t      link: function(scope, element, attrs) {\n\t        if (!$collapseSuppressWarning) {\n\t          $log.warn('collapse is now deprecated. Use uib-collapse instead.');\n\t        }\n\t\n\t        function expand() {\n\t          element.removeClass('collapse')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', true)\n\t            .attr('aria-hidden', false);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              easing: 'ease',\n\t              to: { height: element[0].scrollHeight + 'px' }\n\t            }).start().done(expandDone);\n\t          } else {\n\t            $animate.animate(element, {}, {\n\t              height: element[0].scrollHeight + 'px'\n\t            }).then(expandDone);\n\t          }\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse in')\n\t            .css({height: 'auto'});\n\t        }\n\t\n\t        function collapse() {\n\t          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n\t            return collapseDone();\n\t          }\n\t\n\t          element\n\t            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n\t            // Otherwise, the browser attempts to animate from height 0 (in\n\t            // collapsing class) to the given height here.\n\t            .css({height: element[0].scrollHeight + 'px'})\n\t            // initially all panel collapse have the collapse class, this removal\n\t            // prevents the animation from jumping to collapsed state\n\t            .removeClass('collapse in')\n\t            .addClass('collapsing')\n\t            .attr('aria-expanded', false)\n\t            .attr('aria-hidden', true);\n\t\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              to: {height: '0'}\n\t            }).start().done(collapseDone);\n\t          } else {\n\t            $animate.animate(element, {}, {\n\t              height: '0'\n\t            }).then(collapseDone);\n\t          }\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse');\n\t        }\n\t\n\t        scope.$watch(attrs.collapse, function(shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\t\n\t.constant('uibAccordionConfig', {\n\t  closeOthers: true\n\t})\n\t\n\t.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n\t  // This array keeps track of the accordion groups\n\t  this.groups = [];\n\t\n\t  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n\t  this.closeOthers = function(openGroup) {\n\t    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n\t      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n\t    if (closeOthers) {\n\t      angular.forEach(this.groups, function(group) {\n\t        if (group !== openGroup) {\n\t          group.isOpen = false;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  // This is called from the accordion-group directive to add itself to the accordion\n\t  this.addGroup = function(groupScope) {\n\t    var that = this;\n\t    this.groups.push(groupScope);\n\t\n\t    groupScope.$on('$destroy', function(event) {\n\t      that.removeGroup(groupScope);\n\t    });\n\t  };\n\t\n\t  // This is called from the accordion-group directive when to remove itself\n\t  this.removeGroup = function(group) {\n\t    var index = this.groups.indexOf(group);\n\t    if (index !== -1) {\n\t      this.groups.splice(index, 1);\n\t    }\n\t  };\n\t\n\t}])\n\t\n\t// The accordion directive simply sets up the directive controller\n\t// and adds an accordion CSS class to itself element.\n\t.directive('uibAccordion', function() {\n\t  return {\n\t    controller: 'UibAccordionController',\n\t    controllerAs: 'accordion',\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/accordion/accordion.html';\n\t    }\n\t  };\n\t})\n\t\n\t// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n\t.directive('uibAccordionGroup', function() {\n\t  return {\n\t    require: '^uibAccordion',         // We need this directive to be inside an accordion\n\t    transclude: true,              // It transcludes the contents of the directive into the template\n\t    replace: true,                // The element containing the directive will be replaced with the template\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/accordion/accordion-group.html';\n\t    },\n\t    scope: {\n\t      heading: '@',               // Interpolate the heading attribute onto this scope\n\t      isOpen: '=?',\n\t      isDisabled: '=?'\n\t    },\n\t    controller: function() {\n\t      this.setHeading = function(element) {\n\t        this.heading = element;\n\t      };\n\t    },\n\t    link: function(scope, element, attrs, accordionCtrl) {\n\t      accordionCtrl.addGroup(scope);\n\t\n\t      scope.openClass = attrs.openClass || 'panel-open';\n\t      scope.panelClass = attrs.panelClass;\n\t      scope.$watch('isOpen', function(value) {\n\t        element.toggleClass(scope.openClass, !!value);\n\t        if (value) {\n\t          accordionCtrl.closeOthers(scope);\n\t        }\n\t      });\n\t\n\t      scope.toggleOpen = function($event) {\n\t        if (!scope.isDisabled) {\n\t          if (!$event || $event.which === 32) {\n\t            scope.isOpen = !scope.isOpen;\n\t          }\n\t        }\n\t      };\n\t    }\n\t  };\n\t})\n\t\n\t// Use accordion-heading below an accordion-group to provide a heading containing HTML\n\t.directive('uibAccordionHeading', function() {\n\t  return {\n\t    transclude: true,   // Grab the contents to be used as the heading\n\t    template: '',       // In effect remove this element!\n\t    replace: true,\n\t    require: '^uibAccordionGroup',\n\t    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n\t      // Pass the heading to the accordion-group controller\n\t      // so that it can be transcluded into the right place in the template\n\t      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n\t    }\n\t  };\n\t})\n\t\n\t// Use in the accordion-group template to indicate where you want the heading to be transcluded\n\t// You must provide the property on the accordion-group controller that will hold the transcluded element\n\t.directive('uibAccordionTransclude', function() {\n\t  return {\n\t    require: ['?^uibAccordionGroup', '?^accordionGroup'],\n\t    link: function(scope, element, attrs, controller) {\n\t      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation\n\t      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n\t        if (heading) {\n\t          element.find('span').html('');\n\t          element.find('span').append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated accordion below */\n\t\n\tangular.module('ui.bootstrap.accordion')\n\t\n\t  .value('$accordionSuppressWarning', false)\n\t\n\t  .controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {\n\t    if (!$accordionSuppressWarning) {\n\t      $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibAccordionController', {\n\t      $scope: $scope,\n\t      $attrs: $attrs\n\t    }));\n\t  }])\n\t\n\t  .directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      restrict: 'EA',\n\t      controller: 'AccordionController',\n\t      controllerAs: 'accordion',\n\t      transclude: true,\n\t      replace: false,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.templateUrl || 'template/accordion/accordion.html';\n\t      },\n\t      link: function() {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion is now deprecated. Use uib-accordion instead.');\n\t        }\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      require: '^accordion',         // We need this directive to be inside an accordion\n\t      restrict: 'EA',\n\t      transclude: true,              // It transcludes the contents of the directive into the template\n\t      replace: true,                // The element containing the directive will be replaced with the template\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.templateUrl || 'template/accordion/accordion-group.html';\n\t      },\n\t      scope: {\n\t        heading: '@',               // Interpolate the heading attribute onto this scope\n\t        isOpen: '=?',\n\t        isDisabled: '=?'\n\t      },\n\t      controller: function() {\n\t        this.setHeading = function(element) {\n\t          this.heading = element;\n\t        };\n\t      },\n\t      link: function(scope, element, attrs, accordionCtrl) {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');\n\t        }\n\t\n\t        accordionCtrl.addGroup(scope);\n\t\n\t        scope.openClass = attrs.openClass || 'panel-open';\n\t        scope.panelClass = attrs.panelClass;\n\t        scope.$watch('isOpen', function(value) {\n\t          element.toggleClass(scope.openClass, !!value);\n\t          if (value) {\n\t            accordionCtrl.closeOthers(scope);\n\t          }\n\t        });\n\t\n\t        scope.toggleOpen = function($event) {\n\t          if (!scope.isDisabled) {\n\t            if (!$event || $event.which === 32) {\n\t              scope.isOpen = !scope.isOpen;\n\t            }\n\t          }\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      restrict: 'EA',\n\t      transclude: true,   // Grab the contents to be used as the heading\n\t      template: '',       // In effect remove this element!\n\t      replace: true,\n\t      require: '^accordionGroup',\n\t      link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');\n\t        }\n\t        // Pass the heading to the accordion-group controller\n\t        // so that it can be transcluded into the right place in the template\n\t        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n\t    return {\n\t      require: '^accordionGroup',\n\t      link: function(scope, element, attr, controller) {\n\t        if (!$accordionSuppressWarning) {\n\t          $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');\n\t        }\n\t\n\t        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n\t          if (heading) {\n\t            element.find('span').html('');\n\t            element.find('span').append(heading);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\t\n\tangular.module('ui.bootstrap.alert', [])\n\t\n\t.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n\t  $scope.closeable = !!$attrs.close;\n\t\n\t  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n\t    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\t\n\t  if (dismissOnTimeout) {\n\t    $timeout(function() {\n\t      $scope.close();\n\t    }, parseInt(dismissOnTimeout, 10));\n\t  }\n\t}])\n\t\n\t.directive('uibAlert', function() {\n\t  return {\n\t    controller: 'UibAlertController',\n\t    controllerAs: 'alert',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/alert/alert.html';\n\t    },\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@',\n\t      close: '&'\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated alert below */\n\t\n\tangular.module('ui.bootstrap.alert')\n\t\n\t  .value('$alertSuppressWarning', false)\n\t\n\t  .controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {\n\t    if (!$alertSuppressWarning) {\n\t      $log.warn('AlertController is now deprecated. Use UibAlertController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibAlertController', {\n\t      $scope: $scope,\n\t      $attrs: $attrs\n\t    }));\n\t  }])\n\t\n\t  .directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {\n\t    return {\n\t      controller: 'AlertController',\n\t      controllerAs: 'alert',\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.templateUrl || 'template/alert/alert.html';\n\t      },\n\t      transclude: true,\n\t      replace: true,\n\t      scope: {\n\t        type: '@',\n\t        close: '&'\n\t      },\n\t      link: function() {\n\t        if (!$alertSuppressWarning) {\n\t          $log.warn('alert is now deprecated. Use uib-alert instead.');\n\t        }\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.buttons', [])\n\t\n\t.constant('uibButtonConfig', {\n\t  activeClass: 'active',\n\t  toggleEvent: 'click'\n\t})\n\t\n\t.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n\t  this.activeClass = buttonConfig.activeClass || 'active';\n\t  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n\t}])\n\t\n\t.directive('uibBtnRadio', function() {\n\t  return {\n\t    require: ['uibBtnRadio', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'buttons',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n\t            ngModelCtrl.$render();\n\t          });\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibBtnCheckbox', function() {\n\t  return {\n\t    require: ['uibBtnCheckbox', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'button',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      function getTrueValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t      }\n\t\n\t      function getFalseValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t      }\n\t\n\t      function getCheckboxValue(attribute, defaultValue) {\n\t        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n\t      }\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        scope.$apply(function() {\n\t          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t          ngModelCtrl.$render();\n\t        });\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated buttons below */\n\t\n\tangular.module('ui.bootstrap.buttons')\n\t\n\t  .value('$buttonsSuppressWarning', false)\n\t\n\t  .controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {\n\t    if (!$buttonsSuppressWarning) {\n\t      $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibButtonsController'));\n\t  }])\n\t\n\t  .directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {\n\t    return {\n\t      require: ['btnRadio', 'ngModel'],\n\t      controller: 'ButtonsController',\n\t      controllerAs: 'buttons',\n\t      link: function(scope, element, attrs, ctrls) {\n\t        if (!$buttonsSuppressWarning) {\n\t          $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');\n\t        }\n\t\n\t        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t        element.find('input').css({display: 'none'});\n\t\n\t        //model -> UI\n\t        ngModelCtrl.$render = function() {\n\t          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n\t        };\n\t\n\t        //ui->model\n\t        element.bind(buttonsCtrl.toggleEvent, function() {\n\t          if (attrs.disabled) {\n\t            return;\n\t          }\n\t\n\t          var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t          if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t            scope.$apply(function() {\n\t              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n\t              ngModelCtrl.$render();\n\t            });\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {\n\t    return {\n\t      require: ['btnCheckbox', 'ngModel'],\n\t      controller: 'ButtonsController',\n\t      controllerAs: 'button',\n\t      link: function(scope, element, attrs, ctrls) {\n\t        if (!$buttonsSuppressWarning) {\n\t          $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');\n\t        }\n\t\n\t        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t        element.find('input').css({display: 'none'});\n\t\n\t        function getTrueValue() {\n\t          return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t        }\n\t\n\t        function getFalseValue() {\n\t          return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t        }\n\t\n\t        function getCheckboxValue(attributeValue, defaultValue) {\n\t          var val = scope.$eval(attributeValue);\n\t          return angular.isDefined(val) ? val : defaultValue;\n\t        }\n\t\n\t        //model -> UI\n\t        ngModelCtrl.$render = function() {\n\t          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t        };\n\t\n\t        //ui->model\n\t        element.bind(buttonsCtrl.toggleEvent, function() {\n\t          if (attrs.disabled) {\n\t            return;\n\t          }\n\t\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t            ngModelCtrl.$render();\n\t          });\n\t        });\n\t\n\t        //accessibility\n\t        element.on('keypress', function(e) {\n\t          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {\n\t            return;\n\t          }\n\t\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t            ngModelCtrl.$render();\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.bootstrap.carousel\n\t *\n\t * @description\n\t * AngularJS version of an image carousel.\n\t *\n\t */\n\tangular.module('ui.bootstrap.carousel', [])\n\t\n\t.controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {\n\t  var self = this,\n\t    slides = self.slides = $scope.slides = [],\n\t    NEW_ANIMATE = angular.version.minor >= 4,\n\t    NO_TRANSITION = 'uib-noTransition',\n\t    SLIDE_DIRECTION = 'uib-slideDirection',\n\t    currentIndex = -1,\n\t    currentInterval, isPlaying;\n\t  self.currentSlide = null;\n\t\n\t  var destroyed = false;\n\t  /* direction: \"prev\" or \"next\" */\n\t  self.select = $scope.select = function(nextSlide, direction) {\n\t    var nextIndex = $scope.indexOfSlide(nextSlide);\n\t    //Decide direction if it's not given\n\t    if (direction === undefined) {\n\t      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n\t    }\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {\n\t      goNext(nextSlide, nextIndex, direction);\n\t    }\n\t  };\n\t\n\t  function goNext(slide, index, direction) {\n\t    // Scope has been destroyed, stop here.\n\t    if (destroyed) { return; }\n\t\n\t    angular.extend(slide, {direction: direction, active: true});\n\t    angular.extend(self.currentSlide || {}, {direction: direction, active: false});\n\t    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&\n\t      slide.$element && self.slides.length > 1) {\n\t      slide.$element.data(SLIDE_DIRECTION, slide.direction);\n\t      if (self.currentSlide && self.currentSlide.$element) {\n\t        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);\n\t      }\n\t\n\t      $scope.$currentTransition = true;\n\t      if (NEW_ANIMATE) {\n\t        $animate.on('addClass', slide.$element, function(element, phase) {\n\t          if (phase === 'close') {\n\t            $scope.$currentTransition = null;\n\t            $animate.off('addClass', element);\n\t          }\n\t        });\n\t      } else {\n\t        slide.$element.one('$animate:close', function closeFn() {\n\t          $scope.$currentTransition = null;\n\t        });\n\t      }\n\t    }\n\t\n\t    self.currentSlide = slide;\n\t    currentIndex = index;\n\t\n\t    //every time you change slides, reset the timer\n\t    restartTimer();\n\t  }\n\t\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t  });\n\t\n\t  function getSlideByIndex(index) {\n\t    if (angular.isUndefined(slides[index].index)) {\n\t      return slides[index];\n\t    }\n\t    var i, len = slides.length;\n\t    for (i = 0; i < slides.length; ++i) {\n\t      if (slides[i].index == index) {\n\t        return slides[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  self.getCurrentIndex = function() {\n\t    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {\n\t      return +self.currentSlide.index;\n\t    }\n\t    return currentIndex;\n\t  };\n\t\n\t  /* Allow outside people to call indexOf on slides array */\n\t  $scope.indexOfSlide = function(slide) {\n\t    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);\n\t  };\n\t\n\t  $scope.next = function() {\n\t    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\t\n\t    if (newIndex === 0 && $scope.noWrap()) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(getSlideByIndex(newIndex), 'next');\n\t  };\n\t\n\t  $scope.prev = function() {\n\t    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\t\n\t    if ($scope.noWrap() && newIndex === slides.length - 1) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(getSlideByIndex(newIndex), 'prev');\n\t  };\n\t\n\t  $scope.isActive = function(slide) {\n\t     return self.currentSlide === slide;\n\t  };\n\t\n\t  $scope.$watch('interval', restartTimer);\n\t  $scope.$watchCollection('slides', resetTransition);\n\t  $scope.$on('$destroy', resetTimer);\n\t\n\t  function restartTimer() {\n\t    resetTimer();\n\t    var interval = +$scope.interval;\n\t    if (!isNaN(interval) && interval > 0) {\n\t      currentInterval = $interval(timerFn, interval);\n\t    }\n\t  }\n\t\n\t  function resetTimer() {\n\t    if (currentInterval) {\n\t      $interval.cancel(currentInterval);\n\t      currentInterval = null;\n\t    }\n\t  }\n\t\n\t  function timerFn() {\n\t    var interval = +$scope.interval;\n\t    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n\t      $scope.next();\n\t    } else {\n\t      $scope.pause();\n\t    }\n\t  }\n\t\n\t  function resetTransition(slides) {\n\t    if (!slides.length) {\n\t      $scope.$currentTransition = null;\n\t    }\n\t  }\n\t\n\t  $scope.play = function() {\n\t    if (!isPlaying) {\n\t      isPlaying = true;\n\t      restartTimer();\n\t    }\n\t  };\n\t  $scope.pause = function() {\n\t    if (!$scope.noPause) {\n\t      isPlaying = false;\n\t      resetTimer();\n\t    }\n\t  };\n\t\n\t  self.addSlide = function(slide, element) {\n\t    slide.$element = element;\n\t    slides.push(slide);\n\t    //if this is the first slide or the slide is set to active, select it\n\t    if (slides.length === 1 || slide.active) {\n\t      self.select(slides[slides.length - 1]);\n\t      if (slides.length === 1) {\n\t        $scope.play();\n\t      }\n\t    } else {\n\t      slide.active = false;\n\t    }\n\t  };\n\t\n\t  self.removeSlide = function(slide) {\n\t    if (angular.isDefined(slide.index)) {\n\t      slides.sort(function(a, b) {\n\t        return +a.index > +b.index;\n\t      });\n\t    }\n\t    //get the index of the slide inside the carousel\n\t    var index = slides.indexOf(slide);\n\t    slides.splice(index, 1);\n\t    if (slides.length > 0 && slide.active) {\n\t      if (index >= slides.length) {\n\t        self.select(slides[index - 1]);\n\t      } else {\n\t        self.select(slides[index]);\n\t      }\n\t    } else if (currentIndex > index) {\n\t      currentIndex--;\n\t    }\n\t\n\t    //clean the currentSlide when no more slide\n\t    if (slides.length === 0) {\n\t      self.currentSlide = null;\n\t    }\n\t  };\n\t\n\t  $scope.$watch('noTransition', function(noTransition) {\n\t    $element.data(NO_TRANSITION, noTransition);\n\t  });\n\t\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:carousel\n\t * @restrict EA\n\t *\n\t * @description\n\t * Carousel is the outer container for a set of image 'slides' to showcase.\n\t *\n\t * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n\t * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n\t * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <uib-carousel>\n\t      <uib-slide>\n\t        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>Beautiful!</p>\n\t        </div>\n\t      </uib-slide>\n\t      <uib-slide>\n\t        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n\t        <div class=\"carousel-caption\">\n\t          <p>D'aww!</p>\n\t        </div>\n\t      </uib-slide>\n\t    </uib-carousel>\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t */\n\t.directive('uibCarousel', [function() {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'UibCarouselController',\n\t    controllerAs: 'carousel',\n\t    require: 'carousel',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/carousel.html';\n\t    },\n\t    scope: {\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '=',\n\t      noWrap: '&'\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.carousel.directive:slide\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n\t *\n\t * @param {boolean=} active Model binding, whether or not this slide is currently active.\n\t * @param {number=} index The index of the slide. The slides will be sorted by this parameter.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t<div ng-controller=\"CarouselDemoCtrl\">\n\t  <uib-carousel>\n\t    <uib-slide ng-repeat=\"slide in slides\" active=\"slide.active\" index=\"$index\">\n\t      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n\t      <div class=\"carousel-caption\">\n\t        <h4>Slide {{$index}}</h4>\n\t        <p>{{slide.text}}</p>\n\t      </div>\n\t    </uib-slide>\n\t  </uib-carousel>\n\t  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n\t  <br />Enter a negative number to stop the interval.\n\t</div>\n\t  </file>\n\t  <file name=\"script.js\">\n\tfunction CarouselDemoCtrl($scope) {\n\t  $scope.myInterval = 5000;\n\t}\n\t  </file>\n\t  <file name=\"demo.css\">\n\t    .carousel-indicators {\n\t      top: auto;\n\t      bottom: 15px;\n\t    }\n\t  </file>\n\t</example>\n\t*/\n\t\n\t.directive('uibSlide', function() {\n\t  return {\n\t    require: '^uibCarousel',\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/slide.html';\n\t    },\n\t    scope: {\n\t      active: '=?',\n\t      actual: '=?',\n\t      index: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          carouselCtrl.select(scope);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.animation('.item', [\n\t         '$injector', '$animate',\n\tfunction ($injector, $animate) {\n\t  var NO_TRANSITION = 'uib-noTransition',\n\t    SLIDE_DIRECTION = 'uib-slideDirection',\n\t    $animateCss = null;\n\t\n\t  if ($injector.has('$animateCss')) {\n\t    $animateCss = $injector.get('$animateCss');\n\t  }\n\t\n\t  function removeClass(element, className, callback) {\n\t    element.removeClass(className);\n\t    if (callback) {\n\t      callback();\n\t    }\n\t  }\n\t\n\t  return {\n\t    beforeAddClass: function(element, className, done) {\n\t      // Due to transclusion, noTransition property is on parent's scope\n\t      if (className == 'active' && element.parent() && element.parent().parent() &&\n\t          !element.parent().parent().data(NO_TRANSITION)) {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction == 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element,\n\t          directionClass + ' ' + direction, done);\n\t        element.addClass(direction);\n\t\n\t        if ($animateCss) {\n\t          $animateCss(element, {addClass: directionClass})\n\t            .start()\n\t            .done(removeClassFn);\n\t        } else {\n\t          $animate.addClass(element, directionClass).then(function () {\n\t            if (!stopped) {\n\t              removeClassFn();\n\t            }\n\t            done();\n\t          });\n\t        }\n\t\n\t        return function () {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    },\n\t    beforeRemoveClass: function (element, className, done) {\n\t      // Due to transclusion, noTransition property is on parent's scope\n\t      if (className === 'active' && element.parent() && element.parent().parent() &&\n\t          !element.parent().parent().data(NO_TRANSITION)) {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction == 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\t\n\t        if ($animateCss) {\n\t          $animateCss(element, {addClass: directionClass})\n\t            .start()\n\t            .done(removeClassFn);\n\t        } else {\n\t          $animate.addClass(element, directionClass).then(function() {\n\t            if (!stopped) {\n\t              removeClassFn();\n\t            }\n\t            done();\n\t          });\n\t        }\n\t        return function() {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    }\n\t  };\n\t}]);\n\t\n\t/* deprecated carousel below */\n\t\n\tangular.module('ui.bootstrap.carousel')\n\t\n\t.value('$carouselSuppressWarning', false)\n\t\n\t.controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {\n\t  if (!$carouselSuppressWarning) {\n\t    $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');\n\t  }\n\t\n\t  angular.extend(this, $controller('UibCarouselController', {\n\t    $scope: $scope,\n\t    $element: $element\n\t  }));\n\t}])\n\t\n\t.directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'CarouselController',\n\t    controllerAs: 'carousel',\n\t    require: 'carousel',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/carousel.html';\n\t    },\n\t    scope: {\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '=',\n\t      noWrap: '&'\n\t    },\n\t    link: function() {\n\t      if (!$carouselSuppressWarning) {\n\t        $log.warn('carousel is now deprecated. Use uib-carousel instead.');\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n\t  return {\n\t    require: '^carousel',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/carousel/slide.html';\n\t    },\n\t    scope: {\n\t      active: '=?',\n\t      actual: '=?',\n\t      index: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      if (!$carouselSuppressWarning) {\n\t        $log.warn('slide is now deprecated. Use uib-slide instead.');\n\t      }\n\t\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          carouselCtrl.select(scope);\n\t        }\n\t      });\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.dateparser', [])\n\t\n\t.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {\n\t  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n\t  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\t\n\t  var localeId;\n\t  var formatCodeToRegex;\n\t\n\t  this.init = function() {\n\t    localeId = $locale.id;\n\t\n\t    this.parsers = {};\n\t\n\t    formatCodeToRegex = {\n\t      'yyyy': {\n\t        regex: '\\\\d{4}',\n\t        apply: function(value) { this.year = +value; }\n\t      },\n\t      'yy': {\n\t        regex: '\\\\d{2}',\n\t        apply: function(value) { this.year = +value + 2000; }\n\t      },\n\t      'y': {\n\t        regex: '\\\\d{1,4}',\n\t        apply: function(value) { this.year = +value; }\n\t      },\n\t      'MMMM': {\n\t        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n\t      },\n\t      'MMM': {\n\t        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n\t      },\n\t      'MM': {\n\t        regex: '0[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; }\n\t      },\n\t      'M': {\n\t        regex: '[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; }\n\t      },\n\t      'dd': {\n\t        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; }\n\t      },\n\t      'd': {\n\t        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; }\n\t      },\n\t      'EEEE': {\n\t        regex: $locale.DATETIME_FORMATS.DAY.join('|')\n\t      },\n\t      'EEE': {\n\t        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n\t      },\n\t      'HH': {\n\t        regex: '(?:0|1)[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'hh': {\n\t        regex: '0[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'H': {\n\t        regex: '1?[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'h': {\n\t        regex: '[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; }\n\t      },\n\t      'mm': {\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; }\n\t      },\n\t      'm': {\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; }\n\t      },\n\t      'sss': {\n\t        regex: '[0-9][0-9][0-9]',\n\t        apply: function(value) { this.milliseconds = +value; }\n\t      },\n\t      'ss': {\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; }\n\t      },\n\t      's': {\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; }\n\t      },\n\t      'a': {\n\t        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n\t        apply: function(value) {\n\t          if (this.hours === 12) {\n\t            this.hours = 0;\n\t          }\n\t\n\t          if (value === 'PM') {\n\t            this.hours += 12;\n\t          }\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  this.init();\n\t\n\t  function createParser(format) {\n\t    var map = [], regex = format.split('');\n\t\n\t    angular.forEach(formatCodeToRegex, function(data, code) {\n\t      var index = format.indexOf(code);\n\t\n\t      if (index > -1) {\n\t        format = format.split('');\n\t\n\t        regex[index] = '(' + data.regex + ')';\n\t        format[index] = '$'; // Custom symbol to define consumed part of format\n\t        for (var i = index + 1, n = index + code.length; i < n; i++) {\n\t          regex[i] = '';\n\t          format[i] = '$';\n\t        }\n\t        format = format.join('');\n\t\n\t        map.push({ index: index, apply: data.apply });\n\t      }\n\t    });\n\t\n\t    return {\n\t      regex: new RegExp('^' + regex.join('') + '$'),\n\t      map: orderByFilter(map, 'index')\n\t    };\n\t  }\n\t\n\t  this.parse = function(input, format, baseDate) {\n\t    if (!angular.isString(input) || !format) {\n\t      return input;\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\t\n\t    if ($locale.id !== localeId) {\n\t      this.init();\n\t    }\n\t\n\t    if (!this.parsers[format]) {\n\t      this.parsers[format] = createParser(format);\n\t    }\n\t\n\t    var parser = this.parsers[format],\n\t        regex = parser.regex,\n\t        map = parser.map,\n\t        results = input.match(regex);\n\t\n\t    if (results && results.length) {\n\t      var fields, dt;\n\t      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n\t        fields = {\n\t          year: baseDate.getFullYear(),\n\t          month: baseDate.getMonth(),\n\t          date: baseDate.getDate(),\n\t          hours: baseDate.getHours(),\n\t          minutes: baseDate.getMinutes(),\n\t          seconds: baseDate.getSeconds(),\n\t          milliseconds: baseDate.getMilliseconds()\n\t        };\n\t      } else {\n\t        if (baseDate) {\n\t          $log.warn('dateparser:', 'baseDate is not a valid date');\n\t        }\n\t        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n\t      }\n\t\n\t      for (var i = 1, n = results.length; i < n; i++) {\n\t        var mapper = map[i-1];\n\t        if (mapper.apply) {\n\t          mapper.apply.call(fields, results[i]);\n\t        }\n\t      }\n\t\n\t      if (isValid(fields.year, fields.month, fields.date)) {\n\t        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n\t          dt = new Date(baseDate);\n\t          dt.setFullYear(fields.year, fields.month, fields.date,\n\t            fields.hours, fields.minutes, fields.seconds,\n\t            fields.milliseconds || 0);\n\t        } else {\n\t          dt = new Date(fields.year, fields.month, fields.date,\n\t            fields.hours, fields.minutes, fields.seconds,\n\t            fields.milliseconds || 0);\n\t        }\n\t      }\n\t\n\t      return dt;\n\t    }\n\t  };\n\t\n\t  // Check if date is valid for specific month (and year for February).\n\t  // Month: 0 = Jan, 1 = Feb, etc\n\t  function isValid(year, month, date) {\n\t    if (date < 1) {\n\t      return false;\n\t    }\n\t\n\t    if (month === 1 && date > 28) {\n\t      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n\t    }\n\t\n\t    if (month === 3 || month === 5 || month === 8 || month === 10) {\n\t      return date < 31;\n\t    }\n\t\n\t    return true;\n\t  }\n\t}]);\n\t\n\t/* Deprecated dateparser below */\n\t\n\tangular.module('ui.bootstrap.dateparser')\n\t\n\t.value('$dateParserSuppressWarning', false)\n\t\n\t.service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {\n\t  if (!$dateParserSuppressWarning) {\n\t    $log.warn('dateParser is now deprecated. Use uibDateParser instead.');\n\t  }\n\t\n\t  angular.extend(this, uibDateParser);\n\t}]);\n\t\n\tangular.module('ui.bootstrap.position', [])\n\t\n\t/**\n\t * A set of utility methods that can be use to retrieve position of DOM elements.\n\t * It is meant to be used where we need to absolute-position DOM elements in\n\t * relation to other, existing elements (this is the case for tooltips, popovers,\n\t * typeahead suggestions etc.).\n\t */\n\t  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n\t    function getStyle(el, cssprop) {\n\t      if (el.currentStyle) { //IE\n\t        return el.currentStyle[cssprop];\n\t      } else if ($window.getComputedStyle) {\n\t        return $window.getComputedStyle(el)[cssprop];\n\t      }\n\t      // finally try and get inline style\n\t      return el.style[cssprop];\n\t    }\n\t\n\t    /**\n\t     * Checks if a given element is statically positioned\n\t     * @param element - raw DOM element\n\t     */\n\t    function isStaticPositioned(element) {\n\t      return (getStyle(element, 'position') || 'static' ) === 'static';\n\t    }\n\t\n\t    /**\n\t     * returns the closest, non-statically positioned parentOffset of a given element\n\t     * @param element\n\t     */\n\t    var parentOffsetEl = function(element) {\n\t      var docDomEl = $document[0];\n\t      var offsetParent = element.offsetParent || docDomEl;\n\t      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n\t        offsetParent = offsetParent.offsetParent;\n\t      }\n\t      return offsetParent || docDomEl;\n\t    };\n\t\n\t    return {\n\t      /**\n\t       * Provides read-only equivalent of jQuery's position function:\n\t       * http://api.jquery.com/position/\n\t       */\n\t      position: function(element) {\n\t        var elBCR = this.offset(element);\n\t        var offsetParentBCR = { top: 0, left: 0 };\n\t        var offsetParentEl = parentOffsetEl(element[0]);\n\t        if (offsetParentEl != $document[0]) {\n\t          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n\t          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n\t          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n\t        }\n\t\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: elBCR.top - offsetParentBCR.top,\n\t          left: elBCR.left - offsetParentBCR.left\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's offset function:\n\t       * http://api.jquery.com/offset/\n\t       */\n\t      offset: function(element) {\n\t        var boundingClientRect = element[0].getBoundingClientRect();\n\t        return {\n\t          width: boundingClientRect.width || element.prop('offsetWidth'),\n\t          height: boundingClientRect.height || element.prop('offsetHeight'),\n\t          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n\t          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides coordinates for the targetEl in relation to hostEl\n\t       */\n\t      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {\n\t        var positionStrParts = positionStr.split('-');\n\t        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\t\n\t        var hostElPos,\n\t          targetElWidth,\n\t          targetElHeight,\n\t          targetElPos;\n\t\n\t        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\t\n\t        targetElWidth = targetEl.prop('offsetWidth');\n\t        targetElHeight = targetEl.prop('offsetHeight');\n\t\n\t        var shiftWidth = {\n\t          center: function() {\n\t            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n\t          },\n\t          left: function() {\n\t            return hostElPos.left;\n\t          },\n\t          right: function() {\n\t            return hostElPos.left + hostElPos.width;\n\t          }\n\t        };\n\t\n\t        var shiftHeight = {\n\t          center: function() {\n\t            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n\t          },\n\t          top: function() {\n\t            return hostElPos.top;\n\t          },\n\t          bottom: function() {\n\t            return hostElPos.top + hostElPos.height;\n\t          }\n\t        };\n\t\n\t        switch (pos0) {\n\t          case 'right':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: shiftWidth[pos0]()\n\t            };\n\t            break;\n\t          case 'left':\n\t            targetElPos = {\n\t              top: shiftHeight[pos1](),\n\t              left: hostElPos.left - targetElWidth\n\t            };\n\t            break;\n\t          case 'bottom':\n\t            targetElPos = {\n\t              top: shiftHeight[pos0](),\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t          default:\n\t            targetElPos = {\n\t              top: hostElPos.top - targetElHeight,\n\t              left: shiftWidth[pos1]()\n\t            };\n\t            break;\n\t        }\n\t\n\t        return targetElPos;\n\t      }\n\t    };\n\t  }]);\n\t\n\t/* Deprecated position below */\n\t\n\tangular.module('ui.bootstrap.position')\n\t\n\t.value('$positionSuppressWarning', false)\n\t\n\t.service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {\n\t  if (!$positionSuppressWarning) {\n\t    $log.warn('$position is now deprecated. Use $uibPosition instead.');\n\t  }\n\t\n\t  angular.extend(this, $uibPosition);\n\t}]);\n\t\n\tangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\t\n\t.value('$datepickerSuppressError', false)\n\t\n\t.constant('uibDatepickerConfig', {\n\t  formatDay: 'dd',\n\t  formatMonth: 'MMMM',\n\t  formatYear: 'yyyy',\n\t  formatDayHeader: 'EEE',\n\t  formatDayTitle: 'MMMM yyyy',\n\t  formatMonthTitle: 'yyyy',\n\t  datepickerMode: 'day',\n\t  minMode: 'day',\n\t  maxMode: 'year',\n\t  showWeeks: true,\n\t  startingDay: 0,\n\t  yearRange: 20,\n\t  minDate: null,\n\t  maxDate: null,\n\t  shortcutPropagation: false\n\t})\n\t\n\t.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\t\n\t  // Modes chain\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  // Configuration attributes\n\t  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n\t                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n\t    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n\t  });\n\t\n\t  // Watchable date attributes\n\t  angular.forEach(['minDate', 'maxDate'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = value ? new Date(value) : null;\n\t        self.refreshView();\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n\t    }\n\t  });\n\t\n\t  angular.forEach(['minMode', 'maxMode'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = angular.isDefined(value) ? value : $attrs[key];\n\t        $scope[key] = self[key];\n\t        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n\t          $scope.datepickerMode = self[key];\n\t        }\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] || null;\n\t      $scope[key] = self[key];\n\t    }\n\t  });\n\t\n\t  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t\n\t  if (angular.isDefined($attrs.initDate)) {\n\t    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n\t    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n\t      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t        self.activeDate = initDate;\n\t        self.refreshView();\n\t      }\n\t    });\n\t  } else {\n\t    this.activeDate = new Date();\n\t  }\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if (ngModelCtrl.$viewValue) {\n\t      var date = new Date(ngModelCtrl.$viewValue),\n\t          isValid = !isNaN(date);\n\t\n\t      if (isValid) {\n\t        this.activeDate = date;\n\t      } else if (!$datepickerSuppressError) {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t      }\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if (this.element) {\n\t      this._refreshView();\n\t\n\t      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t    return {\n\t      date: date,\n\t      label: dateFilter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0,\n\t      customClass: this.customClass(date)\n\t    };\n\t  };\n\t\n\t  this.isDisabled = function(date) {\n\t    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n\t  };\n\t\n\t  this.customClass = function(date) {\n\t    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  $scope.select = function(date) {\n\t    if ($scope.datepickerMode === self.minMode) {\n\t      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n\t      ngModelCtrl.$setViewValue(dt);\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n\t    }\n\t  };\n\t\n\t  $scope.move = function(direction) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function(direction) {\n\t    direction = direction || 1;\n\t\n\t    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n\t      return;\n\t    }\n\t\n\t    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\t\n\t  var focusElement = function() {\n\t    self.element[0].focus();\n\t  };\n\t\n\t  // Listen for focus requests from popup directive\n\t  $scope.$on('uib:datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function(evt) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if (!key || evt.shiftKey || evt.altKey) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    if (!self.shortcutPropagation) {\n\t      evt.stopPropagation();\n\t    }\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if (self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\t\n\t  this.step = { months: 1 };\n\t  this.element = $element;\n\t  function getDaysInMonth(year, month) {\n\t    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n\t  }\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    scope.showWeeks = ctrl.showWeeks;\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this.getDates = function(startDate, n) {\n\t    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n\t    while (i < n) {\n\t      date = new Date(current);\n\t      dates[i++] = date;\n\t      current.setDate(current.getDate() + 1);\n\t    }\n\t    return dates;\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var year = this.activeDate.getFullYear(),\n\t      month = this.activeDate.getMonth(),\n\t      firstDayOfMonth = new Date(this.activeDate);\n\t\n\t    firstDayOfMonth.setFullYear(year, month, 1);\n\t\n\t    var difference = this.startingDay - firstDayOfMonth.getDay(),\n\t      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n\t      firstDate = new Date(firstDayOfMonth);\n\t\n\t    if (numDisplayedFromPreviousMonth > 0) {\n\t      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n\t    }\n\t\n\t    // 42 is the number of days on a six-month calendar\n\t    var days = this.getDates(firstDate, 42);\n\t    for (var i = 0; i < 42; i ++) {\n\t      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n\t        secondary: days[i].getMonth() !== month,\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.labels = new Array(7);\n\t    for (var j = 0; j < 7; j++) {\n\t      scope.labels[j] = {\n\t        abbr: dateFilter(days[j].date, this.formatDayHeader),\n\t        full: dateFilter(days[j].date, 'EEEE')\n\t      };\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n\t    scope.rows = this.split(days, 7);\n\t\n\t    if (scope.showWeeks) {\n\t      scope.weekNumbers = [];\n\t      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n\t          numWeeks = scope.rows.length;\n\t      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n\t        scope.weekNumbers.push(\n\t          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n\t      }\n\t    }\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n\t  };\n\t\n\t  function getISO8601WeekNumber(date) {\n\t    var checkDate = new Date(date);\n\t    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n\t    var time = checkDate.getTime();\n\t    checkDate.setMonth(0); // Compare with Jan 1\n\t    checkDate.setDate(1);\n\t    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t  }\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getDate();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;   // up\n\t    } else if (key === 'up') {\n\t      date = date - 7;   // down\n\t    } else if (key === 'right') {\n\t      date = date + 1;   // down\n\t    } else if (key === 'down') {\n\t      date = date + 7;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setMonth(month, 1);\n\t      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n\t    } else if (key === 'home') {\n\t      date = 1;\n\t    } else if (key === 'end') {\n\t      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n\t    }\n\t    this.activeDate.setDate(date);\n\t  };\n\t}])\n\t\n\t.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  this.step = { years: 1 };\n\t  this.element = $element;\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var months = new Array(12),\n\t        year = this.activeDate.getFullYear(),\n\t        date;\n\t\n\t    for (var i = 0; i < 12; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(year, i, 1);\n\t      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n\t    scope.rows = this.split(months, 3);\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getMonth();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;   // up\n\t    } else if (key === 'up') {\n\t      date = date - 3;   // down\n\t    } else if (key === 'right') {\n\t      date = date + 1;   // down\n\t    } else if (key === 'down') {\n\t      date = date + 3;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setFullYear(year);\n\t    } else if (key === 'home') {\n\t      date = 0;\n\t    } else if (key === 'end') {\n\t      date = 11;\n\t    }\n\t    this.activeDate.setMonth(date);\n\t  };\n\t}])\n\t\n\t.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var range;\n\t  this.element = $element;\n\t\n\t  function getStartingYear(year) {\n\t    return parseInt((year - 1) / range, 10) * range + 1;\n\t  }\n\t\n\t  this.yearpickerInit = function() {\n\t    range = this.yearRange;\n\t    this.step = { years: range };\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var years = new Array(range), date;\n\t\n\t    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(start + i, 0, 1);\n\t      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n\t    scope.rows = this.split(years, 5);\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return date1.getFullYear() - date2.getFullYear();\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getFullYear();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;   // up\n\t    } else if (key === 'up') {\n\t      date = date - 5;   // down\n\t    } else if (key === 'right') {\n\t      date = date + 1;   // down\n\t    } else if (key === 'down') {\n\t      date = date + 5;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      date += (key === 'pageup' ? - 1 : 1) * this.step.years;\n\t    } else if (key === 'home') {\n\t      date = getStartingYear(this.activeDate.getFullYear());\n\t    } else if (key === 'end') {\n\t      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n\t    }\n\t    this.activeDate.setFullYear(date);\n\t  };\n\t}])\n\t\n\t.directive('uibDatepicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n\t    },\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      dateDisabled: '&',\n\t      customClass: '&',\n\t      shortcutPropagation: '&?'\n\t    },\n\t    require: ['uibDatepicker', '^ngModel'],\n\t    controller: 'UibDatepickerController',\n\t    controllerAs: 'datepicker',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      datepickerCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDaypicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/day.html';\n\t    },\n\t    require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],\n\t    controller: 'UibDaypickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0] || ctrls[2],\n\t        daypickerCtrl = ctrls[1];\n\t\n\t      daypickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibMonthpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/month.html';\n\t    },\n\t    require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],\n\t    controller: 'UibMonthpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0] || ctrls[2],\n\t        monthpickerCtrl = ctrls[1];\n\t\n\t      monthpickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibYearpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/year.html';\n\t    },\n\t    require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],\n\t    controller: 'UibYearpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ctrl = ctrls[0] || ctrls[2];\n\t      angular.extend(ctrl, ctrls[1]);\n\t      ctrl.yearpickerInit();\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t})\n\t\n\t.constant('uibDatepickerPopupConfig', {\n\t  datepickerPopup: 'yyyy-MM-dd',\n\t  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',\n\t  datepickerTemplateUrl: 'template/datepicker/datepicker.html',\n\t  html5Types: {\n\t    date: 'yyyy-MM-dd',\n\t    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n\t    'month': 'yyyy-MM'\n\t  },\n\t  currentText: 'Today',\n\t  clearText: 'Clear',\n\t  closeText: 'Done',\n\t  closeOnDateSelection: true,\n\t  appendToBody: false,\n\t  showButtonBar: true,\n\t  onOpenFocus: true\n\t})\n\t\n\t.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout',\n\tfunction(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {\n\t  var self = this;\n\t  var cache = {},\n\t    isHtml5DateInput = false;\n\t  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n\t    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,\n\t    ngModel, $popup;\n\t\n\t  scope.watchData = {};\n\t\n\t  this.init = function(_ngModel_) {\n\t    ngModel = _ngModel_;\n\t    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n\t    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n\t    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n\t    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;\n\t    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\t\n\t    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\t\n\t    if (datepickerPopupConfig.html5Types[attrs.type]) {\n\t      dateFormat = datepickerPopupConfig.html5Types[attrs.type];\n\t      isHtml5DateInput = true;\n\t    } else {\n\t      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n\t      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n\t          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n\t          // Invalidate the $modelValue to ensure that formatters re-run\n\t          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n\t          if (newDateFormat !== dateFormat) {\n\t            dateFormat = newDateFormat;\n\t            ngModel.$modelValue = null;\n\t\n\t            if (!dateFormat) {\n\t              throw new Error('uibDatepickerPopup must have a date format specified.');\n\t            }\n\t          }\n\t      });\n\t    }\n\t\n\t    if (!dateFormat) {\n\t      throw new Error('uibDatepickerPopup must have a date format specified.');\n\t    }\n\t\n\t    if (isHtml5DateInput && attrs.datepickerPopup) {\n\t      throw new Error('HTML5 date input types do not support custom formats.');\n\t    }\n\t\n\t    // popup element used to display calendar\n\t    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n\t    popupEl.attr({\n\t      'ng-model': 'date',\n\t      'ng-change': 'dateSelection(date)',\n\t      'template-url': datepickerPopupTemplateUrl\n\t    });\n\t\n\t    // datepicker element\n\t    datepickerEl = angular.element(popupEl.children()[0]);\n\t    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\t\n\t    if (isHtml5DateInput) {\n\t      if (attrs.type === 'month') {\n\t        datepickerEl.attr('datepicker-mode', '\"month\"');\n\t        datepickerEl.attr('min-mode', 'month');\n\t      }\n\t    }\n\t\n\t    if (attrs.datepickerOptions) {\n\t      var options = scope.$parent.$eval(attrs.datepickerOptions);\n\t      if (options && options.initDate) {\n\t        scope.initDate = options.initDate;\n\t        datepickerEl.attr('init-date', 'initDate');\n\t        delete options.initDate;\n\t      }\n\t      angular.forEach(options, function(value, option) {\n\t        datepickerEl.attr(cameltoDash(option), value);\n\t      });\n\t    }\n\t\n\t    angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {\n\t      if (attrs[key]) {\n\t        var getAttribute = $parse(attrs[key]);\n\t        scope.$parent.$watch(getAttribute, function(value) {\n\t          scope.watchData[key] = value;\n\t          if (key === 'minDate' || key === 'maxDate') {\n\t            cache[key] = new Date(value);\n\t          }\n\t        });\n\t        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\t\n\t        // Propagate changes from datepicker to outside\n\t        if (key === 'datepickerMode') {\n\t          var setAttribute = getAttribute.assign;\n\t          scope.$watch('watchData.' + key, function(value, oldvalue) {\n\t            if (angular.isFunction(setAttribute) && value !== oldvalue) {\n\t              setAttribute(scope.$parent, value);\n\t            }\n\t          });\n\t        }\n\t      }\n\t    });\n\t    if (attrs.dateDisabled) {\n\t      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n\t    }\n\t\n\t    if (attrs.showWeeks) {\n\t      datepickerEl.attr('show-weeks', attrs.showWeeks);\n\t    }\n\t\n\t    if (attrs.customClass) {\n\t      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n\t    }\n\t\n\t    if (!isHtml5DateInput) {\n\t      // Internal API to maintain the correct ng-invalid-[key] class\n\t      ngModel.$$parserName = 'date';\n\t      ngModel.$validators.date = validator;\n\t      ngModel.$parsers.unshift(parseDate);\n\t      ngModel.$formatters.push(function(value) {\n\t        scope.date = value;\n\t        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);\n\t      });\n\t    } else {\n\t      ngModel.$formatters.push(function(value) {\n\t        scope.date = value;\n\t        return value;\n\t      });\n\t    }\n\t\n\t    // Detect changes in the view from the text box\n\t    ngModel.$viewChangeListeners.push(function() {\n\t      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);\n\t    });\n\t\n\t    element.bind('keydown', inputKeydownBind);\n\t\n\t    $popup = $compile(popupEl)(scope);\n\t    // Prevent jQuery cache memory leak (template is now redundant after linking)\n\t    popupEl.remove();\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    scope.$on('$destroy', function() {\n\t      if (scope.isOpen === true) {\n\t        if (!$rootScope.$$phase) {\n\t          scope.$apply(function() {\n\t            scope.isOpen = false;\n\t          });\n\t        }\n\t      }\n\t\n\t      $popup.remove();\n\t      element.unbind('keydown', inputKeydownBind);\n\t      $document.unbind('click', documentClickBind);\n\t    });\n\t  };\n\t\n\t  scope.getText = function(key) {\n\t    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n\t  };\n\t\n\t  scope.isDisabled = function(date) {\n\t    if (date === 'today') {\n\t      date = new Date();\n\t    }\n\t\n\t    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||\n\t      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));\n\t  };\n\t\n\t  scope.compare = function(date1, date2) {\n\t    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n\t  };\n\t\n\t  // Inner change\n\t  scope.dateSelection = function(dt) {\n\t    if (angular.isDefined(dt)) {\n\t      scope.date = dt;\n\t    }\n\t    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n\t    element.val(date);\n\t    ngModel.$setViewValue(date);\n\t\n\t    if (closeOnDateSelection) {\n\t      scope.isOpen = false;\n\t      element[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.keydown = function(evt) {\n\t    if (evt.which === 27) {\n\t      scope.isOpen = false;\n\t      element[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.select = function(date) {\n\t    if (date === 'today') {\n\t      var today = new Date();\n\t      if (angular.isDate(scope.date)) {\n\t        date = new Date(scope.date);\n\t        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n\t      } else {\n\t        date = new Date(today.setHours(0, 0, 0, 0));\n\t      }\n\t    }\n\t    scope.dateSelection(date);\n\t  };\n\t\n\t  scope.close = function() {\n\t    scope.isOpen = false;\n\t    element[0].focus();\n\t  };\n\t\n\t  scope.$watch('isOpen', function(value) {\n\t    if (value) {\n\t      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t      scope.position.top = scope.position.top + element.prop('offsetHeight');\n\t\n\t      $timeout(function() {\n\t        if (onOpenFocus) {\n\t          scope.$broadcast('uib:datepicker.focus');\n\t        }\n\t        $document.bind('click', documentClickBind);\n\t      }, 0, false);\n\t    } else {\n\t      $document.unbind('click', documentClickBind);\n\t    }\n\t  });\n\t\n\t  function cameltoDash(string) {\n\t    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n\t  }\n\t\n\t  function parseDate(viewValue) {\n\t    if (angular.isNumber(viewValue)) {\n\t      // presumably timestamp to date object\n\t      viewValue = new Date(viewValue);\n\t    }\n\t\n\t    if (!viewValue) {\n\t      return null;\n\t    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n\t      return viewValue;\n\t    } else if (angular.isString(viewValue)) {\n\t      var date = dateParser.parse(viewValue, dateFormat, scope.date);\n\t      if (isNaN(date)) {\n\t        return undefined;\n\t      } else {\n\t        return date;\n\t      }\n\t    } else {\n\t      return undefined;\n\t    }\n\t  }\n\t\n\t  function validator(modelValue, viewValue) {\n\t    var value = modelValue || viewValue;\n\t\n\t    if (!attrs.ngRequired && !value) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isNumber(value)) {\n\t      value = new Date(value);\n\t    }\n\t    if (!value) {\n\t      return true;\n\t    } else if (angular.isDate(value) && !isNaN(value)) {\n\t      return true;\n\t    } else if (angular.isString(value)) {\n\t      var date = dateParser.parse(value, dateFormat);\n\t      return !isNaN(date);\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  function documentClickBind(event) {\n\t    var popup = $popup[0];\n\t    var dpContainsTarget = element[0].contains(event.target);\n\t    // The popup node may not be an element node\n\t    // In some browsers (IE) only element nodes have the 'contains' function\n\t    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n\t    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n\t      scope.$apply(function() {\n\t        scope.isOpen = false;\n\t      });\n\t    }\n\t  }\n\t\n\t  function inputKeydownBind(evt) {\n\t    if (evt.which === 27 && scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      scope.$apply(function() {\n\t        scope.isOpen = false;\n\t      });\n\t      element[0].focus();\n\t    } else if (evt.which === 40 && !scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      scope.$apply(function() {\n\t        scope.isOpen = true;\n\t      });\n\t    }\n\t  }\n\t}])\n\t\n\t.directive('uibDatepickerPopup', function() {\n\t  return {\n\t    require: ['ngModel', 'uibDatepickerPopup'],\n\t    controller: 'UibDatepickerPopupController',\n\t    scope: {\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&',\n\t      customClass: '&'\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ngModel = ctrls[0],\n\t        ctrl = ctrls[1];\n\t\n\t      ctrl.init(ngModel);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDatepickerPopupWrap', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/popup.html';\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated datepicker below */\n\t\n\tangular.module('ui.bootstrap.datepicker')\n\t\n\t.value('$datepickerSuppressWarning', false)\n\t\n\t.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {\n\t  if (!$datepickerSuppressWarning) {\n\t    $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\t\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n\t    'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n\t    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n\t  });\n\t\n\t  angular.forEach(['minDate', 'maxDate'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = value ? new Date(value) : null;\n\t        self.refreshView();\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n\t    }\n\t  });\n\t\n\t  angular.forEach(['minMode', 'maxMode'], function(key) {\n\t    if ($attrs[key]) {\n\t      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n\t        self[key] = angular.isDefined(value) ? value : $attrs[key];\n\t        $scope[key] = self[key];\n\t        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n\t          $scope.datepickerMode = self[key];\n\t        }\n\t      });\n\t    } else {\n\t      self[key] = datepickerConfig[key] || null;\n\t      $scope[key] = self[key];\n\t    }\n\t  });\n\t\n\t  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t\n\t  if (angular.isDefined($attrs.initDate)) {\n\t    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n\t    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n\t      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t        self.activeDate = initDate;\n\t        self.refreshView();\n\t      }\n\t    });\n\t  } else {\n\t    this.activeDate = new Date();\n\t  }\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if (ngModelCtrl.$viewValue) {\n\t      var date = new Date(ngModelCtrl.$viewValue),\n\t        isValid = !isNaN(date);\n\t\n\t      if (isValid) {\n\t        this.activeDate = date;\n\t      } else if (!$datepickerSuppressError) {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t      }\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if (this.element) {\n\t      this._refreshView();\n\t\n\t      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t    return {\n\t      date: date,\n\t      label: dateFilter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0,\n\t      customClass: this.customClass(date)\n\t    };\n\t  };\n\t\n\t  this.isDisabled = function(date) {\n\t    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n\t  };\n\t\n\t  this.customClass = function(date) {\n\t    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  this.fixTimeZone = function(date) {\n\t    var hours = date.getHours();\n\t    date.setHours(hours === 23 ? hours + 2 : 0);\n\t  };\n\t\n\t  $scope.select = function(date) {\n\t    if ($scope.datepickerMode === self.minMode) {\n\t      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n\t      ngModelCtrl.$setViewValue(dt);\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n\t    }\n\t  };\n\t\n\t  $scope.move = function(direction) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t      month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function(direction) {\n\t    direction = direction || 1;\n\t\n\t    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n\t      return;\n\t    }\n\t\n\t    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\t\n\t  var focusElement = function() {\n\t    self.element[0].focus();\n\t  };\n\t\n\t  $scope.$on('uib:datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function(evt) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if (!key || evt.shiftKey || evt.altKey) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    if (!self.shortcutPropagation) {\n\t      evt.stopPropagation();\n\t    }\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if (self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n\t    },\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      dateDisabled: '&',\n\t      customClass: '&',\n\t      shortcutPropagation: '&?'\n\t    },\n\t    require: ['datepicker', '^ngModel'],\n\t    controller: 'DatepickerController',\n\t    controllerAs: 'datepicker',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');\n\t      }\n\t\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      datepickerCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/day.html',\n\t    require: ['^datepicker', 'daypicker'],\n\t    controller: 'UibDaypickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');\n\t      }\n\t\n\t      var datepickerCtrl = ctrls[0],\n\t        daypickerCtrl = ctrls[1];\n\t\n\t      daypickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/month.html',\n\t    require: ['^datepicker', 'monthpicker'],\n\t    controller: 'UibMonthpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');\n\t      }\n\t\n\t      var datepickerCtrl = ctrls[0],\n\t        monthpickerCtrl = ctrls[1];\n\t\n\t      monthpickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    templateUrl: 'template/datepicker/year.html',\n\t    require: ['^datepicker', 'yearpicker'],\n\t    controller: 'UibYearpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');\n\t      }\n\t\n\t      var ctrl = ctrls[0];\n\t      angular.extend(ctrl, ctrls[1]);\n\t      ctrl.yearpickerInit();\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    require: ['ngModel', 'datepickerPopup'],\n\t    controller: 'UibDatepickerPopupController',\n\t    scope: {\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&',\n\t      customClass: '&'\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');\n\t      }\n\t\n\t      var ngModel = ctrls[0],\n\t        ctrl = ctrls[1];\n\t\n\t      ctrl.init(ngModel);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/datepicker/popup.html';\n\t    },\n\t    link: function() {\n\t      if (!$datepickerSuppressWarning) {\n\t        $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\t\n\t.constant('uibDropdownConfig', {\n\t  openClass: 'open'\n\t})\n\t\n\t.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n\t  var openScope = null;\n\t\n\t  this.open = function(dropdownScope) {\n\t    if (!openScope) {\n\t      $document.bind('click', closeDropdown);\n\t      $document.bind('keydown', keybindFilter);\n\t    }\n\t\n\t    if (openScope && openScope !== dropdownScope) {\n\t      openScope.isOpen = false;\n\t    }\n\t\n\t    openScope = dropdownScope;\n\t  };\n\t\n\t  this.close = function(dropdownScope) {\n\t    if (openScope === dropdownScope) {\n\t      openScope = null;\n\t      $document.unbind('click', closeDropdown);\n\t      $document.unbind('keydown', keybindFilter);\n\t    }\n\t  };\n\t\n\t  var closeDropdown = function(evt) {\n\t    // This method may still be called during the same mouse event that\n\t    // unbound this event handler. So check openScope before proceeding.\n\t    if (!openScope) { return; }\n\t\n\t    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }\n\t\n\t    var toggleElement = openScope.getToggleElement();\n\t    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    var dropdownElement = openScope.getDropdownElement();\n\t    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n\t      dropdownElement && dropdownElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    openScope.isOpen = false;\n\t\n\t    if (!$rootScope.$$phase) {\n\t      openScope.$apply();\n\t    }\n\t  };\n\t\n\t  var keybindFilter = function(evt) {\n\t    if (evt.which === 27) {\n\t      openScope.focusToggleElement();\n\t      closeDropdown();\n\t    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      openScope.focusDropdownEntry(evt.which);\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n\t  var self = this,\n\t    scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t    templateScope,\n\t    openClass = dropdownConfig.openClass,\n\t    getIsOpen,\n\t    setIsOpen = angular.noop,\n\t    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n\t    appendToBody = false,\n\t    keynavEnabled =false,\n\t    selectedOption = null;\n\t\n\t\n\t  $element.addClass('dropdown');\n\t\n\t  this.init = function() {\n\t    if ($attrs.isOpen) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t\n\t    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n\t    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\t\n\t    if (appendToBody && self.dropdownMenu) {\n\t      $document.find('body').append(self.dropdownMenu);\n\t      $element.on('$destroy', function handleDestroyEvent() {\n\t        self.dropdownMenu.remove();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function(open) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.getAutoClose = function() {\n\t    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n\t  };\n\t\n\t  scope.getElement = function() {\n\t    return $element;\n\t  };\n\t\n\t  scope.isKeynavEnabled = function() {\n\t    return keynavEnabled;\n\t  };\n\t\n\t  scope.focusDropdownEntry = function(keyCode) {\n\t    var elems = self.dropdownMenu ? //If append to body is used.\n\t      (angular.element(self.dropdownMenu).find('a')) :\n\t      (angular.element($element).find('ul').eq(0).find('a'));\n\t\n\t    switch (keyCode) {\n\t      case (40): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = 0;\n\t        } else {\n\t          self.selectedOption = (self.selectedOption === elems.length - 1 ?\n\t            self.selectedOption :\n\t            self.selectedOption + 1);\n\t        }\n\t        break;\n\t      }\n\t      case (38): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = elems.length - 1;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === 0 ?\n\t            0 : self.selectedOption - 1;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    elems[self.selectedOption].focus();\n\t  };\n\t\n\t  scope.getDropdownElement = function() {\n\t    return self.dropdownMenu;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if (self.toggleElement) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function(isOpen, wasOpen) {\n\t    if (appendToBody && self.dropdownMenu) {\n\t      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n\t      var css = {\n\t        top: pos.top + 'px',\n\t        display: isOpen ? 'block' : 'none'\n\t      };\n\t\n\t      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n\t      if (!rightalign) {\n\t        css.left = pos.left + 'px';\n\t        css.right = 'auto';\n\t      } else {\n\t        css.left = 'auto';\n\t        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n\t      }\n\t\n\t      self.dropdownMenu.css(css);\n\t    }\n\t\n\t    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n\t      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t        toggleInvoker($scope, { open: !!isOpen });\n\t      }\n\t    });\n\t\n\t    if (isOpen) {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n\t          templateScope = scope.$new();\n\t          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n\t            var newEl = dropdownElement;\n\t            self.dropdownMenu.replaceWith(newEl);\n\t            self.dropdownMenu = newEl;\n\t          });\n\t        });\n\t      }\n\t\n\t      scope.focusToggleElement();\n\t      uibDropdownService.open(scope);\n\t    } else {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        if (templateScope) {\n\t          templateScope.$destroy();\n\t        }\n\t        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n\t        self.dropdownMenu.replaceWith(newEl);\n\t        self.dropdownMenu = newEl;\n\t      }\n\t\n\t      uibDropdownService.close(scope);\n\t      self.selectedOption = null;\n\t    }\n\t\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen($scope, isOpen);\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    if (scope.getAutoClose() !== 'disabled') {\n\t      scope.isOpen = false;\n\t    }\n\t  });\n\t\n\t  var offDestroy = $scope.$on('$destroy', function() {\n\t    scope.$destroy();\n\t  });\n\t  scope.$on('$destroy', offDestroy);\n\t}])\n\t\n\t.directive('uibDropdown', function() {\n\t  return {\n\t    controller: 'UibDropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      dropdownCtrl.init();\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownMenu', function() {\n\t  return {\n\t    restrict: 'AC',\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-menu');\n\t\n\t      var tplUrl = attrs.templateUrl;\n\t      if (tplUrl) {\n\t        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n\t      }\n\t\n\t      if (!dropdownCtrl.dropdownMenu) {\n\t        dropdownCtrl.dropdownMenu = element;\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibKeyboardNav', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      element.bind('keydown', function(e) {\n\t        if ([38, 40].indexOf(e.which) !== -1) {\n\t          e.preventDefault();\n\t          e.stopPropagation();\n\t\n\t          var elems = dropdownCtrl.dropdownMenu.find('a');\n\t\n\t          switch (e.which) {\n\t            case (40): { // Down\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = 0;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n\t                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n\t              }\n\t              break;\n\t            }\n\t            case (38): { // Up\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = elems.length - 1;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n\t                  0 : dropdownCtrl.selectedOption - 1;\n\t              }\n\t              break;\n\t            }\n\t          }\n\t          elems[dropdownCtrl.selectedOption].focus();\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownToggle', function() {\n\t  return {\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-toggle');\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if (!element.hasClass('disabled') && !attrs.disabled) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated dropdown below */\n\t\n\tangular.module('ui.bootstrap.dropdown')\n\t\n\t.value('$dropdownSuppressWarning', false)\n\t\n\t.service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {\n\t  if (!$dropdownSuppressWarning) {\n\t    $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');\n\t  }\n\t\n\t  angular.extend(this, uibDropdownService);\n\t}])\n\t\n\t.controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {\n\t  if (!$dropdownSuppressWarning) {\n\t    $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t    templateScope,\n\t    openClass = dropdownConfig.openClass,\n\t    getIsOpen,\n\t    setIsOpen = angular.noop,\n\t    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n\t    appendToBody = false,\n\t    keynavEnabled =false,\n\t    selectedOption = null;\n\t\n\t\n\t  $element.addClass('dropdown');\n\t\n\t  this.init = function() {\n\t    if ($attrs.isOpen) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t\n\t    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n\t    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\t\n\t    if (appendToBody && self.dropdownMenu) {\n\t      $document.find('body').append(self.dropdownMenu);\n\t      $element.on('$destroy', function handleDestroyEvent() {\n\t        self.dropdownMenu.remove();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function(open) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.getAutoClose = function() {\n\t    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n\t  };\n\t\n\t  scope.getElement = function() {\n\t    return $element;\n\t  };\n\t\n\t  scope.isKeynavEnabled = function() {\n\t    return keynavEnabled;\n\t  };\n\t\n\t  scope.focusDropdownEntry = function(keyCode) {\n\t    var elems = self.dropdownMenu ? //If append to body is used.\n\t      (angular.element(self.dropdownMenu).find('a')) :\n\t      (angular.element($element).find('ul').eq(0).find('a'));\n\t\n\t    switch (keyCode) {\n\t      case (40): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = 0;\n\t        } else {\n\t          self.selectedOption = (self.selectedOption === elems.length -1 ?\n\t            self.selectedOption :\n\t          self.selectedOption + 1);\n\t        }\n\t        break;\n\t      }\n\t      case (38): {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = elems.length - 1;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === 0 ?\n\t            0 : self.selectedOption - 1;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    elems[self.selectedOption].focus();\n\t  };\n\t\n\t  scope.getDropdownElement = function() {\n\t    return self.dropdownMenu;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if (self.toggleElement) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function(isOpen, wasOpen) {\n\t    if (appendToBody && self.dropdownMenu) {\n\t      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n\t      var css = {\n\t        top: pos.top + 'px',\n\t        display: isOpen ? 'block' : 'none'\n\t      };\n\t\n\t      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n\t      if (!rightalign) {\n\t        css.left = pos.left + 'px';\n\t        css.right = 'auto';\n\t      } else {\n\t        css.left = 'auto';\n\t        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n\t      }\n\t\n\t      self.dropdownMenu.css(css);\n\t    }\n\t\n\t    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n\t      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t        toggleInvoker($scope, { open: !!isOpen });\n\t      }\n\t    });\n\t\n\t    if (isOpen) {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n\t          templateScope = scope.$new();\n\t          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n\t            var newEl = dropdownElement;\n\t            self.dropdownMenu.replaceWith(newEl);\n\t            self.dropdownMenu = newEl;\n\t          });\n\t        });\n\t      }\n\t\n\t      scope.focusToggleElement();\n\t      uibDropdownService.open(scope);\n\t    } else {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        if (templateScope) {\n\t          templateScope.$destroy();\n\t        }\n\t        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n\t        self.dropdownMenu.replaceWith(newEl);\n\t        self.dropdownMenu = newEl;\n\t      }\n\t\n\t      uibDropdownService.close(scope);\n\t      self.selectedOption = null;\n\t    }\n\t\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen($scope, isOpen);\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    if (scope.getAutoClose() !== 'disabled') {\n\t      scope.isOpen = false;\n\t    }\n\t  });\n\t\n\t  var offDestroy = $scope.$on('$destroy', function() {\n\t    scope.$destroy();\n\t  });\n\t  scope.$on('$destroy', offDestroy);\n\t}])\n\t\n\t.directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    controller: 'DropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');\n\t      }\n\t\n\t      dropdownCtrl.init();\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    restrict: 'AC',\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n\t        return;\n\t      }\n\t\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');\n\t      }\n\t\n\t      element.addClass('dropdown-menu');\n\t\n\t      var tplUrl = attrs.templateUrl;\n\t      if (tplUrl) {\n\t        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n\t      }\n\t\n\t      if (!dropdownCtrl.dropdownMenu) {\n\t        dropdownCtrl.dropdownMenu = element;\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');\n\t      }\n\t\n\t      element.bind('keydown', function(e) {\n\t        if ([38, 40].indexOf(e.which) !== -1) {\n\t          e.preventDefault();\n\t          e.stopPropagation();\n\t\n\t          var elems = dropdownCtrl.dropdownMenu.find('a');\n\t\n\t          switch (e.which) {\n\t            case (40): { // Down\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = 0;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n\t                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n\t              }\n\t              break;\n\t            }\n\t            case (38): { // Up\n\t              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n\t                dropdownCtrl.selectedOption = elems.length - 1;\n\t              } else {\n\t                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n\t                  0 : dropdownCtrl.selectedOption - 1;\n\t              }\n\t              break;\n\t            }\n\t          }\n\t          elems[dropdownCtrl.selectedOption].focus();\n\t        }\n\t      });\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n\t  return {\n\t    require: '?^dropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!$dropdownSuppressWarning) {\n\t        $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');\n\t      }\n\t\n\t      if (!dropdownCtrl) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-toggle');\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if (!element.hasClass('disabled') && !attrs.disabled) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.stackedMap', [])\n\t/**\n\t * A helper, internal data structure that acts as a map but also allows getting / removing\n\t * elements in the LIFO order\n\t */\n\t  .factory('$$stackedMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var stack = [];\n\t\n\t        return {\n\t          add: function(key, value) {\n\t            stack.push({\n\t              key: key,\n\t              value: value\n\t            });\n\t          },\n\t          get: function(key) {\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                return stack[i];\n\t              }\n\t            }\n\t          },\n\t          keys: function() {\n\t            var keys = [];\n\t            for (var i = 0; i < stack.length; i++) {\n\t              keys.push(stack[i].key);\n\t            }\n\t            return keys;\n\t          },\n\t          top: function() {\n\t            return stack[stack.length - 1];\n\t          },\n\t          remove: function(key) {\n\t            var idx = -1;\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key == stack[i].key) {\n\t                idx = i;\n\t                break;\n\t              }\n\t            }\n\t            return stack.splice(idx, 1)[0];\n\t          },\n\t          removeTop: function() {\n\t            return stack.splice(stack.length - 1, 1)[0];\n\t          },\n\t          length: function() {\n\t            return stack.length;\n\t          }\n\t        };\n\t      }\n\t    };\n\t  });\n\tangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n\t/**\n\t * A helper, internal data structure that stores all references attached to key\n\t */\n\t  .factory('$$multiMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var map = {};\n\t\n\t        return {\n\t          entries: function() {\n\t            return Object.keys(map).map(function(key) {\n\t              return {\n\t                key: key,\n\t                value: map[key]\n\t              };\n\t            });\n\t          },\n\t          get: function(key) {\n\t            return map[key];\n\t          },\n\t          hasKey: function(key) {\n\t            return !!map[key];\n\t          },\n\t          keys: function() {\n\t            return Object.keys(map);\n\t          },\n\t          put: function(key, value) {\n\t            if (!map[key]) {\n\t              map[key] = [];\n\t            }\n\t\n\t            map[key].push(value);\n\t          },\n\t          remove: function(key, value) {\n\t            var values = map[key];\n\t\n\t            if (!values) {\n\t              return;\n\t            }\n\t\n\t            var idx = values.indexOf(value);\n\t\n\t            if (idx !== -1) {\n\t              values.splice(idx, 1);\n\t            }\n\t\n\t            if (!values.length) {\n\t              delete map[key];\n\t            }\n\t          }\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t/**\n\t * A helper directive for the $modal service. It creates a backdrop element.\n\t */\n\t  .directive('uibModalBackdrop', [\n\t           '$animate', '$injector', '$uibModalStack',\n\t  function($animate ,  $injector,   $modalStack) {\n\t    var $animateCss = null;\n\t\n\t    if ($injector.has('$animateCss')) {\n\t      $animateCss = $injector.get('$animateCss');\n\t    }\n\t\n\t    return {\n\t      replace: true,\n\t      templateUrl: 'template/modal/backdrop.html',\n\t      compile: function(tElement, tAttrs) {\n\t        tElement.addClass(tAttrs.backdropClass);\n\t        return linkFn;\n\t      }\n\t    };\n\t\n\t    function linkFn(scope, element, attrs) {\n\t      // Temporary fix for prefixing\n\t      element.addClass('modal-backdrop');\n\t\n\t      if (attrs.modalInClass) {\n\t        if ($animateCss) {\n\t          $animateCss(element, {\n\t            addClass: attrs.modalInClass\n\t          }).start();\n\t        } else {\n\t          $animate.addClass(element, attrs.modalInClass);\n\t        }\n\t\n\t        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t          var done = setIsAsync();\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              removeClass: attrs.modalInClass\n\t            }).start().then(done);\n\t          } else {\n\t            $animate.removeClass(element, attrs.modalInClass).then(done);\n\t          }\n\t        });\n\t      }\n\t    }\n\t  }])\n\t\n\t  .directive('uibModalWindow', [\n\t           '$uibModalStack', '$q', '$animate', '$injector',\n\t  function($modalStack ,  $q ,  $animate,   $injector) {\n\t    var $animateCss = null;\n\t\n\t    if ($injector.has('$animateCss')) {\n\t      $animateCss = $injector.get('$animateCss');\n\t    }\n\t\n\t    return {\n\t      scope: {\n\t        index: '@'\n\t      },\n\t      replace: true,\n\t      transclude: true,\n\t      templateUrl: function(tElement, tAttrs) {\n\t        return tAttrs.templateUrl || 'template/modal/window.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        element.addClass(attrs.windowClass || '');\n\t        element.addClass(attrs.windowTopClass || '');\n\t        scope.size = attrs.size;\n\t\n\t        scope.close = function(evt) {\n\t          var modal = $modalStack.getTop();\n\t          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n\t            evt.preventDefault();\n\t            evt.stopPropagation();\n\t            $modalStack.dismiss(modal.key, 'backdrop click');\n\t          }\n\t        };\n\t\n\t        // moved from template to fix issue #2280\n\t        element.on('click', scope.close);\n\t\n\t        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n\t        // We can detect that by using this property in the template associated with this directive and then use\n\t        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n\t        scope.$isRendered = true;\n\t\n\t        // Deferred object that will be resolved when this modal is render.\n\t        var modalRenderDeferObj = $q.defer();\n\t        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n\t        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n\t        attrs.$observe('modalRender', function(value) {\n\t          if (value == 'true') {\n\t            modalRenderDeferObj.resolve();\n\t          }\n\t        });\n\t\n\t        modalRenderDeferObj.promise.then(function() {\n\t          var animationPromise = null;\n\t\n\t          if (attrs.modalInClass) {\n\t            if ($animateCss) {\n\t              animationPromise = $animateCss(element, {\n\t                addClass: attrs.modalInClass\n\t              }).start();\n\t            } else {\n\t              animationPromise = $animate.addClass(element, attrs.modalInClass);\n\t            }\n\t\n\t            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t              var done = setIsAsync();\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  removeClass: attrs.modalInClass\n\t                }).start().then(done);\n\t              } else {\n\t                $animate.removeClass(element, attrs.modalInClass).then(done);\n\t              }\n\t            });\n\t          }\n\t\n\t\n\t          $q.when(animationPromise).then(function() {\n\t            var inputWithAutofocus = element[0].querySelector('[autofocus]');\n\t            /**\n\t             * Auto-focusing of a freshly-opened modal element causes any child elements\n\t             * with the autofocus attribute to lose focus. This is an issue on touch\n\t             * based devices which will show and then hide the onscreen keyboard.\n\t             * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t             * the modal element if the modal does not contain an autofocus element.\n\t             */\n\t            if (inputWithAutofocus) {\n\t              inputWithAutofocus.focus();\n\t            } else {\n\t              element[0].focus();\n\t            }\n\t          });\n\t\n\t          // Notify {@link $modalStack} that modal is rendered.\n\t          var modal = $modalStack.getTop();\n\t          if (modal) {\n\t            $modalStack.modalRendered(modal.key);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('uibModalAnimationClass', function() {\n\t    return {\n\t      compile: function(tElement, tAttrs) {\n\t        if (tAttrs.modalAnimation) {\n\t          tElement.addClass(tAttrs.uibModalAnimationClass);\n\t        }\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibModalTransclude', function() {\n\t    return {\n\t      link: function($scope, $element, $attrs, controller, $transclude) {\n\t        $transclude($scope.$parent, function(clone) {\n\t          $element.empty();\n\t          $element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  })\n\t\n\t  .factory('$uibModalStack', [\n\t             '$animate', '$timeout', '$document', '$compile', '$rootScope',\n\t             '$q',\n\t             '$injector',\n\t             '$$multiMap',\n\t             '$$stackedMap',\n\t    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n\t              $q,\n\t              $injector,\n\t              $$multiMap,\n\t              $$stackedMap) {\n\t      var $animateCss = null;\n\t\n\t      if ($injector.has('$animateCss')) {\n\t        $animateCss = $injector.get('$animateCss');\n\t      }\n\t\n\t      var OPENED_MODAL_CLASS = 'modal-open';\n\t\n\t      var backdropDomEl, backdropScope;\n\t      var openedWindows = $$stackedMap.createNew();\n\t      var openedClasses = $$multiMap.createNew();\n\t      var $modalStack = {\n\t        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n\t      };\n\t\n\t      //Modal focus behavior\n\t      var focusableElementList;\n\t      var focusIndex = 0;\n\t      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n\t        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n\t        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\t\n\t      function backdropIndex() {\n\t        var topBackdropIndex = -1;\n\t        var opened = openedWindows.keys();\n\t        for (var i = 0; i < opened.length; i++) {\n\t          if (openedWindows.get(opened[i]).value.backdrop) {\n\t            topBackdropIndex = i;\n\t          }\n\t        }\n\t        return topBackdropIndex;\n\t      }\n\t\n\t      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n\t        if (backdropScope) {\n\t          backdropScope.index = newBackdropIndex;\n\t        }\n\t      });\n\t\n\t      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n\t        var body = $document.find('body').eq(0);\n\t        var modalWindow = openedWindows.get(modalInstance).value;\n\t\n\t        //clean up the stack\n\t        openedWindows.remove(modalInstance);\n\t\n\t        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n\t          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n\t          openedClasses.remove(modalBodyClass, modalInstance);\n\t          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n\t          toggleTopWindowClass(true);\n\t        });\n\t        checkRemoveBackdrop();\n\t\n\t        //move focus to specified element if available, or else to body\n\t        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n\t          elementToReceiveFocus.focus();\n\t        } else {\n\t          body.focus();\n\t        }\n\t      }\n\t\n\t      // Add or remove \"windowTopClass\" from the top window in the stack\n\t      function toggleTopWindowClass(toggleSwitch) {\n\t        var modalWindow;\n\t\n\t        if (openedWindows.length() > 0) {\n\t          modalWindow = openedWindows.top().value;\n\t          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n\t        }\n\t      }\n\t\n\t      function checkRemoveBackdrop() {\n\t        //remove backdrop if no longer needed\n\t        if (backdropDomEl && backdropIndex() == -1) {\n\t          var backdropScopeRef = backdropScope;\n\t          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n\t            backdropScopeRef = null;\n\t          });\n\t          backdropDomEl = undefined;\n\t          backdropScope = undefined;\n\t        }\n\t      }\n\t\n\t      function removeAfterAnimate(domEl, scope, done) {\n\t        var asyncDeferred;\n\t        var asyncPromise = null;\n\t        var setIsAsync = function() {\n\t          if (!asyncDeferred) {\n\t            asyncDeferred = $q.defer();\n\t            asyncPromise = asyncDeferred.promise;\n\t          }\n\t\n\t          return function asyncDone() {\n\t            asyncDeferred.resolve();\n\t          };\n\t        };\n\t        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\t\n\t        // Note that it's intentional that asyncPromise might be null.\n\t        // That's when setIsAsync has not been called during the\n\t        // NOW_CLOSING_EVENT broadcast.\n\t        return $q.when(asyncPromise).then(afterAnimating);\n\t\n\t        function afterAnimating() {\n\t          if (afterAnimating.done) {\n\t            return;\n\t          }\n\t          afterAnimating.done = true;\n\t\n\t          if ($animateCss) {\n\t            $animateCss(domEl, {\n\t              event: 'leave'\n\t            }).start().then(function() {\n\t              domEl.remove();\n\t            });\n\t          } else {\n\t            $animate.leave(domEl);\n\t          }\n\t          scope.$destroy();\n\t          if (done) {\n\t            done();\n\t          }\n\t        }\n\t      }\n\t\n\t      $document.bind('keydown', function(evt) {\n\t        if (evt.isDefaultPrevented()) {\n\t          return evt;\n\t        }\n\t\n\t        var modal = openedWindows.top();\n\t        if (modal && modal.value.keyboard) {\n\t          switch (evt.which) {\n\t            case 27: {\n\t              evt.preventDefault();\n\t              $rootScope.$apply(function() {\n\t                $modalStack.dismiss(modal.key, 'escape key press');\n\t              });\n\t              break;\n\t            }\n\t            case 9: {\n\t              $modalStack.loadFocusElementList(modal);\n\t              var focusChanged = false;\n\t              if (evt.shiftKey) {\n\t                if ($modalStack.isFocusInFirstItem(evt)) {\n\t                  focusChanged = $modalStack.focusLastFocusableElement();\n\t                }\n\t              } else {\n\t                if ($modalStack.isFocusInLastItem(evt)) {\n\t                  focusChanged = $modalStack.focusFirstFocusableElement();\n\t                }\n\t              }\n\t\n\t              if (focusChanged) {\n\t                evt.preventDefault();\n\t                evt.stopPropagation();\n\t              }\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      });\n\t\n\t      $modalStack.open = function(modalInstance, modal) {\n\t        var modalOpener = $document[0].activeElement,\n\t          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\t\n\t        toggleTopWindowClass(false);\n\t\n\t        openedWindows.add(modalInstance, {\n\t          deferred: modal.deferred,\n\t          renderDeferred: modal.renderDeferred,\n\t          modalScope: modal.scope,\n\t          backdrop: modal.backdrop,\n\t          keyboard: modal.keyboard,\n\t          openedClass: modal.openedClass,\n\t          windowTopClass: modal.windowTopClass\n\t        });\n\t\n\t        openedClasses.put(modalBodyClass, modalInstance);\n\t\n\t        var body = $document.find('body').eq(0),\n\t            currBackdropIndex = backdropIndex();\n\t\n\t        if (currBackdropIndex >= 0 && !backdropDomEl) {\n\t          backdropScope = $rootScope.$new(true);\n\t          backdropScope.index = currBackdropIndex;\n\t          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n\t          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n\t          if (modal.animation) {\n\t            angularBackgroundDomEl.attr('modal-animation', 'true');\n\t          }\n\t          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n\t          body.append(backdropDomEl);\n\t        }\n\t\n\t        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n\t        angularDomEl.attr({\n\t          'template-url': modal.windowTemplateUrl,\n\t          'window-class': modal.windowClass,\n\t          'window-top-class': modal.windowTopClass,\n\t          'size': modal.size,\n\t          'index': openedWindows.length() - 1,\n\t          'animate': 'animate'\n\t        }).html(modal.content);\n\t        if (modal.animation) {\n\t          angularDomEl.attr('modal-animation', 'true');\n\t        }\n\t\n\t        var modalDomEl = $compile(angularDomEl)(modal.scope);\n\t        openedWindows.top().value.modalDomEl = modalDomEl;\n\t        openedWindows.top().value.modalOpener = modalOpener;\n\t        body.append(modalDomEl);\n\t        body.addClass(modalBodyClass);\n\t\n\t        $modalStack.clearFocusListCache();\n\t      };\n\t\n\t      function broadcastClosing(modalWindow, resultOrReason, closing) {\n\t        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n\t      }\n\t\n\t      $modalStack.close = function(modalInstance, result) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.resolve(result);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismiss = function(modalInstance, reason) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.reject(reason);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismissAll = function(reason) {\n\t        var topModal = this.getTop();\n\t        while (topModal && this.dismiss(topModal.key, reason)) {\n\t          topModal = this.getTop();\n\t        }\n\t      };\n\t\n\t      $modalStack.getTop = function() {\n\t        return openedWindows.top();\n\t      };\n\t\n\t      $modalStack.modalRendered = function(modalInstance) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.renderDeferred.resolve();\n\t        }\n\t      };\n\t\n\t      $modalStack.focusFirstFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[0].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t      $modalStack.focusLastFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[focusableElementList.length - 1].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInFirstItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) == focusableElementList[0];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInLastItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.clearFocusListCache = function() {\n\t        focusableElementList = [];\n\t        focusIndex = 0;\n\t      };\n\t\n\t      $modalStack.loadFocusElementList = function(modalWindow) {\n\t        if (focusableElementList === undefined || !focusableElementList.length) {\n\t          if (modalWindow) {\n\t            var modalDomE1 = modalWindow.value.modalDomEl;\n\t            if (modalDomE1 && modalDomE1.length) {\n\t              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      return $modalStack;\n\t    }])\n\t\n\t  .provider('$uibModal', function() {\n\t    var $modalProvider = {\n\t      options: {\n\t        animation: true,\n\t        backdrop: true, //can also be false or 'static'\n\t        keyboard: true\n\t      },\n\t      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log',\n\t        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {\n\t          var $modal = {};\n\t\n\t          function getTemplatePromise(options) {\n\t            return options.template ? $q.when(options.template) :\n\t              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);\n\t          }\n\t\n\t          function getResolvePromises(resolves) {\n\t            var promisesArr = [];\n\t            angular.forEach(resolves, function(value) {\n\t              if (angular.isFunction(value) || angular.isArray(value)) {\n\t                promisesArr.push($q.when($injector.invoke(value)));\n\t              } else if (angular.isString(value)) {\n\t                promisesArr.push($q.when($injector.get(value)));\n\t              } else {\n\t                promisesArr.push($q.when(value));\n\t              }\n\t            });\n\t            return promisesArr;\n\t          }\n\t\n\t          var promiseChain = null;\n\t          $modal.getPromiseChain = function() {\n\t            return promiseChain;\n\t          };\n\t\n\t          $modal.open = function(modalOptions) {\n\t            var modalResultDeferred = $q.defer();\n\t            var modalOpenedDeferred = $q.defer();\n\t            var modalRenderDeferred = $q.defer();\n\t\n\t            //prepare an instance of a modal to be injected into controllers and returned to a caller\n\t            var modalInstance = {\n\t              result: modalResultDeferred.promise,\n\t              opened: modalOpenedDeferred.promise,\n\t              rendered: modalRenderDeferred.promise,\n\t              close: function (result) {\n\t                return $modalStack.close(modalInstance, result);\n\t              },\n\t              dismiss: function (reason) {\n\t                return $modalStack.dismiss(modalInstance, reason);\n\t              }\n\t            };\n\t\n\t            //merge and clean up options\n\t            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n\t            modalOptions.resolve = modalOptions.resolve || {};\n\t\n\t            //verify options\n\t            if (!modalOptions.template && !modalOptions.templateUrl) {\n\t              throw new Error('One of template or templateUrl options is required.');\n\t            }\n\t\n\t            var templateAndResolvePromise =\n\t              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\t\n\t            function resolveWithTemplate() {\n\t              return templateAndResolvePromise;\n\t            }\n\t\n\t            // Wait for the resolution of the existing promise chain.\n\t            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n\t            // Then add to $modalStack and resolve opened.\n\t            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n\t            var samePromise;\n\t            samePromise = promiseChain = $q.all([promiseChain])\n\t              .then(resolveWithTemplate, resolveWithTemplate)\n\t              .then(function resolveSuccess(tplAndVars) {\n\t\n\t                var modalScope = (modalOptions.scope || $rootScope).$new();\n\t                modalScope.$close = modalInstance.close;\n\t                modalScope.$dismiss = modalInstance.dismiss;\n\t\n\t                modalScope.$on('$destroy', function() {\n\t                  if (!modalScope.$$uibDestructionScheduled) {\n\t                    modalScope.$dismiss('$uibUnscheduledDestruction');\n\t                  }\n\t                });\n\t\n\t                var ctrlInstance, ctrlLocals = {};\n\t                var resolveIter = 1;\n\t\n\t                //controllers\n\t                if (modalOptions.controller) {\n\t                  ctrlLocals.$scope = modalScope;\n\t                  ctrlLocals.$uibModalInstance = modalInstance;\n\t                  Object.defineProperty(ctrlLocals, '$modalInstance', {\n\t                    get: function() {\n\t                      if (!$modalSuppressWarning) {\n\t                        $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');\n\t                      }\n\t\n\t                      return modalInstance;\n\t                    }\n\t                  });\n\t                  angular.forEach(modalOptions.resolve, function(value, key) {\n\t                    ctrlLocals[key] = tplAndVars[resolveIter++];\n\t                  });\n\t\n\t                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n\t                  if (modalOptions.controllerAs) {\n\t                    if (modalOptions.bindToController) {\n\t                      angular.extend(ctrlInstance, modalScope);\n\t                    }\n\t\n\t                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n\t                  }\n\t                }\n\t\n\t                $modalStack.open(modalInstance, {\n\t                  scope: modalScope,\n\t                  deferred: modalResultDeferred,\n\t                  renderDeferred: modalRenderDeferred,\n\t                  content: tplAndVars[0],\n\t                  animation: modalOptions.animation,\n\t                  backdrop: modalOptions.backdrop,\n\t                  keyboard: modalOptions.keyboard,\n\t                  backdropClass: modalOptions.backdropClass,\n\t                  windowTopClass: modalOptions.windowTopClass,\n\t                  windowClass: modalOptions.windowClass,\n\t                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n\t                  size: modalOptions.size,\n\t                  openedClass: modalOptions.openedClass\n\t                });\n\t                modalOpenedDeferred.resolve(true);\n\t\n\t            }, function resolveError(reason) {\n\t              modalOpenedDeferred.reject(reason);\n\t              modalResultDeferred.reject(reason);\n\t            })\n\t            .finally(function() {\n\t              if (promiseChain === samePromise) {\n\t                promiseChain = null;\n\t              }\n\t            });\n\t\n\t            return modalInstance;\n\t          };\n\t\n\t          return $modal;\n\t        }\n\t      ]\n\t    };\n\t\n\t    return $modalProvider;\n\t  });\n\t\n\t/* deprecated modal below */\n\t\n\tangular.module('ui.bootstrap.modal')\n\t\n\t  .value('$modalSuppressWarning', false)\n\t\n\t  /**\n\t   * A helper directive for the $modal service. It creates a backdrop element.\n\t   */\n\t  .directive('modalBackdrop', [\n\t    '$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning',\n\t    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {\n\t      var $animateCss = null;\n\t\n\t      if ($injector.has('$animateCss')) {\n\t        $animateCss = $injector.get('$animateCss');\n\t      }\n\t\n\t      return {\n\t        replace: true,\n\t        templateUrl: 'template/modal/backdrop.html',\n\t        compile: function(tElement, tAttrs) {\n\t          tElement.addClass(tAttrs.backdropClass);\n\t          return linkFn;\n\t        }\n\t      };\n\t\n\t      function linkFn(scope, element, attrs) {\n\t        if (!$modalSuppressWarning) {\n\t          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');\n\t        }\n\t        element.addClass('modal-backdrop');\n\t\n\t        if (attrs.modalInClass) {\n\t          if ($animateCss) {\n\t            $animateCss(element, {\n\t              addClass: attrs.modalInClass\n\t            }).start();\n\t          } else {\n\t            $animate.addClass(element, attrs.modalInClass);\n\t          }\n\t\n\t          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t            var done = setIsAsync();\n\t            if ($animateCss) {\n\t              $animateCss(element, {\n\t                removeClass: attrs.modalInClass\n\t              }).start().then(done);\n\t            } else {\n\t              $animate.removeClass(element, attrs.modalInClass).then(done);\n\t            }\n\t          });\n\t        }\n\t      }\n\t    }])\n\t\n\t  .directive('modalWindow', [\n\t    '$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning',\n\t    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {\n\t      var $animateCss = null;\n\t\n\t      if ($injector.has('$animateCss')) {\n\t        $animateCss = $injector.get('$animateCss');\n\t      }\n\t\n\t      return {\n\t        scope: {\n\t          index: '@'\n\t        },\n\t        replace: true,\n\t        transclude: true,\n\t        templateUrl: function(tElement, tAttrs) {\n\t          return tAttrs.templateUrl || 'template/modal/window.html';\n\t        },\n\t        link: function(scope, element, attrs) {\n\t          if (!$modalSuppressWarning) {\n\t            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');\n\t          }\n\t          element.addClass(attrs.windowClass || '');\n\t          element.addClass(attrs.windowTopClass || '');\n\t          scope.size = attrs.size;\n\t\n\t          scope.close = function(evt) {\n\t            var modal = $modalStack.getTop();\n\t            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n\t              evt.preventDefault();\n\t              evt.stopPropagation();\n\t              $modalStack.dismiss(modal.key, 'backdrop click');\n\t            }\n\t          };\n\t\n\t          // moved from template to fix issue #2280\n\t          element.on('click', scope.close);\n\t\n\t          // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n\t          // We can detect that by using this property in the template associated with this directive and then use\n\t          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n\t          scope.$isRendered = true;\n\t\n\t          // Deferred object that will be resolved when this modal is render.\n\t          var modalRenderDeferObj = $q.defer();\n\t          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n\t          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n\t          attrs.$observe('modalRender', function(value) {\n\t            if (value == 'true') {\n\t              modalRenderDeferObj.resolve();\n\t            }\n\t          });\n\t\n\t          modalRenderDeferObj.promise.then(function() {\n\t            var animationPromise = null;\n\t\n\t            if (attrs.modalInClass) {\n\t              if ($animateCss) {\n\t                animationPromise = $animateCss(element, {\n\t                  addClass: attrs.modalInClass\n\t                }).start();\n\t              } else {\n\t                animationPromise = $animate.addClass(element, attrs.modalInClass);\n\t              }\n\t\n\t              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t                var done = setIsAsync();\n\t                if ($animateCss) {\n\t                  $animateCss(element, {\n\t                    removeClass: attrs.modalInClass\n\t                  }).start().then(done);\n\t                } else {\n\t                  $animate.removeClass(element, attrs.modalInClass).then(done);\n\t                }\n\t              });\n\t            }\n\t\n\t\n\t            $q.when(animationPromise).then(function() {\n\t              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n\t              /**\n\t               * Auto-focusing of a freshly-opened modal element causes any child elements\n\t               * with the autofocus attribute to lose focus. This is an issue on touch\n\t               * based devices which will show and then hide the onscreen keyboard.\n\t               * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t               * the modal element if the modal does not contain an autofocus element.\n\t               */\n\t              if (inputWithAutofocus) {\n\t                inputWithAutofocus.focus();\n\t              } else {\n\t                element[0].focus();\n\t              }\n\t            });\n\t\n\t            // Notify {@link $modalStack} that modal is rendered.\n\t            var modal = $modalStack.getTop();\n\t            if (modal) {\n\t              $modalStack.modalRendered(modal.key);\n\t            }\n\t          });\n\t        }\n\t      };\n\t    }])\n\t\n\t  .directive('modalAnimationClass', [\n\t    '$log', '$modalSuppressWarning',\n\t    function ($log, $modalSuppressWarning) {\n\t      return {\n\t        compile: function(tElement, tAttrs) {\n\t          if (!$modalSuppressWarning) {\n\t            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');\n\t          }\n\t          if (tAttrs.modalAnimation) {\n\t            tElement.addClass(tAttrs.modalAnimationClass);\n\t          }\n\t        }\n\t      };\n\t    }])\n\t\n\t  .directive('modalTransclude', [\n\t    '$log', '$modalSuppressWarning',\n\t    function ($log, $modalSuppressWarning) {\n\t    return {\n\t      link: function($scope, $element, $attrs, controller, $transclude) {\n\t        if (!$modalSuppressWarning) {\n\t          $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');\n\t        }\n\t        $transclude($scope.$parent, function(clone) {\n\t          $element.empty();\n\t          $element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .service('$modalStack', [\n\t    '$animate', '$timeout', '$document', '$compile', '$rootScope',\n\t    '$q',\n\t    '$injector',\n\t    '$$multiMap',\n\t    '$$stackedMap',\n\t    '$uibModalStack',\n\t    '$log',\n\t    '$modalSuppressWarning',\n\t    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n\t             $q,\n\t             $injector,\n\t             $$multiMap,\n\t             $$stackedMap,\n\t             $uibModalStack,\n\t             $log,\n\t             $modalSuppressWarning) {\n\t      if (!$modalSuppressWarning) {\n\t        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');\n\t      }\n\t\n\t      angular.extend(this, $uibModalStack);\n\t    }])\n\t\n\t  .provider('$modal', ['$uibModalProvider', function($uibModalProvider) {\n\t    angular.extend(this, $uibModalProvider);\n\t\n\t    this.$get = ['$injector', '$log', '$modalSuppressWarning',\n\t      function ($injector, $log, $modalSuppressWarning) {\n\t        if (!$modalSuppressWarning) {\n\t          $log.warn('$modal is now deprecated. Use $uibModal instead.');\n\t        }\n\t\n\t        return $injector.invoke($uibModalProvider.$get);\n\t      }];\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.pagination', [])\n\t.controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t\n\t  this.init = function(ngModelCtrl_, config) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    this.config = config;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t\n\t    if ($attrs.itemsPerPage) {\n\t      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n\t        self.itemsPerPage = parseInt(value, 10);\n\t        $scope.totalPages = self.calculateTotalPages();\n\t      });\n\t    } else {\n\t      this.itemsPerPage = config.itemsPerPage;\n\t    }\n\t\n\t    $scope.$watch('totalItems', function() {\n\t      $scope.totalPages = self.calculateTotalPages();\n\t    });\n\t\n\t    $scope.$watch('totalPages', function(value) {\n\t      setNumPages($scope.$parent, value); // Readonly variable\n\t\n\t      if ( $scope.page > value ) {\n\t        $scope.selectPage(value);\n\t      } else {\n\t        ngModelCtrl.$render();\n\t      }\n\t    });\n\t  };\n\t\n\t  this.calculateTotalPages = function() {\n\t    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n\t    return Math.max(totalPages || 0, 1);\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n\t  };\n\t\n\t  $scope.selectPage = function(page, evt) {\n\t    if (evt) {\n\t      evt.preventDefault();\n\t    }\n\t\n\t    var clickAllowed = !$scope.ngDisabled || !evt;\n\t    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t      if (evt && evt.target) {\n\t        evt.target.blur();\n\t      }\n\t      ngModelCtrl.$setViewValue(page);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.getText = function(key) {\n\t    return $scope[key + 'Text'] || self.config[key + 'Text'];\n\t  };\n\t\n\t  $scope.noPrevious = function() {\n\t    return $scope.page === 1;\n\t  };\n\t\n\t  $scope.noNext = function() {\n\t    return $scope.page === $scope.totalPages;\n\t  };\n\t}])\n\t\n\t.constant('uibPaginationConfig', {\n\t  itemsPerPage: 10,\n\t  boundaryLinks: false,\n\t  directionLinks: true,\n\t  firstText: 'First',\n\t  previousText: 'Previous',\n\t  nextText: 'Next',\n\t  lastText: 'Last',\n\t  rotate: true\n\t})\n\t\n\t.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@',\n\t      ngDisabled:'='\n\t    },\n\t    require: ['uibPagination', '?ngModel'],\n\t    controller: 'UibPaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pagination.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      // Setup configuration parameters\n\t      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n\t          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n\t      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n\t      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\t\n\t      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\t\n\t      if (attrs.maxSize) {\n\t        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n\t          maxSize = parseInt(value, 10);\n\t          paginationCtrl.render();\n\t        });\n\t      }\n\t\n\t      // Create page object used in template\n\t      function makePage(number, text, isActive) {\n\t        return {\n\t          number: number,\n\t          text: text,\n\t          active: isActive\n\t        };\n\t      }\n\t\n\t      function getPages(currentPage, totalPages) {\n\t        var pages = [];\n\t\n\t        // Default page limits\n\t        var startPage = 1, endPage = totalPages;\n\t        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\t\n\t        // recompute if maxSize\n\t        if (isMaxSized) {\n\t          if (rotate) {\n\t            // Current page is displayed in the middle of the visible ones\n\t            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n\t            endPage   = startPage + maxSize - 1;\n\t\n\t            // Adjust if limit is exceeded\n\t            if (endPage > totalPages) {\n\t              endPage   = totalPages;\n\t              startPage = endPage - maxSize + 1;\n\t            }\n\t          } else {\n\t            // Visible pages are paginated with maxSize\n\t            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\t\n\t            // Adjust last page if limit is exceeded\n\t            endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t          }\n\t        }\n\t\n\t        // Add page number links\n\t        for (var number = startPage; number <= endPage; number++) {\n\t          var page = makePage(number, number, number === currentPage);\n\t          pages.push(page);\n\t        }\n\t\n\t        // Add links to move between page sets\n\t        if (isMaxSized && ! rotate) {\n\t          if (startPage > 1) {\n\t            var previousPageSet = makePage(startPage - 1, '...', false);\n\t            pages.unshift(previousPageSet);\n\t          }\n\t\n\t          if (endPage < totalPages) {\n\t            var nextPageSet = makePage(endPage + 1, '...', false);\n\t            pages.push(nextPageSet);\n\t          }\n\t        }\n\t\n\t        return pages;\n\t      }\n\t\n\t      var originalRender = paginationCtrl.render;\n\t      paginationCtrl.render = function() {\n\t        originalRender();\n\t        if (scope.page > 0 && scope.page <= scope.totalPages) {\n\t          scope.pages = getPages(scope.page, scope.totalPages);\n\t        }\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('uibPagerConfig', {\n\t  itemsPerPage: 10,\n\t  previousText: ' Previous',\n\t  nextText: 'Next ',\n\t  align: true\n\t})\n\t\n\t.directive('uibPager', ['uibPagerConfig', function(pagerConfig) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      ngDisabled: '='\n\t    },\n\t    require: ['uibPager', '?ngModel'],\n\t    controller: 'UibPaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pager.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n\t      paginationCtrl.init(ngModelCtrl, pagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/* Deprecated Pagination Below */\n\t\n\tangular.module('ui.bootstrap.pagination')\n\t.value('$paginationSuppressWarning', false)\n\t.controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {\n\t  if (!$paginationSuppressWarning) {\n\t    $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t\n\t  this.init = function(ngModelCtrl_, config) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    this.config = config;\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t\n\t    if ($attrs.itemsPerPage) {\n\t      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n\t        self.itemsPerPage = parseInt(value, 10);\n\t        $scope.totalPages = self.calculateTotalPages();\n\t      });\n\t    } else {\n\t      this.itemsPerPage = config.itemsPerPage;\n\t    }\n\t\n\t    $scope.$watch('totalItems', function() {\n\t      $scope.totalPages = self.calculateTotalPages();\n\t    });\n\t\n\t    $scope.$watch('totalPages', function(value) {\n\t      setNumPages($scope.$parent, value); // Readonly variable\n\t\n\t      if ( $scope.page > value ) {\n\t        $scope.selectPage(value);\n\t      } else {\n\t        ngModelCtrl.$render();\n\t      }\n\t    });\n\t  };\n\t\n\t  this.calculateTotalPages = function() {\n\t    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n\t    return Math.max(totalPages || 0, 1);\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n\t  };\n\t\n\t  $scope.selectPage = function(page, evt) {\n\t    if (evt) {\n\t      evt.preventDefault();\n\t    }\n\t\n\t    var clickAllowed = !$scope.ngDisabled || !evt;\n\t    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t      if (evt && evt.target) {\n\t        evt.target.blur();\n\t      }\n\t      ngModelCtrl.$setViewValue(page);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.getText = function(key) {\n\t    return $scope[key + 'Text'] || self.config[key + 'Text'];\n\t  };\n\t\n\t  $scope.noPrevious = function() {\n\t    return $scope.page === 1;\n\t  };\n\t\n\t  $scope.noNext = function() {\n\t    return $scope.page === $scope.totalPages;\n\t  };\n\t}])\n\t.directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@',\n\t      ngDisabled:'='\n\t    },\n\t    require: ['pagination', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pagination.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$paginationSuppressWarning) {\n\t        $log.warn('pagination is now deprecated. Use uib-pagination instead.');\n\t      }\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      // Setup configuration parameters\n\t      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n\t          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n\t      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n\t      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\t\n\t      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\t\n\t      if (attrs.maxSize) {\n\t        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n\t          maxSize = parseInt(value, 10);\n\t          paginationCtrl.render();\n\t        });\n\t      }\n\t\n\t      // Create page object used in template\n\t      function makePage(number, text, isActive) {\n\t        return {\n\t          number: number,\n\t          text: text,\n\t          active: isActive\n\t        };\n\t      }\n\t\n\t      function getPages(currentPage, totalPages) {\n\t        var pages = [];\n\t\n\t        // Default page limits\n\t        var startPage = 1, endPage = totalPages;\n\t        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\t\n\t        // recompute if maxSize\n\t        if (isMaxSized) {\n\t          if (rotate) {\n\t            // Current page is displayed in the middle of the visible ones\n\t            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n\t            endPage   = startPage + maxSize - 1;\n\t\n\t            // Adjust if limit is exceeded\n\t            if (endPage > totalPages) {\n\t              endPage   = totalPages;\n\t              startPage = endPage - maxSize + 1;\n\t            }\n\t          } else {\n\t            // Visible pages are paginated with maxSize\n\t            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\t\n\t            // Adjust last page if limit is exceeded\n\t            endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t          }\n\t        }\n\t\n\t        // Add page number links\n\t        for (var number = startPage; number <= endPage; number++) {\n\t          var page = makePage(number, number, number === currentPage);\n\t          pages.push(page);\n\t        }\n\t\n\t        // Add links to move between page sets\n\t        if (isMaxSized && ! rotate) {\n\t          if (startPage > 1) {\n\t            var previousPageSet = makePage(startPage - 1, '...', false);\n\t            pages.unshift(previousPageSet);\n\t          }\n\t\n\t          if (endPage < totalPages) {\n\t            var nextPageSet = makePage(endPage + 1, '...', false);\n\t            pages.push(nextPageSet);\n\t          }\n\t        }\n\t\n\t        return pages;\n\t      }\n\t\n\t      var originalRender = paginationCtrl.render;\n\t      paginationCtrl.render = function() {\n\t        originalRender();\n\t        if (scope.page > 0 && scope.page <= scope.totalPages) {\n\t          scope.pages = getPages(scope.page, scope.totalPages);\n\t        }\n\t      };\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {\n\t  return {\n\t    restrict: 'EA',\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      ngDisabled: '='\n\t    },\n\t    require: ['pager', '?ngModel'],\n\t    controller: 'PaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/pagination/pager.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$paginationSuppressWarning) {\n\t        $log.warn('pager is now deprecated. Use uib-pager instead.');\n\t      }\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n\t      paginationCtrl.init(ngModelCtrl, pagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html tooltips, and selector delegation.\n\t */\n\tangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\t\n\t/**\n\t * The $tooltip service creates tooltip- and popover-like directives as well as\n\t * houses global options for them.\n\t */\n\t.provider('$uibTooltip', function() {\n\t  // The default options tooltip and popover.\n\t  var defaultOptions = {\n\t    placement: 'top',\n\t    animation: true,\n\t    popupDelay: 0,\n\t    popupCloseDelay: 0,\n\t    useContentExp: false\n\t  };\n\t\n\t  // Default hide triggers for each show trigger\n\t  var triggerMap = {\n\t    'mouseenter': 'mouseleave',\n\t    'click': 'click',\n\t    'focus': 'blur',\n\t    'none': ''\n\t  };\n\t\n\t  // The options specified to the provider globally.\n\t  var globalOptions = {};\n\t\n\t  /**\n\t   * `options({})` allows global configuration of all tooltips in the\n\t   * application.\n\t   *\n\t   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n\t   *     // place tooltips left instead of top by default\n\t   *     $tooltipProvider.options( { placement: 'left' } );\n\t   *   });\n\t   */\n\t\tthis.options = function(value) {\n\t\t\tangular.extend(globalOptions, value);\n\t\t};\n\t\n\t  /**\n\t   * This allows you to extend the set of trigger mappings available. E.g.:\n\t   *\n\t   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n\t   */\n\t  this.setTriggers = function setTriggers(triggers) {\n\t    angular.extend(triggerMap, triggers);\n\t  };\n\t\n\t  /**\n\t   * This is a helper function for translating camel-case to snake-case.\n\t   */\n\t  function snake_case(name) {\n\t    var regexp = /[A-Z]/g;\n\t    var separator = '-';\n\t    return name.replace(regexp, function(letter, pos) {\n\t      return (pos ? separator : '') + letter.toLowerCase();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns the actual instance of the $tooltip service.\n\t   * TODO support multiple triggers\n\t   */\n\t  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n\t    var openedTooltips = $$stackedMap.createNew();\n\t    $document.on('keypress', function(e) {\n\t      if (e.which === 27) {\n\t        var last = openedTooltips.top();\n\t        if (last) {\n\t          last.value.close();\n\t          openedTooltips.removeTop();\n\t          last = null;\n\t        }\n\t      }\n\t    });\n\t\n\t    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n\t      options = angular.extend({}, defaultOptions, globalOptions, options);\n\t\n\t      /**\n\t       * Returns an object of show and hide triggers.\n\t       *\n\t       * If a trigger is supplied,\n\t       * it is used to show the tooltip; otherwise, it will use the `trigger`\n\t       * option passed to the `$tooltipProvider.options` method; else it will\n\t       * default to the trigger supplied to this directive factory.\n\t       *\n\t       * The hide trigger is based on the show trigger. If the `trigger` option\n\t       * was passed to the `$tooltipProvider.options` method, it will use the\n\t       * mapped trigger from `triggerMap` or the passed trigger if the map is\n\t       * undefined; otherwise, it uses the `triggerMap` value of the show\n\t       * trigger; else it will just use the show trigger.\n\t       */\n\t      function getTriggers(trigger) {\n\t        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n\t        var hide = show.map(function(trigger) {\n\t          return triggerMap[trigger] || trigger;\n\t        });\n\t        return {\n\t          show: show,\n\t          hide: hide\n\t        };\n\t      }\n\t\n\t      var directiveName = snake_case(ttType);\n\t\n\t      var startSym = $interpolate.startSymbol();\n\t      var endSym = $interpolate.endSymbol();\n\t      var template =\n\t        '<div '+ directiveName + '-popup '+\n\t          'title=\"' + startSym + 'title' + endSym + '\" '+\n\t          (options.useContentExp ?\n\t            'content-exp=\"contentExp()\" ' :\n\t            'content=\"' + startSym + 'content' + endSym + '\" ') +\n\t          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n\t          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n\t          'animation=\"animation\" ' +\n\t          'is-open=\"isOpen\"' +\n\t          'origin-scope=\"origScope\" ' +\n\t          'style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"' +\n\t          '>' +\n\t        '</div>';\n\t\n\t      return {\n\t        compile: function(tElem, tAttrs) {\n\t          var tooltipLinker = $compile(template);\n\t\n\t          return function link(scope, element, attrs, tooltipCtrl) {\n\t            var tooltip;\n\t            var tooltipLinkedScope;\n\t            var transitionTimeout;\n\t            var showTimeout;\n\t            var hideTimeout;\n\t            var positionTimeout;\n\t            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n\t            var triggers = getTriggers(undefined);\n\t            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n\t            var ttScope = scope.$new(true);\n\t            var repositionScheduled = false;\n\t            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n\t            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n\t            var observers = [];\n\t\n\t            var positionTooltip = function() {\n\t              // check if tooltip exists and is not empty\n\t              if (!tooltip || !tooltip.html()) { return; }\n\t\n\t              if (!positionTimeout) {\n\t                positionTimeout = $timeout(function() {\n\t                  // Reset the positioning.\n\t                  tooltip.css({ top: 0, left: 0 });\n\t\n\t                  // Now set the calculated positioning.\n\t                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n\t                  ttCss.top += 'px';\n\t                  ttCss.left += 'px';\n\t                  ttCss.visibility = 'visible';\n\t                  tooltip.css(ttCss);\n\t\n\t                  positionTimeout = null;\n\t                }, 0, false);\n\t              }\n\t            };\n\t\n\t            // Set up the correct scope to allow transclusion later\n\t            ttScope.origScope = scope;\n\t\n\t            // By default, the tooltip is not open.\n\t            // TODO add ability to start tooltip opened\n\t            ttScope.isOpen = false;\n\t            openedTooltips.add(ttScope, {\n\t              close: hide\n\t            });\n\t\n\t            function toggleTooltipBind() {\n\t              if (!ttScope.isOpen) {\n\t                showTooltipBind();\n\t              } else {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip with delay if specified, otherwise show it immediately\n\t            function showTooltipBind() {\n\t              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n\t                return;\n\t              }\n\t\n\t              cancelHide();\n\t              prepareTooltip();\n\t\n\t              if (ttScope.popupDelay) {\n\t                // Do nothing if the tooltip was already scheduled to pop-up.\n\t                // This happens if show is triggered multiple times before any hide is triggered.\n\t                if (!showTimeout) {\n\t                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n\t                }\n\t              } else {\n\t                show();\n\t              }\n\t            }\n\t\n\t            function hideTooltipBind() {\n\t              cancelShow();\n\t\n\t              if (ttScope.popupCloseDelay) {\n\t                if (!hideTimeout) {\n\t                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n\t                }\n\t              } else {\n\t                hide();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip popup element.\n\t            function show() {\n\t              cancelShow();\n\t              cancelHide();\n\t\n\t              // Don't show empty tooltips.\n\t              if (!ttScope.content) {\n\t                return angular.noop;\n\t              }\n\t\n\t              createTooltip();\n\t\n\t              // And show the tooltip.\n\t              ttScope.$evalAsync(function() {\n\t                ttScope.isOpen = true;\n\t                assignIsOpen(true);\n\t                positionTooltip();\n\t              });\n\t            }\n\t\n\t            function cancelShow() {\n\t              if (showTimeout) {\n\t                $timeout.cancel(showTimeout);\n\t                showTimeout = null;\n\t              }\n\t\n\t              if (positionTimeout) {\n\t                $timeout.cancel(positionTimeout);\n\t                positionTimeout = null;\n\t              }\n\t            }\n\t\n\t            // Hide the tooltip popup element.\n\t            function hide() {\n\t              cancelShow();\n\t              cancelHide();\n\t\n\t              if (!ttScope) {\n\t                return;\n\t              }\n\t\n\t              // First things first: we don't show it anymore.\n\t              ttScope.$evalAsync(function() {\n\t                ttScope.isOpen = false;\n\t                assignIsOpen(false);\n\t                // And now we remove it from the DOM. However, if we have animation, we\n\t                // need to wait for it to expire beforehand.\n\t                // FIXME: this is a placeholder for a port of the transitions library.\n\t                // The fade transition in TWBS is 150ms.\n\t                if (ttScope.animation) {\n\t                  if (!transitionTimeout) {\n\t                    transitionTimeout = $timeout(removeTooltip, 150, false);\n\t                  }\n\t                } else {\n\t                  removeTooltip();\n\t                }\n\t              });\n\t            }\n\t\n\t            function cancelHide() {\n\t              if (hideTimeout) {\n\t                $timeout.cancel(hideTimeout);\n\t                hideTimeout = null;\n\t              }\n\t              if (transitionTimeout) {\n\t                $timeout.cancel(transitionTimeout);\n\t                transitionTimeout = null;\n\t              }\n\t            }\n\t\n\t            function createTooltip() {\n\t              // There can only be one tooltip element per directive shown at once.\n\t              if (tooltip) {\n\t                return;\n\t              }\n\t\n\t              tooltipLinkedScope = ttScope.$new();\n\t              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n\t                if (appendToBody) {\n\t                  $document.find('body').append(tooltip);\n\t                } else {\n\t                  element.after(tooltip);\n\t                }\n\t              });\n\t\n\t              prepObservers();\n\t            }\n\t\n\t            function removeTooltip() {\n\t              unregisterObservers();\n\t\n\t              transitionTimeout = null;\n\t              if (tooltip) {\n\t                tooltip.remove();\n\t                tooltip = null;\n\t              }\n\t              if (tooltipLinkedScope) {\n\t                tooltipLinkedScope.$destroy();\n\t                tooltipLinkedScope = null;\n\t              }\n\t            }\n\t\n\t            /**\n\t             * Set the inital scope values. Once\n\t             * the tooltip is created, the observers\n\t             * will be added to keep things in synch.\n\t             */\n\t            function prepareTooltip() {\n\t              ttScope.title = attrs[prefix + 'Title'];\n\t              if (contentParse) {\n\t                ttScope.content = contentParse(scope);\n\t              } else {\n\t                ttScope.content = attrs[ttType];\n\t              }\n\t\n\t              ttScope.popupClass = attrs[prefix + 'Class'];\n\t              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\t\n\t              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n\t              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n\t              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n\t              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n\t            }\n\t\n\t            function assignIsOpen(isOpen) {\n\t              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n\t                isOpenParse.assign(scope, isOpen);\n\t              }\n\t            }\n\t\n\t            ttScope.contentExp = function() {\n\t              return ttScope.content;\n\t            };\n\t\n\t            /**\n\t             * Observe the relevant attributes.\n\t             */\n\t            attrs.$observe('disabled', function(val) {\n\t              if (val) {\n\t                cancelShow();\n\t              }\n\t\n\t              if (val && ttScope.isOpen) {\n\t                hide();\n\t              }\n\t            });\n\t\n\t            if (isOpenParse) {\n\t              scope.$watch(isOpenParse, function(val) {\n\t                /*jshint -W018 */\n\t                if (ttScope && !val === ttScope.isOpen) {\n\t                  toggleTooltipBind();\n\t                }\n\t                /*jshint +W018 */\n\t              });\n\t            }\n\t\n\t            function prepObservers() {\n\t              observers.length = 0;\n\t\n\t              if (contentParse) {\n\t                observers.push(\n\t                  scope.$watch(contentParse, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    }\n\t                  })\n\t                );\n\t\n\t                observers.push(\n\t                  tooltipLinkedScope.$watch(function() {\n\t                    if (!repositionScheduled) {\n\t                      repositionScheduled = true;\n\t                      tooltipLinkedScope.$$postDigest(function() {\n\t                        repositionScheduled = false;\n\t                        if (ttScope && ttScope.isOpen) {\n\t                          positionTooltip();\n\t                        }\n\t                      });\n\t                    }\n\t                  })\n\t                );\n\t              } else {\n\t                observers.push(\n\t                  attrs.$observe(ttType, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    } else {\n\t                      positionTooltip();\n\t                    }\n\t                  })\n\t                );\n\t              }\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Title', function(val) {\n\t                  ttScope.title = val;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Placement', function(val) {\n\t                  ttScope.placement = val ? val : options.placement;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t            }\n\t\n\t            function unregisterObservers() {\n\t              if (observers.length) {\n\t                angular.forEach(observers, function(observer) {\n\t                  observer();\n\t                });\n\t                observers.length = 0;\n\t              }\n\t            }\n\t\n\t            var unregisterTriggers = function() {\n\t              triggers.show.forEach(function(trigger) {\n\t                element.unbind(trigger, showTooltipBind);\n\t              });\n\t              triggers.hide.forEach(function(trigger) {\n\t                trigger.split(' ').forEach(function(hideTrigger) {\n\t                  element[0].removeEventListener(hideTrigger, hideTooltipBind);\n\t                });\n\t              });\n\t            };\n\t\n\t            function prepTriggers() {\n\t              var val = attrs[prefix + 'Trigger'];\n\t              unregisterTriggers();\n\t\n\t              triggers = getTriggers(val);\n\t\n\t              if (triggers.show !== 'none') {\n\t                triggers.show.forEach(function(trigger, idx) {\n\t                  // Using raw addEventListener due to jqLite/jQuery bug - #4060\n\t                  if (trigger === triggers.hide[idx]) {\n\t                    element[0].addEventListener(trigger, toggleTooltipBind);\n\t                  } else if (trigger) {\n\t                    element[0].addEventListener(trigger, showTooltipBind);\n\t                    triggers.hide[idx].split(' ').forEach(function(trigger) {\n\t                      element[0].addEventListener(trigger, hideTooltipBind);\n\t                    });\n\t                  }\n\t\n\t                  element.on('keypress', function(e) {\n\t                    if (e.which === 27) {\n\t                      hideTooltipBind();\n\t                    }\n\t                  });\n\t                });\n\t              }\n\t            }\n\t\n\t            prepTriggers();\n\t\n\t            var animation = scope.$eval(attrs[prefix + 'Animation']);\n\t            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\t\n\t            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);\n\t            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\t\n\t            // if a tooltip is attached to <body> we need to remove it on\n\t            // location change as its parent scope will probably not be destroyed\n\t            // by the change.\n\t            if (appendToBody) {\n\t              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {\n\t                if (ttScope.isOpen) {\n\t                  hide();\n\t                }\n\t              });\n\t            }\n\t\n\t            // Make sure tooltip is destroyed and removed.\n\t            scope.$on('$destroy', function onDestroyTooltip() {\n\t              cancelShow();\n\t              cancelHide();\n\t              unregisterTriggers();\n\t              removeTooltip();\n\t              openedTooltips.remove(ttScope);\n\t              ttScope = null;\n\t            });\n\t          };\n\t        }\n\t      };\n\t    };\n\t  }];\n\t})\n\t\n\t// This is mostly ngInclude code but with a custom scope\n\t.directive('uibTooltipTemplateTransclude', [\n\t         '$animate', '$sce', '$compile', '$templateRequest',\n\tfunction ($animate ,  $sce ,  $compile ,  $templateRequest) {\n\t  return {\n\t    link: function(scope, elem, attrs) {\n\t      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\t\n\t      var changeCounter = 0,\n\t        currentScope,\n\t        previousElement,\n\t        currentElement;\n\t\n\t      var cleanupLastIncludeContent = function() {\n\t        if (previousElement) {\n\t          previousElement.remove();\n\t          previousElement = null;\n\t        }\n\t\n\t        if (currentScope) {\n\t          currentScope.$destroy();\n\t          currentScope = null;\n\t        }\n\t\n\t        if (currentElement) {\n\t          $animate.leave(currentElement).then(function() {\n\t            previousElement = null;\n\t          });\n\t          previousElement = currentElement;\n\t          currentElement = null;\n\t        }\n\t      };\n\t\n\t      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n\t        var thisChangeId = ++changeCounter;\n\t\n\t        if (src) {\n\t          //set the 2nd param to true to ignore the template request error so that the inner\n\t          //contents and scope can be cleaned up.\n\t          $templateRequest(src, true).then(function(response) {\n\t            if (thisChangeId !== changeCounter) { return; }\n\t            var newScope = origScope.$new();\n\t            var template = response;\n\t\n\t            var clone = $compile(template)(newScope, function(clone) {\n\t              cleanupLastIncludeContent();\n\t              $animate.enter(clone, elem);\n\t            });\n\t\n\t            currentScope = newScope;\n\t            currentElement = clone;\n\t\n\t            currentScope.$emit('$includeContentLoaded', src);\n\t          }, function() {\n\t            if (thisChangeId === changeCounter) {\n\t              cleanupLastIncludeContent();\n\t              scope.$emit('$includeContentError', src);\n\t            }\n\t          });\n\t          scope.$emit('$includeContentRequested', src);\n\t        } else {\n\t          cleanupLastIncludeContent();\n\t        }\n\t      });\n\t\n\t      scope.$on('$destroy', cleanupLastIncludeContent);\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * Note that it's intentional that these classes are *not* applied through $animate.\n\t * They must not be animated as they're expected to be present on the tooltip on\n\t * initialization.\n\t */\n\t.directive('uibTooltipClasses', function() {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attrs) {\n\t      if (scope.placement) {\n\t        element.addClass(scope.placement);\n\t      }\n\t\n\t      if (scope.popupClass) {\n\t        element.addClass(scope.popupClass);\n\t      }\n\t\n\t      if (scope.animation()) {\n\t        element.addClass(attrs.tooltipAnimationClass);\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltipPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-popup.html',\n\t    link: function(scope, element) {\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n\t}])\n\t\n\t.directive('uibTooltipTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n\t    link: function(scope, element) {\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibTooltipHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n\t    link: function(scope, element) {\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}]);\n\t\n\t/* Deprecated tooltip below */\n\t\n\tangular.module('ui.bootstrap.tooltip')\n\t\n\t.value('$tooltipSuppressWarning', false)\n\t\n\t.provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {\n\t  angular.extend(this, $uibTooltipProvider);\n\t\n\t  this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {\n\t    if (!$tooltipSuppressWarning) {\n\t      $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');\n\t    }\n\t\n\t    return $injector.invoke($uibTooltipProvider.$get);\n\t  }];\n\t}])\n\t\n\t// This is mostly ngInclude code but with a custom scope\n\t.directive('tooltipTemplateTransclude', [\n\t         '$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning',\n\tfunction ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {\n\t  return {\n\t    link: function(scope, elem, attrs) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');\n\t      }\n\t\n\t      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\t\n\t      var changeCounter = 0,\n\t        currentScope,\n\t        previousElement,\n\t        currentElement;\n\t\n\t      var cleanupLastIncludeContent = function() {\n\t        if (previousElement) {\n\t          previousElement.remove();\n\t          previousElement = null;\n\t        }\n\t        if (currentScope) {\n\t          currentScope.$destroy();\n\t          currentScope = null;\n\t        }\n\t        if (currentElement) {\n\t          $animate.leave(currentElement).then(function() {\n\t            previousElement = null;\n\t          });\n\t          previousElement = currentElement;\n\t          currentElement = null;\n\t        }\n\t      };\n\t\n\t      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {\n\t        var thisChangeId = ++changeCounter;\n\t\n\t        if (src) {\n\t          //set the 2nd param to true to ignore the template request error so that the inner\n\t          //contents and scope can be cleaned up.\n\t          $templateRequest(src, true).then(function(response) {\n\t            if (thisChangeId !== changeCounter) { return; }\n\t            var newScope = origScope.$new();\n\t            var template = response;\n\t\n\t            var clone = $compile(template)(newScope, function(clone) {\n\t              cleanupLastIncludeContent();\n\t              $animate.enter(clone, elem);\n\t            });\n\t\n\t            currentScope = newScope;\n\t            currentElement = clone;\n\t\n\t            currentScope.$emit('$includeContentLoaded', src);\n\t          }, function() {\n\t            if (thisChangeId === changeCounter) {\n\t              cleanupLastIncludeContent();\n\t              scope.$emit('$includeContentError', src);\n\t            }\n\t          });\n\t          scope.$emit('$includeContentRequested', src);\n\t        } else {\n\t          cleanupLastIncludeContent();\n\t        }\n\t      });\n\t\n\t      scope.$on('$destroy', cleanupLastIncludeContent);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attrs) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');\n\t      }\n\t\n\t      if (scope.placement) {\n\t        element.addClass(scope.placement);\n\t      }\n\t      if (scope.popupClass) {\n\t        element.addClass(scope.popupClass);\n\t      }\n\t      if (scope.animation()) {\n\t        element.addClass(attrs.tooltipAnimationClass);\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-popup.html',\n\t    link: function(scope, element) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');\n\t      }\n\t\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltip', ['$tooltip', function($tooltip) {\n\t  return $tooltip('tooltip', 'tooltip', 'mouseenter');\n\t}])\n\t\n\t.directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n\t    link: function(scope, element) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');\n\t      }\n\t\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipTemplate', ['$tooltip', function($tooltip) {\n\t  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n\t    link: function(scope, element) {\n\t      if (!$tooltipSuppressWarning) {\n\t        $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');\n\t      }\n\t\n\t      element.addClass('tooltip');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('tooltipHtml', ['$tooltip', function($tooltip) {\n\t  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: popup delay, animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, and selector delegatation.\n\t */\n\tangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\t\n\t.directive('uibPopoverTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/popover/popover-template.html',\n\t    link: function(scope, element) {\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover-html.html',\n\t    link: function(scope, element) {\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover.html',\n\t    link: function(scope, element) {\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopover', 'popover', 'click');\n\t}]);\n\t\n\t/* Deprecated popover below */\n\t\n\tangular.module('ui.bootstrap.popover')\n\t\n\t.value('$popoverSuppressWarning', false)\n\t\n\t.directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'template/popover/popover-template.html',\n\t    link: function(scope, element) {\n\t      if (!$popoverSuppressWarning) {\n\t        $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');\n\t      }\n\t\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('popoverTemplate', ['$tooltip', function($tooltip) {\n\t  return $tooltip('popoverTemplate', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover-html.html',\n\t    link: function(scope, element) {\n\t      if (!$popoverSuppressWarning) {\n\t        $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');\n\t      }\n\t\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('popoverHtml', ['$tooltip', function($tooltip) {\n\t  return $tooltip('popoverHtml', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'template/popover/popover.html',\n\t    link: function(scope, element) {\n\t      if (!$popoverSuppressWarning) {\n\t        $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');\n\t      }\n\t\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('popover', ['$tooltip', function($tooltip) {\n\t\n\t  return $tooltip('popover', 'popover', 'click');\n\t}]);\n\t\n\tangular.module('ui.bootstrap.progressbar', [])\n\t\n\t.constant('uibProgressConfig', {\n\t  animate: true,\n\t  max: 100\n\t})\n\t\n\t.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n\t  var self = this,\n\t      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t  this.bars = [];\n\t  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\t\n\t  this.addBar = function(bar, element, attrs) {\n\t    if (!animate) {\n\t      element.css({'transition': 'none'});\n\t    }\n\t\n\t    this.bars.push(bar);\n\t\n\t    bar.max = $scope.max;\n\t    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\t\n\t    bar.$watch('value', function(value) {\n\t      bar.recalculatePercentage();\n\t    });\n\t\n\t    bar.recalculatePercentage = function() {\n\t      var totalPercentage = self.bars.reduce(function(total, bar) {\n\t        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\t        return total + bar.percent;\n\t      }, 0);\n\t\n\t      if (totalPercentage > 100) {\n\t        bar.percent -= totalPercentage - 100;\n\t      }\n\t    };\n\t\n\t    bar.$on('$destroy', function() {\n\t      element = null;\n\t      self.removeBar(bar);\n\t    });\n\t  };\n\t\n\t  this.removeBar = function(bar) {\n\t    this.bars.splice(this.bars.indexOf(bar), 1);\n\t    this.bars.forEach(function (bar) {\n\t      bar.recalculatePercentage();\n\t    });\n\t  };\n\t\n\t  $scope.$watch('max', function(max) {\n\t    self.bars.forEach(function(bar) {\n\t      bar.max = $scope.max;\n\t      bar.recalculatePercentage();\n\t    });\n\t  });\n\t}])\n\t\n\t.directive('uibProgress', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    require: 'uibProgress',\n\t    scope: {\n\t      max: '=?'\n\t    },\n\t    templateUrl: 'template/progressbar/progress.html'\n\t  };\n\t})\n\t\n\t.directive('uibBar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    require: '^uibProgress',\n\t    scope: {\n\t      value: '=',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/bar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, element, attrs);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibProgressbar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    scope: {\n\t      value: '=',\n\t      max: '=?',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/progressbar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated progressbar below */\n\t\n\tangular.module('ui.bootstrap.progressbar')\n\t\n\t.value('$progressSuppressWarning', false)\n\t\n\t.controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {\n\t  if (!$progressSuppressWarning) {\n\t    $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');\n\t  }\n\t\n\t  var self = this,\n\t    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t  this.bars = [];\n\t  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\t\n\t  this.addBar = function(bar, element, attrs) {\n\t    if (!animate) {\n\t      element.css({'transition': 'none'});\n\t    }\n\t\n\t    this.bars.push(bar);\n\t\n\t    bar.max = $scope.max;\n\t    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\t\n\t    bar.$watch('value', function(value) {\n\t      bar.recalculatePercentage();\n\t    });\n\t\n\t    bar.recalculatePercentage = function() {\n\t      bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\t\n\t      var totalPercentage = self.bars.reduce(function(total, bar) {\n\t        return total + bar.percent;\n\t      }, 0);\n\t\n\t      if (totalPercentage > 100) {\n\t        bar.percent -= totalPercentage - 100;\n\t      }\n\t    };\n\t\n\t    bar.$on('$destroy', function() {\n\t      element = null;\n\t      self.removeBar(bar);\n\t    });\n\t  };\n\t\n\t  this.removeBar = function(bar) {\n\t    this.bars.splice(this.bars.indexOf(bar), 1);\n\t  };\n\t\n\t  $scope.$watch('max', function(max) {\n\t    self.bars.forEach(function(bar) {\n\t      bar.max = $scope.max;\n\t      bar.recalculatePercentage();\n\t    });\n\t  });\n\t}])\n\t\n\t.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'ProgressController',\n\t    require: 'progress',\n\t    scope: {\n\t      max: '=?',\n\t      title: '@?'\n\t    },\n\t    templateUrl: 'template/progressbar/progress.html',\n\t    link: function() {\n\t      if (!$progressSuppressWarning) {\n\t        $log.warn('progress is now deprecated. Use uib-progress instead.');\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    require: '^progress',\n\t    scope: {\n\t      value: '=',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/bar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      if (!$progressSuppressWarning) {\n\t        $log.warn('bar is now deprecated. Use uib-bar instead.');\n\t      }\n\t      progressCtrl.addBar(scope, element);\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'ProgressController',\n\t    scope: {\n\t      value: '=',\n\t      max: '=?',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'template/progressbar/progressbar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      if (!$progressSuppressWarning) {\n\t        $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');\n\t      }\n\t      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.rating', [])\n\t\n\t.constant('uibRatingConfig', {\n\t  max: 5,\n\t  stateOn: null,\n\t  stateOff: null,\n\t  titles : ['one', 'two', 'three', 'four', 'five']\n\t})\n\t\n\t.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n\t  var ngModelCtrl  = { $setViewValue: angular.noop };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.push(function(value) {\n\t      if (angular.isNumber(value) && value << 0 !== value) {\n\t        value = Math.round(value);\n\t      }\n\t      return value;\n\t    });\n\t\n\t    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n\t    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\t    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n\t    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n\t      tmpTitles : ratingConfig.titles;\n\t\n\t    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n\t      $scope.$parent.$eval($attrs.ratingStates) :\n\t      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n\t    $scope.range = this.buildTemplateObjects(ratingStates);\n\t  };\n\t\n\t  this.buildTemplateObjects = function(states) {\n\t    for (var i = 0, n = states.length; i < n; i++) {\n\t      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n\t    }\n\t    return states;\n\t  };\n\t\n\t  this.getTitle = function(index) {\n\t    if (index >= this.titles.length) {\n\t      return index + 1;\n\t    } else {\n\t      return this.titles[index];\n\t    }\n\t  };\n\t\n\t  $scope.rate = function(value) {\n\t    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n\t      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.enter = function(value) {\n\t    if (!$scope.readonly) {\n\t      $scope.value = value;\n\t    }\n\t    $scope.onHover({value: value});\n\t  };\n\t\n\t  $scope.reset = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t    $scope.onLeave();\n\t  };\n\t\n\t  $scope.onKeydown = function(evt) {\n\t    if (/(37|38|39|40)/.test(evt.which)) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n\t    }\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t  };\n\t}])\n\t\n\t.directive('uibRating', function() {\n\t  return {\n\t    require: ['uibRating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'UibRatingController',\n\t    templateUrl: 'template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      ratingCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated rating below */\n\t\n\tangular.module('ui.bootstrap.rating')\n\t\n\t.value('$ratingSuppressWarning', false)\n\t\n\t.controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {\n\t  if (!$ratingSuppressWarning) {\n\t    $log.warn('RatingController is now deprecated. Use UibRatingController instead.');\n\t  }\n\t\n\t  angular.extend(this, $controller('UibRatingController', {\n\t    $scope: $scope,\n\t    $attrs: $attrs\n\t  }));\n\t}])\n\t\n\t.directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {\n\t  return {\n\t    require: ['rating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'RatingController',\n\t    templateUrl: 'template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$ratingSuppressWarning) {\n\t        $log.warn('rating is now deprecated. Use uib-rating instead.');\n\t      }\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      ratingCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t}]);\n\t\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.bootstrap.tabs\n\t *\n\t * @description\n\t * AngularJS version of the tabs directive.\n\t */\n\t\n\tangular.module('ui.bootstrap.tabs', [])\n\t\n\t.controller('UibTabsetController', ['$scope', function ($scope) {\n\t  var ctrl = this,\n\t      tabs = ctrl.tabs = $scope.tabs = [];\n\t\n\t  ctrl.select = function(selectedTab) {\n\t    angular.forEach(tabs, function(tab) {\n\t      if (tab.active && tab !== selectedTab) {\n\t        tab.active = false;\n\t        tab.onDeselect();\n\t        selectedTab.selectCalled = false;\n\t      }\n\t    });\n\t    selectedTab.active = true;\n\t    // only call select if it has not already been called\n\t    if (!selectedTab.selectCalled) {\n\t      selectedTab.onSelect();\n\t      selectedTab.selectCalled = true;\n\t    }\n\t  };\n\t\n\t  ctrl.addTab = function addTab(tab) {\n\t    tabs.push(tab);\n\t    // we can't run the select function on the first tab\n\t    // since that would select it twice\n\t    if (tabs.length === 1 && tab.active !== false) {\n\t      tab.active = true;\n\t    } else if (tab.active) {\n\t      ctrl.select(tab);\n\t    } else {\n\t      tab.active = false;\n\t    }\n\t  };\n\t\n\t  ctrl.removeTab = function removeTab(tab) {\n\t    var index = tabs.indexOf(tab);\n\t    //Select a new tab if the tab to be removed is selected and not destroyed\n\t    if (tab.active && tabs.length > 1 && !destroyed) {\n\t      //If this is the last tab, select the previous tab. else, the next tab.\n\t      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n\t      ctrl.select(tabs[newActiveIndex]);\n\t    }\n\t    tabs.splice(index, 1);\n\t  };\n\t\n\t  var destroyed;\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t  });\n\t}])\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabset\n\t * @restrict EA\n\t *\n\t * @description\n\t * Tabset is the outer container for the tabs directive\n\t *\n\t * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n\t * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <uib-tabset>\n\t      <uib-tab heading=\"Tab 1\"><b>First</b> Content!</uib-tab>\n\t      <uib-tab heading=\"Tab 2\"><i>Second</i> Content!</uib-tab>\n\t    </uib-tabset>\n\t    <hr />\n\t    <uib-tabset vertical=\"true\">\n\t      <uib-tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</uib-tab>\n\t      <uib-tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</uib-tab>\n\t    </uib-tabset>\n\t    <uib-tabset justified=\"true\">\n\t      <uib-tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</uib-tab>\n\t      <uib-tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</uib-tab>\n\t    </uib-tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('uibTabset', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@'\n\t    },\n\t    controller: 'UibTabsetController',\n\t    templateUrl: 'template/tabs/tabset.html',\n\t    link: function(scope, element, attrs) {\n\t      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n\t      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n\t    }\n\t  };\n\t})\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tab\n\t * @restrict EA\n\t *\n\t * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n\t * @param {string=} select An expression to evaluate when the tab is selected.\n\t * @param {boolean=} active A binding, telling whether or not this tab is selected.\n\t * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n\t *\n\t * @description\n\t * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <div ng-controller=\"TabsDemoCtrl\">\n\t      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n\t        Select item 1, using active binding\n\t      </button>\n\t      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n\t        Enable/disable item 2, using disabled binding\n\t      </button>\n\t      <br />\n\t      <uib-tabset>\n\t        <uib-tab heading=\"Tab 1\">First Tab</uib-tab>\n\t        <uib-tab select=\"alertMe()\">\n\t          <uib-tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n\t          Second Tab, with alert callback and html heading!\n\t        </uib-tab>\n\t        <uib-tab ng-repeat=\"item in items\"\n\t          heading=\"{{item.title}}\"\n\t          disabled=\"item.disabled\"\n\t          active=\"item.active\">\n\t          {{item.content}}\n\t        </uib-tab>\n\t      </uib-tabset>\n\t    </div>\n\t  </file>\n\t  <file name=\"script.js\">\n\t    function TabsDemoCtrl($scope) {\n\t      $scope.items = [\n\t        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n\t        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n\t      ];\n\t\n\t      $scope.alertMe = function() {\n\t        setTimeout(function() {\n\t          alert(\"You've selected the alert tab!\");\n\t        });\n\t      };\n\t    };\n\t  </file>\n\t</example>\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.bootstrap.tabs.directive:tabHeading\n\t * @restrict EA\n\t *\n\t * @description\n\t * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n\t *\n\t * @example\n\t<example module=\"ui.bootstrap\">\n\t  <file name=\"index.html\">\n\t    <uib-tabset>\n\t      <uib-tab>\n\t        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>\n\t        And some content, too!\n\t      </uib-tab>\n\t      <uib-tab>\n\t        <uib-tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n\t        That's right.\n\t      </uib-tab>\n\t    </uib-tabset>\n\t  </file>\n\t</example>\n\t */\n\t.directive('uibTab', ['$parse', function($parse) {\n\t  return {\n\t    require: '^uibTabset',\n\t    restrict: 'EA',\n\t    replace: true,\n\t    templateUrl: 'template/tabs/tab.html',\n\t    transclude: true,\n\t    scope: {\n\t      active: '=?',\n\t      heading: '@',\n\t      onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t                          //once it inserts the tab's content into the dom\n\t      onDeselect: '&deselect'\n\t    },\n\t    controller: function() {\n\t      //Empty controller so other directives can require being 'under' a tab\n\t    },\n\t    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n\t      scope.$watch('active', function(active) {\n\t        if (active) {\n\t          tabsetCtrl.select(scope);\n\t        }\n\t      });\n\t\n\t      scope.disabled = false;\n\t      if (attrs.disable) {\n\t        scope.$parent.$watch($parse(attrs.disable), function(value) {\n\t          scope.disabled = !! value;\n\t        });\n\t      }\n\t\n\t      scope.select = function() {\n\t        if (!scope.disabled) {\n\t          scope.active = true;\n\t        }\n\t      };\n\t\n\t      tabsetCtrl.addTab(scope);\n\t      scope.$on('$destroy', function() {\n\t        tabsetCtrl.removeTab(scope);\n\t      });\n\t\n\t      //We need to transclude later, once the content container is ready.\n\t      //when this link happens, we're inside a tab heading.\n\t      scope.$transcludeFn = transclude;\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTabHeadingTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uibTab', '?^tab'], // TODO: change to '^uibTab' after deprecation removal\n\t    link: function(scope, elm) {\n\t      scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t        if (heading) {\n\t          elm.html('');\n\t          elm.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTabContentTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uibTabset', '?^tabset'], // TODO: change to '^uibTabset' after deprecation removal\n\t    link: function(scope, elm, attrs) {\n\t      var tab = scope.$eval(attrs.uibTabContentTransclude);\n\t\n\t      //Now our tab is ready to be transcluded: both the tab heading area\n\t      //and the tab content area are loaded.  Transclude 'em both.\n\t      tab.$transcludeFn(tab.$parent, function(contents) {\n\t        angular.forEach(contents, function(node) {\n\t          if (isTabHeading(node)) {\n\t            //Let tabHeadingTransclude know.\n\t            tab.headingElement = node;\n\t          } else {\n\t            elm.append(node);\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t\n\t  function isTabHeading(node) {\n\t    return node.tagName && (\n\t      node.hasAttribute('tab-heading') || // TODO: remove after deprecation removal\n\t      node.hasAttribute('data-tab-heading') || // TODO: remove after deprecation removal\n\t      node.hasAttribute('x-tab-heading') || // TODO: remove after deprecation removal\n\t      node.hasAttribute('uib-tab-heading') ||\n\t      node.hasAttribute('data-uib-tab-heading') ||\n\t      node.hasAttribute('x-uib-tab-heading') ||\n\t      node.tagName.toLowerCase() === 'tab-heading' || // TODO: remove after deprecation removal\n\t      node.tagName.toLowerCase() === 'data-tab-heading' || // TODO: remove after deprecation removal\n\t      node.tagName.toLowerCase() === 'x-tab-heading' || // TODO: remove after deprecation removal\n\t      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n\t    );\n\t  }\n\t});\n\t\n\t/* deprecated tabs below */\n\t\n\tangular.module('ui.bootstrap.tabs')\n\t\n\t  .value('$tabsSuppressWarning', false)\n\t\n\t  .controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {\n\t    if (!$tabsSuppressWarning) {\n\t      $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');\n\t    }\n\t\n\t    angular.extend(this, $controller('UibTabsetController', {\n\t      $scope: $scope\n\t    }));\n\t  }])\n\t\n\t  .directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n\t    return {\n\t      restrict: 'EA',\n\t      transclude: true,\n\t      replace: true,\n\t      scope: {\n\t        type: '@'\n\t      },\n\t      controller: 'TabsetController',\n\t      templateUrl: 'template/tabs/tabset.html',\n\t      link: function(scope, element, attrs) {\n\t\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tabset is now deprecated. Use uib-tabset instead.');\n\t        }\n\t        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n\t        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {\n\t    return {\n\t      require: '^tabset',\n\t      restrict: 'EA',\n\t      replace: true,\n\t      templateUrl: 'template/tabs/tab.html',\n\t      transclude: true,\n\t      scope: {\n\t        active: '=?',\n\t        heading: '@',\n\t        onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t        //once it inserts the tab's content into the dom\n\t        onDeselect: '&deselect'\n\t      },\n\t      controller: function() {\n\t        //Empty controller so other directives can require being 'under' a tab\n\t      },\n\t      link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tab is now deprecated. Use uib-tab instead.');\n\t        }\n\t\n\t        scope.$watch('active', function(active) {\n\t          if (active) {\n\t            tabsetCtrl.select(scope);\n\t          }\n\t        });\n\t\n\t        scope.disabled = false;\n\t        if (attrs.disable) {\n\t          scope.$parent.$watch($parse(attrs.disable), function(value) {\n\t            scope.disabled = !!value;\n\t          });\n\t        }\n\t\n\t        scope.select = function() {\n\t          if (!scope.disabled) {\n\t            scope.active = true;\n\t          }\n\t        };\n\t\n\t        tabsetCtrl.addTab(scope);\n\t        scope.$on('$destroy', function() {\n\t          tabsetCtrl.removeTab(scope);\n\t        });\n\t\n\t        //We need to transclude later, once the content container is ready.\n\t        //when this link happens, we're inside a tab heading.\n\t        scope.$transcludeFn = transclude;\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n\t    return {\n\t      restrict: 'A',\n\t      require: '^tab',\n\t      link: function(scope, elm) {\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');\n\t        }\n\t\n\t        scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t          if (heading) {\n\t            elm.html('');\n\t            elm.append(heading);\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n\t    return {\n\t      restrict: 'A',\n\t      require: '^tabset',\n\t      link: function(scope, elm, attrs) {\n\t        if (!$tabsSuppressWarning) {\n\t          $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');\n\t        }\n\t\n\t        var tab = scope.$eval(attrs.tabContentTransclude);\n\t\n\t        //Now our tab is ready to be transcluded: both the tab heading area\n\t        //and the tab content area are loaded.  Transclude 'em both.\n\t        tab.$transcludeFn(tab.$parent, function(contents) {\n\t          angular.forEach(contents, function(node) {\n\t            if (isTabHeading(node)) {\n\t              //Let tabHeadingTransclude know.\n\t              tab.headingElement = node;\n\t            }\n\t            else {\n\t              elm.append(node);\n\t            }\n\t          });\n\t        });\n\t      }\n\t    };\n\t\n\t    function isTabHeading(node) {\n\t      return node.tagName && (\n\t          node.hasAttribute('tab-heading') ||\n\t          node.hasAttribute('data-tab-heading') ||\n\t          node.hasAttribute('x-tab-heading') ||\n\t          node.tagName.toLowerCase() === 'tab-heading' ||\n\t          node.tagName.toLowerCase() === 'data-tab-heading' ||\n\t          node.tagName.toLowerCase() === 'x-tab-heading'\n\t        );\n\t    }\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.timepicker', [])\n\t\n\t.constant('uibTimepickerConfig', {\n\t  hourStep: 1,\n\t  minuteStep: 1,\n\t  showMeridian: true,\n\t  meridians: null,\n\t  readonlyInput: false,\n\t  mousewheel: true,\n\t  arrowkeys: true,\n\t  showSpinners: true\n\t})\n\t\n\t.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n\t  var selected = new Date(),\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\t\n\t  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n\t  $element.removeAttr('tabindex');\n\t\n\t  this.init = function(ngModelCtrl_, inputs) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.unshift(function(modelValue) {\n\t      return modelValue ? new Date(modelValue) : null;\n\t    });\n\t\n\t    var hoursInputEl = inputs.eq(0),\n\t        minutesInputEl = inputs.eq(1);\n\t\n\t    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\t    if (mousewheel) {\n\t      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);\n\t    }\n\t\n\t    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n\t    if (arrowkeys) {\n\t      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);\n\t    }\n\t\n\t    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n\t    this.setupInputEvents(hoursInputEl, minutesInputEl);\n\t  };\n\t\n\t  var hourStep = timepickerConfig.hourStep;\n\t  if ($attrs.hourStep) {\n\t    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n\t      hourStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  var minuteStep = timepickerConfig.minuteStep;\n\t  if ($attrs.minuteStep) {\n\t    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n\t      minuteStep = parseInt(value, 10);\n\t    });\n\t  }\n\t\n\t  var min;\n\t  $scope.$parent.$watch($parse($attrs.min), function(value) {\n\t    var dt = new Date(value);\n\t    min = isNaN(dt) ? undefined : dt;\n\t  });\n\t\n\t  var max;\n\t  $scope.$parent.$watch($parse($attrs.max), function(value) {\n\t    var dt = new Date(value);\n\t    max = isNaN(dt) ? undefined : dt;\n\t  });\n\t\n\t  $scope.noIncrementHours = function() {\n\t    var incrementedSelected = addMinutes(selected, hourStep * 60);\n\t    return incrementedSelected > max ||\n\t      (incrementedSelected < selected && incrementedSelected < min);\n\t  };\n\t\n\t  $scope.noDecrementHours = function() {\n\t    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n\t    return decrementedSelected < min ||\n\t      (decrementedSelected > selected && decrementedSelected > max);\n\t  };\n\t\n\t  $scope.noIncrementMinutes = function() {\n\t    var incrementedSelected = addMinutes(selected, minuteStep);\n\t    return incrementedSelected > max ||\n\t      (incrementedSelected < selected && incrementedSelected < min);\n\t  };\n\t\n\t  $scope.noDecrementMinutes = function() {\n\t    var decrementedSelected = addMinutes(selected, -minuteStep);\n\t    return decrementedSelected < min ||\n\t      (decrementedSelected > selected && decrementedSelected > max);\n\t  };\n\t\n\t  $scope.noToggleMeridian = function() {\n\t    if (selected.getHours() < 13) {\n\t      return addMinutes(selected, 12 * 60) > max;\n\t    } else {\n\t      return addMinutes(selected, -12 * 60) < min;\n\t    }\n\t  };\n\t\n\t  // 12H / 24H mode\n\t  $scope.showMeridian = timepickerConfig.showMeridian;\n\t  if ($attrs.showMeridian) {\n\t    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n\t      $scope.showMeridian = !!value;\n\t\n\t      if (ngModelCtrl.$error.time) {\n\t        // Evaluate from template\n\t        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n\t        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t          selected.setHours(hours);\n\t          refresh();\n\t        }\n\t      } else {\n\t        updateTemplate();\n\t      }\n\t    });\n\t  }\n\t\n\t  // Get $scope.hours in 24H mode if valid\n\t  function getHoursFromTemplate() {\n\t    var hours = parseInt($scope.hours, 10);\n\t    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n\t    if (!valid) {\n\t      return undefined;\n\t    }\n\t\n\t    if ($scope.showMeridian) {\n\t      if (hours === 12) {\n\t        hours = 0;\n\t      }\n\t      if ($scope.meridian === meridians[1]) {\n\t        hours = hours + 12;\n\t      }\n\t    }\n\t    return hours;\n\t  }\n\t\n\t  function getMinutesFromTemplate() {\n\t    var minutes = parseInt($scope.minutes, 10);\n\t    return (minutes >= 0 && minutes < 60) ? minutes : undefined;\n\t  }\n\t\n\t  function pad(value) {\n\t    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();\n\t  }\n\t\n\t  // Respond on mousewheel spin\n\t  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {\n\t    var isScrollingUp = function(e) {\n\t      if (e.originalEvent) {\n\t        e = e.originalEvent;\n\t      }\n\t      //pick correct delta variable depending on event\n\t      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n\t      return (e.detail || delta > 0);\n\t    };\n\t\n\t    hoursInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n\t      e.preventDefault();\n\t    });\n\t\n\t    minutesInputEl.bind('mousewheel wheel', function(e) {\n\t      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n\t      e.preventDefault();\n\t    });\n\t\n\t  };\n\t\n\t  // Respond on up/down arrowkeys\n\t  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {\n\t    hoursInputEl.bind('keydown', function(e) {\n\t      if (e.which === 38) { // up\n\t        e.preventDefault();\n\t        $scope.incrementHours();\n\t        $scope.$apply();\n\t      } else if (e.which === 40) { // down\n\t        e.preventDefault();\n\t        $scope.decrementHours();\n\t        $scope.$apply();\n\t      }\n\t    });\n\t\n\t    minutesInputEl.bind('keydown', function(e) {\n\t      if (e.which === 38) { // up\n\t        e.preventDefault();\n\t        $scope.incrementMinutes();\n\t        $scope.$apply();\n\t      } else if (e.which === 40) { // down\n\t        e.preventDefault();\n\t        $scope.decrementMinutes();\n\t        $scope.$apply();\n\t      }\n\t    });\n\t  };\n\t\n\t  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {\n\t    if ($scope.readonlyInput) {\n\t      $scope.updateHours = angular.noop;\n\t      $scope.updateMinutes = angular.noop;\n\t      return;\n\t    }\n\t\n\t    var invalidate = function(invalidHours, invalidMinutes) {\n\t      ngModelCtrl.$setViewValue(null);\n\t      ngModelCtrl.$setValidity('time', false);\n\t      if (angular.isDefined(invalidHours)) {\n\t        $scope.invalidHours = invalidHours;\n\t      }\n\t      if (angular.isDefined(invalidMinutes)) {\n\t        $scope.invalidMinutes = invalidMinutes;\n\t      }\n\t    };\n\t\n\t    $scope.updateHours = function() {\n\t      var hours = getHoursFromTemplate(),\n\t        minutes = getMinutesFromTemplate();\n\t\n\t      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t        selected.setHours(hours);\n\t        if (selected < min || selected > max) {\n\t          invalidate(true);\n\t        } else {\n\t          refresh('h');\n\t        }\n\t      } else {\n\t        invalidate(true);\n\t      }\n\t    };\n\t\n\t    hoursInputEl.bind('blur', function(e) {\n\t      if (!$scope.invalidHours && $scope.hours < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.hours = pad($scope.hours);\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateMinutes = function() {\n\t      var minutes = getMinutesFromTemplate(),\n\t        hours = getHoursFromTemplate();\n\t\n\t      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n\t        selected.setMinutes(minutes);\n\t        if (selected < min || selected > max) {\n\t          invalidate(undefined, true);\n\t        } else {\n\t          refresh('m');\n\t        }\n\t      } else {\n\t        invalidate(undefined, true);\n\t      }\n\t    };\n\t\n\t    minutesInputEl.bind('blur', function(e) {\n\t      if (!$scope.invalidMinutes && $scope.minutes < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.minutes = pad($scope.minutes);\n\t        });\n\t      }\n\t    });\n\t\n\t  };\n\t\n\t  this.render = function() {\n\t    var date = ngModelCtrl.$viewValue;\n\t\n\t    if (isNaN(date)) {\n\t      ngModelCtrl.$setValidity('time', false);\n\t      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t    } else {\n\t      if (date) {\n\t        selected = date;\n\t      }\n\t\n\t      if (selected < min || selected > max) {\n\t        ngModelCtrl.$setValidity('time', false);\n\t        $scope.invalidHours = true;\n\t        $scope.invalidMinutes = true;\n\t      } else {\n\t        makeValid();\n\t      }\n\t      updateTemplate();\n\t    }\n\t  };\n\t\n\t  // Call internally when we know that model is valid.\n\t  function refresh(keyboardChange) {\n\t    makeValid();\n\t    ngModelCtrl.$setViewValue(new Date(selected));\n\t    updateTemplate(keyboardChange);\n\t  }\n\t\n\t  function makeValid() {\n\t    ngModelCtrl.$setValidity('time', true);\n\t    $scope.invalidHours = false;\n\t    $scope.invalidMinutes = false;\n\t  }\n\t\n\t  function updateTemplate(keyboardChange) {\n\t    var hours = selected.getHours(), minutes = selected.getMinutes();\n\t\n\t    if ($scope.showMeridian) {\n\t      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system\n\t    }\n\t\n\t    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n\t    if (keyboardChange !== 'm') {\n\t      $scope.minutes = pad(minutes);\n\t    }\n\t    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t  }\n\t\n\t  function addMinutes(date, minutes) {\n\t    var dt = new Date(date.getTime() + minutes * 60000);\n\t    var newDate = new Date(date);\n\t    newDate.setHours(dt.getHours(), dt.getMinutes());\n\t    return newDate;\n\t  }\n\t\n\t  function addMinutesToSelected(minutes) {\n\t    selected = addMinutes(selected, minutes);\n\t    refresh();\n\t  }\n\t\n\t  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n\t    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\t\n\t  $scope.incrementHours = function() {\n\t    if (!$scope.noIncrementHours()) {\n\t      addMinutesToSelected(hourStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.decrementHours = function() {\n\t    if (!$scope.noDecrementHours()) {\n\t      addMinutesToSelected(-hourStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.incrementMinutes = function() {\n\t    if (!$scope.noIncrementMinutes()) {\n\t      addMinutesToSelected(minuteStep);\n\t    }\n\t  };\n\t\n\t  $scope.decrementMinutes = function() {\n\t    if (!$scope.noDecrementMinutes()) {\n\t      addMinutesToSelected(-minuteStep);\n\t    }\n\t  };\n\t\n\t  $scope.toggleMeridian = function() {\n\t    if (!$scope.noToggleMeridian()) {\n\t      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTimepicker', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['uibTimepicker', '?^ngModel'],\n\t    controller: 'UibTimepickerController',\n\t    controllerAs: 'timepicker',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (ngModelCtrl) {\n\t        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n\t      }\n\t    }\n\t  };\n\t});\n\t\n\t/* Deprecated timepicker below */\n\t\n\tangular.module('ui.bootstrap.timepicker')\n\t\n\t.value('$timepickerSuppressWarning', false)\n\t\n\t.controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {\n\t  if (!$timepickerSuppressWarning) {\n\t    $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');\n\t  }\n\t\n\t  angular.extend(this, $controller('UibTimepickerController', {\n\t    $scope: $scope,\n\t    $element: $element,\n\t    $attrs: $attrs\n\t  }));\n\t}])\n\t\n\t.directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {\n\t  return {\n\t    restrict: 'EA',\n\t    require: ['timepicker', '?^ngModel'],\n\t    controller: 'TimepickerController',\n\t    controllerAs: 'timepicker',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      if (!$timepickerSuppressWarning) {\n\t        $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');\n\t      }\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (ngModelCtrl) {\n\t        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])\n\t\n\t/**\n\t * A helper service that can parse typeahead's syntax (string provided by users)\n\t * Extracted to a separate service for ease of unit testing\n\t */\n\t  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n\t    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n\t    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\t    return {\n\t      parse: function(input) {\n\t        var match = input.match(TYPEAHEAD_REGEXP);\n\t        if (!match) {\n\t          throw new Error(\n\t            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n\t              ' but got \"' + input + '\".');\n\t        }\n\t\n\t        return {\n\t          itemName: match[3],\n\t          source: $parse(match[4]),\n\t          viewMapper: $parse(match[2] || match[1]),\n\t          modelMapper: $parse(match[1])\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser',\n\t    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {\n\t    var HOT_KEYS = [9, 13, 27, 38, 40];\n\t    var eventDebounceTime = 200;\n\t    var modelCtrl, ngModelOptions;\n\t    //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t    //minimal no of characters that needs to be entered before typeahead kicks-in\n\t    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n\t    if (!minLength && minLength !== 0) {\n\t      minLength = 1;\n\t    }\n\t\n\t    //minimal wait time after last character typed before typeahead kicks-in\n\t    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t    //should it restrict model values to the ones selected from the popup only?\n\t    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t\n\t    //binding to a variable that indicates if matches are being retrieved asynchronously\n\t    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t    //a callback executed when a match is selected\n\t    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t    //should it select highlighted popup value when losing focus?\n\t    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\t\n\t    //binding to a variable that indicates if there were no results after the query is completed\n\t    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\t\n\t    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t    var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\t\n\t    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\t\n\t    //If input matches an item of the list exactly, select it automatically\n\t    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\t\n\t    //INTERNAL VARIABLES\n\t\n\t    //model setter executed upon match selection\n\t    var parsedModel = $parse(attrs.ngModel);\n\t    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n\t    var $setModelValue = function(scope, newValue) {\n\t      if (angular.isFunction(parsedModel(originalScope)) &&\n\t        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n\t        return invokeModelSetter(scope, {$$$p: newValue});\n\t      } else {\n\t        return parsedModel.assign(scope, newValue);\n\t      }\n\t    };\n\t\n\t    //expressions used by typeahead\n\t    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\t\n\t    var hasFocus;\n\t\n\t    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n\t    //mousedown & mouseup events\n\t    //Issue #3699\n\t    var selected;\n\t\n\t    //create a child scope for the typeahead directive so we are not polluting original scope\n\t    //with typeahead-specific data (matches, query etc.)\n\t    var scope = originalScope.$new();\n\t    var offDestroy = originalScope.$on('$destroy', function() {\n\t      scope.$destroy();\n\t    });\n\t    scope.$on('$destroy', offDestroy);\n\t\n\t    // WAI-ARIA\n\t    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t    element.attr({\n\t      'aria-autocomplete': 'list',\n\t      'aria-expanded': false,\n\t      'aria-owns': popupId\n\t    });\n\t\n\t    //pop-up element used to display matches\n\t    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n\t    popUpEl.attr({\n\t      id: popupId,\n\t      matches: 'matches',\n\t      active: 'activeIdx',\n\t      select: 'select(activeIdx)',\n\t      'move-in-progress': 'moveInProgress',\n\t      query: 'query',\n\t      position: 'position'\n\t    });\n\t    //custom item template\n\t    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t    }\n\t\n\t    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n\t      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n\t    }\n\t\n\t    var resetMatches = function() {\n\t      scope.matches = [];\n\t      scope.activeIdx = -1;\n\t      element.attr('aria-expanded', false);\n\t    };\n\t\n\t    var getMatchId = function(index) {\n\t      return popupId + '-option-' + index;\n\t    };\n\t\n\t    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t    // This attribute is added or removed automatically when the `activeIdx` changes.\n\t    scope.$watch('activeIdx', function(index) {\n\t      if (index < 0) {\n\t        element.removeAttr('aria-activedescendant');\n\t      } else {\n\t        element.attr('aria-activedescendant', getMatchId(index));\n\t      }\n\t    });\n\t\n\t    var inputIsExactMatch = function(inputValue, index) {\n\t      if (scope.matches.length > index && inputValue) {\n\t        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    var getMatchesAsync = function(inputValue) {\n\t      var locals = {$viewValue: inputValue};\n\t      isLoadingSetter(originalScope, true);\n\t      isNoResultsSetter(originalScope, false);\n\t      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t        //it might happen that several async queries were in progress if a user were typing fast\n\t        //but we are interested only in responses that correspond to the current view value\n\t        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n\t        if (onCurrentRequest && hasFocus) {\n\t          if (matches && matches.length > 0) {\n\t            scope.activeIdx = focusFirst ? 0 : -1;\n\t            isNoResultsSetter(originalScope, false);\n\t            scope.matches.length = 0;\n\t\n\t            //transform labels\n\t            for (var i = 0; i < matches.length; i++) {\n\t              locals[parserResult.itemName] = matches[i];\n\t              scope.matches.push({\n\t                id: getMatchId(i),\n\t                label: parserResult.viewMapper(scope, locals),\n\t                model: matches[i]\n\t              });\n\t            }\n\t\n\t            scope.query = inputValue;\n\t            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t            //due to other elements being rendered\n\t            recalculatePosition();\n\t\n\t            element.attr('aria-expanded', true);\n\t\n\t            //Select the single remaining option if user input matches\n\t            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n\t              scope.select(0);\n\t            }\n\t          } else {\n\t            resetMatches();\n\t            isNoResultsSetter(originalScope, true);\n\t          }\n\t        }\n\t        if (onCurrentRequest) {\n\t          isLoadingSetter(originalScope, false);\n\t        }\n\t      }, function() {\n\t        resetMatches();\n\t        isLoadingSetter(originalScope, false);\n\t        isNoResultsSetter(originalScope, true);\n\t      });\n\t    };\n\t\n\t    // bind events only if appendToBody params exist - performance feature\n\t    if (appendToBody) {\n\t      angular.element($window).bind('resize', fireRecalculating);\n\t      $document.find('body').bind('scroll', fireRecalculating);\n\t    }\n\t\n\t    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t    var timeoutEventPromise;\n\t\n\t    // Default progress type\n\t    scope.moveInProgress = false;\n\t\n\t    function fireRecalculating() {\n\t      if (!scope.moveInProgress) {\n\t        scope.moveInProgress = true;\n\t        scope.$digest();\n\t      }\n\t\n\t      // Cancel previous timeout\n\t      if (timeoutEventPromise) {\n\t        $timeout.cancel(timeoutEventPromise);\n\t      }\n\t\n\t      // Debounced executing recalculate after events fired\n\t      timeoutEventPromise = $timeout(function() {\n\t        // if popup is visible\n\t        if (scope.matches.length) {\n\t          recalculatePosition();\n\t        }\n\t\n\t        scope.moveInProgress = false;\n\t      }, eventDebounceTime);\n\t    }\n\t\n\t    // recalculate actual position and set new values to scope\n\t    // after digest loop is popup in right position\n\t    function recalculatePosition() {\n\t      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t      scope.position.top += element.prop('offsetHeight');\n\t    }\n\t\n\t    //we need to propagate user's query so we can higlight matches\n\t    scope.query = undefined;\n\t\n\t    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t    var timeoutPromise;\n\t\n\t    var scheduleSearchWithTimeout = function(inputValue) {\n\t      timeoutPromise = $timeout(function() {\n\t        getMatchesAsync(inputValue);\n\t      }, waitTime);\n\t    };\n\t\n\t    var cancelPreviousTimeout = function() {\n\t      if (timeoutPromise) {\n\t        $timeout.cancel(timeoutPromise);\n\t      }\n\t    };\n\t\n\t    resetMatches();\n\t\n\t    scope.select = function(activeIdx) {\n\t      //called from within the $digest() cycle\n\t      var locals = {};\n\t      var model, item;\n\t\n\t      selected = true;\n\t      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t      model = parserResult.modelMapper(originalScope, locals);\n\t      $setModelValue(originalScope, model);\n\t      modelCtrl.$setValidity('editable', true);\n\t      modelCtrl.$setValidity('parse', true);\n\t\n\t      onSelectCallback(originalScope, {\n\t        $item: item,\n\t        $model: model,\n\t        $label: parserResult.viewMapper(originalScope, locals)\n\t      });\n\t\n\t      resetMatches();\n\t\n\t      //return focus to the input element if a match was selected via a mouse click event\n\t      // use timeout to avoid $rootScope:inprog error\n\t      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n\t        $timeout(function() { element[0].focus(); }, 0, false);\n\t      }\n\t    };\n\t\n\t    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t    element.bind('keydown', function(evt) {\n\t      //typeahead is open and an \"interesting\" key was pressed\n\t      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t        return;\n\t      }\n\t\n\t      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n\t      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n\t        resetMatches();\n\t        scope.$digest();\n\t        return;\n\t      }\n\t\n\t      evt.preventDefault();\n\t\n\t      if (evt.which === 40) {\n\t        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t        scope.$digest();\n\t      } else if (evt.which === 38) {\n\t        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n\t        scope.$digest();\n\t      } else if (evt.which === 13 || evt.which === 9) {\n\t        scope.$apply(function () {\n\t          scope.select(scope.activeIdx);\n\t        });\n\t      } else if (evt.which === 27) {\n\t        evt.stopPropagation();\n\t\n\t        resetMatches();\n\t        scope.$digest();\n\t      }\n\t    });\n\t\n\t    element.bind('blur', function() {\n\t      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n\t        selected = true;\n\t        scope.$apply(function() {\n\t          scope.select(scope.activeIdx);\n\t        });\n\t      }\n\t      hasFocus = false;\n\t      selected = false;\n\t    });\n\t\n\t    // Keep reference to click handler to unbind it.\n\t    var dismissClickHandler = function(evt) {\n\t      // Issue #3973\n\t      // Firefox treats right click as a click on document\n\t      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n\t        resetMatches();\n\t        if (!$rootScope.$$phase) {\n\t          scope.$digest();\n\t        }\n\t      }\n\t    };\n\t\n\t    $document.bind('click', dismissClickHandler);\n\t\n\t    originalScope.$on('$destroy', function() {\n\t      $document.unbind('click', dismissClickHandler);\n\t      if (appendToBody || appendToElementId) {\n\t        $popup.remove();\n\t      }\n\t\n\t      if (appendToBody) {\n\t        angular.element($window).unbind('resize', fireRecalculating);\n\t        $document.find('body').unbind('scroll', fireRecalculating);\n\t      }\n\t      // Prevent jQuery cache memory leak\n\t      popUpEl.remove();\n\t    });\n\t\n\t    var $popup = $compile(popUpEl)(scope);\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else if (appendToElementId !== false) {\n\t      angular.element($document[0].getElementById(appendToElementId)).append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    this.init = function(_modelCtrl, _ngModelOptions) {\n\t      modelCtrl = _modelCtrl;\n\t      ngModelOptions = _ngModelOptions;\n\t\n\t      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t      modelCtrl.$parsers.unshift(function(inputValue) {\n\t        hasFocus = true;\n\t\n\t        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n\t          if (waitTime > 0) {\n\t            cancelPreviousTimeout();\n\t            scheduleSearchWithTimeout(inputValue);\n\t          } else {\n\t            getMatchesAsync(inputValue);\n\t          }\n\t        } else {\n\t          isLoadingSetter(originalScope, false);\n\t          cancelPreviousTimeout();\n\t          resetMatches();\n\t        }\n\t\n\t        if (isEditable) {\n\t          return inputValue;\n\t        } else {\n\t          if (!inputValue) {\n\t            // Reset in case user had typed something previously.\n\t            modelCtrl.$setValidity('editable', true);\n\t            return null;\n\t          } else {\n\t            modelCtrl.$setValidity('editable', false);\n\t            return undefined;\n\t          }\n\t        }\n\t      });\n\t\n\t      modelCtrl.$formatters.push(function(modelValue) {\n\t        var candidateViewValue, emptyViewValue;\n\t        var locals = {};\n\t\n\t        // The validity may be set to false via $parsers (see above) if\n\t        // the model is restricted to selected values. If the model\n\t        // is set manually it is considered to be valid.\n\t        if (!isEditable) {\n\t          modelCtrl.$setValidity('editable', true);\n\t        }\n\t\n\t        if (inputFormatter) {\n\t          locals.$model = modelValue;\n\t          return inputFormatter(originalScope, locals);\n\t        } else {\n\t          //it might happen that we don't have enough info to properly render input value\n\t          //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t          locals[parserResult.itemName] = modelValue;\n\t          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t          locals[parserResult.itemName] = undefined;\n\t          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n\t        }\n\t      });\n\t    };\n\t  }])\n\t\n\t  .directive('uibTypeahead', function() {\n\t    return {\n\t      controller: 'UibTypeaheadController',\n\t      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n\t      link: function(originalScope, element, attrs, ctrls) {\n\t        ctrls[2].init(ctrls[0], ctrls[1]);\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibTypeaheadPopup', function() {\n\t    return {\n\t      scope: {\n\t        matches: '=',\n\t        query: '=',\n\t        active: '=',\n\t        position: '&',\n\t        moveInProgress: '=',\n\t        select: '&'\n\t      },\n\t      replace: true,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function() {\n\t          return scope.matches.length > 0;\n\t        };\n\t\n\t        scope.isActive = function(matchIdx) {\n\t          return scope.active == matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function(matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function(activeIdx) {\n\t          scope.select({activeIdx:activeIdx});\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n\t    return {\n\t      scope: {\n\t        index: '=',\n\t        match: '=',\n\t        query: '='\n\t      },\n\t      link:function(scope, element, attrs) {\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n\t        $templateRequest(tplUrl).then(function(tplContent) {\n\t          $compile(tplContent.trim())(scope, function(clonedElement) {\n\t            element.replaceWith(clonedElement);\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n\t    var isSanitizePresent;\n\t    isSanitizePresent = $injector.has('$sanitize');\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      // Regex: capture the whole query string and replace it with the string that will be used to match\n\t      // the results, for example if the capture is \"a\" the result will be \\a\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    function containsHtml(matchItem) {\n\t      return /<.*>/g.test(matchItem);\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      if (!isSanitizePresent && containsHtml(matchItem)) {\n\t        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n\t      }\n\t      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n\t      if (!isSanitizePresent) {\n\t        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n\t      }\n\t      return matchItem;\n\t    };\n\t  }]);\n\t\n\t/* Deprecated typeahead below */\n\t  \n\tangular.module('ui.bootstrap.typeahead')\n\t  .value('$typeaheadSuppressWarning', false)\n\t  .service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {\n\t    if (!$typeaheadSuppressWarning) {\n\t      $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');\n\t    }\n\t\n\t    return uibTypeaheadParser;\n\t  }])\n\t\n\t  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning',\n\t    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {\n\t    var HOT_KEYS = [9, 13, 27, 38, 40];\n\t    var eventDebounceTime = 200;\n\t    return {\n\t      require: ['ngModel', '^?ngModelOptions'],\n\t      link: function(originalScope, element, attrs, ctrls) {\n\t        if (!$typeaheadSuppressWarning) {\n\t          $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');\n\t        }\n\t        var modelCtrl = ctrls[0];\n\t        var ngModelOptions = ctrls[1];\n\t        //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t        //minimal no of characters that needs to be entered before typeahead kicks-in\n\t        var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n\t        if (!minLength && minLength !== 0) {\n\t          minLength = 1;\n\t        }\n\t\n\t        //minimal wait time after last character typed before typeahead kicks-in\n\t        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t        //should it restrict model values to the ones selected from the popup only?\n\t        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t\n\t        //binding to a variable that indicates if matches are being retrieved asynchronously\n\t        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t        //a callback executed when a match is selected\n\t        var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t        //should it select highlighted popup value when losing focus?\n\t        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\t\n\t        //binding to a variable that indicates if there were no results after the query is completed\n\t        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\t\n\t        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t        var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\t\n\t        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\t\n\t        //If input matches an item of the list exactly, select it automatically\n\t        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\t\n\t        //INTERNAL VARIABLES\n\t\n\t        //model setter executed upon match selection\n\t        var parsedModel = $parse(attrs.ngModel);\n\t        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n\t        var $setModelValue = function(scope, newValue) {\n\t          if (angular.isFunction(parsedModel(originalScope)) &&\n\t            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n\t            return invokeModelSetter(scope, {$$$p: newValue});\n\t          } else {\n\t            return parsedModel.assign(scope, newValue);\n\t          }\n\t        };\n\t\n\t        //expressions used by typeahead\n\t        var parserResult = typeaheadParser.parse(attrs.typeahead);\n\t\n\t        var hasFocus;\n\t\n\t        //Used to avoid bug in iOS webview where iOS keyboard does not fire\n\t        //mousedown & mouseup events\n\t        //Issue #3699\n\t        var selected;\n\t\n\t        //create a child scope for the typeahead directive so we are not polluting original scope\n\t        //with typeahead-specific data (matches, query etc.)\n\t        var scope = originalScope.$new();\n\t        var offDestroy = originalScope.$on('$destroy', function() {\n\t\t\t\t    scope.$destroy();\n\t        });\n\t        scope.$on('$destroy', offDestroy);\n\t\n\t        // WAI-ARIA\n\t        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t        element.attr({\n\t          'aria-autocomplete': 'list',\n\t          'aria-expanded': false,\n\t          'aria-owns': popupId\n\t        });\n\t\n\t        //pop-up element used to display matches\n\t        var popUpEl = angular.element('<div typeahead-popup></div>');\n\t        popUpEl.attr({\n\t          id: popupId,\n\t          matches: 'matches',\n\t          active: 'activeIdx',\n\t          select: 'select(activeIdx)',\n\t          'move-in-progress': 'moveInProgress',\n\t          query: 'query',\n\t          position: 'position'\n\t        });\n\t        //custom item template\n\t        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t        }\n\t\n\t        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n\t          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n\t        }\n\t\n\t        var resetMatches = function() {\n\t          scope.matches = [];\n\t          scope.activeIdx = -1;\n\t          element.attr('aria-expanded', false);\n\t        };\n\t\n\t        var getMatchId = function(index) {\n\t          return popupId + '-option-' + index;\n\t        };\n\t\n\t        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t        // This attribute is added or removed automatically when the `activeIdx` changes.\n\t        scope.$watch('activeIdx', function(index) {\n\t          if (index < 0) {\n\t            element.removeAttr('aria-activedescendant');\n\t          } else {\n\t            element.attr('aria-activedescendant', getMatchId(index));\n\t          }\n\t        });\n\t\n\t        var inputIsExactMatch = function(inputValue, index) {\n\t          if (scope.matches.length > index && inputValue) {\n\t            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n\t          }\n\t\n\t          return false;\n\t        };\n\t\n\t        var getMatchesAsync = function(inputValue) {\n\t          var locals = {$viewValue: inputValue};\n\t          isLoadingSetter(originalScope, true);\n\t          isNoResultsSetter(originalScope, false);\n\t          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t            //it might happen that several async queries were in progress if a user were typing fast\n\t            //but we are interested only in responses that correspond to the current view value\n\t            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n\t            if (onCurrentRequest && hasFocus) {\n\t              if (matches && matches.length > 0) {\n\t                scope.activeIdx = focusFirst ? 0 : -1;\n\t                isNoResultsSetter(originalScope, false);\n\t                scope.matches.length = 0;\n\t\n\t                //transform labels\n\t                for (var i = 0; i < matches.length; i++) {\n\t                  locals[parserResult.itemName] = matches[i];\n\t                  scope.matches.push({\n\t                    id: getMatchId(i),\n\t                    label: parserResult.viewMapper(scope, locals),\n\t                    model: matches[i]\n\t                  });\n\t                }\n\t\n\t                scope.query = inputValue;\n\t                //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t                //due to other elements being rendered\n\t                recalculatePosition();\n\t\n\t                element.attr('aria-expanded', true);\n\t\n\t                //Select the single remaining option if user input matches\n\t                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n\t                  scope.select(0);\n\t                }\n\t              } else {\n\t                resetMatches();\n\t                isNoResultsSetter(originalScope, true);\n\t              }\n\t            }\n\t            if (onCurrentRequest) {\n\t              isLoadingSetter(originalScope, false);\n\t            }\n\t          }, function() {\n\t            resetMatches();\n\t            isLoadingSetter(originalScope, false);\n\t            isNoResultsSetter(originalScope, true);\n\t          });\n\t        };\n\t\n\t        // bind events only if appendToBody params exist - performance feature\n\t        if (appendToBody) {\n\t          angular.element($window).bind('resize', fireRecalculating);\n\t          $document.find('body').bind('scroll', fireRecalculating);\n\t        }\n\t\n\t        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t        var timeoutEventPromise;\n\t\n\t        // Default progress type\n\t        scope.moveInProgress = false;\n\t\n\t        function fireRecalculating() {\n\t          if (!scope.moveInProgress) {\n\t            scope.moveInProgress = true;\n\t            scope.$digest();\n\t          }\n\t\n\t          // Cancel previous timeout\n\t          if (timeoutEventPromise) {\n\t            $timeout.cancel(timeoutEventPromise);\n\t          }\n\t\n\t          // Debounced executing recalculate after events fired\n\t          timeoutEventPromise = $timeout(function() {\n\t            // if popup is visible\n\t            if (scope.matches.length) {\n\t              recalculatePosition();\n\t            }\n\t\n\t            scope.moveInProgress = false;\n\t          }, eventDebounceTime);\n\t        }\n\t\n\t        // recalculate actual position and set new values to scope\n\t        // after digest loop is popup in right position\n\t        function recalculatePosition() {\n\t          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t          scope.position.top += element.prop('offsetHeight');\n\t        }\n\t\n\t        resetMatches();\n\t\n\t        //we need to propagate user's query so we can higlight matches\n\t        scope.query = undefined;\n\t\n\t        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t        var timeoutPromise;\n\t\n\t        var scheduleSearchWithTimeout = function(inputValue) {\n\t          timeoutPromise = $timeout(function() {\n\t            getMatchesAsync(inputValue);\n\t          }, waitTime);\n\t        };\n\t\n\t        var cancelPreviousTimeout = function() {\n\t          if (timeoutPromise) {\n\t            $timeout.cancel(timeoutPromise);\n\t          }\n\t        };\n\t\n\t        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t        modelCtrl.$parsers.unshift(function(inputValue) {\n\t          hasFocus = true;\n\t\n\t          if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n\t            if (waitTime > 0) {\n\t              cancelPreviousTimeout();\n\t              scheduleSearchWithTimeout(inputValue);\n\t            } else {\n\t              getMatchesAsync(inputValue);\n\t            }\n\t          } else {\n\t            isLoadingSetter(originalScope, false);\n\t            cancelPreviousTimeout();\n\t            resetMatches();\n\t          }\n\t\n\t          if (isEditable) {\n\t            return inputValue;\n\t          } else {\n\t            if (!inputValue) {\n\t              // Reset in case user had typed something previously.\n\t              modelCtrl.$setValidity('editable', true);\n\t              return null;\n\t            } else {\n\t              modelCtrl.$setValidity('editable', false);\n\t              return undefined;\n\t            }\n\t          }\n\t        });\n\t\n\t        modelCtrl.$formatters.push(function(modelValue) {\n\t          var candidateViewValue, emptyViewValue;\n\t          var locals = {};\n\t\n\t          // The validity may be set to false via $parsers (see above) if\n\t          // the model is restricted to selected values. If the model\n\t          // is set manually it is considered to be valid.\n\t          if (!isEditable) {\n\t            modelCtrl.$setValidity('editable', true);\n\t          }\n\t\n\t          if (inputFormatter) {\n\t            locals.$model = modelValue;\n\t            return inputFormatter(originalScope, locals);\n\t          } else {\n\t            //it might happen that we don't have enough info to properly render input value\n\t            //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t            locals[parserResult.itemName] = modelValue;\n\t            candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t            locals[parserResult.itemName] = undefined;\n\t            emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n\t          }\n\t        });\n\t\n\t        scope.select = function(activeIdx) {\n\t          //called from within the $digest() cycle\n\t          var locals = {};\n\t          var model, item;\n\t\n\t          selected = true;\n\t          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t          model = parserResult.modelMapper(originalScope, locals);\n\t          $setModelValue(originalScope, model);\n\t          modelCtrl.$setValidity('editable', true);\n\t          modelCtrl.$setValidity('parse', true);\n\t\n\t          onSelectCallback(originalScope, {\n\t            $item: item,\n\t            $model: model,\n\t            $label: parserResult.viewMapper(originalScope, locals)\n\t          });\n\t\n\t          resetMatches();\n\t\n\t          //return focus to the input element if a match was selected via a mouse click event\n\t          // use timeout to avoid $rootScope:inprog error\n\t          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n\t            $timeout(function() { element[0].focus(); }, 0, false);\n\t          }\n\t        };\n\t\n\t        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t        element.bind('keydown', function(evt) {\n\t          //typeahead is open and an \"interesting\" key was pressed\n\t          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t            return;\n\t          }\n\t\n\t          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n\t          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n\t            resetMatches();\n\t            scope.$digest();\n\t            return;\n\t          }\n\t\n\t          evt.preventDefault();\n\t\n\t          if (evt.which === 40) {\n\t            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t            scope.$digest();\n\t          } else if (evt.which === 38) {\n\t            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n\t            scope.$digest();\n\t          } else if (evt.which === 13 || evt.which === 9) {\n\t            scope.$apply(function () {\n\t              scope.select(scope.activeIdx);\n\t            });\n\t          } else if (evt.which === 27) {\n\t            evt.stopPropagation();\n\t\n\t            resetMatches();\n\t            scope.$digest();\n\t          }\n\t        });\n\t\n\t        element.bind('blur', function() {\n\t          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n\t            selected = true;\n\t            scope.$apply(function() {\n\t              scope.select(scope.activeIdx);\n\t            });\n\t          }\n\t          hasFocus = false;\n\t          selected = false;\n\t        });\n\t\n\t        // Keep reference to click handler to unbind it.\n\t        var dismissClickHandler = function(evt) {\n\t          // Issue #3973\n\t          // Firefox treats right click as a click on document\n\t          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n\t            resetMatches();\n\t            if (!$rootScope.$$phase) {\n\t              scope.$digest();\n\t            }\n\t          }\n\t        };\n\t\n\t        $document.bind('click', dismissClickHandler);\n\t\n\t        originalScope.$on('$destroy', function() {\n\t          $document.unbind('click', dismissClickHandler);\n\t          if (appendToBody || appendToElementId) {\n\t            $popup.remove();\n\t          }\n\t\n\t          if (appendToBody) {\n\t            angular.element($window).unbind('resize', fireRecalculating);\n\t            $document.find('body').unbind('scroll', fireRecalculating);\n\t          }\n\t          // Prevent jQuery cache memory leak\n\t          popUpEl.remove();\n\t        });\n\t\n\t        var $popup = $compile(popUpEl)(scope);\n\t\n\t        if (appendToBody) {\n\t          $document.find('body').append($popup);\n\t        } else if (appendToElementId !== false) {\n\t          angular.element($document[0].getElementById(appendToElementId)).append($popup);\n\t        } else {\n\t          element.after($popup);\n\t        }\n\t      }\n\t    };\n\t  }])\n\t  \n\t  .directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {\n\t    return {\n\t      scope: {\n\t        matches: '=',\n\t        query: '=',\n\t        active: '=',\n\t        position: '&',\n\t        moveInProgress: '=',\n\t        select: '&'\n\t      },\n\t      replace: true,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        \n\t        if (!$typeaheadSuppressWarning) {\n\t          $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');\n\t        }\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function() {\n\t          return scope.matches.length > 0;\n\t        };\n\t\n\t        scope.isActive = function(matchIdx) {\n\t          return scope.active == matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function(matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function(activeIdx) {\n\t          scope.select({activeIdx:activeIdx});\n\t        };\n\t      }\n\t    };\n\t  }])\n\t  \n\t  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {\n\t    return {\n\t      restrict: 'EA',\n\t      scope: {\n\t        index: '=',\n\t        match: '=',\n\t        query: '='\n\t      },\n\t      link:function(scope, element, attrs) {\n\t        if (!$typeaheadSuppressWarning) {\n\t          $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');\n\t        }\n\t\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n\t        $templateRequest(tplUrl).then(function(tplContent) {\n\t          $compile(tplContent.trim())(scope, function(clonedElement) {\n\t            element.replaceWith(clonedElement);\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }])\n\t  \n\t  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {\n\t    var isSanitizePresent;\n\t    isSanitizePresent = $injector.has('$sanitize');\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      // Regex: capture the whole query string and replace it with the string that will be used to match\n\t      // the results, for example if the capture is \"a\" the result will be \\a\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    function containsHtml(matchItem) {\n\t      return /<.*>/g.test(matchItem);\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      if (!$typeaheadSuppressWarning) {\n\t        $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');\n\t      }\n\t\n\t      if (!isSanitizePresent && containsHtml(matchItem)) {\n\t        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n\t      }\n\t\n\t      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n\t      if (!isSanitizePresent) {\n\t        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n\t      }\n\t\n\t      return matchItem;\n\t    };\n\t  }]);\n\t\n\tangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/accordion/accordion-group.html\",\n\t    \"<div class=\\\"panel {{panelClass || 'panel-default'}}\\\">\\n\" +\n\t    \"  <div class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n\t    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n\t    \"      <a href tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n\t    \"    </h4>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"  <div class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n\t    \"\t  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/accordion/accordion.html\",\n\t    \"<div class=\\\"panel-group\\\" ng-transclude></div>\");\n\t}]);\n\t\n\tangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/alert/alert.html\",\n\t    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n\t    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n\t    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n\t    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n\t    \"    </button>\\n\" +\n\t    \"    <div ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/carousel/carousel.html\",\n\t    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n\t    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n\t    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"  </ol>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/carousel/slide.html\",\n\t    \"<div ng-class=\\\"{\\n\" +\n\t    \"    'active': active\\n\" +\n\t    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/datepicker.html\",\n\t    \"<div ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n\t    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n\t    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n\t    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n\t    \"</div>\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/day.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n\t    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default btn-sm\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/month.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" dropdown-nested ng-if=\\\"isOpen\\\" style=\\\"display: block\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n\t    \"\t<li ng-transclude></li>\\n\" +\n\t    \"\t<li ng-if=\\\"showButtonBar\\\" style=\\\"padding:10px 9px 2px\\\">\\n\" +\n\t    \"\t\t<span class=\\\"btn-group pull-left\\\">\\n\" +\n\t    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-info\\\" ng-click=\\\"select('today')\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n\t    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n\t    \"\t\t</span>\\n\" +\n\t    \"\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n\t    \"\t</li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/datepicker/year.html\",\n\t    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"3\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/modal/backdrop.html\",\n\t    \"<div uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"     modal-in-class=\\\"in\\\"\\n\" +\n\t    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n\t    \"></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/modal/window.html\",\n\t    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n\t    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"    modal-in-class=\\\"in\\\"\\n\" +\n\t    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n\t    \"    <div class=\\\"modal-dialog\\\" ng-class=\\\"size ? 'modal-' + size : ''\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/pagination/pager.html\",\n\t    \"<ul class=\\\"pager\\\">\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/pagination/pagination.html\",\n\t    \"<ul class=\\\"pagination\\\">\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-html-popup.html\",\n\t    \"<div\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\n\t    \"<div\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tooltip/tooltip-template-popup.html\",\n\t    \"<div\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n\t    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover-html.html\",\n\t    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover-template.html\",\n\t    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\"\\n\" +\n\t    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/popover/popover.html\",\n\t    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/bar.html\",\n\t    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/progress.html\",\n\t    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n\t}]);\n\t\n\tangular.module(\"template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/progressbar/progressbar.html\",\n\t    \"<div class=\\\"progress\\\">\\n\" +\n\t    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/rating/rating.html\",\n\t    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n\t    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n\t    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n\t    \"</span>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tabs/tab.html\",\n\t    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\">\\n\" +\n\t    \"  <a href ng-click=\\\"select()\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n\t    \"</li>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/tabs/tabset.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n\t    \"  <div class=\\\"tab-content\\\">\\n\" +\n\t    \"    <div class=\\\"tab-pane\\\" \\n\" +\n\t    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n\t    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n\t    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n\t    \"    </div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/timepicker/timepicker.html\",\n\t    \"<table>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td>:</td>\\n\" +\n\t    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/typeahead/typeahead-match.html\",\n\t    \"<a href tabindex=\\\"-1\\\" ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"></a>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"template/typeahead/typeahead-popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" style=\\\"display: block;\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n\t    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t!angular.$$csp() && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendors.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t1:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".app.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/statistikwbt/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8cfa1d3139ee92e72f0c\n **/","module.exports = angular;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 2\n ** module chunks = 1\n **/","//! api-check version 7.5.5 built with  by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) ( _)==(_ )\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"apiCheck\"] = factory();\n\telse\n\t\troot[\"apiCheck\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _apiCheck = __webpack_require__(1);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = _apiCheck2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\tvar apiCheckUtil = __webpack_require__(3);\n\tvar each = apiCheckUtil.each;\n\tvar isError = apiCheckUtil.isError;\n\tvar t = apiCheckUtil.t;\n\tvar arrayify = apiCheckUtil.arrayify;\n\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\tvar typeOf = apiCheckUtil.typeOf;\n\tvar getError = apiCheckUtil.getError;\n\n\tvar checkers = __webpack_require__(4);\n\tvar apiCheckApis = getApiCheckApis();\n\n\tmodule.exports = getApiCheckInstance;\n\tmodule.exports.VERSION = (\"7.5.5\");\n\tmodule.exports.utils = apiCheckUtil;\n\tmodule.exports.globalConfig = {\n\t  verbose: false,\n\t  disabled: false\n\t};\n\n\tvar apiCheckApiCheck = getApiCheckInstance({\n\t  output: { prefix: 'apiCheck' }\n\t});\n\tmodule.exports.internalChecker = apiCheckApiCheck;\n\n\teach(checkers, function (checker, name) {\n\t  return module.exports[name] = checker;\n\t});\n\n\tfunction getApiCheckInstance() {\n\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t  /* eslint complexity:[2, 6] */\n\t  if (apiCheckApiCheck && arguments.length) {\n\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t      prefix: 'creating an apiCheck instance'\n\t    });\n\t  }\n\n\t  var additionalProperties = {\n\t    'throw': getApiCheck(true),\n\t    warn: getApiCheck(false),\n\t    getErrorMessage: getErrorMessage,\n\t    handleErrorMessage: handleErrorMessage,\n\t    config: {\n\t      output: config.output || {\n\t        prefix: '',\n\t        suffix: '',\n\t        docsBaseUrl: ''\n\t      },\n\t      verbose: config.verbose || false,\n\t      disabled: config.disabled || false\n\t    },\n\t    utils: apiCheckUtil\n\t  };\n\n\t  each(additionalProperties, function (wrapper, name) {\n\t    return apiCheck[name] = wrapper;\n\t  });\n\n\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\t  each(extraCheckers, function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\n\t  return apiCheck;\n\n\t  /**\n\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t   * @param {Array} api - the checkers to check with\n\t   * @param {Array} args - the args to check\n\t   * @param {Object} output - output options\n\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t   */\n\t  function apiCheck(api, args, output) {\n\t    /* eslint complexity:[2, 8] */\n\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t      return {\n\t        apiTypes: {}, argTypes: {},\n\t        passed: true, message: '',\n\t        failed: false\n\t      }; // empty version of what is normally returned\n\t    }\n\t    checkApiCheckApi(arguments);\n\t    if (!Array.isArray(api)) {\n\t      api = [api];\n\t      args = [args];\n\t    } else {\n\t      // turn arguments into an array\n\t      args = Array.prototype.slice.call(args);\n\t    }\n\t    var messages = checkEnoughArgs(api, args);\n\t    if (!messages.length) {\n\t      // this is where we actually go perform the checks.\n\t      messages = checkApiWithArgs(api, args);\n\t    }\n\n\t    var returnObject = getTypes(api, args);\n\t    returnObject.args = args;\n\t    if (messages.length) {\n\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t      returnObject.failed = true;\n\t      returnObject.passed = false;\n\t    } else {\n\t      returnObject.message = '';\n\t      returnObject.failed = false;\n\t      returnObject.passed = true;\n\t    }\n\t    return returnObject;\n\t  }\n\n\t  /**\n\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t   */\n\t  function checkApiCheckApi(checkApiArgs) {\n\t    var api = checkApiArgs[0];\n\t    var args = checkApiArgs[1];\n\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\n\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t    }\n\t    // dog fooding here\n\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t    if (errors.length) {\n\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t        prefix: 'apiCheck'\n\t      });\n\t      apiCheck.handleErrorMessage(message, true);\n\t    }\n\t  }\n\n\t  function getApiCheck(shouldThrow) {\n\t    return function apiCheckWrapper(api, args, output) {\n\t      var result = apiCheck(api, args, output);\n\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t      return result; // wont get here if an error is thrown\n\t    };\n\t  }\n\n\t  function handleErrorMessage(message, shouldThrow) {\n\t    if (shouldThrow && message) {\n\t      throw new Error(message);\n\t    } else if (message) {\n\t      /* eslint no-console:0 */\n\t      console.warn(message);\n\t    }\n\t  }\n\n\t  function getErrorMessage(api, args) {\n\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n\t    var gOut = apiCheck.config.output || {};\n\t    var prefix = getPrefix();\n\t    var suffix = getSuffix();\n\t    var url = getUrl();\n\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\n\t    function getPrefix() {\n\t      var p = output.onlyPrefix;\n\t      if (!p) {\n\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t      }\n\t      return p;\n\t    }\n\n\t    function getSuffix() {\n\t      var s = output.onlySuffix;\n\t      if (!s) {\n\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t      }\n\t      return s;\n\t    }\n\n\t    function getUrl() {\n\t      var u = output.url;\n\t      if (!u) {\n\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t      }\n\t      return u;\n\t    }\n\t  }\n\n\t  function buildMessageFromApiAndArgs(api, args) {\n\t    var _getTypes = getTypes(api, args);\n\n\t    var apiTypes = _getTypes.apiTypes;\n\t    var argTypes = _getTypes.argTypes;\n\n\t    var copy = Array.prototype.slice.call(args || []);\n\t    var replacedItems = [];\n\t    replaceFunctionWithName(copy);\n\t    var passedArgs = getObjectString(copy);\n\t    argTypes = getObjectString(argTypes);\n\t    apiTypes = getObjectString(apiTypes);\n\n\t    return generateMessage();\n\n\t    // functions\n\n\t    function replaceFunctionWithName(obj) {\n\t      each(obj, function (val, name) {\n\t        /* eslint complexity:[2, 6] */\n\t        if (replacedItems.indexOf(val) === -1) {\n\t          // avoid recursive problems\n\t          replacedItems.push(val);\n\t          if (typeof val === 'object') {\n\t            replaceFunctionWithName(obj);\n\t          } else if (typeof val === 'function') {\n\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t          }\n\t        }\n\t      });\n\t    }\n\n\t    function getObjectString(types) {\n\t      if (!types || !types.length) {\n\t        return 'nothing';\n\t      } else if (types && types.length === 1) {\n\t        types = types[0];\n\t      }\n\t      return stringify(types, null, 2);\n\t    }\n\n\t    function generateMessage() {\n\t      var n = '\\n';\n\t      var useS = true;\n\t      if (args && args.length === 1) {\n\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t          useS = !!Object.keys(args[0]).length;\n\t        } else {\n\t          useS = false;\n\t        }\n\t      }\n\t      var types = 'type' + (useS ? 's' : '');\n\t      var newLine = n + n;\n\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t    }\n\t  }\n\n\t  function getTypes(api, args) {\n\t    api = arrayify(api);\n\t    args = arrayify(args);\n\t    var apiTypes = api.map(function (checker, index) {\n\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t      return getCheckerDisplay(checker, {\n\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t        obj: args[index],\n\t        addHelpers: true\n\t      });\n\t    });\n\t    var argTypes = args.map(function (arg) {\n\t      return getArgDisplay(arg, []);\n\t    });\n\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t  }\n\t}\n\n\t// STATELESS FUNCTIONS\n\n\t/**\n\t * This is where the magic happens for actually checking the arguments with the api.\n\t * @param {Array} api - checkers\n\t * @param  {Array} args - and arguments object\n\t * @returns {Array} - the error messages\n\t */\n\tfunction checkApiWithArgs(api, args) {\n\t  /* eslint complexity:[2, 7] */\n\t  var messages = [];\n\t  var failed = false;\n\t  var checkerIndex = 0;\n\t  var argIndex = 0;\n\t  var arg = undefined,\n\t      checker = undefined,\n\t      res = undefined,\n\t      lastChecker = undefined,\n\t      argName = undefined,\n\t      argFailed = undefined,\n\t      skipPreviousChecker = undefined;\n\t  /* jshint -W084 */\n\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t    arg = args[argIndex++];\n\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t    res = checker(arg, 'value', argName);\n\t    argFailed = isError(res);\n\t    lastChecker = checkerIndex >= api.length;\n\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t      failed = true;\n\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t    } else if (argFailed && checker.isOptional) {\n\t      argIndex--;\n\t    } else {\n\t      messages.push(t(argName) + ' passed');\n\t    }\n\t  }\n\t  return failed ? messages : [];\n\t}\n\n\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\tfunction checkerTypeType(checkerType, name, location) {\n\t  var apiCheckDataChecker = checkers.shape({\n\t    type: checkers.string,\n\t    optional: checkers.bool\n\t  });\n\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t  if (isError(wrongShape)) {\n\t    return wrongShape;\n\t  }\n\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t    return getError(name, location, checkerTypeType.type);\n\t  }\n\t}\n\n\tfunction getCheckerErrorMessage(res, checker, val) {\n\t  var checkerHelp = getCheckerHelp(checker, val);\n\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t  return res.message + checkerHelp;\n\t}\n\n\tfunction getCheckerHelp(_ref, val) {\n\t  var help = _ref.help;\n\n\t  if (!help) {\n\t    return '';\n\t  }\n\t  if (typeof help === 'function') {\n\t    help = help(val);\n\t  }\n\t  return help;\n\t}\n\n\tfunction checkEnoughArgs(api, args) {\n\t  var requiredArgs = api.filter(function (a) {\n\t    return !a.isOptional;\n\t  });\n\t  if (args.length < requiredArgs.length) {\n\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t  } else {\n\t    return [];\n\t  }\n\t}\n\n\tfunction getArgDisplay(arg, gottenArgs) {\n\t  /* eslint complexity:[2, 7] */\n\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t  var type = typeOf(arg);\n\t  if (type === 'function') {\n\t    if (hasKeys()) {\n\t      var properties = stringify(getDisplayIfNotGotten());\n\t      return cName + ' (with properties: ' + properties + ')';\n\t    }\n\t    return cName;\n\t  }\n\n\t  if (arg === null) {\n\t    return 'null';\n\t  }\n\n\t  if (type !== 'array' && type !== 'object') {\n\t    return type;\n\t  }\n\n\t  if (hasKeys()) {\n\t    return getDisplayIfNotGotten();\n\t  }\n\n\t  return cName;\n\n\t  // utility functions\n\t  function hasKeys() {\n\t    return arg && Object.keys(arg).length;\n\t  }\n\n\t  function getDisplayIfNotGotten() {\n\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t      return '[Circular]';\n\t    }\n\t    gottenArgs.push(arg);\n\t    return getDisplay(arg, gottenArgs);\n\t  }\n\t}\n\n\tfunction getDisplay(obj, gottenArgs) {\n\t  var argDisplay = {};\n\t  each(obj, function (v, k) {\n\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t  });\n\t  return argDisplay;\n\t}\n\n\tfunction getApiCheckApis() {\n\t  var os = checkers.string.optional;\n\n\t  var checkerFnChecker = checkers.func.withProperties({\n\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t    displayName: checkers.string.optional,\n\t    shortType: checkers.string.optional,\n\t    notOptional: checkers.bool.optional,\n\t    notRequired: checkers.bool.optional\n\t  });\n\n\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t    output: checkers.shape({\n\t      prefix: checkers.string.optional,\n\t      suffix: checkers.string.optional,\n\t      docsBaseUrl: checkers.string.optional\n\t    }).strict.optional,\n\t    verbose: checkers.bool.optional,\n\t    disabled: checkers.bool.optional\n\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\n\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t  }).strict.optional];\n\n\t  return {\n\t    checkerFnChecker: checkerFnChecker,\n\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t    checkApiCheckApi: checkApiCheckApi\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = stringify;\n\n\tfunction getSerialize (fn, decycle) {\n\t  var seen = [], keys = [];\n\t  decycle = decycle || function(key, value) {\n\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t  };\n\t  return function(key, value) {\n\t    var ret = value;\n\t    if (typeof value === 'object' && value) {\n\t      if (seen.indexOf(value) !== -1)\n\t        ret = decycle(key, value);\n\t      else {\n\t        seen.push(value);\n\t        keys.push(key);\n\t      }\n\t    }\n\t    if (fn) ret = fn(key, ret);\n\t    return ret;\n\t  }\n\t}\n\n\tfunction getPath (value, seen, keys) {\n\t  var index = seen.indexOf(value);\n\t  var path = [ keys[index] ];\n\t  for (index--; index >= 0; index--) {\n\t    if (seen[index][ path[0] ] === value) {\n\t      value = seen[index];\n\t      path.unshift(keys[index]);\n\t    }\n\t  }\n\t  return '~' + path.join('.');\n\t}\n\n\tfunction stringify(obj, fn, spaces, decycle) {\n\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t}\n\n\tstringify.getSerialize = getSerialize;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\tvar stringify = __webpack_require__(2);\n\tvar checkerHelpers = {\n\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t};\n\n\tmodule.exports = {\n\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t  noop: noop\n\t};\n\n\tfunction copy(obj) {\n\t  var type = typeOf(obj);\n\t  var daCopy = undefined;\n\t  if (type === 'array') {\n\t    daCopy = [];\n\t  } else if (type === 'object') {\n\t    daCopy = {};\n\t  } else {\n\t    return obj;\n\t  }\n\t  each(obj, function (val, key) {\n\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t  });\n\t  return daCopy;\n\t}\n\n\tfunction typeOf(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return 'array';\n\t  } else if (obj instanceof RegExp) {\n\t    return 'object';\n\t  } else {\n\t    return typeof obj;\n\t  }\n\t}\n\n\tfunction getCheckerDisplay(checker, options) {\n\t  /* eslint complexity:[2, 7] */\n\t  var display = undefined;\n\t  var short = options && options.short;\n\t  if (short && checker.shortType) {\n\t    display = checker.shortType;\n\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t    display = getCheckerType(checker, options);\n\t  } else {\n\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t  }\n\t  return display;\n\t}\n\n\tfunction getCheckerType(_ref, options) {\n\t  var type = _ref.type;\n\n\t  if (typeof type === 'function') {\n\t    var __apiCheckData = type.__apiCheckData;\n\t    var typeTypes = type(options);\n\t    type = _defineProperty({\n\t      __apiCheckData: __apiCheckData\n\t    }, __apiCheckData.type, typeTypes);\n\t  }\n\t  return type;\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (!obj) {\n\t    return [];\n\t  } else if (Array.isArray(obj)) {\n\t    return obj;\n\t  } else {\n\t    return [obj];\n\t  }\n\t}\n\n\tfunction each(obj, iterator, context) {\n\t  if (Array.isArray(obj)) {\n\t    return eachArry(obj, iterator, context);\n\t  } else {\n\t    return eachObj(obj, iterator, context);\n\t  }\n\t}\n\n\tfunction eachObj(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t  for (var key in obj) {\n\t    if (hasOwn.call(obj, key)) {\n\t      ret = iterator.call(context, obj[key], key, obj);\n\t      if (ret === false) {\n\t        return ret;\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction eachArry(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var length = obj.length;\n\t  for (var i = 0; i < length; i++) {\n\t    ret = iterator.call(context, obj[i], i, obj);\n\t    if (ret === false) {\n\t      return ret;\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction isError(obj) {\n\t  return obj instanceof Error;\n\t}\n\n\tfunction list(arry, join, finalJoin) {\n\t  arry = arrayify(arry);\n\t  var copy = arry.slice();\n\t  var last = copy.pop();\n\t  if (copy.length === 1) {\n\t    join = ' ';\n\t  }\n\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t}\n\n\tfunction getError(name, location, checkerType) {\n\t  if (typeof checkerType === 'function') {\n\t    checkerType = checkerType({ short: true });\n\t  }\n\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t}\n\n\tfunction nAtL(name, location) {\n\t  var tName = t(name || 'value');\n\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t  return '' + tName + tLocation;\n\t}\n\n\tfunction t(thing) {\n\t  return '`' + thing + '`';\n\t}\n\n\tfunction undef(thing) {\n\t  return typeof thing === 'undefined';\n\t}\n\n\t/**\n\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t * optional version\n\t *\n\t * @param {Function} checker - the checker to setup with properties\n\t * @param {Object} properties - properties to add to the checker\n\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t * @returns {Function} checker - the setup checker\n\t */\n\tfunction setupChecker(checker, properties, disabled) {\n\t  /* eslint complexity:[2, 9] */\n\t  if (disabled) {\n\t    // swap out the checker for its own copy of noop\n\t    checker = getNoop();\n\t    checker.isNoop = true;\n\t  }\n\n\t  if (typeof checker.type === 'string') {\n\t    checker.shortType = checker.type;\n\t  }\n\n\t  // assign all properties given\n\t  each(properties, function (prop, name) {\n\t    return checker[name] = prop;\n\t  });\n\n\t  if (!checker.displayName) {\n\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t  }\n\n\t  if (!checker.notRequired) {\n\t    checker = getRequiredVersion(checker, disabled);\n\t  }\n\n\t  if (!checker.notNullable) {\n\t    addNullable(checker, disabled);\n\t  }\n\n\t  if (!checker.notOptional) {\n\t    addOptional(checker, disabled);\n\t  }\n\n\t  return checker;\n\t}\n\n\tfunction getRequiredVersion(checker, disabled) {\n\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t    if (undef(val) && !checker.isOptional) {\n\t      var tLocation = location ? ' in ' + t(location) : '';\n\t      var type = getCheckerDisplay(checker, { short: true });\n\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t    } else {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  copyProps(checker, requiredChecker);\n\t  requiredChecker.originalChecker = checker;\n\t  return requiredChecker;\n\t}\n\n\tfunction addOptional(checker, disabled) {\n\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t    if (!undef(val)) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, optionalCheck);\n\n\t  optionalCheck.isOptional = true;\n\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t  optionalCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .optional to the end of the checkers\n\t  checker.optional = optionalCheck;\n\n\t  fixType(checker, checker.optional);\n\t}\n\n\tfunction addNullable(checker, disabled) {\n\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t    if (val !== null) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, nullableCheck);\n\n\t  nullableCheck.isNullable = true;\n\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t  nullableCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t  checker.nullable = nullableCheck;\n\n\t  fixType(checker, checker.nullable);\n\t  if (!checker.notOptional) {\n\t    addOptional(checker.nullable, disabled);\n\t  }\n\t}\n\n\tfunction fixType(checker, checkerCopy) {\n\t  // fix type, because it's not a straight copy...\n\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t  // we also want to add \"(optional)\" to the types with a string\n\t  if (typeof checkerCopy.type === 'object') {\n\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t  } else if (typeof checkerCopy.type === 'function') {\n\t      checkerCopy.type = function () {\n\t        return checker.type.apply(checker, arguments);\n\t      };\n\t    } else {\n\t      checkerCopy.type += ' (optional)';\n\t      return;\n\t    }\n\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t  checkerCopy.type.__apiCheckData.optional = true;\n\t}\n\n\t// UTILS\n\n\tfunction copyProps(src, dest) {\n\t  each(Object.keys(src), function (key) {\n\t    return dest[key] = src[key];\n\t  });\n\t}\n\n\tfunction noop() {}\n\n\tfunction getNoop() {\n\t  /* eslint no-shadow:0 */\n\t  /* istanbul ignore next */\n\t  return function noop() {};\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\n\tvar _require = __webpack_require__(3);\n\n\tvar typeOf = _require.typeOf;\n\tvar each = _require.each;\n\tvar copy = _require.copy;\n\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\tvar isError = _require.isError;\n\tvar arrayify = _require.arrayify;\n\tvar list = _require.list;\n\tvar getError = _require.getError;\n\tvar nAtL = _require.nAtL;\n\tvar t = _require.t;\n\tvar checkerHelpers = _require.checkerHelpers;\n\tvar undef = _require.undef;\n\tvar setupChecker = checkerHelpers.setupChecker;\n\n\tvar checkers = module.exports = getCheckers();\n\tmodule.exports.getCheckers = getCheckers;\n\n\tfunction getCheckers(disabled) {\n\t  return {\n\t    array: typeOfCheckGetter('Array'),\n\t    bool: typeOfCheckGetter('Boolean'),\n\t    number: typeOfCheckGetter('Number'),\n\t    string: typeOfCheckGetter('String'),\n\t    func: funcCheckGetter(),\n\t    object: objectCheckGetter(),\n\n\t    emptyObject: emptyObjectCheckGetter(),\n\n\t    instanceOf: instanceCheckGetter,\n\t    oneOf: oneOfCheckGetter,\n\t    oneOfType: oneOfTypeCheckGetter,\n\n\t    arrayOf: arrayOfCheckGetter,\n\t    objectOf: objectOfCheckGetter,\n\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\n\t    range: rangeCheckGetter,\n\t    lessThan: lessThanCheckGetter,\n\t    greaterThan: greaterThanCheckGetter,\n\n\t    shape: getShapeCheckGetter(),\n\t    args: argumentsCheckerGetter(),\n\n\t    any: anyCheckGetter(),\n\t    'null': nullCheckGetter()\n\n\t  };\n\n\t  function typeOfCheckGetter(type) {\n\t    var lType = type.toLowerCase();\n\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== lType) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function funcCheckGetter() {\n\t    var type = 'Function';\n\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'function') {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\n\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t      if (isError(apiError)) {\n\t        throw apiError;\n\t      }\n\t      var shapeChecker = checkers.shape(properties, true);\n\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\n\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t        var notFunction = checkers.func(val, name, location);\n\t        if (isError(notFunction)) {\n\t          return notFunction;\n\t        }\n\t        return shapeChecker(val, name, location);\n\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t    };\n\t    return functionChecker;\n\t  }\n\n\t  function objectCheckGetter() {\n\t    var type = 'Object';\n\t    var nullType = 'Object (null ok)';\n\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'object') {\n\t        return getError(name, location, nullType);\n\t      }\n\t    }, { type: nullType }, disabled);\n\n\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t        return getError(name, location, objectChecker.type);\n\t      }\n\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\n\t    return objectChecker;\n\t  }\n\n\t  function instanceCheckGetter(classToCheck) {\n\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t      if (!(val instanceof classToCheck)) {\n\t        return getError(name, location, classToCheck.name);\n\t      }\n\t    }, { type: classToCheck.name }, disabled);\n\t  }\n\n\t  function oneOfCheckGetter(enums) {\n\t    var type = {\n\t      __apiCheckData: { optional: false, type: 'enum' },\n\t      'enum': enums\n\t    };\n\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t      return stringify(enm);\n\t    }).join(', ') + ']';\n\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t      if (!enums.some(function (enm) {\n\t        return enm === val;\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t      return getCheckerDisplay(checker, { short: true });\n\t    });\n\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return typeCheckers.map(function (checker) {\n\t        return getCheckerDisplay(checker, options);\n\t      });\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t      if (!typeCheckers.some(function (checker) {\n\t        return !isError(checker(val, name, location));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function arrayOfCheckGetter(checker) {\n\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\n\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t        return !isError(checker(item));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function objectOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\n\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t      var notObject = checkers.object(val, name, location);\n\t      if (isError(notObject)) {\n\t        return notObject;\n\t      }\n\t      var allTypesSuccess = each(val, function (item, key) {\n\t        if (isError(checker(item, key, name))) {\n\t          return false;\n\t        }\n\t      });\n\t      if (!allTypesSuccess) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function typeOrArrayOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\n\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function getShapeCheckGetter() {\n\t    function shapeCheckGetter(shape, nonObject) {\n\t      var shapeTypes = {};\n\t      each(shape, function (checker, prop) {\n\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t      });\n\t      function type() {\n\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t        var ret = {};\n\t        var terse = options.terse;\n\t        var obj = options.obj;\n\t        var addHelpers = options.addHelpers;\n\n\t        var parentRequired = options.required;\n\t        each(shape, function (checker, prop) {\n\t          /* eslint complexity:[2, 6] */\n\t          var specified = obj && obj.hasOwnProperty(prop);\n\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t          if (!terse || (specified || !checker.isOptional)) {\n\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t          }\n\t          if (addHelpers) {\n\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t          }\n\t        });\n\t        return ret;\n\n\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t          if (!specified && required && !checker.isOptional) {\n\t            var item = 'ITEM';\n\t            if (checker.type && checker.type.__apiCheckData) {\n\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t            }\n\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t          } else if (specified) {\n\t            var error = checker(obj[prop], prop, null, obj);\n\t            if (isError(error)) {\n\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t            }\n\t          }\n\n\t          function addHelper(property, objectMessage, stringMessage) {\n\t            if (typeof theRet[prop] === 'string') {\n\t              theRet[prop] += stringMessage;\n\t            } else {\n\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t        /* eslint complexity:[2, 6] */\n\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t        if (isError(isObject)) {\n\t          return isObject;\n\t        }\n\t        var shapePropError = undefined;\n\t        location = location ? location + (name ? '/' : '') : '';\n\t        name = name || '';\n\t        each(shape, function (checker, prop) {\n\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t            return !isError(shapePropError);\n\t          }\n\t        });\n\t        if (isError(shapePropError)) {\n\t          return shapePropError;\n\t        }\n\t      }, { type: type, shortType: 'shape' }, disabled);\n\n\t      function strictType() {\n\t        return type.apply(undefined, arguments);\n\t      }\n\n\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t      strictType.__apiCheckData.strict = true;\n\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t        var shapeError = shapeChecker(val, name, location);\n\t        if (isError(shapeError)) {\n\t          return shapeError;\n\t        }\n\t        var allowedProperties = Object.keys(shape);\n\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t          return allowedProperties.indexOf(prop) === -1;\n\t        });\n\t        if (extraProps.length) {\n\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t        }\n\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\n\t      return shapeChecker;\n\t    }\n\n\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t      } else {\n\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (propExists === otherPropsExist) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t      otherProps = arrayify(otherProps);\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t      } else {\n\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t        var othersPresent = otherProps.every(function (property) {\n\t          return obj.hasOwnProperty(property);\n\t        });\n\t        if (!othersPresent) {\n\t          return getError(propName, location, type);\n\t        } else {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        throw new Error('requiredIfNot.all must be passed an array');\n\t      }\n\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t    };\n\n\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t      var props = t(otherProps.join(', '));\n\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var iteration = all ? 'every' : 'some';\n\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (!otherPropsExist && !propExists) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, notRequired: true }, disabled);\n\t    }\n\n\t    return shapeCheckGetter;\n\n\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t      function type(options) {\n\t        if (options && options.short) {\n\t          return shortType;\n\t        }\n\t        return getCheckerDisplay(propChecker);\n\t      }\n\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t      return type;\n\t    }\n\t  }\n\n\t  function argumentsCheckerGetter() {\n\t    var type = 'function arguments';\n\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function anyCheckGetter() {\n\t    return setupChecker(function anyCheckerDefinition() {\n\t      // don't do anything\n\t    }, { type: 'any' }, disabled);\n\t  }\n\n\t  function nullCheckGetter() {\n\t    var type = 'null';\n\t    return setupChecker(function nullChecker(val, name, location) {\n\t      if (val !== null) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function rangeCheckGetter(min, max) {\n\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t    return setupChecker(function rangeChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < min || val > max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function lessThanCheckGetter(min) {\n\t    var type = 'lessThan[' + min + ']';\n\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val > min) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function greaterThanCheckGetter(max) {\n\t    var type = 'greaterThan[' + max + ']';\n\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function emptyObjectCheckGetter() {\n\t    var type = 'empty object';\n\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/api-check/dist/api-check.js\n ** module id = 3\n ** module chunks = 1\n **/","/*!\n* angular-formly JavaScript Library v7.2.3\n*\n* @license MIT (http://license.angular-formly.com)\n*\n* built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n* ( _)==(_ )\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _indexCommon = __webpack_require__(1);\n\n\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\n\texports['default'] = _indexCommon2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\n\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\n\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\n\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\n\tvar _providersFormlyUsability = __webpack_require__(7);\n\n\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\n\tvar _providersFormlyConfig = __webpack_require__(8);\n\n\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\n\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\n\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\n\tvar _servicesFormlyUtil = __webpack_require__(11);\n\n\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\n\tvar _servicesFormlyWarn = __webpack_require__(12);\n\n\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\n\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\n\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\n\tvar _directivesFormlyField = __webpack_require__(14);\n\n\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\n\tvar _directivesFormlyFocus = __webpack_require__(15);\n\n\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\n\tvar _directivesFormlyForm = __webpack_require__(16);\n\n\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\n\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\n\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\n\tvar _runFormlyCustomTags = __webpack_require__(18);\n\n\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\n\tvar ngModuleName = 'formly';\n\n\texports['default'] = ngModuleName;\n\n\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\n\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\tngModule.constant('formlyVersion', (\"7.2.3\")); // <-- webpack variable\n\n\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\n\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\n\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\n\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\tngModule.run(_runFormlyCustomTags2['default']);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar angular = __webpack_require__(3);\n\n\t/* istanbul ignore next */\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\texports['default'] = angular;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\tvar apiCheck = (0, _apiCheck2['default'])({\n\t  output: {\n\t    prefix: 'angular-formly:',\n\t    docsBaseUrl: __webpack_require__(6)\n\t  }\n\t});\n\n\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t    otherProps = [otherProps];\n\t  }\n\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\n\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t      return obj && obj.hasOwnProperty(otherProp);\n\t    });\n\t    if (!otherPropsExist && !propExists) {\n\t      return apiCheck.utils.getError(propName, location, type);\n\t    } else if (propExists) {\n\t      return propChecker(prop, propName, location, obj);\n\t    }\n\t  }\n\n\t  shapeRequiredIfNotDefinition.type = type;\n\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t}\n\n\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\n\tvar apiCheckProperty = apiCheck.func;\n\n\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t  warn: apiCheck.func,\n\t  'throw': apiCheck.func,\n\t  shape: apiCheck.func\n\t}));\n\n\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\n\tvar formlyWrapperType = apiCheck.shape({\n\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  overwriteOk: apiCheck.bool.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional\n\t}).strict;\n\n\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\n\tvar templateManipulators = apiCheck.shape({\n\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t}).strict.nullable;\n\n\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar fieldOptionsApiShape = {\n\t  $$hashKey: apiCheck.any.optional,\n\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  model: modelChecker.optional,\n\t  originalModel: modelChecker.optional,\n\t  className: apiCheck.string.optional,\n\t  id: apiCheck.string.optional,\n\t  name: apiCheck.string.optional,\n\t  expressionProperties: expressionProperties.optional,\n\t  extras: apiCheck.shape({\n\t    validateOnModelChange: apiCheck.bool.optional,\n\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t  }).strict.optional,\n\t  data: apiCheck.object.optional,\n\t  templateOptions: apiCheck.object.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  modelOptions: apiCheck.shape({\n\t    updateOn: apiCheck.string.optional,\n\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t    allowInvalid: apiCheck.bool.optional,\n\t    getterSetter: apiCheck.bool.optional,\n\t    timezone: apiCheck.string.optional\n\t  }).optional,\n\t  watcher: apiCheck.typeOrArrayOf(apiCheck.shape({\n\t    expression: formlyExpression.optional,\n\t    listener: formlyExpression\n\t  })).optional,\n\t  validators: validatorChecker.optional,\n\t  asyncValidators: validatorChecker.optional,\n\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t  noFormControl: apiCheck.bool.optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t  }).strict).optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  link: apiCheck.func.optional,\n\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t  validation: apiCheck.shape({\n\t    show: apiCheck.bool.nullable.optional,\n\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t  }).optional,\n\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t  value: apiCheck.func.optional,\n\t  runExpressions: apiCheck.func.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  initialValue: apiCheck.any.optional,\n\t  defaultValue: apiCheck.any.optional\n\t};\n\n\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\n\tvar formOptionsApi = apiCheck.shape({\n\t  formState: apiCheck.object.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t  data: apiCheck.object.optional\n\t}).strict;\n\n\tvar fieldGroup = apiCheck.shape({\n\t  $$hashKey: apiCheck.any.optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  // danger. Nested field groups wont get api-checked...\n\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t  className: apiCheck.string.optional,\n\t  options: formOptionsApi.optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  data: apiCheck.object.optional,\n\t  model: modelChecker.optional,\n\t  form: apiCheck.object.optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t}).strict;\n\n\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\n\tvar formlyTypeOptions = apiCheck.shape({\n\t  name: apiCheck.string,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t  link: apiCheck.func.optional,\n\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t  'extends': apiCheck.string.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  data: apiCheck.object.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional,\n\t  overwriteOk: apiCheck.bool.optional\n\t}).strict;\n\n\t_angularFix2['default'].extend(apiCheck, {\n\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t});\n\n\texports['default'] = apiCheck;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.2.3\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyUsability;\n\n\t// @ngInject\n\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t  var _this = this;\n\n\t  _angularFix2['default'].extend(this, {\n\t    getFormlyError: getFormlyError,\n\t    getFieldError: getFieldError,\n\t    checkWrapper: checkWrapper,\n\t    checkWrapperTemplate: checkWrapperTemplate,\n\t    getErrorMessage: getErrorMessage,\n\t    $get: function $get() {\n\t      return _this;\n\t    }\n\t  });\n\n\t  function getFieldError(errorInfoSlug, message, field) {\n\t    if (arguments.length < 3) {\n\t      field = message;\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t  }\n\n\t  function getFormlyError(errorInfoSlug, message) {\n\t    if (!message) {\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t  }\n\n\t  function getErrorMessage(errorInfoSlug, message) {\n\t    var url = '';\n\t    if (errorInfoSlug !== null) {\n\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t    }\n\t    return 'Formly Error: ' + message + '. ' + url;\n\t  }\n\n\t  function checkWrapper(wrapper) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t      prefix: 'formlyConfig.setWrapper',\n\t      urlSuffix: 'setwrapper-validation-failed'\n\t    });\n\t  }\n\n\t  function checkWrapperTemplate(template, additionalInfo) {\n\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t    if (template.indexOf(formlyTransclude) === -1) {\n\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t    }\n\t  }\n\t}\n\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyConfig;\n\n\t// @ngInject\n\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t  var _this2 = this;\n\n\t  var typeMap = {};\n\t  var templateWrappersMap = {};\n\t  var defaultWrapperName = 'default';\n\t  var _this = this;\n\t  var getError = formlyUsabilityProvider.getFormlyError;\n\n\t  _angularFix2['default'].extend(this, {\n\t    setType: setType,\n\t    getType: getType,\n\t    getTypeHeritage: getTypeHeritage,\n\t    setWrapper: setWrapper,\n\t    getWrapper: getWrapper,\n\t    getWrapperByType: getWrapperByType,\n\t    removeWrapperByName: removeWrapperByName,\n\t    removeWrappersForType: removeWrappersForType,\n\t    disableWarnings: false,\n\t    extras: {\n\t      disableNgModelAttrsManipulator: false,\n\t      fieldTransform: [],\n\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t      removeChromeAutoComplete: false,\n\t      defaultHideDirective: 'ng-if',\n\t      getFieldId: null\n\t    },\n\t    templateManipulators: {\n\t      preWrapper: [],\n\t      postWrapper: []\n\t    },\n\t    $get: function $get() {\n\t      return _this2;\n\t    }\n\t  });\n\n\t  function setType(options) {\n\t    if (_angularFix2['default'].isArray(options)) {\n\t      var _ret = (function () {\n\t        var allTypes = [];\n\t        _angularFix2['default'].forEach(options, function (item) {\n\t          allTypes.push(setType(item));\n\t        });\n\t        return {\n\t          v: allTypes\n\t        };\n\t      })();\n\n\t      if (typeof _ret === 'object') return _ret.v;\n\t    } else if (_angularFix2['default'].isObject(options)) {\n\t      checkType(options);\n\t      if (options['extends']) {\n\t        extendTypeOptions(options);\n\t      }\n\t      typeMap[options.name] = options;\n\t      return typeMap[options.name];\n\t    } else {\n\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t    }\n\t  }\n\n\t  function checkType(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t      prefix: 'formlyConfig.setType',\n\t      url: 'settype-validation-failed'\n\t    });\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t    } else {\n\t      options.overwriteOk = undefined;\n\t    }\n\t  }\n\n\t  function extendTypeOptions(options) {\n\t    var extendsType = getType(options['extends'], true, options);\n\t    extendTypeControllerFunction(options, extendsType);\n\t    extendTypeLinkFunction(options, extendsType);\n\t    extendTypeDefaultOptions(options, extendsType);\n\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t    extendTemplate(options, extendsType);\n\t  }\n\n\t  function extendTemplate(options, extendsType) {\n\t    if (options.template && extendsType.templateUrl) {\n\t      delete options.templateUrl;\n\t    } else if (options.templateUrl && extendsType.template) {\n\t      delete options.template;\n\t    }\n\t  }\n\n\t  function extendTypeControllerFunction(options, extendsType) {\n\t    var extendsCtrl = extendsType.controller;\n\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t      return;\n\t    }\n\t    var optionsCtrl = options.controller;\n\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t      options.controller = function ($scope, $controller) {\n\t        $controller(extendsCtrl, { $scope: $scope });\n\t        $controller(optionsCtrl, { $scope: $scope });\n\t      };\n\t      options.controller.$inject = ['$scope', '$controller'];\n\t    } else {\n\t      options.controller = extendsCtrl;\n\t    }\n\t  }\n\n\t  function extendTypeLinkFunction(options, extendsType) {\n\t    var extendsFn = extendsType.link;\n\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t      return;\n\t    }\n\t    var optionsFn = options.link;\n\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t      options.link = function () {\n\t        extendsFn.apply(undefined, arguments);\n\t        optionsFn.apply(undefined, arguments);\n\t      };\n\t    } else {\n\t      options.link = extendsFn;\n\t    }\n\t  }\n\n\t  function extendTypeDefaultOptions(options, extendsType) {\n\t    var extendsDO = extendsType.defaultOptions;\n\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t      return;\n\t    }\n\t    var optionsDO = options.defaultOptions;\n\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t    if (extendsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t        var mergedDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t        var extenderOptionsDefaultOptions = optionsDO;\n\t        if (optionsDOIsFn) {\n\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t        }\n\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t        return extendsDefaultOptions;\n\t      };\n\t    } else if (optionsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var newDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t        return optionsDO(newDefaultOptions, scope);\n\t      };\n\t    }\n\t  }\n\n\t  function getType(name, throwError, errorContext) {\n\t    if (!name) {\n\t      return undefined;\n\t    }\n\t    var type = typeMap[name];\n\t    if (!type && throwError === true) {\n\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t    } else {\n\t      return type;\n\t    }\n\t  }\n\n\t  function getTypeHeritage(parent) {\n\t    var heritage = [];\n\t    var type = parent;\n\t    if (_angularFix2['default'].isString(type)) {\n\t      type = getType(parent);\n\t    }\n\t    parent = type['extends'];\n\t    while (parent) {\n\t      type = getType(parent);\n\t      heritage.push(type);\n\t      parent = type['extends'];\n\t    }\n\t    return heritage;\n\t  }\n\n\t  function setWrapper(_x, _x2) {\n\t    var _again = true;\n\n\t    _function: while (_again) {\n\t      var options = _x,\n\t          name = _x2;\n\t      _again = false;\n\n\t      if (_angularFix2['default'].isArray(options)) {\n\t        return options.map(function (wrapperOptions) {\n\t          return setWrapper(wrapperOptions);\n\t        });\n\t      } else if (_angularFix2['default'].isObject(options)) {\n\t        options.types = getOptionsTypes(options);\n\t        options.name = getOptionsName(options, name);\n\t        checkWrapperAPI(options);\n\t        templateWrappersMap[options.name] = options;\n\t        return options;\n\t      } else if (_angularFix2['default'].isString(options)) {\n\t        _x = {\n\t          template: options,\n\t          name: name\n\t        };\n\t        _x2 = undefined;\n\t        _again = true;\n\t        continue _function;\n\t      }\n\t    }\n\t  }\n\n\t  function getOptionsTypes(options) {\n\t    if (_angularFix2['default'].isString(options.types)) {\n\t      return [options.types];\n\t    }\n\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t      return [];\n\t    } else {\n\t      return options.types;\n\t    }\n\t  }\n\n\t  function getOptionsName(options, name) {\n\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t  }\n\n\t  function checkWrapperAPI(options) {\n\t    formlyUsabilityProvider.checkWrapper(options);\n\t    if (options.template) {\n\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t    }\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t    } else {\n\t      delete options.overwriteOk;\n\t    }\n\t    checkWrapperTypes(options);\n\t  }\n\n\t  function checkWrapperTypes(options) {\n\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t    if (shouldThrow) {\n\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t    }\n\t  }\n\n\t  function checkOverwrite(property, object, newValue, objectName) {\n\t    if (object.hasOwnProperty(property)) {\n\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t    }\n\t  }\n\n\t  function getWrapper(name) {\n\t    return templateWrappersMap[name || defaultWrapperName];\n\t  }\n\n\t  function getWrapperByType(type) {\n\t    /* eslint prefer-const:0 */\n\t    var wrappers = [];\n\t    for (var _name in templateWrappersMap) {\n\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t          wrappers.push(templateWrappersMap[_name]);\n\t        }\n\t      }\n\t    }\n\t    return wrappers;\n\t  }\n\n\t  function removeWrapperByName(name) {\n\t    var wrapper = templateWrappersMap[name];\n\t    delete templateWrappersMap[name];\n\t    return wrapper;\n\t  }\n\n\t  function removeWrappersForType(type) {\n\t    var wrappers = getWrapperByType(type);\n\t    if (!wrappers) {\n\t      return undefined;\n\t    }\n\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t      return removeWrapperByName(wrappers.name);\n\t    } else {\n\t      wrappers.forEach(function (wrapper) {\n\t        return removeWrapperByName(wrapper.name);\n\t      });\n\t      return wrappers;\n\t    }\n\t  }\n\n\t  function warn() {\n\t    if (!_this.disableWarnings && console.warn) {\n\t      /* eslint no-console:0 */\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      console.warn.apply(console, _toConsumableArray(args));\n\t    }\n\t  }\n\t}\n\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = {\n\t  formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName, arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t};\n\n\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t  if (_angularFix2['default'].isFunction(expression)) {\n\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t  } else {\n\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t  }\n\t}\n\n\tfunction getFieldId(formId, options, index) {\n\t  if (options.id) {\n\t    return options.id;\n\t  }\n\t  var type = options.type;\n\t  if (!type && options.template) {\n\t    type = 'template';\n\t  } else if (!type && options.templateUrl) {\n\t    type = 'templateUrl';\n\t  }\n\n\t  return [formId, type, options.key, index].join('_');\n\t}\n\n\tfunction reverseDeepMerge(dest) {\n\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t    if (!index) {\n\t      return;\n\t    }\n\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t        dest[prop] = _angularFix2['default'].copy(val);\n\t      } else if (objAndSameType(dest[prop], val)) {\n\t        reverseDeepMerge(dest[prop], val);\n\t      }\n\t    });\n\t  });\n\t  return dest;\n\t}\n\n\tfunction objAndSameType(obj1, obj2) {\n\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t}\n\n\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\tfunction findByNodeName(el, nodeName) {\n\t  if (!el.prop) {\n\t    // not a jQuery or jqLite object -> wrap it\n\t    el = _angularFix2['default'].element(el);\n\t  }\n\n\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t    return el;\n\t  }\n\n\t  var c = el.children();\n\t  for (var i = 0; c && i < c.length; i++) {\n\t    var node = findByNodeName(c[i], nodeName);\n\t    if (node) {\n\t      return node;\n\t    }\n\t  }\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t    obj = [obj];\n\t  } else if (!obj) {\n\t    obj = [];\n\t  }\n\t  return obj;\n\t}\n\n\tfunction extendFunction() {\n\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t    fns[_key] = arguments[_key];\n\t  }\n\n\t  return function extendedFunction() {\n\t    var args = arguments;\n\t    fns.forEach(function (fn) {\n\t      return fn.apply(null, args);\n\t    });\n\t  };\n\t}\n\n\tfunction extendArray(primary, secondary, property) {\n\t  if (property) {\n\t    primary = primary[property];\n\t    secondary = secondary[property];\n\t  }\n\t  if (secondary && primary) {\n\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t      if (primary.indexOf(item) === -1) {\n\t        primary.push(item);\n\t      }\n\t    });\n\t    return primary;\n\t  } else if (secondary) {\n\t    return secondary;\n\t  } else {\n\t    return primary;\n\t  }\n\t}\n\n\tfunction startsWith(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n\tfunction contains(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = formlyValidationMessages;\n\n\t// @ngInject\n\tfunction formlyValidationMessages() {\n\n\t  var validationMessages = {\n\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t    addStringMessage: addStringMessage,\n\t    messages: {}\n\t  };\n\n\t  return validationMessages;\n\n\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t  }\n\n\t  function addStringMessage(name, string) {\n\t    validationMessages.messages[name] = function () {\n\t      return string;\n\t    };\n\t  }\n\n\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t      if (scope.options.templateOptions[prop]) {\n\t        return prefix + \" \" + scope.options.templateOptions[prop] + \" \" + suffix;\n\t      } else {\n\t        return alternate;\n\t      }\n\t    };\n\t  }\n\t}\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyUtil;\n\n\t// @ngInject\n\tfunction formlyUtil() {\n\t  return _otherUtils2['default'];\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\texports['default'] = formlyWarn;\n\n\t// @ngInject\n\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t  return function warn() {\n\t    if (!formlyConfig.disableWarnings) {\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      $log.warn.apply($log, _toConsumableArray(args));\n\t    }\n\t  };\n\t}\n\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyCustomValidation;\n\n\t// @ngInject\n\tfunction formlyCustomValidation(formlyUtil) {\n\t  return {\n\t    restrict: 'A',\n\t    require: 'ngModel',\n\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t      var opts = scope.options;\n\t      opts.validation.messages = opts.validation.messages || {};\n\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t        opts.validation.messages[key] = function () {\n\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t        };\n\t      });\n\n\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\n\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t        setupMessage(validator, name);\n\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t        if (useNewValidatorsApi) {\n\t          setupWithValidators(validator, name, isAsync);\n\t        } else {\n\t          setupWithParsers(validator, name, isAsync);\n\t        }\n\t      }\n\n\t      function setupMessage(validator, name) {\n\t        var message = validator.message;\n\t        if (message) {\n\t          opts.validation.messages[name] = function () {\n\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t          };\n\t        }\n\t      }\n\n\t      function setupWithValidators(validator, name, isAsync) {\n\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\n\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t        };\n\t      }\n\n\t      function setupWithParsers(validator, name, isAsync) {\n\t        var inFlightValidator = undefined;\n\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t          if (isAsync) {\n\t            ctrl.$pending = ctrl.$pending || {};\n\t            ctrl.$pending[name] = true;\n\t            inFlightValidator = isValid;\n\t            isValid.then(function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, true);\n\t              }\n\t            })['catch'](function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, false);\n\t              }\n\t            })['finally'](function () {\n\t              var $pending = ctrl.$pending || {};\n\t              if (Object.keys($pending).length === 1) {\n\t                delete ctrl.$pending;\n\t              } else {\n\t                delete ctrl.$pending[name];\n\t              }\n\t            });\n\t          } else {\n\t            ctrl.$setValidity(name, isValid);\n\t          }\n\t          return viewValue;\n\t        });\n\t      }\n\t    }\n\t  };\n\t}\n\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = formlyField;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyField\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t  var arrayify = formlyUtil.arrayify;\n\n\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t  return {\n\t    restrict: 'AE',\n\t    transclude: true,\n\t    require: '?^formlyForm',\n\t    scope: {\n\t      options: '=',\n\t      model: '=',\n\t      originalModel: '=?',\n\t      formId: '@', // TODO remove formId in a breaking release\n\t      index: '=?',\n\t      fields: '=?',\n\t      formState: '=?',\n\t      formOptions: '=?',\n\t      form: '=?' // TODO require form in a breaking release\n\t    },\n\t    controller: FormlyFieldController,\n\t    link: fieldLink\n\t  };\n\n\t  // @ngInject\n\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t    /* eslint max-statements:[2, 31] */\n\t    if ($scope.options.fieldGroup) {\n\t      setupFieldGroup();\n\t      return;\n\t    }\n\n\t    var fieldType = getFieldType($scope.options);\n\t    simplifyLife($scope.options);\n\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t    checkApi($scope.options);\n\t    // set field id to link labels and fields\n\n\t    // initalization\n\t    setFieldIdAndName();\n\t    setDefaultValue();\n\t    setInitialValue();\n\t    runExpressions();\n\t    addValidationMessages($scope.options);\n\t    invokeControllers($scope, $scope.options, fieldType);\n\n\t    // function definitions\n\t    function runExpressions() {\n\t      // must run on next tick to make sure that the current value is correct.\n\t      return $timeout(function runExpressionsOnNextTick() {\n\t        var field = $scope.options;\n\t        var currentValue = valueGetterSetter();\n\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t          var setter = $parse(prop).assign;\n\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t          promise.then(function setFieldValue(value) {\n\t            setter(field, value);\n\t          });\n\t        });\n\t      }, 0, false);\n\t    }\n\n\t    function valueGetterSetter(newVal) {\n\t      if (!$scope.model || !$scope.options.key) {\n\t        return undefined;\n\t      }\n\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t        $scope.model[$scope.options.key] = newVal;\n\t      }\n\t      return $scope.model[$scope.options.key];\n\t    }\n\n\t    function simplifyLife(options) {\n\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t      formlyUtil.reverseDeepMerge(options, {\n\t        originalModel: options.model,\n\t        extras: {},\n\t        data: {},\n\t        templateOptions: {},\n\t        validation: {}\n\t      });\n\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t      $scope.to = $scope.options.templateOptions;\n\t      $scope.formOptions = $scope.formOptions || {};\n\t    }\n\n\t    function setFieldIdAndName() {\n\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t      } else {\n\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t      }\n\t      $scope.options.id = $scope.id;\n\t      $scope.name = $scope.options.name || $scope.options.id;\n\t      $scope.options.name = $scope.name;\n\t    }\n\n\t    function setDefaultValue() {\n\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined($scope.model[$scope.options.key])) {\n\t        var setter = $parse($scope.options.key).assign;\n\t        setter($scope.model, $scope.options.defaultValue);\n\t      }\n\t    }\n\n\t    function setInitialValue() {\n\t      $scope.options.initialValue = $scope.model && $scope.model[$scope.options.key];\n\t    }\n\n\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t      if (type) {\n\t        mergeOptions(options, type.defaultOptions);\n\t      }\n\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t      });\n\t    }\n\n\t    function mergeOptions(options, extraOptions) {\n\t      if (extraOptions) {\n\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t          extraOptions = extraOptions(options, $scope);\n\t        }\n\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t      }\n\t    }\n\n\t    function extendOptionsWithDefaults(options, index) {\n\t      var key = options.key || index || 0;\n\t      _angularFix2['default'].extend(options, {\n\t        // attach the key in case the formly-field directive is used directly\n\t        key: key,\n\t        value: options.value || valueGetterSetter,\n\t        runExpressions: runExpressions,\n\t        resetModel: resetModel,\n\t        updateInitialValue: updateInitialValue\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      $scope.model[$scope.options.key] = $scope.options.initialValue;\n\t      if ($scope.options.formControl) {\n\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t            resetFormControl(formControl, true);\n\t          });\n\t        } else {\n\t          resetFormControl($scope.options.formControl);\n\t        }\n\t      }\n\t    }\n\n\t    function resetFormControl(formControl, isMultiNgModel) {\n\t      if (!isMultiNgModel) {\n\t        formControl.$setViewValue($scope.model[$scope.options.key]);\n\t      }\n\n\t      formControl.$render();\n\t      formControl.$setUntouched && formControl.$setUntouched();\n\t      formControl.$setPristine();\n\n\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t      if (!$scope.$root.$$phase) {\n\t        $scope.$digest();\n\t      }\n\t    }\n\n\t    function updateInitialValue() {\n\t      $scope.options.initialValue = $scope.model[$scope.options.key];\n\t    }\n\n\t    function addValidationMessages(options) {\n\t      options.validation.messages = options.validation.messages || {};\n\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t        if (!options.validation.messages[name]) {\n\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t          };\n\t        }\n\t      });\n\t    }\n\n\t    function invokeControllers(scope) {\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t        if (controller) {\n\t          $controller(controller, { $scope: scope });\n\t        }\n\t      });\n\t    }\n\n\t    function setupFieldGroup() {\n\t      $scope.options.options = $scope.options.options || {};\n\t      $scope.options.options.formState = $scope.formState;\n\t    }\n\t  }\n\n\t  // link function\n\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t    if (scope.options.fieldGroup) {\n\t      setFieldGroupTemplate();\n\t      return;\n\t    }\n\n\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t    if (!formlyFormCtrl && scope.options.model) {\n\t      scope.$watch('options.model', function () {\n\t        return scope.options.runExpressions();\n\t      }, true);\n\t    }\n\n\t    addAttributes();\n\t    addClasses();\n\n\t    var type = getFieldType(scope.options);\n\t    var args = arguments;\n\t    var thusly = this;\n\t    var fieldCount = 0;\n\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t    });\n\n\t    function setFieldGroupTemplate() {\n\t      checkFieldGroupApi(scope.options);\n\t      el.addClass('formly-field-group');\n\t      var extraAttributes = '';\n\t      if (scope.options.elementAttributes) {\n\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t        }).join(' ');\n\t      }\n\t      var modelValue = 'model';\n\t      scope.options.form = scope.form;\n\t      if (scope.options.key) {\n\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t      }\n\t      setElementTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ');\n\t    }\n\n\t    function addAttributes() {\n\t      if (scope.options.elementAttributes) {\n\t        el.attr(scope.options.elementAttributes);\n\t      }\n\t    }\n\n\t    function addClasses() {\n\t      if (scope.options.className) {\n\t        el.addClass(scope.options.className);\n\t      }\n\t      if (scope.options.type) {\n\t        el.addClass('formly-field-' + scope.options.type);\n\t      }\n\t    }\n\n\t    function setElementTemplate(templateString) {\n\t      el.html(asHtml(templateString));\n\t      $compile(el.contents())(scope);\n\t      return templateString;\n\t    }\n\n\t    function watchFormControl(templateString) {\n\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t      if (scope.options.noFormControl) {\n\t        return;\n\t      }\n\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\n\t      if (ngModelNodes.length) {\n\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t          fieldCount++;\n\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t        });\n\t      }\n\n\t      function watchFieldNameOrExistence(name) {\n\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t        var nameExpression = nameExpressionRegex.exec(name);\n\t        if (nameExpression) {\n\t          name = $interpolate(name)(scope);\n\t        }\n\t        watchFieldExistence(name);\n\t      }\n\n\t      function watchFieldExistence(name) {\n\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t          if (formControl) {\n\t            if (fieldCount > 1) {\n\t              if (!scope.options.formControl) {\n\t                scope.options.formControl = [];\n\t              }\n\t              scope.options.formControl.push(formControl);\n\t            } else {\n\t              scope.options.formControl = formControl;\n\t            }\n\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t            stopWatchingShowError();\n\t            addShowMessagesWatcher();\n\t            addParsers();\n\t            addFormatters();\n\t          }\n\t        });\n\t      }\n\n\t      function addShowMessagesWatcher() {\n\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t          var options = scope.options;\n\t          var fc = scope.fc;\n\n\t          if (!fc.$invalid) {\n\t            return false;\n\t          } else if (typeof options.validation.show === 'boolean') {\n\t            return options.validation.show;\n\t          } else if (customExpression) {\n\t            return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t          } else {\n\t            var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t            return scope.fc.$touched || noTouchedButDirty;\n\t          }\n\t        }, function onShowValidationChange(show) {\n\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t          scope.showError = show; // shortcut for template authors\n\t        });\n\t      }\n\n\t      function addParsers() {\n\t        setParsersOrFormatters('parsers');\n\t      }\n\n\t      function addFormatters() {\n\t        setParsersOrFormatters('formatters');\n\t        var ctrl = scope.fc;\n\t        var formWasPristine = scope.form.$pristine;\n\t        if (scope.options.formatters) {\n\t          (function () {\n\t            var value = ctrl.$modelValue;\n\t            ctrl.$formatters.forEach(function (formatter) {\n\t              value = formatter(value);\n\t            });\n\n\t            ctrl.$setViewValue(value);\n\t            ctrl.$render();\n\t            ctrl.$setPristine();\n\t            if (formWasPristine) {\n\t              scope.form.$setPristine();\n\t            }\n\t          })();\n\t        }\n\t      }\n\n\t      function setParsersOrFormatters(which) {\n\t        var originalThingProp = 'originalParser';\n\t        if (which === 'formatters') {\n\t          originalThingProp = 'originalFormatter';\n\t        }\n\n\t        // init with type's parsers\n\t        var things = getThingsFromType(type);\n\n\t        // get optionsTypes things\n\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\n\t        // get field's things\n\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\n\t        // convert things into formlyExpression things\n\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t          things[index] = getFormlyExpressionThing(thing);\n\t        });\n\n\t        var ngModelCtrls = scope.fc;\n\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t          ngModelCtrls = [ngModelCtrls];\n\t        }\n\n\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t          var _ngModelCtrl;\n\n\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t        });\n\n\t        function getThingsFromType(theType) {\n\t          if (!theType) {\n\t            return [];\n\t          }\n\t          if (_angularFix2['default'].isString(theType)) {\n\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t          }\n\t          var typeThings = [];\n\n\t          // get things from parent\n\t          if (theType['extends']) {\n\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t          }\n\n\t          // get own type's things\n\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\n\t          // get things from optionsTypes\n\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\n\t          return typeThings;\n\t        }\n\n\t        function getThingsFromOptionsTypes() {\n\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n\t          var optionsTypesThings = [];\n\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t          });\n\t          return optionsTypesThings;\n\t        }\n\n\t        function getFormlyExpressionThing(thing) {\n\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t          return formlyExpressionParserOrFormatterFunction;\n\n\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t            var $modelValue = scope.options.value();\n\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    function callLinkFunctions() {\n\t      if (type && type.link) {\n\t        type.link.apply(thusly, args);\n\t      }\n\t      if (scope.options.link) {\n\t        scope.options.link.apply(thusly, args);\n\t      }\n\t    }\n\n\t    function runManipulators(manipulators) {\n\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t        var chain = $q.when(templateToManipulate);\n\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t          chain = chain.then(function (template) {\n\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t            });\n\t          });\n\t        });\n\t        return chain;\n\t      };\n\t    }\n\t  }\n\n\t  // sort-of stateless util functions\n\t  function asHtml(el) {\n\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t    return wrapper.append(el).html();\n\t  }\n\n\t  function getFieldType(options) {\n\t    return options.type && formlyConfig.getType(options.type);\n\t  }\n\n\t  function getManipulators(options, formOptions) {\n\t    var preWrapper = [];\n\t    var postWrapper = [];\n\t    addManipulators(options.templateManipulators);\n\t    addManipulators(formOptions.templateManipulators);\n\t    addManipulators(formlyConfig.templateManipulators);\n\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\n\t    function addManipulators(manipulators) {\n\t      /* eslint-disable */ // it doesn't understand this :-(\n\n\t      var _ref = manipulators || {};\n\n\t      var _ref$preWrapper = _ref.preWrapper;\n\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t      var _ref$postWrapper = _ref.postWrapper;\n\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\n\t      preWrapper = preWrapper.concat(pre);\n\t      postWrapper = postWrapper.concat(post);\n\t      /* eslint-enable */\n\t    }\n\t  }\n\n\t  function getFieldTemplate(options) {\n\t    function fromOptionsOrType(key, fieldType) {\n\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t        return options[key];\n\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t        return fieldType[key];\n\t      }\n\t    }\n\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    var template = fromOptionsOrType('template', type);\n\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t    }\n\n\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t  }\n\n\t  function getTemplate(template, isUrl, options) {\n\t    var templatePromise = undefined;\n\t    if (_angularFix2['default'].isFunction(template)) {\n\t      templatePromise = $q.when(template(options));\n\t    } else {\n\t      templatePromise = $q.when(template);\n\t    }\n\n\t    if (!isUrl) {\n\t      return templatePromise;\n\t    } else {\n\t      var _ret2 = (function () {\n\t        var httpOptions = { cache: $templateCache };\n\t        return {\n\t          v: templatePromise.then(function (url) {\n\t            return $http.get(url, httpOptions);\n\t          }).then(function (response) {\n\t            return response.data;\n\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t          })\n\t        };\n\t      })();\n\n\t      if (typeof _ret2 === 'object') return _ret2.v;\n\t    }\n\t  }\n\n\t  function transcludeInWrappers(options, formOptions) {\n\t    var wrapper = getWrapperOption(options, formOptions);\n\n\t    return function transcludeTemplate(template) {\n\t      if (!wrapper.length) {\n\t        return $q.when(template);\n\t      }\n\n\t      wrapper.forEach(function (aWrapper) {\n\t        formlyUsability.checkWrapper(aWrapper, options);\n\t        runApiCheck(aWrapper, options);\n\t      });\n\t      var promises = wrapper.map(function (w) {\n\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t      });\n\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t        });\n\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t        var totalWrapper = wrappersTemplates.shift();\n\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t        });\n\t        return doTransclusion(totalWrapper, template);\n\t      });\n\t    };\n\t  }\n\n\t  function doTransclusion(wrapper, template) {\n\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t    superWrapper.append(wrapper);\n\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t    if (!transcludeEl.length) {\n\t      // try it using our custom find function\n\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t    }\n\t    transcludeEl.replaceWith(template);\n\t    return superWrapper.html();\n\t  }\n\n\t  function getWrapperOption(options, formOptions) {\n\t    /* eslint complexity:[2, 6] */\n\t    var wrapper = options.wrapper;\n\t    // explicit null means no wrapper\n\t    if (wrapper === null) {\n\t      return [];\n\t    }\n\n\t    // nothing specified means use the default wrapper for the type\n\t    if (!wrapper) {\n\t      // get all wrappers that specify they apply to this type\n\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t    } else {\n\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t    }\n\n\t    // get all wrappers for that the type specified that it uses.\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    if (type && type.wrapper) {\n\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(typeWrappers);\n\t    }\n\n\t    // add form wrappers\n\t    if (formOptions.wrapper) {\n\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(formWrappers);\n\t    }\n\n\t    // add the default wrapper last\n\t    var defaultWrapper = formlyConfig.getWrapper();\n\t    if (defaultWrapper) {\n\t      wrapper.push(defaultWrapper);\n\t    }\n\t    return wrapper;\n\t  }\n\n\t  function checkApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t    // validate with the type\n\t    var type = options.type && formlyConfig.getType(options.type);\n\t    if (type) {\n\t      runApiCheck(type, options, true);\n\t    }\n\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t    }\n\t  }\n\n\t  function checkFieldGroupApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t  }\n\n\t  function runApiCheck(_ref2, options, forType) {\n\t    var apiCheck = _ref2.apiCheck;\n\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\n\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t    if (forType && options.type) {\n\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t      });\n\t    }\n\t  }\n\n\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t    /* eslint complexity:[2, 9] */\n\t    if (!apiCheck) {\n\t      return;\n\t    }\n\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t      return;\n\t    }\n\t    var fn = apiCheckFunction || 'warn';\n\t    // this is the new API\n\t    var checkerObjects = apiCheck(instance);\n\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t      var checker = instance.shape(shape);\n\t      var checkOptions = _angularFix2['default'].extend({\n\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t      }, apiCheckOptions);\n\t      instance[fn](checker, options[name], checkOptions);\n\t    });\n\t  }\n\t}\n\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\n\t// Stateless util functions\n\tfunction getDefaultOptionsOptionsTypes(type) {\n\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t}\n\n\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = formlyFocus;\n\n\t// @ngInject\n\tfunction formlyFocus($timeout, $document) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function formlyFocusLink(scope, element, attrs) {\n\t      var previousEl = null;\n\t      var el = element[0];\n\t      var doc = $document[0];\n\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t        if (value === 'true') {\n\t          $timeout(function setElementFocus() {\n\t            previousEl = doc.activeElement;\n\t            el.focus();\n\t          }, ~ ~attrs.focusWait);\n\t        } else if (value === 'false') {\n\t          if (doc.activeElement === el) {\n\t            el.blur();\n\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t              previousEl.focus();\n\t            }\n\t          }\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar _slice = Array.prototype.slice;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyForm;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyForm\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t  var currentFormId = 1;\n\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t  return {\n\t    restrict: 'AE',\n\t    template: formlyFormGetTemplate,\n\t    replace: true,\n\t    transclude: true,\n\t    scope: {\n\t      fields: '=',\n\t      model: '=',\n\t      form: '=?',\n\t      options: '=?'\n\t    },\n\t    controller: FormlyFormController,\n\t    link: formlyFormLink\n\t  };\n\n\t  function formlyFormGetTemplate(el, attrs) {\n\t    var rootEl = getRootEl();\n\t    var fieldRootEl = getFieldRootEl();\n\t    var formId = 'formly_' + currentFormId++;\n\t    var parentFormAttributes = '';\n\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t    }\n\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\n\t    function getRootEl() {\n\t      return attrs.rootEl || 'ng-form';\n\t    }\n\n\t    function getFieldRootEl() {\n\t      return attrs.fieldRootEl || 'div';\n\t    }\n\n\t    function getHideDirective() {\n\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t    }\n\n\t    function getTrackBy() {\n\t      if (!attrs.trackBy) {\n\t        return '';\n\t      } else {\n\t        return 'track by ' + attrs.trackBy;\n\t      }\n\t    }\n\n\t    function getFormName() {\n\t      var formName = formId;\n\t      var bindName = attrs.bindName;\n\t      if (bindName) {\n\t        if (_angularFix2['default'].version.minor < 3) {\n\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t        }\n\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t      }\n\t      return formName;\n\t    }\n\n\t    function getTranscludeClass() {\n\t      return attrs.transcludeClass || '';\n\t    }\n\n\t    function copyAttributes(attributes) {\n\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t      var arrayAttrs = [];\n\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t        var nodeName = _ref.nodeName;\n\t        var value = _ref.value;\n\n\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t        }\n\t      });\n\t      return arrayAttrs.join(' ');\n\t    }\n\t  }\n\n\t  // @ngInject\n\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t    setupOptions();\n\t    $scope.model = $scope.model || {};\n\t    setupFields();\n\n\t    // watch the model and evaluate watch expressions that depend on it.\n\t    $scope.$watch('model', onModelOrFormStateChange, true);\n\t    if ($scope.options.formState) {\n\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t    }\n\n\t    function onModelOrFormStateChange() {\n\t      _angularFix2['default'].forEach($scope.fields, function runFieldExpressionProperties(field, index) {\n\t        var model = field.model || $scope.model;\n\t        var promise = field.runExpressions && field.runExpressions();\n\t        if (field.hideExpression) {\n\t          // can't use hide with expressionProperties reliably\n\t          var val = model[field.key];\n\t          field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t        }\n\t        if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t          var validate = field.formControl.$validate;\n\t          if (promise) {\n\t            promise.then(validate);\n\t          } else {\n\t            validate();\n\t          }\n\t        }\n\t      });\n\t    }\n\n\t    function setupFields() {\n\t      $scope.fields = $scope.fields || [];\n\n\t      checkDeprecatedOptions($scope.options);\n\n\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\n\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t        fieldTransforms = [fieldTransforms];\n\t      }\n\n\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t        if (fieldTransform) {\n\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t          if (!$scope.fields) {\n\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t          }\n\t        }\n\t      });\n\n\t      setupModels();\n\n\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t    }\n\n\t    function checkDeprecatedOptions(options) {\n\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t      }\n\t    }\n\n\t    function setupOptions() {\n\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t      $scope.options = $scope.options || {};\n\t      $scope.options.formState = $scope.options.formState || {};\n\n\t      _angularFix2['default'].extend($scope.options, {\n\t        updateInitialValue: updateInitialValue,\n\t        resetModel: resetModel\n\t      });\n\t    }\n\n\t    function updateInitialValue() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.updateInitialValue();\n\t        } else {\n\t          field.updateInitialValue();\n\t        }\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.resetModel();\n\t        } else if (field.resetModel) {\n\t          field.resetModel();\n\t        }\n\t      });\n\t    }\n\n\t    function setupModels() {\n\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t      var watchedModels = [$scope.model];\n\n\t      if ($scope.options.formState) {\n\t        // $scope.options.formState will have its own watcher\n\t        watchedModels.push($scope.options.formState);\n\t      }\n\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        var isNewModel = initModel(field);\n\n\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1) {\n\t          $scope.$watch(function () {\n\t            return field.model;\n\t          }, onModelOrFormStateChange, true);\n\t          watchedModels.push(field.model);\n\t        }\n\t      });\n\t    }\n\n\t    function initModel(field) {\n\t      var isNewModel = true;\n\n\t      if (_angularFix2['default'].isString(field.model)) {\n\t        var expression = field.model;\n\t        var index = $scope.fields.indexOf(field);\n\n\t        isNewModel = !refrencesCurrentlyWatchedModel(expression);\n\n\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t        if (!field.model) {\n\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t        }\n\t      }\n\t      return isNewModel;\n\t    }\n\n\t    function refrencesCurrentlyWatchedModel(expression) {\n\t      return ['model', 'formState'].some(function (item) {\n\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t      });\n\t    }\n\n\t    function attachKey(field, index) {\n\t      if (!isFieldGroup(field)) {\n\t        field.key = field.key || index || 0;\n\t      }\n\t    }\n\n\t    function setupWatchers(field, index) {\n\t      if (isFieldGroup(field) || !_angularFix2['default'].isDefined(field.watcher)) {\n\t        return;\n\t      }\n\t      var watchers = field.watcher;\n\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t        watchers = [watchers];\n\t      }\n\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t        if (!_angularFix2['default'].isDefined(watcher.listener)) {\n\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t        }\n\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t        var watchListener = getWatchListener(watcher, field, index);\n\n\t        var type = watcher.type || '$watch';\n\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t      });\n\t    }\n\n\t    function getWatchExpression(watcher, field, index) {\n\t      var watchExpression = watcher.expression || 'model[\\'' + field.key + '\\']';\n\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t        (function () {\n\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalExpression = watchExpression;\n\t          watchExpression = function formlyWatchExpression() {\n\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t          };\n\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchExpression;\n\t    }\n\n\t    function getWatchListener(watcher, field, index) {\n\t      var watchListener = watcher.listener;\n\t      if (_angularFix2['default'].isFunction(watchListener)) {\n\t        (function () {\n\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalListener = watchListener;\n\t          watchListener = function formlyWatchListener() {\n\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t            return originalListener.apply(undefined, _toConsumableArray(args));\n\t          };\n\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchListener;\n\t    }\n\n\t    function modifyArgs(watcher, index) {\n\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t        originalArgs[_key - 2] = arguments[_key];\n\t      }\n\n\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t    }\n\n\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t    }\n\n\t    function getFormlyFieldLikeLocals(field, index) {\n\t      // this makes it closer to what a regular formlyExpression would be\n\t      return {\n\t        options: field,\n\t        index: index,\n\t        formState: $scope.options.formState,\n\t        formId: $scope.formId\n\t      };\n\t    }\n\t  }\n\n\t  function formlyFormLink(scope, el, attrs) {\n\t    setFormController();\n\t    fixChromeAutocomplete();\n\n\t    function setFormController() {\n\t      var formId = attrs.name;\n\t      scope.formId = formId;\n\t      scope.theFormlyForm = scope[formId];\n\t      if (attrs.form) {\n\t        var getter = $parse(attrs.form);\n\t        var setter = getter.assign;\n\t        var parentForm = getter(scope.$parent);\n\t        if (parentForm) {\n\t          scope.theFormlyForm = parentForm;\n\t          if (scope[formId]) {\n\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t          }\n\n\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t          // to children forms :-( This line was added to solve this issue:\n\t          // https://github.com/formly-js/angular-formly/issues/287\n\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t          // so I expect it will remain this way for the life of angular 1.x\n\t          el.removeData('$formController');\n\t        } else {\n\t          setter(scope.$parent, scope[formId]);\n\t        }\n\t      }\n\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t        /* eslint no-console:0 */\n\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t      }\n\t    }\n\n\t    /*\n\t     * chrome autocomplete lameness\n\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t     * ()   ()     ()\n\t     */\n\t    function fixChromeAutocomplete() {\n\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t      if (global && !offInstance || onInstance) {\n\t        var input = document.createElement('input');\n\t        input.setAttribute('autocomplete', 'address-level4');\n\t        input.setAttribute('hidden', 'true');\n\t        el[0].appendChild(input);\n\t      }\n\t    }\n\t  }\n\n\t  // stateless util functions\n\t  function toKebabCase(string) {\n\t    if (string) {\n\t      return string.replace(/([A-Z])/g, function ($1) {\n\t        return '-' + $1.toLowerCase();\n\t      });\n\t    } else {\n\t      return '';\n\t    }\n\t  }\n\n\t  function isFieldGroup(field) {\n\t    return field && !!field.fieldGroup;\n\t  }\n\t}\n\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\texports['default'] = addFormlyNgModelAttrsManipulator;\n\n\t// @ngInject\n\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t    return;\n\t  }\n\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\n\t  function ngModelAttrsManipulator(template, options, scope) {\n\t    var node = document.createElement('div');\n\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t    if (skip === true) {\n\t      return template;\n\t    }\n\t    node.innerHTML = template;\n\n\t    var modelNodes = getNgModelNodes(node, skip);\n\t    if (!modelNodes || !modelNodes.length) {\n\t      return template;\n\t    }\n\n\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\n\t    addValidation();\n\t    alterNgModelAttr();\n\t    addModelOptions();\n\t    addTemplateOptionsAttrs();\n\t    addNgModelElAttrs();\n\n\t    return node.innerHTML;\n\n\t    function addValidation() {\n\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t      }\n\t    }\n\n\t    function alterNgModelAttr() {\n\t      if (isPropertyAccessor(options.key)) {\n\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t      }\n\t    }\n\n\t    function addModelOptions() {\n\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t        if (options.modelOptions.getterSetter) {\n\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t        }\n\t      }\n\t    }\n\n\t    function addTemplateOptionsAttrs() {\n\t      if (!options.templateOptions && !options.expressionProperties) {\n\t        // no need to run these if there are no templateOptions or expressionProperties\n\t        return;\n\t      }\n\t      var to = options.templateOptions || {};\n\t      var ep = options.expressionProperties || {};\n\n\t      var ngModelAttributes = getBuiltInAttributes();\n\n\t      // extend with the user's specifications winning\n\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\n\t      // Feel free to make this more simple :-)\n\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t        /* eslint complexity:[2, 14] */\n\t        var attrVal = undefined,\n\t            attrName = undefined;\n\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t        var toVal = to[name];\n\t        var epVal = getEpValue(ep, name);\n\n\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t        if (val.value) {\n\t          // I realize this looks backwards, but it's right, trust me...\n\t          attrName = val.value;\n\t          attrVal = name;\n\t        } else if (val.statement && inTo) {\n\t          attrName = val.statement;\n\t          if (_angularFix2['default'].isString(to[name])) {\n\t            attrVal = '$eval(' + ref + ')';\n\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t          } else {\n\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t          }\n\t        } else if (val.bound && inEp) {\n\t          attrName = val.bound;\n\t          attrVal = ref;\n\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t          attrName = val.attribute || val.boolean;\n\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t        } else if (val.attribute && inTo) {\n\t          attrName = val.attribute;\n\t          attrVal = toVal;\n\t        } else if (val.boolean) {\n\t          if (inTo && !inEp && toVal) {\n\t            attrName = val.boolean;\n\t            attrVal = true;\n\t          } else {\n\t            /* eslint no-empty:0 */\n\t            // empty to illustrate that a boolean will not be added via val.bound\n\t            // if you want it added via val.bound, then put it in expressionProperties\n\t          }\n\t        } else if (val.bound && inTo) {\n\t            attrName = val.bound;\n\t            attrVal = ref;\n\t          }\n\n\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t        }\n\t      });\n\t    }\n\n\t    function addNgModelElAttrs() {\n\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t        addRegardlessOfPresence(modelNodes, name, val);\n\t      });\n\t    }\n\t  }\n\n\t  // Utility functions\n\t  function getNgModelNodes(node, skip) {\n\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t    try {\n\t      return node.querySelectorAll(query);\n\t    } catch (e) {\n\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t      //it should be removed when IE8 support is dropped\n\t      return getNgModelNodesFallback(node, skip);\n\t    }\n\t  }\n\n\t  function getNgModelNodesFallback(node, skip) {\n\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t    var matchingNgModelNodes = [];\n\n\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t    matchingNgModelNodes.item = function (i) {\n\t      return this[i];\n\t    };\n\n\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t      var ngModelNode = allNgModelNodes[i];\n\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t        matchingNgModelNodes.push(ngModelNode);\n\t      }\n\t    }\n\n\t    return matchingNgModelNodes;\n\t  }\n\n\t  function nodeMatches(node, selector) {\n\t    var div = document.createElement('div');\n\t    div.innerHTML = node.outerHTML;\n\t    return div.querySelector(selector);\n\t  }\n\n\t  function getBuiltInAttributes() {\n\t    var ngModelAttributes = {\n\t      focus: {\n\t        attribute: 'formly-focus'\n\t      }\n\t    };\n\t    var boundOnly = [];\n\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t    var attributeOnly = ['placeholder', 'min', 'max', 'tabindex', 'type'];\n\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t      bothAttributeAndBound.push('maxlength');\n\t    } else {\n\t      boundOnly.push('maxlength');\n\t    }\n\n\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t      ngModelAttributes[item] = { attribute: item };\n\t    });\n\t    return ngModelAttributes;\n\t  }\n\n\t  function getEpValue(ep, name) {\n\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t  }\n\n\t  function addIfNotPresent(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      if (!node.getAttribute(attr)) {\n\t        node.setAttribute(attr, val);\n\t      }\n\t    });\n\t  }\n\n\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      node.setAttribute(attr, val);\n\t    });\n\t  }\n\n\t  function isPropertyAccessor(key) {\n\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t  }\n\t}\n\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = addCustomTags;\n\n\t// @ngInject\n\tfunction addCustomTags($document) {\n\t  if ($document && $document.get) {\n\t    (function () {\n\t      // IE8 check ->\n\t      // http://stackoverflow.com/questions/10964966/detect-ie-version-prior-to-v9-in-javascript/10965203#10965203\n\t      var document = $document.get(0);\n\t      var div = document.createElement('div');\n\t      div.innerHTML = '<!--[if lt IE 9]><i></i><![endif]-->';\n\t      var isIeLessThan9 = div.getElementsByTagName('i').length === 1;\n\n\t      if (isIeLessThan9) {\n\t        // add the custom elements that we need for formly\n\t        var customElements = ['formly-field', 'formly-form', 'formly-custom-validation', 'formly-focus', 'formly-transpose'];\n\t        _angularFix2['default'].forEach(customElements, function (el) {\n\t          document.createElement(el);\n\t        });\n\t      }\n\t    })();\n\t  }\n\t}\n\taddCustomTags.$inject = [\"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly/dist/formly.js\n ** module id = 4\n ** module chunks = 1\n **/","//! angular-formly-templates-bootstrap version 6.1.5 built with  by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> ( _)==(_ )\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tmodule.exports = __webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar ngModuleName = 'formlyBootstrap';\n\tvar angular = __webpack_require__(2);\n\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t  output: {\n\t    prefix: 'angular-formly-bootstrap'\n\t  }\n\t}));\n\tngModule.constant('formlyBootstrapVersion', (\"6.1.5\"));\n\n\t__webpack_require__(6)(ngModule);\n\t__webpack_require__(9)(ngModule);\n\t__webpack_require__(19)(ngModule);\n\n\texports['default'] = ngModuleName;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tvar angular = __webpack_require__(3);\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\tmodule.exports = angular;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addWrappers);\n\n\t  function addWrappers(formlyConfigProvider) {\n\t    formlyConfigProvider.setWrapper([{\n\t      name: 'bootstrapLabel',\n\t      template: __webpack_require__(7),\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string,\n\t            required: check.bool.optional,\n\t            labelSrOnly: check.bool.optional\n\t          }\n\t        };\n\t      }\n\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t  }\n\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  __webpack_require__(10)(ngModule);\n\t  __webpack_require__(12)(ngModule);\n\t  __webpack_require__(14)(ngModule);\n\t  __webpack_require__(15)(ngModule);\n\t  __webpack_require__(17)(ngModule);\n\t  __webpack_require__(18)(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'checkbox',\n\t      template: __webpack_require__(11),\n\t      wrapper: ['bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'multiCheckbox',\n\t      template: __webpack_require__(13),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      },\n\t      defaultOptions: {\n\t        noFormControl: false,\n\t        ngModelAttrs: {\n\t          required: {\n\t            attribute: '',\n\t            bound: ''\n\t          }\n\t        }\n\t      },\n\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t        var to = $scope.to;\n\t        var opts = $scope.options;\n\t        $scope.multiCheckbox = {\n\t          checked: [],\n\t          change: setModel\n\t        };\n\n\t        // initialize the checkboxes check property\n\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t          var modelValue, valueProp;\n\n\t          if (Object.keys(newModelValue).length) {\n\t            modelValue = newModelValue[opts.key];\n\n\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t                valueProp = to.valueProp || 'value';\n\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t                }\n\t              }\n\t            });\n\t          }\n\t        }, true);\n\n\t        function checkValidity(expressionValue) {\n\t          var valid;\n\n\t          if ($scope.to.required) {\n\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\n\t            $scope.fc.$setValidity('required', valid);\n\t          }\n\t        }\n\n\t        function setModel() {\n\t          $scope.model[opts.key] = [];\n\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t            if (checkbox) {\n\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t            }\n\t          });\n\n\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t          $scope.fc.$setTouched();\n\t          checkValidity(true);\n\t        }\n\n\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t          $scope.$watch(function () {\n\t            return $scope.to.required;\n\t          }, function (newValue) {\n\t            checkValidity(newValue);\n\t          });\n\t        }\n\n\t        if ($scope.to.required) {\n\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t            if (!newValue) {\n\t              return;\n\t            }\n\t            checkValidity(true);\n\t            unwatchFormControl();\n\t          });\n\t        }\n\t      }]\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addInputType);\n\n\t  function addInputType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'input',\n\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t    });\n\t  }\n\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addRadioType);\n\n\t  function addRadioType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'radio',\n\t      template: __webpack_require__(16),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        noFormControl: false\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addSelectType);\n\n\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\n\t  function addSelectType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'select',\n\t      template: template,\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: function defaultOptions(options) {\n\t        /* jshint maxlen:195 */\n\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t        return {\n\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t          })\n\t        };\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            optionsAttr: check.string.optional,\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional,\n\t            groupProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addTextareaType);\n\n\t  function addTextareaType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'textarea',\n\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        ngModelAttrs: {\n\t          rows: { attribute: 'rows' },\n\t          cols: { attribute: 'cols' }\n\t        }\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            rows: check.number.optional,\n\t            cols: check.number.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _addons = __webpack_require__(20);\n\n\tvar _addons2 = _interopRequireDefault(_addons);\n\n\tvar _description = __webpack_require__(22);\n\n\tvar _description2 = _interopRequireDefault(_description);\n\n\texports['default'] = function (ngModule) {\n\t  (0, _addons2['default'])(ngModule);\n\t  (0, _description2['default'])(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addAddonsManipulator);\n\n\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t    var addonTemplate = __webpack_require__(21);\n\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t      'class': formlyBootstrapApiCheck.string.optional,\n\t      text: formlyBootstrapApiCheck.string.optional,\n\t      onClick: formlyBootstrapApiCheck.func.optional\n\t    }).strict.optional;\n\t    var api = formlyBootstrapApiCheck.shape({\n\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t        addonLeft: addonChecker,\n\t        addonRight: addonChecker\n\t      })\n\t    });\n\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t        return template;\n\t      }\n\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t    });\n\t  }\n\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addDescriptionManipulator);\n\n\t  function addDescriptionManipulator(formlyConfig) {\n\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t      if (angular.isDefined(options.templateOptions.description)) {\n\t        var el = document.createElement('div');\n\t        el.appendChild(angular.element(template)[0]);\n\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t        if (modelEls) {\n\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t        }\n\t        return el.innerHTML;\n\t      } else {\n\t        return template;\n\t      }\n\t    });\n\t  }\n\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js\n ** module id = 6\n ** module chunks = 1\n **/","/**\n * angular-permission\n * Route permission and access control as simple as it can get\n * @version v0.3.1 - 2015-07-07\n * @link http://www.rafaelvidaurre.com\n * @author Rafael Vidaurre <narzerus@gmail.com>\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n(function () {\n  'use strict';\n\n  angular.module('permission', ['ui.router'])\n    .run(['$rootScope', 'Permission', '$state', '$q',\n    function ($rootScope, Permission, $state, $q) {\n      $rootScope.$on('$stateChangeStart',\n      function (event, toState, toParams, fromState, fromParams) {\n        if (toState.$$finishAuthorize) {\n          return;\n        }\n\n        // If there are permissions set then prevent default and attempt to authorize\n        var permissions;\n        if (toState.data && toState.data.permissions) {\n          permissions = toState.data.permissions;\n        } else if (toState.permissions) {\n          /**\n          * This way of defining permissions will be depracated in v1. Should use\n          * `data` key instead\n          */\n          console.log('Deprecation Warning: permissions should be set inside the `data` key ');\n          console.log('Setting permissions for a state outside `data` will be depracated in' +\n            ' version 1');\n          permissions = toState.permissions;\n        }\n\n        if (permissions) {\n          event.preventDefault();\n          toState = angular.extend({'$$finishAuthorize': true}, toState);\n\n          if ($rootScope.$broadcast('$stateChangePermissionStart', toState, toParams).defaultPrevented) {\n            return;\n          }\n\n          Permission.authorize(permissions, toParams).then(function () {\n            // If authorized, use call state.go without triggering the event.\n            // Then trigger $stateChangeSuccess manually to resume the rest of the process\n            // Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n              $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams);\n\n              $state.go(toState.name, toParams, {notify: false}).then(function() {\n                $rootScope\n                  .$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams);\n              });\n            }\n          }, function () {\n            if (!$rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams).defaultPrevented) {\n              $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams);\n\n              var redirectTo = permissions.redirectTo;\n              var result;\n\n              if (angular.isFunction(redirectTo)) {\n                redirectTo = redirectTo();\n\n                $q.when(redirectTo).then(function (newState) {\n                  if (newState) {\n                    $state.go(newState, toParams);\n                  }\n                });\n\n              } else {\n                if (redirectTo) {\n                  $state.go(redirectTo, toParams);\n                }\n              }\n            }\n          });\n        }\n      });\n    }]);\n}());\n\n(function () {\n  'use strict';\n\n  angular.module('permission')\n    .provider('Permission', function () {\n      var roleValidationConfig = {};\n      var validateRoleDefinitionParams = function (roleName, validationFunction) {\n        if (!angular.isString(roleName)) {\n          throw new Error('Role name must be a string');\n        }\n        if (!angular.isFunction(validationFunction)) {\n          throw new Error('Validation function not provided correctly');\n        }\n      };\n\n      var validateManyRolesDefinitionParams = function(roles, validationFunction) {\n        if (!angular.isArray(roles)) {\n          throw new Error('Roles must be an array');\n        } else {\n          for(var i = 0; i < roles.length; i++) {\n            validateRoleDefinitionParams(roles[i], validationFunction);\n          }\n        }\n      };\n\n      this.defineRole = function (roleName, validationFunction) {\n        /**\n          This method is only available in config-time, and cannot access services, as they are\n          not yet injected anywere which makes this kinda useless.\n          Should remove if we cannot find a use for it.\n        **/\n        validateRoleDefinitionParams(roleName, validationFunction);\n        roleValidationConfig[roleName] = validationFunction;\n\n        return this;\n      };\n\n      this.$get = ['$q', function ($q) {\n        var Permission = {\n          _promiseify: function (value) {\n            /**\n              Converts a value into a promise, if the value is truthy it resolves it, otherwise\n              it rejects it\n            **/\n            if (value && angular.isFunction(value.then)) {\n              return value;\n            }\n\n            var deferred = $q.defer();\n            if (value) {\n              deferred.resolve();\n            } else {\n              deferred.reject();\n            }\n            return deferred.promise;\n          },\n          _validateRoleMap: function (roleMap) {\n            if (typeof(roleMap) !== 'object' || roleMap instanceof Array) {\n              throw new Error('Role map has to be an object');\n            }\n            if (roleMap.only === undefined && roleMap.except === undefined) {\n              throw new Error('Either \"only\" or \"except\" keys must me defined');\n            }\n            if (roleMap.only) {\n              if (!(roleMap.only instanceof Array)) {\n                throw new Error('Array of roles expected');\n              }\n            } else if (roleMap.except) {\n              if (!(roleMap.except instanceof Array)) {\n                throw new Error('Array of roles expected');\n              }\n            }\n          },\n          _findMatchingRole: function (rolesArray, toParams) {\n            var roles = angular.copy(rolesArray);\n            var deferred = $q.defer();\n            var currentRole = roles.shift();\n\n            // If no roles left to validate reject promise\n            if (!currentRole) {\n              deferred.reject();\n              return deferred.promise;\n            }\n            // Validate role definition exists\n            if (!angular.isFunction(Permission.roleValidations[currentRole])) {\n              throw new Error('undefined role or invalid role validation');\n            }\n\n            var validatingRole = Permission.roleValidations[currentRole](toParams, currentRole);\n            validatingRole = Permission._promiseify(validatingRole);\n\n            validatingRole.then(function () {\n              deferred.resolve();\n            }, function () {\n              Permission._findMatchingRole(roles, toParams).then(function () {\n                deferred.resolve();\n              }, function () {\n                deferred.reject();\n              });\n            });\n\n            return deferred.promise;\n          },\n          defineRole: function (roleName, validationFunction) {\n            /**\n              Service-available version of defineRole, the callback passed here lives in the\n              scope where it is defined and therefore can interact with other modules\n            **/\n            validateRoleDefinitionParams(roleName, validationFunction);\n            roleValidationConfig[roleName] = validationFunction;\n\n            return Permission;\n          },\n          defineManyRoles: function(roles, validationFunction) {\n            validateManyRolesDefinitionParams(roles, validationFunction);\n\n            var definedPermissions = Permission;\n            for(var i = 0; i < roles.length; i++) {\n               definedPermissions = definedPermissions.defineRole(roles[i], validationFunction);\n            }\n\n            return definedPermissions;\n          },\n          resolveIfMatch: function (rolesArray, toParams) {\n            var roles = angular.copy(rolesArray);\n            var deferred = $q.defer();\n            Permission._findMatchingRole(roles, toParams).then(function () {\n              // Found role match\n              deferred.resolve();\n            }, function () {\n              // No match\n              deferred.reject();\n            });\n            return deferred.promise;\n          },\n          rejectIfMatch: function (roles, toParams) {\n            var deferred = $q.defer();\n            Permission._findMatchingRole(roles, toParams).then(function () {\n              // Role found\n              deferred.reject();\n            }, function () {\n              // Role not found\n              deferred.resolve();\n            });\n            return deferred.promise;\n          },\n          roleValidations: roleValidationConfig,\n          authorize: function (roleMap, toParams) {\n            // Validate input\n            Permission._validateRoleMap(roleMap);\n\n            var authorizing;\n\n            if (roleMap.only) {\n              authorizing = Permission.resolveIfMatch(roleMap.only, toParams);\n            } else {\n              authorizing = Permission.rejectIfMatch(roleMap.except, toParams);\n            }\n\n            return authorizing;\n          }\n        };\n\n        return Permission;\n      }];\n    });\n\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-permission/dist/angular-permission.js\n ** module id = 7\n ** module chunks = 1\n **/","require('./ui-bootstrap-tpls');\nmodule.exports = 'ui.bootstrap';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/index.js\n ** module id = 8\n ** module chunks = 1\n **/","/**\r\n * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n * @author Mark Lagendijk <mark@lagendijk.info>\r\n * @license MIT\r\n */\r\nangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n        var self = this;\r\n\r\n        /**\r\n         * Recursively sets the states using $stateProvider.state.\r\n         * Child states are defined via a `children` property.\r\n         *\r\n         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n         * 3. Sets `parent` property of the descendant states.\r\n         *\r\n         * @param {Object} state - A regular ui.router state object.\r\n         * @param {Array} [state.children] - An optional array of child states.\r\n         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n         * @param {Object} [options] - An optional options object.\r\n         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n         *     prevents conversion of names to dot notation if true.\r\n         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n         */\r\n        this.state = function(state){\r\n            var args = Array.prototype.slice.apply(arguments);\r\n            var options = {\r\n                keepOriginalNames: false,\r\n                siblingTraversal: false\r\n            };  \r\n\r\n            if (typeof args[1] === 'boolean') {\r\n                options.keepOriginalNames = args[1];\r\n            } \r\n            else if (typeof args[1] === 'object') {\r\n                angular.extend(options, args[1]);\r\n            }\r\n\r\n            if (!options.keepOriginalNames) {\r\n                fixStateName(state);\r\n            }\r\n\r\n            $stateProvider.state(state);\r\n\r\n            if(state.children && state.children.length){\r\n                state.children.forEach(function(childState){\r\n                    childState.parent = state;\r\n                    self.state(childState, options);\r\n                });\r\n\r\n                if (options.siblingTraversal) {\r\n                    addSiblings(state);\r\n                }\r\n            }\r\n\r\n            return self;\r\n        };\r\n\r\n        this.setNestedState = this.state;\r\n\r\n        self.$get = angular.noop;\r\n\r\n        /**\r\n         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n         * @param state\r\n         */\r\n        function fixStateName(state){\r\n            if(state.parent){\r\n                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n            }\r\n        }\r\n\r\n        function addSiblings(state) {\r\n            state.children.forEach(function (childState, idx, array) {\r\n                if (array[idx + 1]) {\r\n                    childState.nextSibling = array[idx + 1].name;\r\n                }\r\n                if (array[idx - 1]) {\r\n                    childState.previousSibling = array[idx - 1].name;\r\n                }\r\n            });\r\n        }\r\n    }]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router.statehelper/statehelper.js\n ** module id = 9\n ** module chunks = 1\n **/","/**\n * State-based routing for AngularJS\n * @version v0.2.15\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\]-]+)|\\{([\\w\\[\\]-]+)(?:\\:((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+(-+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:  surroundPattern = ['?(', ')?']; break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n    type        = $$UMFP.type(regexp || \"string\") || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    var param = this.params[paramName];\n    var paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validate\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  function valToString(val) { return val != null ? val.toString().replace(/\\//g, \"%2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/%2F/g, \"/\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    string: {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    int: {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    bool: {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    date: {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    json: {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    any: { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n      return config.type instanceof Type ? config.type : new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {object} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. if handle is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|object} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];\n  function $get(   $location,   $rootScope,   $injector,   $browser) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = extend({}, state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"'' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explictly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Re-add the saved hash before we start returning things\n        if (hash) toParams['#'] = hash;\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .value('$stateParams', {})\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        if (result && options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$viewContentLoading\n         * @eventOf ui.router.state.$view\n         * @eventType broadcast on root scope\n         * @description\n         *\n         * Fired once the view **begins loading**, *before* the DOM is rendered.\n         *\n         * @param {Object} event Event object.\n         * @param {Object} viewConfig The view config properties (template, controller, etc).\n         *\n         * @example\n         *\n         * <pre>\n         * $scope.$on('$viewContentLoading',\n         * function(event, viewConfig){\n         *     // Access to all the view config properties.\n         *     // and one special property 'targetView'\n         *     // viewConfig.targetView\n         * });\n         * </pre>\n         */\n          $rootScope.$broadcast('$viewContentLoading', options);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = function() {\n      return {\n        enter: function (element, target, cb) { target.after(element); cb(); },\n        leave: function (element, cb) { element.remove(); cb(); }\n      };\n    };\n\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          var promise = $animate.enter(element, null, target, cb);\n          if (promise && promise.then) promise.then(cb);\n        },\n        leave: function(element, cb) {\n          var promise = $animate.leave(element, cb);\n          if (promise && promise.then) promise.then(cb);\n        }\n      };\n    }\n\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics();\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n        scope.$on('$viewContentLoading', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          if (previousEl) {\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description           *\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           */\n          currentScope.$emit('$viewContentLoaded');\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated \n * URL, the directive will automatically generate & update the `href` attribute via \n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking \n * the link will trigger a state transition with optional parameters. \n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be \n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative \n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the \n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the \n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n * \n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n * \n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];\n\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref = parseStateRef(attrs.uiSref, $state.current.name);\n      var params = null, url = null, base = stateContext(element) || $state.$current;\n      // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n      var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ?\n                 'xlink:href' : 'href';\n      var newHref = null, isAnchor = element.prop(\"tagName\").toUpperCase() === \"A\";\n      var isForm = element[0].nodeName === \"FORM\";\n      var attr = isForm ? \"action\" : hrefKind, nav = true;\n\n      var options = { relative: base, inherit: true };\n      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};\n\n      angular.forEach(allowedOptions, function(option) {\n        if (option in optionsOverride) {\n          options[option] = optionsOverride[option];\n        }\n      });\n\n      var update = function(newVal) {\n        if (newVal) params = angular.copy(newVal);\n        if (!nav) return;\n\n        newHref = $state.href(ref.state, params, options);\n\n        var activeDirective = uiSrefActive[1] || uiSrefActive[0];\n        if (activeDirective) {\n          activeDirective.$$addStateInfo(ref.state, params);\n        }\n        if (newHref === null) {\n          nav = false;\n          return false;\n        }\n        attrs.$set(attr, newHref);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(newVal, oldVal) {\n          if (newVal !== params) update(newVal);\n        }, true);\n        params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (isForm) return;\n\n      element.bind(\"click\", function(e) {\n        var button = e.which || e.button;\n        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {\n          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n          var transition = $timeout(function() {\n            $state.go(ref.state, params, options);\n          });\n          e.preventDefault();\n\n          // if the state has no URL, ignore one preventDefault from the <a> directive.\n          var ignorePreventDefaultCount = isAnchor && !newHref ? 1: 0;\n          e.preventDefault = function() {\n            if (ignorePreventDefaultCount-- <= 0)\n              $timeout.cancel(transition);\n          };\n        }\n      });\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {\n      var states = [], activeClass;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        var state = $state.get(newState, stateContext($element));\n\n        states.push({\n          state: state || { name: newState },\n          params: newParams\n        });\n\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      // Update route state\n      function update() {\n        if (anyMatch()) {\n          $element.addClass(activeClass);\n        } else {\n          $element.removeClass(activeClass);\n        }\n      }\n\n      function anyMatch() {\n        for (var i = 0; i < states.length; i++) {\n          if (isMatch(states[i].state, states[i].params)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      function isMatch(state, params) {\n        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {\n          return $state.is(state.name, params);\n        } else {\n          return $state.includes(state.name, params);\n        }\n      }\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state) {\n    return $state.is(state);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state) {\n    return $state.includes(state);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router/release/angular-ui-router.js\n ** module id = 10\n ** module chunks = 1\n **/","(function (root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(['angular'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('angular'));\n  } else {\n    // Browser globals (root is window), we don't register it.\n    factory(root.angular);\n  }\n}(this , function (angular) {\n    'use strict';\n\n    // RequireJS does not pass in Angular to us (will be undefined).\n    // Fallback to window which should mostly be there.\n    angular = (angular && angular.module ) ? angular : window.angular;\n\n    /**\n     * @ngdoc overview\n     * @name ngStorage\n     */\n\n    return angular.module('ngStorage', [])\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$localStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$localStorage', _storageProvider('localStorage'))\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$sessionStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\n    function _storageProvider(storageType) {\n        return function () {\n          var storageKeyPrefix = 'ngStorage-';\n\n          this.setKeyPrefix = function (prefix) {\n            if (typeof prefix !== 'string') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n            }\n            storageKeyPrefix = prefix;\n          };\n\n          var serializer = angular.toJson;\n          var deserializer = angular.fromJson;\n\n          this.setSerializer = function (s) {\n            if (typeof s !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n            }\n\n            serializer = s;\n          };\n\n          this.setDeserializer = function (d) {\n            if (typeof d !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n            }\n\n            deserializer = d;\n          };\n\n          // Note: This is not very elegant at all.\n          this.get = function (key) {\n            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n          };\n\n          // Note: This is not very elegant at all.\n          this.set = function (key, value) {\n            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n          };\n\n          this.$get = [\n              '$rootScope',\n              '$window',\n              '$log',\n              '$timeout',\n\n              function(\n                  $rootScope,\n                  $window,\n                  $log,\n                  $timeout\n              ){\n                function isStorageSupported(storageType) {\n\n                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n                    // that error and allow execution to continue.\n\n                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n                    // when \"Block cookies\": \"Always block\" is turned on\n                    var supported;\n                    try {\n                        supported = $window[storageType];\n                    }\n                    catch (err) {\n                        supported = false;\n                    }\n\n                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n                    // is available, but trying to call .setItem throws an exception below:\n                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n                    if (supported && storageType === 'localStorage') {\n                        var key = '__' + Math.round(Math.random() * 1e7);\n\n                        try {\n                            localStorage.setItem(key, key);\n                            localStorage.removeItem(key);\n                        }\n                        catch (err) {\n                            supported = false;\n                        }\n                    }\n\n                    return supported;\n                }\n\n                // The magic number 10 is used which only works for some keyPrefixes...\n                // See https://github.com/gsklee/ngStorage/issues/137\n                var prefixLength = storageKeyPrefix.length;\n\n                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop}),\n                    $storage = {\n                        $default: function(items) {\n                            for (var k in items) {\n                                angular.isDefined($storage[k]) || ($storage[k] = items[k]);\n                            }\n\n                            $storage.$sync();\n                            return $storage;\n                        },\n                        $reset: function(items) {\n                            for (var k in $storage) {\n                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n                            }\n\n                            return $storage.$default(items);\n                        },\n                        $sync: function () {\n                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n                            }\n                        },\n                        $apply: function() {\n                            var temp$storage;\n\n                            _debounce = null;\n\n                            if (!angular.equals($storage, _last$storage)) {\n                                temp$storage = angular.copy(_last$storage);\n                                angular.forEach($storage, function(v, k) {\n                                    if (angular.isDefined(v) && '$' !== k[0]) {\n                                        webStorage.setItem(storageKeyPrefix + k, serializer(v))\n                                        delete temp$storage[k];\n                                    }\n                                });\n\n                                for (var k in temp$storage) {\n                                    webStorage.removeItem(storageKeyPrefix + k);\n                                }\n\n                                _last$storage = angular.copy($storage);\n                            }\n                        },\n                    },\n                    _last$storage,\n                    _debounce;\n\n                $storage.$sync();\n\n                _last$storage = angular.copy($storage);\n\n                $rootScope.$watch(function() {\n                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n                });\n\n                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n                $window.addEventListener && $window.addEventListener('storage', function(event) {\n                    if (storageKeyPrefix === event.key.slice(0, prefixLength)) {\n                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\n                        _last$storage = angular.copy($storage);\n\n                        $rootScope.$apply();\n                    }\n                });\n\n                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n                    $storage.$apply();\n                });\n\n                return $storage;\n            }\n        ];\n      };\n    }\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngstorage/ngStorage.js\n ** module id = 11\n ** module chunks = 1\n **/","/**\n * oclazyload - Load modules on demand (lazy load) with angularJS\n * @version v1.0.6\n * @link https://github.com/ocombe/ocLazyLoad\n * @license MIT\n * @author Olivier Combe <olivier.combe@gmail.com>\n */\n(function (angular, window) {\n    'use strict';\n\n    var regModules = ['ng', 'oc.lazyLoad'],\n        regInvokes = {},\n        regConfigs = [],\n        modulesToLoad = [],\n        // modules to load from angular.module or other sources\n    realModules = [],\n        // real modules called from angular.module\n    recordDeclarations = [],\n        broadcast = angular.noop,\n        runBlocks = {},\n        justLoaded = [];\n\n    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\n    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n        var modules = {},\n            providers = {\n            $controllerProvider: $controllerProvider,\n            $compileProvider: $compileProvider,\n            $filterProvider: $filterProvider,\n            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n            $injector: $injector,\n            $animateProvider: $animateProvider\n        },\n            debug = false,\n            events = false,\n            moduleCache = [],\n            modulePromises = {};\n\n        moduleCache.push = function (value) {\n            if (this.indexOf(value) === -1) {\n                Array.prototype.push.apply(this, arguments);\n            }\n        };\n\n        this.config = function (config) {\n            // If we want to define modules configs\n            if (angular.isDefined(config.modules)) {\n                if (angular.isArray(config.modules)) {\n                    angular.forEach(config.modules, function (moduleConfig) {\n                        modules[moduleConfig.name] = moduleConfig;\n                    });\n                } else {\n                    modules[config.modules.name] = config.modules;\n                }\n            }\n\n            if (angular.isDefined(config.debug)) {\n                debug = config.debug;\n            }\n\n            if (angular.isDefined(config.events)) {\n                events = config.events;\n            }\n        };\n\n        /**\r\n         * Get the list of existing registered modules\r\n         * @param element\r\n         */\n        this._init = function _init(element) {\n            // this is probably useless now because we override angular.bootstrap\n            if (modulesToLoad.length === 0) {\n                var elements = [element],\n                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n                    append = function append(elm) {\n                    return elm && elements.push(elm);\n                };\n\n                angular.forEach(names, function (name) {\n                    names[name] = true;\n                    append(document.getElementById(name));\n                    name = name.replace(':', '\\\\:');\n                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n                    }\n                });\n\n                angular.forEach(elements, function (elm) {\n                    if (modulesToLoad.length === 0) {\n                        var className = ' ' + element.className + ' ';\n                        var match = NG_APP_CLASS_REGEXP.exec(className);\n                        if (match) {\n                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n                        } else {\n                            angular.forEach(elm.attributes, function (attr) {\n                                if (modulesToLoad.length === 0 && names[attr.name]) {\n                                    modulesToLoad.push(attr.value);\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n\n            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n            }\n\n            var addReg = function addReg(moduleName) {\n                if (regModules.indexOf(moduleName) === -1) {\n                    // register existing modules\n                    regModules.push(moduleName);\n                    var mainModule = angular.module(moduleName);\n\n                    // register existing components (directives, services, ...)\n                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\n                    angular.forEach(mainModule.requires, addReg);\n                }\n            };\n\n            angular.forEach(modulesToLoad, function (moduleName) {\n                addReg(moduleName);\n            });\n\n            modulesToLoad = []; // reset for next bootstrap\n            recordDeclarations.pop(); // wait for the next lazy load\n        };\n\n        /**\r\n         * Like JSON.stringify but that doesn't throw on circular references\r\n         * @param obj\r\n         */\n        var stringify = function stringify(obj) {\n            try {\n                return JSON.stringify(obj);\n            } catch (e) {\n                var cache = [];\n                return JSON.stringify(obj, function (key, value) {\n                    if (angular.isObject(value) && value !== null) {\n                        if (cache.indexOf(value) !== -1) {\n                            // Circular reference found, discard key\n                            return;\n                        }\n                        // Store value in our collection\n                        cache.push(value);\n                    }\n                    return value;\n                });\n            }\n        };\n\n        var hashCode = function hashCode(str) {\n            var hash = 0,\n                i,\n                chr,\n                len;\n            if (str.length == 0) {\n                return hash;\n            }\n            for (i = 0, len = str.length; i < len; i++) {\n                chr = str.charCodeAt(i);\n                hash = (hash << 5) - hash + chr;\n                hash |= 0; // Convert to 32bit integer\n            }\n            return hash;\n        };\n\n        function _register(providers, registerModules, params) {\n            if (registerModules) {\n                var k,\n                    moduleName,\n                    moduleFn,\n                    tempRunBlocks = [];\n                for (k = registerModules.length - 1; k >= 0; k--) {\n                    moduleName = registerModules[k];\n                    if (!angular.isString(moduleName)) {\n                        moduleName = getModuleName(moduleName);\n                    }\n                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n                        continue;\n                    }\n                    // new if not registered\n                    var newModule = regModules.indexOf(moduleName) === -1;\n                    moduleFn = ngModuleFct(moduleName);\n                    if (newModule) {\n                        regModules.push(moduleName);\n                        _register(providers, moduleFn.requires, params);\n                    }\n                    if (moduleFn._runBlocks.length > 0) {\n                        // new run blocks detected! Replace the old ones (if existing)\n                        runBlocks[moduleName] = [];\n                        while (moduleFn._runBlocks.length > 0) {\n                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n                        }\n                    }\n                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n                    }\n                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n                    registerModules.pop();\n                    justLoaded.push(moduleName);\n                }\n                // execute the run blocks at the end\n                var instanceInjector = providers.getInstanceInjector();\n                angular.forEach(tempRunBlocks, function (fn) {\n                    instanceInjector.invoke(fn);\n                });\n            }\n        }\n\n        function _registerInvokeList(args, moduleName) {\n            var invokeList = args[2][0],\n                type = args[1],\n                newInvoke = false;\n            if (angular.isUndefined(regInvokes[moduleName])) {\n                regInvokes[moduleName] = {};\n            }\n            if (angular.isUndefined(regInvokes[moduleName][type])) {\n                regInvokes[moduleName][type] = {};\n            }\n            var onInvoke = function onInvoke(invokeName, invoke) {\n                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n                    regInvokes[moduleName][type][invokeName] = [];\n                }\n                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n                    newInvoke = true;\n                    regInvokes[moduleName][type][invokeName].push(invoke);\n                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n                }\n            };\n\n            function checkHashes(potentialNew, invokes) {\n                var isNew = true,\n                    newHash;\n                if (invokes.length) {\n                    newHash = signature(potentialNew);\n                    angular.forEach(invokes, function (invoke) {\n                        isNew = isNew && signature(invoke) !== newHash;\n                    });\n                }\n                return isNew;\n            }\n\n            function signature(data) {\n                if (angular.isArray(data)) {\n                    // arrays are objects, we need to test for it first\n                    return hashCode(data.toString());\n                } else if (angular.isObject(data)) {\n                    // constants & values for example\n                    return hashCode(stringify(data));\n                } else {\n                    if (angular.isDefined(data) && data !== null) {\n                        return hashCode(data.toString());\n                    } else {\n                        // null & undefined constants\n                        return data;\n                    }\n                }\n            }\n\n            if (angular.isString(invokeList)) {\n                onInvoke(invokeList, args[2][1]);\n            } else if (angular.isObject(invokeList)) {\n                angular.forEach(invokeList, function (invoke, key) {\n                    if (angular.isString(invoke)) {\n                        // decorators for example\n                        onInvoke(invoke, invokeList[1]);\n                    } else {\n                        // components registered as object lists {\"componentName\": function() {}}\n                        onInvoke(key, invoke);\n                    }\n                });\n            } else {\n                return false;\n            }\n            return newInvoke;\n        }\n\n        function _invokeQueue(providers, queue, moduleName, reconfig) {\n            if (!queue) {\n                return;\n            }\n\n            var i, len, args, provider;\n            for (i = 0, len = queue.length; i < len; i++) {\n                args = queue[i];\n                if (angular.isArray(args)) {\n                    if (providers !== null) {\n                        if (providers.hasOwnProperty(args[0])) {\n                            provider = providers[args[0]];\n                        } else {\n                            throw new Error('unsupported provider ' + args[0]);\n                        }\n                    }\n                    var isNew = _registerInvokeList(args, moduleName);\n                    if (args[1] !== 'invoke') {\n                        if (isNew && angular.isDefined(provider)) {\n                            provider[args[1]].apply(provider, args[2]);\n                        }\n                    } else {\n                        // config block\n                        var callInvoke = function callInvoke(fct) {\n                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n                            if (invoked === -1 || reconfig) {\n                                if (invoked === -1) {\n                                    regConfigs.push(moduleName + '-' + fct);\n                                }\n                                if (angular.isDefined(provider)) {\n                                    provider[args[1]].apply(provider, args[2]);\n                                }\n                            }\n                        };\n                        if (angular.isFunction(args[2][0])) {\n                            callInvoke(args[2][0]);\n                        } else if (angular.isArray(args[2][0])) {\n                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n                                if (angular.isFunction(args[2][0][j])) {\n                                    callInvoke(args[2][0][j]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function getModuleName(module) {\n            var moduleName = null;\n            if (angular.isString(module)) {\n                moduleName = module;\n            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n                moduleName = module.name;\n            }\n            return moduleName;\n        }\n\n        function moduleExists(moduleName) {\n            if (!angular.isString(moduleName)) {\n                return false;\n            }\n            try {\n                return ngModuleFct(moduleName);\n            } catch (e) {\n                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                    return false;\n                }\n            }\n        }\n\n        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n            var instanceInjector,\n                filesCache = $cacheFactory('ocLazyLoad');\n\n            if (!debug) {\n                $log = {};\n                $log['error'] = angular.noop;\n                $log['warn'] = angular.noop;\n                $log['info'] = angular.noop;\n            }\n\n            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n            providers.getInstanceInjector = function () {\n                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n            };\n\n            broadcast = function broadcast(eventName, params) {\n                if (events) {\n                    $rootScope.$broadcast(eventName, params);\n                }\n                if (debug) {\n                    $log.info(eventName, params);\n                }\n            };\n\n            function reject(e) {\n                var deferred = $q.defer();\n                $log.error(e.message);\n                deferred.reject(e);\n                return deferred.promise;\n            }\n\n            return {\n                _broadcast: broadcast,\n\n                _$log: $log,\n\n                /**\r\n                 * Returns the files cache used by the loaders to store the files currently loading\r\n                 * @returns {*}\r\n                 */\n                _getFilesCache: function getFilesCache() {\n                    return filesCache;\n                },\n\n                /**\r\n                 * Let the service know that it should monitor angular.module because files are loading\r\n                 * @param watch boolean\r\n                 */\n                toggleWatch: function toggleWatch(watch) {\n                    if (watch) {\n                        recordDeclarations.push(true);\n                    } else {\n                        recordDeclarations.pop();\n                    }\n                },\n\n                /**\r\n                 * Let you get a module config object\r\n                 * @param moduleName String the name of the module\r\n                 * @returns {*}\r\n                 */\n                getModuleConfig: function getModuleConfig(moduleName) {\n                    if (!angular.isString(moduleName)) {\n                        throw new Error('You need to give the name of the module to get');\n                    }\n                    if (!modules[moduleName]) {\n                        return null;\n                    }\n                    return angular.copy(modules[moduleName]);\n                },\n\n                /**\r\n                 * Let you define a module config object\r\n                 * @param moduleConfig Object the module config object\r\n                 * @returns {*}\r\n                 */\n                setModuleConfig: function setModuleConfig(moduleConfig) {\n                    if (!angular.isObject(moduleConfig)) {\n                        throw new Error('You need to give the module config object to set');\n                    }\n                    modules[moduleConfig.name] = moduleConfig;\n                    return moduleConfig;\n                },\n\n                /**\r\n                 * Returns the list of loaded modules\r\n                 * @returns {string[]}\r\n                 */\n                getModules: function getModules() {\n                    return regModules;\n                },\n\n                /**\r\n                 * Let you check if a module has been loaded into Angular or not\r\n                 * @param modulesNames String/Object a module name, or a list of module names\r\n                 * @returns {boolean}\r\n                 */\n                isLoaded: function isLoaded(modulesNames) {\n                    var moduleLoaded = function moduleLoaded(module) {\n                        var isLoaded = regModules.indexOf(module) > -1;\n                        if (!isLoaded) {\n                            isLoaded = !!moduleExists(module);\n                        }\n                        return isLoaded;\n                    };\n                    if (angular.isString(modulesNames)) {\n                        modulesNames = [modulesNames];\n                    }\n                    if (angular.isArray(modulesNames)) {\n                        var i, len;\n                        for (i = 0, len = modulesNames.length; i < len; i++) {\n                            if (!moduleLoaded(modulesNames[i])) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    } else {\n                        throw new Error('You need to define the module(s) name(s)');\n                    }\n                },\n\n                /**\r\n                 * Given a module, return its name\r\n                 * @param module\r\n                 * @returns {String}\r\n                 */\n                _getModuleName: getModuleName,\n\n                /**\r\n                 * Returns a module if it exists\r\n                 * @param moduleName\r\n                 * @returns {module}\r\n                 */\n                _getModule: function getModule(moduleName) {\n                    try {\n                        return ngModuleFct(moduleName);\n                    } catch (e) {\n                        // this error message really suxx\n                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n                        }\n                        throw e;\n                    }\n                },\n\n                /**\r\n                 * Check if a module exists and returns it if it does\r\n                 * @param moduleName\r\n                 * @returns {boolean}\r\n                 */\n                moduleExists: moduleExists,\n\n                /**\r\n                 * Load the dependencies, and might try to load new files depending on the config\r\n                 * @param moduleName (String or Array of Strings)\r\n                 * @param localParams\r\n                 * @returns {*}\r\n                 * @private\r\n                 */\n                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n                    var loadedModule,\n                        requires,\n                        diff,\n                        promisesList = [],\n                        self = this;\n\n                    moduleName = self._getModuleName(moduleName);\n\n                    if (moduleName === null) {\n                        return $q.when();\n                    } else {\n                        try {\n                            loadedModule = self._getModule(moduleName);\n                        } catch (e) {\n                            return reject(e);\n                        }\n                        // get unloaded requires\n                        requires = self.getRequires(loadedModule);\n                    }\n\n                    angular.forEach(requires, function (requireEntry) {\n                        // If no configuration is provided, try and find one from a previous load.\n                        // If there isn't one, bail and let the normal flow run\n                        if (angular.isString(requireEntry)) {\n                            var config = self.getModuleConfig(requireEntry);\n                            if (config === null) {\n                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n                                return;\n                            }\n                            requireEntry = config;\n                            // ignore the name because it's probably not a real module name\n                            config.name = undefined;\n                        }\n\n                        // Check if this dependency has been loaded previously\n                        if (self.moduleExists(requireEntry.name)) {\n                            // compare against the already loaded module to see if the new definition adds any new files\n                            diff = requireEntry.files.filter(function (n) {\n                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n                            });\n\n                            // If the module was redefined, advise via the console\n                            if (diff.length !== 0) {\n                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n                            }\n\n                            // Push everything to the file loader, it will weed out the duplicates.\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                            return;\n                        } else if (angular.isArray(requireEntry)) {\n                            var files = [];\n                            angular.forEach(requireEntry, function (entry) {\n                                // let's check if the entry is a file name or a config name\n                                var config = self.getModuleConfig(entry);\n                                if (config === null) {\n                                    files.push(entry);\n                                } else if (config.files) {\n                                    files = files.concat(config.files);\n                                }\n                            });\n                            if (files.length > 0) {\n                                requireEntry = {\n                                    files: files\n                                };\n                            }\n                        } else if (angular.isObject(requireEntry)) {\n                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n                                self.setModuleConfig(requireEntry);\n                                moduleCache.push(requireEntry['name']);\n                            }\n                        }\n\n                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                        }\n                    });\n\n                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n                    return $q.all(promisesList);\n                },\n\n                /**\r\n                 * Inject new modules into Angular\r\n                 * @param moduleName\r\n                 * @param localParams\r\n                 * @param real\r\n                 */\n                inject: function inject(moduleName) {\n                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n                    var self = this,\n                        deferred = $q.defer();\n                    if (angular.isDefined(moduleName) && moduleName !== null) {\n                        if (angular.isArray(moduleName)) {\n                            var promisesList = [];\n                            angular.forEach(moduleName, function (module) {\n                                promisesList.push(self.inject(moduleName, localParams, real));\n                            });\n                            return $q.all(promisesList);\n                        } else {\n                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n                        }\n                    }\n                    if (modulesToLoad.length > 0) {\n                        var res = modulesToLoad.slice(); // clean copy\n                        var loadNext = function loadNext(moduleName) {\n                            moduleCache.push(moduleName);\n                            modulePromises[moduleName] = deferred.promise;\n                            self._loadDependencies(moduleName, localParams).then(function success() {\n                                try {\n                                    justLoaded = [];\n                                    _register(providers, moduleCache, localParams);\n                                } catch (e) {\n                                    self._$log.error(e.message);\n                                    deferred.reject(e);\n                                    return;\n                                }\n\n                                if (modulesToLoad.length > 0) {\n                                    loadNext(modulesToLoad.shift()); // load the next in list\n                                } else {\n                                        deferred.resolve(res); // everything has been loaded, resolve\n                                    }\n                            }, function error(err) {\n                                deferred.reject(err);\n                            });\n                        };\n\n                        // load the first in list\n                        loadNext(modulesToLoad.shift());\n                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n                        return modulePromises[localParams.name];\n                    } else {\n                        deferred.resolve();\n                    }\n                    return deferred.promise;\n                },\n\n                /**\r\n                 * Get the list of required modules/services/... for this module\r\n                 * @param module\r\n                 * @returns {Array}\r\n                 */\n                getRequires: function getRequires(module) {\n                    var requires = [];\n                    angular.forEach(module.requires, function (requireModule) {\n                        if (regModules.indexOf(requireModule) === -1) {\n                            requires.push(requireModule);\n                        }\n                    });\n                    return requires;\n                },\n\n                /**\r\n                 * Invoke the new modules & component by their providers\r\n                 * @param providers\r\n                 * @param queue\r\n                 * @param moduleName\r\n                 * @param reconfig\r\n                 * @private\r\n                 */\n                _invokeQueue: _invokeQueue,\n\n                /**\r\n                 * Check if a module has been invoked and registers it if not\r\n                 * @param args\r\n                 * @param moduleName\r\n                 * @returns {boolean} is new\r\n                 */\n                _registerInvokeList: _registerInvokeList,\n\n                /**\r\n                 * Register a new module and loads it, executing the run/config blocks if needed\r\n                 * @param providers\r\n                 * @param registerModules\r\n                 * @param params\r\n                 * @private\r\n                 */\n                _register: _register,\n\n                /**\r\n                 * Add a module name to the list of modules that will be loaded in the next inject\r\n                 * @param name\r\n                 * @param force\r\n                 * @private\r\n                 */\n                _addToLoadList: _addToLoadList\n            };\n        }];\n\n        // Let's get the list of loaded modules & components\n        this._init(angular.element(window.document));\n    }]);\n\n    var bootstrapFct = angular.bootstrap;\n    angular.bootstrap = function (element, modules, config) {\n        // we use slice to make a clean copy\n        angular.forEach(modules.slice(), function (module) {\n            _addToLoadList(module, true, true);\n        });\n        return bootstrapFct(element, modules, config);\n    };\n\n    var _addToLoadList = function _addToLoadList(name, force, real) {\n        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n            modulesToLoad.push(name);\n            if (real) {\n                realModules.push(name);\n            }\n        }\n    };\n\n    var ngModuleFct = angular.module;\n    angular.module = function (name, requires, configFn) {\n        _addToLoadList(name, false, true);\n        return ngModuleFct(name, requires, configFn);\n    };\n\n    // CommonJS package manager support:\n    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n        module.exports = 'oc.lazyLoad';\n    }\n})(angular, window);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", function ($ocLazyLoad, $compile, $animate, $parse) {\n        return {\n            restrict: 'A',\n            terminal: true,\n            priority: 1000,\n            compile: function compile(element, attrs) {\n                // we store the content and remove it before compilation\n                var content = element.contents();\n                element.html('');\n\n                return function ($scope, $element, $attr) {\n                    var model = $parse($attr.ocLazyLoad);\n                    $scope.$watch(function () {\n                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n                    }, function (moduleName) {\n                        if (angular.isDefined(moduleName)) {\n                            $ocLazyLoad.load(moduleName).then(function () {\n                                $animate.enter($compile(content)($scope), $element);\n                            });\n                        }\n                    }, true);\n                };\n            }\n        };\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n            var uaCssChecked = false,\n                useCssLoadPatch = false,\n                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\n            /**\r\n             * Load a js/css file\r\n             * @param type\r\n             * @param path\r\n             * @param params\r\n             * @returns promise\r\n             */\n            $delegate.buildElement = function buildElement(type, path, params) {\n                var deferred = $q.defer(),\n                    el,\n                    loaded,\n                    filesCache = $delegate._getFilesCache(),\n                    cacheBuster = function cacheBuster(url) {\n                    var dc = new Date().getTime();\n                    if (url.indexOf('?') >= 0) {\n                        if (url.substring(0, url.length - 1) === '&') {\n                            return url + '_dc=' + dc;\n                        }\n                        return url + '&_dc=' + dc;\n                    } else {\n                        return url + '?_dc=' + dc;\n                    }\n                };\n\n                // Store the promise early so the file load can be detected by other parallel lazy loads\n                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n                // as it causes false positive load results.\n                if (angular.isUndefined(filesCache.get(path))) {\n                    filesCache.put(path, deferred.promise);\n                }\n\n                // Switch in case more content types are added later\n                switch (type) {\n                    case 'css':\n                        el = $window.document.createElement('link');\n                        el.type = 'text/css';\n                        el.rel = 'stylesheet';\n                        el.href = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    case 'js':\n                        el = $window.document.createElement('script');\n                        el.src = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    default:\n                        filesCache.remove(path);\n                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n                        break;\n                }\n                el.onload = el['onreadystatechange'] = function (e) {\n                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n                    el.onload = el['onreadystatechange'] = null;\n                    loaded = 1;\n                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n                    deferred.resolve();\n                };\n                el.onerror = function () {\n                    filesCache.remove(path);\n                    deferred.reject(new Error('Unable to load ' + path));\n                };\n                el.async = params.serie ? 0 : 1;\n\n                var insertBeforeElem = anchor.lastChild;\n                if (params.insertBefore) {\n                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n                    if (element && element.length > 0) {\n                        insertBeforeElem = element[0];\n                    }\n                }\n                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\n                /*\r\n                 The event load or readystatechange doesn't fire in:\r\n                 - iOS < 6       (default mobile browser)\r\n                 - Android < 4.4 (default mobile browser)\r\n                 - Safari < 6    (desktop browser)\r\n                 */\n                if (type == 'css') {\n                    if (!uaCssChecked) {\n                        var ua = $window.navigator.userAgent.toLowerCase();\n\n                        // iOS < 6\n                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n                            useCssLoadPatch = iOSVersion < 6;\n                        } else if (ua.indexOf(\"android\") > -1) {\n                            // Android < 4.4\n                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n                            useCssLoadPatch = androidVersion < 4.4;\n                        } else if (ua.indexOf('safari') > -1) {\n                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n                        }\n                    }\n\n                    if (useCssLoadPatch) {\n                        var tries = 1000; // * 20 = 20000 miliseconds\n                        var interval = $interval(function () {\n                            try {\n                                el.sheet.cssRules;\n                                $interval.cancel(interval);\n                                el.onload();\n                            } catch (e) {\n                                if (--tries <= 0) {\n                                    el.onerror();\n                                }\n                            }\n                        }, 20);\n                    }\n                }\n\n                return deferred.promise;\n            };\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\r\n             * The function that loads new files\r\n             * @param config\r\n             * @param params\r\n             * @returns {*}\r\n             */\n            $delegate.filesLoader = function filesLoader(config) {\n                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var cssFiles = [],\n                    templatesFiles = [],\n                    jsFiles = [],\n                    promises = [],\n                    cachePromise = null,\n                    filesCache = $delegate._getFilesCache();\n\n                $delegate.toggleWatch(true); // start watching angular.module calls\n\n                angular.extend(params, config);\n\n                var pushFile = function pushFile(path) {\n                    var file_type = null,\n                        m;\n                    if (angular.isObject(path)) {\n                        file_type = path.type;\n                        path = path.path;\n                    }\n                    cachePromise = filesCache.get(path);\n                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\n                        // always check for requirejs syntax just in case\n                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n                            // Detect file type using preceding type declaration (ala requireJS)\n                            file_type = m[1];\n                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n                        }\n\n                        if (!file_type) {\n                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n                                // Detect file type via file extension\n                                file_type = m[1];\n                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('load')) {\n                                // requirejs\n                                file_type = 'js';\n                            } else {\n                                $delegate._$log.error('File type could not be determined. ' + path);\n                                return;\n                            }\n                        }\n\n                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n                            cssFiles.push(path);\n                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n                            templatesFiles.push(path);\n                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n                            jsFiles.push(path);\n                        } else {\n                            $delegate._$log.error('File type is not valid. ' + path);\n                        }\n                    } else if (cachePromise) {\n                        promises.push(cachePromise);\n                    }\n                };\n\n                if (params.serie) {\n                    pushFile(params.files.shift());\n                } else {\n                    angular.forEach(params.files, function (path) {\n                        pushFile(path);\n                    });\n                }\n\n                if (cssFiles.length > 0) {\n                    var cssDeferred = $q.defer();\n                    $delegate.cssLoader(cssFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            cssDeferred.reject(err);\n                        } else {\n                            cssDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(cssDeferred.promise);\n                }\n\n                if (templatesFiles.length > 0) {\n                    var templatesDeferred = $q.defer();\n                    $delegate.templatesLoader(templatesFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            templatesDeferred.reject(err);\n                        } else {\n                            templatesDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(templatesDeferred.promise);\n                }\n\n                if (jsFiles.length > 0) {\n                    var jsDeferred = $q.defer();\n                    $delegate.jsLoader(jsFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            jsDeferred.reject(err);\n                        } else {\n                            jsDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(jsDeferred.promise);\n                }\n\n                if (promises.length === 0) {\n                    var deferred = $q.defer(),\n                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n                    $delegate._$log.error(err);\n                    deferred.reject(err);\n                    return deferred.promise;\n                } else if (params.serie && params.files.length > 0) {\n                    return $q.all(promises).then(function () {\n                        return $delegate.filesLoader(config, params);\n                    });\n                } else {\n                    return $q.all(promises)['finally'](function (res) {\n                        $delegate.toggleWatch(false); // stop watching angular.module calls\n                        return res;\n                    });\n                }\n            };\n\n            /**\r\n             * Load a module or a list of modules into Angular\r\n             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n             * @param params Object optional parameters\r\n             * @returns promise\r\n             */\n            $delegate.load = function (originalModule) {\n                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var self = this,\n                    config = null,\n                    deferredList = [],\n                    deferred = $q.defer(),\n                    errText;\n\n                // clean copy\n                var module = angular.copy(originalModule);\n                var params = angular.copy(originalParams);\n\n                // If module is an array, break it down\n                if (angular.isArray(module)) {\n                    // Resubmit each entry as a single module\n                    angular.forEach(module, function (m) {\n                        deferredList.push(self.load(m, params));\n                    });\n\n                    // Resolve the promise once everything has loaded\n                    $q.all(deferredList).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n\n                    return deferred.promise;\n                }\n\n                // Get or Set a configuration depending on what was passed in\n                if (angular.isString(module)) {\n                    config = self.getModuleConfig(module);\n                    if (!config) {\n                        config = {\n                            files: [module]\n                        };\n                    }\n                } else if (angular.isObject(module)) {\n                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n                        config = {\n                            files: [module]\n                        };\n                    } else {\n                        config = self.setModuleConfig(module);\n                    }\n                }\n\n                if (config === null) {\n                    var moduleName = self._getModuleName(module);\n                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n                    $delegate._$log.error(errText);\n                    deferred.reject(new Error(errText));\n                    return deferred.promise;\n                } else {\n                    // deprecated\n                    if (angular.isDefined(config.template)) {\n                        if (angular.isUndefined(config.files)) {\n                            config.files = [];\n                        }\n                        if (angular.isString(config.template)) {\n                            config.files.push(config.template);\n                        } else if (angular.isArray(config.template)) {\n                            config.files.concat(config.template);\n                        }\n                    }\n                }\n\n                var localParams = angular.extend({}, params, config);\n\n                // if someone used an external loader and called the load function with just the module name\n                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n                    return $delegate.inject(config.name, localParams, true);\n                }\n\n                $delegate.filesLoader(config, localParams).then(function () {\n                    $delegate.inject(null, localParams).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n                }, function (err) {\n                    deferred.reject(err);\n                });\n\n                return deferred.promise;\n            };\n\n            // return the patched service\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * cssLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite cssLoader and it will probably not use promises :(\n             */\n            $delegate.cssLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('css', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.cssLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * jsLoader function\n             * @type Function\n             * @param paths array list of js files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite jsLoader and it will probably not use promises :(\n             */\n            $delegate.jsLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('js', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.jsLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n            /**\n             * templatesLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters for $http\n             * because the user can overwrite templatesLoader and it will probably not use promises :(\n             */\n            $delegate.templatesLoader = function (paths, callback, params) {\n                var promises = [],\n                    filesCache = $delegate._getFilesCache();\n\n                angular.forEach(paths, function (url) {\n                    var deferred = $q.defer();\n                    promises.push(deferred.promise);\n                    $http.get(url, params).success(function (data) {\n                        if (angular.isString(data) && data.length > 0) {\n                            angular.forEach(angular.element(data), function (node) {\n                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n                                    $templateCache.put(node.id, node.innerHTML);\n                                }\n                            });\n                        }\n                        if (angular.isUndefined(filesCache.get(url))) {\n                            filesCache.put(url, true);\n                        }\n                        deferred.resolve();\n                    }).error(function (err) {\n                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n                    });\n                });\n                return $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n// Array.indexOf polyfill for IE8\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement, fromIndex) {\n        var k;\n\n        // 1. Let O be the result of calling ToObject passing\n        //    the this value as the argument.\n        if (this == null) {\n            throw new TypeError('\"this\" is null or not defined');\n        }\n\n        var O = Object(this);\n\n        // 2. Let lenValue be the result of calling the Get\n        //    internal method of O with the argument \"length\".\n        // 3. Let len be ToUint32(lenValue).\n        var len = O.length >>> 0;\n\n        // 4. If len is 0, return -1.\n        if (len === 0) {\n            return -1;\n        }\n\n        // 5. If argument fromIndex was passed let n be\n        //    ToInteger(fromIndex); else let n be 0.\n        var n = +fromIndex || 0;\n\n        if (Math.abs(n) === Infinity) {\n            n = 0;\n        }\n\n        // 6. If n >= len, return -1.\n        if (n >= len) {\n            return -1;\n        }\n\n        // 7. If n >= 0, then Let k be n.\n        // 8. Else, n<0, Let k be len - abs(n).\n        //    If k is less than 0, then let k be 0.\n        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n        // 9. Repeat, while k < len\n        while (k < len) {\n            // a. Let Pk be ToString(k).\n            //   This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the\n            //    HasProperty internal method of O with argument Pk.\n            //   This step can be combined with c\n            // c. If kPresent is true, then\n            //    i.  Let elementK be the result of calling the Get\n            //        internal method of O with the argument ToString(k).\n            //   ii.  Let same be the result of applying the\n            //        Strict Equality Comparison Algorithm to\n            //        searchElement and elementK.\n            //  iii.  If same is true, return k.\n            if (k in O && O[k] === searchElement) {\n                return k;\n            }\n            k++;\n        }\n        return -1;\n    };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/oclazyload/dist/ocLazyLoad.js\n ** module id = 12\n ** module chunks = 1\n **/","/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 0.14.3 - 2015-10-23\n * License: MIT\n */\nangular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module(\"ui.bootstrap.tpls\", [\"template/accordion/accordion-group.html\",\"template/accordion/accordion.html\",\"template/alert/alert.html\",\"template/carousel/carousel.html\",\"template/carousel/slide.html\",\"template/datepicker/datepicker.html\",\"template/datepicker/day.html\",\"template/datepicker/month.html\",\"template/datepicker/popup.html\",\"template/datepicker/year.html\",\"template/modal/backdrop.html\",\"template/modal/window.html\",\"template/pagination/pager.html\",\"template/pagination/pagination.html\",\"template/tooltip/tooltip-html-popup.html\",\"template/tooltip/tooltip-popup.html\",\"template/tooltip/tooltip-template-popup.html\",\"template/popover/popover-html.html\",\"template/popover/popover-template.html\",\"template/popover/popover.html\",\"template/progressbar/bar.html\",\"template/progressbar/progress.html\",\"template/progressbar/progressbar.html\",\"template/rating/rating.html\",\"template/tabs/tab.html\",\"template/tabs/tabset.html\",\"template/timepicker/timepicker.html\",\"template/typeahead/typeahead-match.html\",\"template/typeahead/typeahead-popup.html\"]);\nangular.module('ui.bootstrap.collapse', [])\n\n  .directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        function expand() {\n          element.removeClass('collapse')\n            .addClass('collapsing')\n            .attr('aria-expanded', true)\n            .attr('aria-hidden', false);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              addClass: 'in',\n              easing: 'ease',\n              to: { height: element[0].scrollHeight + 'px' }\n            }).start().finally(expandDone);\n          } else {\n            $animate.addClass(element, 'in', {\n              to: { height: element[0].scrollHeight + 'px' }\n            }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse')\n            .css({height: 'auto'});\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          element\n            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n            // Otherwise, the browser attempts to animate from height 0 (in\n            // collapsing class) to the given height here.\n            .css({height: element[0].scrollHeight + 'px'})\n            // initially all panel collapse have the collapse class, this removal\n            // prevents the animation from jumping to collapsed state\n            .removeClass('collapse')\n            .addClass('collapsing')\n            .attr('aria-expanded', false)\n            .attr('aria-hidden', true);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              removeClass: 'in',\n              to: {height: '0'}\n            }).start().finally(collapseDone);\n          } else {\n            $animate.removeClass(element, 'in', {\n              to: {height: '0'}\n            }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n        }\n\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\n/* Deprecated collapse below */\n\nangular.module('ui.bootstrap.collapse')\n\n  .value('$collapseSuppressWarning', false)\n\n  .directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        if (!$collapseSuppressWarning) {\n          $log.warn('collapse is now deprecated. Use uib-collapse instead.');\n        }\n\n        function expand() {\n          element.removeClass('collapse')\n            .addClass('collapsing')\n            .attr('aria-expanded', true)\n            .attr('aria-hidden', false);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              easing: 'ease',\n              to: { height: element[0].scrollHeight + 'px' }\n            }).start().done(expandDone);\n          } else {\n            $animate.animate(element, {}, {\n              height: element[0].scrollHeight + 'px'\n            }).then(expandDone);\n          }\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse in')\n            .css({height: 'auto'});\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          element\n            // IMPORTANT: The height must be set before adding \"collapsing\" class.\n            // Otherwise, the browser attempts to animate from height 0 (in\n            // collapsing class) to the given height here.\n            .css({height: element[0].scrollHeight + 'px'})\n            // initially all panel collapse have the collapse class, this removal\n            // prevents the animation from jumping to collapsed state\n            .removeClass('collapse in')\n            .addClass('collapsing')\n            .attr('aria-expanded', false)\n            .attr('aria-hidden', true);\n\n          if ($animateCss) {\n            $animateCss(element, {\n              to: {height: '0'}\n            }).start().done(collapseDone);\n          } else {\n            $animate.animate(element, {}, {\n              height: '0'\n            }).then(collapseDone);\n          }\n        }\n\n        function collapseDone() {\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n        }\n\n        scope.$watch(attrs.collapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\n.constant('uibAccordionConfig', {\n  closeOthers: true\n})\n\n.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if (closeOthers) {\n      angular.forEach(this.groups, function(group) {\n        if (group !== openGroup) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function(event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if (index !== -1) {\n      this.groups.splice(index, 1);\n    }\n  };\n\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('uibAccordion', function() {\n  return {\n    controller: 'UibAccordionController',\n    controllerAs: 'accordion',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/accordion/accordion.html';\n    }\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('uibAccordionGroup', function() {\n  return {\n    require: '^uibAccordion',         // We need this directive to be inside an accordion\n    transclude: true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/accordion/accordion-group.html';\n    },\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      accordionCtrl.addGroup(scope);\n\n      scope.openClass = attrs.openClass || 'panel-open';\n      scope.panelClass = attrs.panelClass;\n      scope.$watch('isOpen', function(value) {\n        element.toggleClass(scope.openClass, !!value);\n        if (value) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function($event) {\n        if (!scope.isDisabled) {\n          if (!$event || $event.which === 32) {\n            scope.isOpen = !scope.isOpen;\n          }\n        }\n      };\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n.directive('uibAccordionHeading', function() {\n  return {\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n.directive('uibAccordionTransclude', function() {\n  return {\n    require: ['?^uibAccordionGroup', '?^accordionGroup'],\n    link: function(scope, element, attrs, controller) {\n      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n        if (heading) {\n          element.find('span').html('');\n          element.find('span').append(heading);\n        }\n      });\n    }\n  };\n});\n\n/* Deprecated accordion below */\n\nangular.module('ui.bootstrap.accordion')\n\n  .value('$accordionSuppressWarning', false)\n\n  .controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {\n    if (!$accordionSuppressWarning) {\n      $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');\n    }\n\n    angular.extend(this, $controller('UibAccordionController', {\n      $scope: $scope,\n      $attrs: $attrs\n    }));\n  }])\n\n  .directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      restrict: 'EA',\n      controller: 'AccordionController',\n      controllerAs: 'accordion',\n      transclude: true,\n      replace: false,\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || 'template/accordion/accordion.html';\n      },\n      link: function() {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion is now deprecated. Use uib-accordion instead.');\n        }\n      }\n    };\n  }])\n\n  .directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      require: '^accordion',         // We need this directive to be inside an accordion\n      restrict: 'EA',\n      transclude: true,              // It transcludes the contents of the directive into the template\n      replace: true,                // The element containing the directive will be replaced with the template\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || 'template/accordion/accordion-group.html';\n      },\n      scope: {\n        heading: '@',               // Interpolate the heading attribute onto this scope\n        isOpen: '=?',\n        isDisabled: '=?'\n      },\n      controller: function() {\n        this.setHeading = function(element) {\n          this.heading = element;\n        };\n      },\n      link: function(scope, element, attrs, accordionCtrl) {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');\n        }\n\n        accordionCtrl.addGroup(scope);\n\n        scope.openClass = attrs.openClass || 'panel-open';\n        scope.panelClass = attrs.panelClass;\n        scope.$watch('isOpen', function(value) {\n          element.toggleClass(scope.openClass, !!value);\n          if (value) {\n            accordionCtrl.closeOthers(scope);\n          }\n        });\n\n        scope.toggleOpen = function($event) {\n          if (!scope.isDisabled) {\n            if (!$event || $event.which === 32) {\n              scope.isOpen = !scope.isOpen;\n            }\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      restrict: 'EA',\n      transclude: true,   // Grab the contents to be used as the heading\n      template: '',       // In effect remove this element!\n      replace: true,\n      require: '^accordionGroup',\n      link: function(scope, element, attr, accordionGroupCtrl, transclude) {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');\n        }\n        // Pass the heading to the accordion-group controller\n        // so that it can be transcluded into the right place in the template\n        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n      }\n    };\n  }])\n\n  .directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {\n    return {\n      require: '^accordionGroup',\n      link: function(scope, element, attr, controller) {\n        if (!$accordionSuppressWarning) {\n          $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');\n        }\n\n        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {\n          if (heading) {\n            element.find('span').html('');\n            element.find('span').append(heading);\n          }\n        });\n      }\n    };\n  }]);\n\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n  $scope.closeable = !!$attrs.close;\n\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\n  if (dismissOnTimeout) {\n    $timeout(function() {\n      $scope.close();\n    }, parseInt(dismissOnTimeout, 10));\n  }\n}])\n\n.directive('uibAlert', function() {\n  return {\n    controller: 'UibAlertController',\n    controllerAs: 'alert',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/alert/alert.html';\n    },\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@',\n      close: '&'\n    }\n  };\n});\n\n/* Deprecated alert below */\n\nangular.module('ui.bootstrap.alert')\n\n  .value('$alertSuppressWarning', false)\n\n  .controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {\n    if (!$alertSuppressWarning) {\n      $log.warn('AlertController is now deprecated. Use UibAlertController instead.');\n    }\n\n    angular.extend(this, $controller('UibAlertController', {\n      $scope: $scope,\n      $attrs: $attrs\n    }));\n  }])\n\n  .directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {\n    return {\n      controller: 'AlertController',\n      controllerAs: 'alert',\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || 'template/alert/alert.html';\n      },\n      transclude: true,\n      replace: true,\n      scope: {\n        type: '@',\n        close: '&'\n      },\n      link: function() {\n        if (!$alertSuppressWarning) {\n          $log.warn('alert is now deprecated. Use uib-alert instead.');\n        }\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('uibButtonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('uibBtnRadio', function() {\n  return {\n    require: ['uibBtnRadio', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'buttons',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n    }\n  };\n})\n\n.directive('uibBtnCheckbox', function() {\n  return {\n    require: ['uibBtnCheckbox', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'button',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attribute, defaultValue) {\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        scope.$apply(function() {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\n/* Deprecated buttons below */\n\nangular.module('ui.bootstrap.buttons')\n\n  .value('$buttonsSuppressWarning', false)\n\n  .controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {\n    if (!$buttonsSuppressWarning) {\n      $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');\n    }\n\n    angular.extend(this, $controller('UibButtonsController'));\n  }])\n\n  .directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {\n    return {\n      require: ['btnRadio', 'ngModel'],\n      controller: 'ButtonsController',\n      controllerAs: 'buttons',\n      link: function(scope, element, attrs, ctrls) {\n        if (!$buttonsSuppressWarning) {\n          $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');\n        }\n\n        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        element.find('input').css({display: 'none'});\n\n        //model -> UI\n        ngModelCtrl.$render = function() {\n          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));\n        };\n\n        //ui->model\n        element.bind(buttonsCtrl.toggleEvent, function() {\n          if (attrs.disabled) {\n            return;\n          }\n\n          var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n          if (!isActive || angular.isDefined(attrs.uncheckable)) {\n            scope.$apply(function() {\n              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));\n              ngModelCtrl.$render();\n            });\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {\n    return {\n      require: ['btnCheckbox', 'ngModel'],\n      controller: 'ButtonsController',\n      controllerAs: 'button',\n      link: function(scope, element, attrs, ctrls) {\n        if (!$buttonsSuppressWarning) {\n          $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');\n        }\n\n        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        element.find('input').css({display: 'none'});\n\n        function getTrueValue() {\n          return getCheckboxValue(attrs.btnCheckboxTrue, true);\n        }\n\n        function getFalseValue() {\n          return getCheckboxValue(attrs.btnCheckboxFalse, false);\n        }\n\n        function getCheckboxValue(attributeValue, defaultValue) {\n          var val = scope.$eval(attributeValue);\n          return angular.isDefined(val) ? val : defaultValue;\n        }\n\n        //model -> UI\n        ngModelCtrl.$render = function() {\n          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n        };\n\n        //ui->model\n        element.bind(buttonsCtrl.toggleEvent, function() {\n          if (attrs.disabled) {\n            return;\n          }\n\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n            ngModelCtrl.$render();\n          });\n        });\n\n        //accessibility\n        element.on('keypress', function(e) {\n          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {\n            return;\n          }\n\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n            ngModelCtrl.$render();\n          });\n        });\n      }\n    };\n  }]);\n\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.carousel\n *\n * @description\n * AngularJS version of an image carousel.\n *\n */\nangular.module('ui.bootstrap.carousel', [])\n\n.controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    NEW_ANIMATE = angular.version.minor >= 4,\n    NO_TRANSITION = 'uib-noTransition',\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    currentIndex = -1,\n    currentInterval, isPlaying;\n  self.currentSlide = null;\n\n  var destroyed = false;\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = $scope.indexOfSlide(nextSlide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n    }\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {\n      goNext(nextSlide, nextIndex, direction);\n    }\n  };\n\n  function goNext(slide, index, direction) {\n    // Scope has been destroyed, stop here.\n    if (destroyed) { return; }\n\n    angular.extend(slide, {direction: direction, active: true});\n    angular.extend(self.currentSlide || {}, {direction: direction, active: false});\n    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&\n      slide.$element && self.slides.length > 1) {\n      slide.$element.data(SLIDE_DIRECTION, slide.direction);\n      if (self.currentSlide && self.currentSlide.$element) {\n        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);\n      }\n\n      $scope.$currentTransition = true;\n      if (NEW_ANIMATE) {\n        $animate.on('addClass', slide.$element, function(element, phase) {\n          if (phase === 'close') {\n            $scope.$currentTransition = null;\n            $animate.off('addClass', element);\n          }\n        });\n      } else {\n        slide.$element.one('$animate:close', function closeFn() {\n          $scope.$currentTransition = null;\n        });\n      }\n    }\n\n    self.currentSlide = slide;\n    currentIndex = index;\n\n    //every time you change slides, reset the timer\n    restartTimer();\n  }\n\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n\n  function getSlideByIndex(index) {\n    if (angular.isUndefined(slides[index].index)) {\n      return slides[index];\n    }\n    var i, len = slides.length;\n    for (i = 0; i < slides.length; ++i) {\n      if (slides[i].index == index) {\n        return slides[i];\n      }\n    }\n  }\n\n  self.getCurrentIndex = function() {\n    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {\n      return +self.currentSlide.index;\n    }\n    return currentIndex;\n  };\n\n  /* Allow outside people to call indexOf on slides array */\n  $scope.indexOfSlide = function(slide) {\n    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);\n  };\n\n  $scope.next = function() {\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\n    if (newIndex === 0 && $scope.noWrap()) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), 'next');\n  };\n\n  $scope.prev = function() {\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(getSlideByIndex(newIndex), 'prev');\n  };\n\n  $scope.isActive = function(slide) {\n     return self.currentSlide === slide;\n  };\n\n  $scope.$watch('interval', restartTimer);\n  $scope.$watchCollection('slides', resetTransition);\n  $scope.$on('$destroy', resetTimer);\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval > 0) {\n      currentInterval = $interval(timerFn, interval);\n    }\n  }\n\n  function resetTimer() {\n    if (currentInterval) {\n      $interval.cancel(currentInterval);\n      currentInterval = null;\n    }\n  }\n\n  function timerFn() {\n    var interval = +$scope.interval;\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n      $scope.next();\n    } else {\n      $scope.pause();\n    }\n  }\n\n  function resetTransition(slides) {\n    if (!slides.length) {\n      $scope.$currentTransition = null;\n    }\n  }\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  self.addSlide = function(slide, element) {\n    slide.$element = element;\n    slides.push(slide);\n    //if this is the first slide or the slide is set to active, select it\n    if (slides.length === 1 || slide.active) {\n      self.select(slides[slides.length - 1]);\n      if (slides.length === 1) {\n        $scope.play();\n      }\n    } else {\n      slide.active = false;\n    }\n  };\n\n  self.removeSlide = function(slide) {\n    if (angular.isDefined(slide.index)) {\n      slides.sort(function(a, b) {\n        return +a.index > +b.index;\n      });\n    }\n    //get the index of the slide inside the carousel\n    var index = slides.indexOf(slide);\n    slides.splice(index, 1);\n    if (slides.length > 0 && slide.active) {\n      if (index >= slides.length) {\n        self.select(slides[index - 1]);\n      } else {\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n    }\n\n    //clean the currentSlide when no more slide\n    if (slides.length === 0) {\n      self.currentSlide = null;\n    }\n  };\n\n  $scope.$watch('noTransition', function(noTransition) {\n    $element.data(NO_TRANSITION, noTransition);\n  });\n\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:carousel\n * @restrict EA\n *\n * @description\n * Carousel is the outer container for a set of image 'slides' to showcase.\n *\n * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.\n * @param {boolean=} noTransition Whether to disable transitions on the carousel.\n * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <uib-carousel>\n      <uib-slide>\n        <img src=\"http://placekitten.com/150/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>Beautiful!</p>\n        </div>\n      </uib-slide>\n      <uib-slide>\n        <img src=\"http://placekitten.com/100/150\" style=\"margin:auto;\">\n        <div class=\"carousel-caption\">\n          <p>D'aww!</p>\n        </div>\n      </uib-slide>\n    </uib-carousel>\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n */\n.directive('uibCarousel', [function() {\n  return {\n    transclude: true,\n    replace: true,\n    controller: 'UibCarouselController',\n    controllerAs: 'carousel',\n    require: 'carousel',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/carousel.html';\n    },\n    scope: {\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    }\n  };\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.carousel.directive:slide\n * @restrict EA\n *\n * @description\n * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.\n *\n * @param {boolean=} active Model binding, whether or not this slide is currently active.\n * @param {number=} index The index of the slide. The slides will be sorted by this parameter.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n<div ng-controller=\"CarouselDemoCtrl\">\n  <uib-carousel>\n    <uib-slide ng-repeat=\"slide in slides\" active=\"slide.active\" index=\"$index\">\n      <img ng-src=\"{{slide.image}}\" style=\"margin:auto;\">\n      <div class=\"carousel-caption\">\n        <h4>Slide {{$index}}</h4>\n        <p>{{slide.text}}</p>\n      </div>\n    </uib-slide>\n  </uib-carousel>\n  Interval, in milliseconds: <input type=\"number\" ng-model=\"myInterval\">\n  <br />Enter a negative number to stop the interval.\n</div>\n  </file>\n  <file name=\"script.js\">\nfunction CarouselDemoCtrl($scope) {\n  $scope.myInterval = 5000;\n}\n  </file>\n  <file name=\"demo.css\">\n    .carousel-indicators {\n      top: auto;\n      bottom: 15px;\n    }\n  </file>\n</example>\n*/\n\n.directive('uibSlide', function() {\n  return {\n    require: '^uibCarousel',\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/slide.html';\n    },\n    scope: {\n      active: '=?',\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n})\n\n.animation('.item', [\n         '$injector', '$animate',\nfunction ($injector, $animate) {\n  var NO_TRANSITION = 'uib-noTransition',\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    $animateCss = null;\n\n  if ($injector.has('$animateCss')) {\n    $animateCss = $injector.get('$animateCss');\n  }\n\n  function removeClass(element, className, callback) {\n    element.removeClass(className);\n    if (callback) {\n      callback();\n    }\n  }\n\n  return {\n    beforeAddClass: function(element, className, done) {\n      // Due to transclusion, noTransition property is on parent's scope\n      if (className == 'active' && element.parent() && element.parent().parent() &&\n          !element.parent().parent().data(NO_TRANSITION)) {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction == 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element,\n          directionClass + ' ' + direction, done);\n        element.addClass(direction);\n\n        if ($animateCss) {\n          $animateCss(element, {addClass: directionClass})\n            .start()\n            .done(removeClassFn);\n        } else {\n          $animate.addClass(element, directionClass).then(function () {\n            if (!stopped) {\n              removeClassFn();\n            }\n            done();\n          });\n        }\n\n        return function () {\n          stopped = true;\n        };\n      }\n      done();\n    },\n    beforeRemoveClass: function (element, className, done) {\n      // Due to transclusion, noTransition property is on parent's scope\n      if (className === 'active' && element.parent() && element.parent().parent() &&\n          !element.parent().parent().data(NO_TRANSITION)) {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction == 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\n        if ($animateCss) {\n          $animateCss(element, {addClass: directionClass})\n            .start()\n            .done(removeClassFn);\n        } else {\n          $animate.addClass(element, directionClass).then(function() {\n            if (!stopped) {\n              removeClassFn();\n            }\n            done();\n          });\n        }\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    }\n  };\n}]);\n\n/* deprecated carousel below */\n\nangular.module('ui.bootstrap.carousel')\n\n.value('$carouselSuppressWarning', false)\n\n.controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {\n  if (!$carouselSuppressWarning) {\n    $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');\n  }\n\n  angular.extend(this, $controller('UibCarouselController', {\n    $scope: $scope,\n    $element: $element\n  }));\n}])\n\n.directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n  return {\n    transclude: true,\n    replace: true,\n    controller: 'CarouselController',\n    controllerAs: 'carousel',\n    require: 'carousel',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/carousel.html';\n    },\n    scope: {\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    },\n    link: function() {\n      if (!$carouselSuppressWarning) {\n        $log.warn('carousel is now deprecated. Use uib-carousel instead.');\n      }\n    }\n  };\n}])\n\n.directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {\n  return {\n    require: '^carousel',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/carousel/slide.html';\n    },\n    scope: {\n      active: '=?',\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      if (!$carouselSuppressWarning) {\n        $log.warn('slide is now deprecated. Use uib-slide instead.');\n      }\n\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        if (active) {\n          carouselCtrl.select(scope);\n        }\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  var localeId;\n  var formatCodeToRegex;\n\n  this.init = function() {\n    localeId = $locale.id;\n\n    this.parsers = {};\n\n    formatCodeToRegex = {\n      'yyyy': {\n        regex: '\\\\d{4}',\n        apply: function(value) { this.year = +value; }\n      },\n      'yy': {\n        regex: '\\\\d{2}',\n        apply: function(value) { this.year = +value + 2000; }\n      },\n      'y': {\n        regex: '\\\\d{1,4}',\n        apply: function(value) { this.year = +value; }\n      },\n      'MMMM': {\n        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }\n      },\n      'MMM': {\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }\n      },\n      'MM': {\n        regex: '0[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; }\n      },\n      'M': {\n        regex: '[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; }\n      },\n      'dd': {\n        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; }\n      },\n      'd': {\n        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; }\n      },\n      'EEEE': {\n        regex: $locale.DATETIME_FORMATS.DAY.join('|')\n      },\n      'EEE': {\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')\n      },\n      'HH': {\n        regex: '(?:0|1)[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'hh': {\n        regex: '0[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'H': {\n        regex: '1?[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'h': {\n        regex: '[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; }\n      },\n      'mm': {\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.minutes = +value; }\n      },\n      'm': {\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.minutes = +value; }\n      },\n      'sss': {\n        regex: '[0-9][0-9][0-9]',\n        apply: function(value) { this.milliseconds = +value; }\n      },\n      'ss': {\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.seconds = +value; }\n      },\n      's': {\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.seconds = +value; }\n      },\n      'a': {\n        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n        apply: function(value) {\n          if (this.hours === 12) {\n            this.hours = 0;\n          }\n\n          if (value === 'PM') {\n            this.hours += 12;\n          }\n        }\n      }\n    };\n  };\n\n  this.init();\n\n  function createParser(format) {\n    var map = [], regex = format.split('');\n\n    angular.forEach(formatCodeToRegex, function(data, code) {\n      var index = format.indexOf(code);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + code.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({ index: index, apply: data.apply });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  this.parse = function(input, format, baseDate) {\n    if (!angular.isString(input) || !format) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.parsers[format]) {\n      this.parsers[format] = createParser(format);\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex);\n\n    if (results && results.length) {\n      var fields, dt;\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n        fields = {\n          year: baseDate.getFullYear(),\n          month: baseDate.getMonth(),\n          date: baseDate.getDate(),\n          hours: baseDate.getHours(),\n          minutes: baseDate.getMinutes(),\n          seconds: baseDate.getSeconds(),\n          milliseconds: baseDate.getMilliseconds()\n        };\n      } else {\n        if (baseDate) {\n          $log.warn('dateparser:', 'baseDate is not a valid date');\n        }\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n      }\n\n      for (var i = 1, n = results.length; i < n; i++) {\n        var mapper = map[i-1];\n        if (mapper.apply) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      if (isValid(fields.year, fields.month, fields.date)) {\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n          dt = new Date(baseDate);\n          dt.setFullYear(fields.year, fields.month, fields.date,\n            fields.hours, fields.minutes, fields.seconds,\n            fields.milliseconds || 0);\n        } else {\n          dt = new Date(fields.year, fields.month, fields.date,\n            fields.hours, fields.minutes, fields.seconds,\n            fields.milliseconds || 0);\n        }\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if (date < 1) {\n      return false;\n    }\n\n    if (month === 1 && date > 28) {\n      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);\n    }\n\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\n      return date < 31;\n    }\n\n    return true;\n  }\n}]);\n\n/* Deprecated dateparser below */\n\nangular.module('ui.bootstrap.dateparser')\n\n.value('$dateParserSuppressWarning', false)\n\n.service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {\n  if (!$dateParserSuppressWarning) {\n    $log.warn('dateParser is now deprecated. Use uibDateParser instead.');\n  }\n\n  angular.extend(this, uibDateParser);\n}]);\n\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n    function getStyle(el, cssprop) {\n      if (el.currentStyle) { //IE\n        return el.currentStyle[cssprop];\n      } else if ($window.getComputedStyle) {\n        return $window.getComputedStyle(el)[cssprop];\n      }\n      // finally try and get inline style\n      return el.style[cssprop];\n    }\n\n    /**\n     * Checks if a given element is statically positioned\n     * @param element - raw DOM element\n     */\n    function isStaticPositioned(element) {\n      return (getStyle(element, 'position') || 'static' ) === 'static';\n    }\n\n    /**\n     * returns the closest, non-statically positioned parentOffset of a given element\n     * @param element\n     */\n    var parentOffsetEl = function(element) {\n      var docDomEl = $document[0];\n      var offsetParent = element.offsetParent || docDomEl;\n      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docDomEl;\n    };\n\n    return {\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/\n       */\n      position: function(element) {\n        var elBCR = this.offset(element);\n        var offsetParentBCR = { top: 0, left: 0 };\n        var offsetParentEl = parentOffsetEl(element[0]);\n        if (offsetParentEl != $document[0]) {\n          offsetParentBCR = this.offset(angular.element(offsetParentEl));\n          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n        }\n\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: elBCR.top - offsetParentBCR.top,\n          left: elBCR.left - offsetParentBCR.left\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/\n       */\n      offset: function(element) {\n        var boundingClientRect = element[0].getBoundingClientRect();\n        return {\n          width: boundingClientRect.width || element.prop('offsetWidth'),\n          height: boundingClientRect.height || element.prop('offsetHeight'),\n          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n        };\n      },\n\n      /**\n       * Provides coordinates for the targetEl in relation to hostEl\n       */\n      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {\n        var positionStrParts = positionStr.split('-');\n        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\n        var hostElPos,\n          targetElWidth,\n          targetElHeight,\n          targetElPos;\n\n        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n\n        targetElWidth = targetEl.prop('offsetWidth');\n        targetElHeight = targetEl.prop('offsetHeight');\n\n        var shiftWidth = {\n          center: function() {\n            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n          },\n          left: function() {\n            return hostElPos.left;\n          },\n          right: function() {\n            return hostElPos.left + hostElPos.width;\n          }\n        };\n\n        var shiftHeight = {\n          center: function() {\n            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n          },\n          top: function() {\n            return hostElPos.top;\n          },\n          bottom: function() {\n            return hostElPos.top + hostElPos.height;\n          }\n        };\n\n        switch (pos0) {\n          case 'right':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: shiftWidth[pos0]()\n            };\n            break;\n          case 'left':\n            targetElPos = {\n              top: shiftHeight[pos1](),\n              left: hostElPos.left - targetElWidth\n            };\n            break;\n          case 'bottom':\n            targetElPos = {\n              top: shiftHeight[pos0](),\n              left: shiftWidth[pos1]()\n            };\n            break;\n          default:\n            targetElPos = {\n              top: hostElPos.top - targetElHeight,\n              left: shiftWidth[pos1]()\n            };\n            break;\n        }\n\n        return targetElPos;\n      }\n    };\n  }]);\n\n/* Deprecated position below */\n\nangular.module('ui.bootstrap.position')\n\n.value('$positionSuppressWarning', false)\n\n.service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {\n  if (!$positionSuppressWarning) {\n    $log.warn('$position is now deprecated. Use $uibPosition instead.');\n  }\n\n  angular.extend(this, $uibPosition);\n}]);\n\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])\n\n.value('$datepickerSuppressError', false)\n\n.constant('uibDatepickerConfig', {\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  datepickerMode: 'day',\n  minMode: 'day',\n  maxMode: 'year',\n  showWeeks: true,\n  startingDay: 0,\n  yearRange: 20,\n  minDate: null,\n  maxDate: null,\n  shortcutPropagation: false\n})\n\n.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  // Configuration attributes\n  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  // Watchable date attributes\n  angular.forEach(['minDate', 'maxDate'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  angular.forEach(['minMode', 'maxMode'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = angular.isDefined(value) ? value : $attrs[key];\n        $scope[key] = self[key];\n        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n          $scope.datepickerMode = self[key];\n        }\n      });\n    } else {\n      self[key] = datepickerConfig[key] || null;\n      $scope[key] = self[key];\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  if (angular.isDefined($attrs.initDate)) {\n    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n        self.activeDate = initDate;\n        self.refreshView();\n      }\n    });\n  } else {\n    this.activeDate = new Date();\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n          isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = date;\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date)\n    };\n  };\n\n  this.isDisabled = function(date) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  this.step = { months: 1 };\n  this.element = $element;\n  function getDaysInMonth(year, month) {\n    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];\n  }\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    scope.showWeeks = ctrl.showWeeks;\n    ctrl.refreshView();\n  };\n\n  this.getDates = function(startDate, n) {\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n    while (i < n) {\n      date = new Date(current);\n      dates[i++] = date;\n      current.setDate(current.getDate() + 1);\n    }\n    return dates;\n  };\n\n  this._refreshView = function() {\n    var year = this.activeDate.getFullYear(),\n      month = this.activeDate.getMonth(),\n      firstDayOfMonth = new Date(this.activeDate);\n\n    firstDayOfMonth.setFullYear(year, month, 1);\n\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\n      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,\n      firstDate = new Date(firstDayOfMonth);\n\n    if (numDisplayedFromPreviousMonth > 0) {\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n    }\n\n    // 42 is the number of days on a six-month calendar\n    var days = this.getDates(firstDate, 42);\n    for (var i = 0; i < 42; i ++) {\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n        secondary: days[i].getMonth() !== month,\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.labels = new Array(7);\n    for (var j = 0; j < 7; j++) {\n      scope.labels[j] = {\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\n        full: dateFilter(days[j].date, 'EEEE')\n      };\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n    scope.rows = this.split(days, 7);\n\n    if (scope.showWeeks) {\n      scope.weekNumbers = [];\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n          numWeeks = scope.rows.length;\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n        scope.weekNumbers.push(\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n      }\n    }\n  };\n\n  this.compare = function(date1, date2) {\n    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n  };\n\n  function getISO8601WeekNumber(date) {\n    var checkDate = new Date(date);\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  }\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getDate();\n\n    if (key === 'left') {\n      date = date - 1;   // up\n    } else if (key === 'up') {\n      date = date - 7;   // down\n    } else if (key === 'right') {\n      date = date + 1;   // down\n    } else if (key === 'down') {\n      date = date + 7;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setMonth(month, 1);\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n    } else if (key === 'home') {\n      date = 1;\n    } else if (key === 'end') {\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n    }\n    this.activeDate.setDate(date);\n  };\n}])\n\n.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  this.step = { years: 1 };\n  this.element = $element;\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    ctrl.refreshView();\n  };\n\n  this._refreshView = function() {\n    var months = new Array(12),\n        year = this.activeDate.getFullYear(),\n        date;\n\n    for (var i = 0; i < 12; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(year, i, 1);\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n    scope.rows = this.split(months, 3);\n  };\n\n  this.compare = function(date1, date2) {\n    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getMonth();\n\n    if (key === 'left') {\n      date = date - 1;   // up\n    } else if (key === 'up') {\n      date = date - 3;   // down\n    } else if (key === 'right') {\n      date = date + 1;   // down\n    } else if (key === 'down') {\n      date = date + 3;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setFullYear(year);\n    } else if (key === 'home') {\n      date = 0;\n    } else if (key === 'end') {\n      date = 11;\n    }\n    this.activeDate.setMonth(date);\n  };\n}])\n\n.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var range;\n  this.element = $element;\n\n  function getStartingYear(year) {\n    return parseInt((year - 1) / range, 10) * range + 1;\n  }\n\n  this.yearpickerInit = function() {\n    range = this.yearRange;\n    this.step = { years: range };\n  };\n\n  this._refreshView = function() {\n    var years = new Array(range), date;\n\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(start + i, 0, 1);\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n    scope.rows = this.split(years, 5);\n  };\n\n  this.compare = function(date1, date2) {\n    return date1.getFullYear() - date2.getFullYear();\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getFullYear();\n\n    if (key === 'left') {\n      date = date - 1;   // up\n    } else if (key === 'up') {\n      date = date - 5;   // down\n    } else if (key === 'right') {\n      date = date + 1;   // down\n    } else if (key === 'down') {\n      date = date + 5;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      date += (key === 'pageup' ? - 1 : 1) * this.step.years;\n    } else if (key === 'home') {\n      date = getStartingYear(this.activeDate.getFullYear());\n    } else if (key === 'end') {\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n    }\n    this.activeDate.setFullYear(date);\n  };\n}])\n\n.directive('uibDatepicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerMode: '=?',\n      dateDisabled: '&',\n      customClass: '&',\n      shortcutPropagation: '&?'\n    },\n    require: ['uibDatepicker', '^ngModel'],\n    controller: 'UibDatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n})\n\n.directive('uibDaypicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/day.html';\n    },\n    require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0] || ctrls[2],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibMonthpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/month.html';\n    },\n    require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0] || ctrls[2],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibYearpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/year.html';\n    },\n    require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var ctrl = ctrls[0] || ctrls[2];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n})\n\n.constant('uibDatepickerPopupConfig', {\n  datepickerPopup: 'yyyy-MM-dd',\n  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',\n  datepickerTemplateUrl: 'template/datepicker/datepicker.html',\n  html5Types: {\n    date: 'yyyy-MM-dd',\n    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n    'month': 'yyyy-MM'\n  },\n  currentText: 'Today',\n  clearText: 'Clear',\n  closeText: 'Done',\n  closeOnDateSelection: true,\n  appendToBody: false,\n  showButtonBar: true,\n  onOpenFocus: true\n})\n\n.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout',\nfunction(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {\n  var self = this;\n  var cache = {},\n    isHtml5DateInput = false;\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,\n    ngModel, $popup;\n\n  scope.watchData = {};\n\n  this.init = function(_ngModel_) {\n    ngModel = _ngModel_;\n    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;\n    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;\n    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;\n    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\n    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;\n\n    if (datepickerPopupConfig.html5Types[attrs.type]) {\n      dateFormat = datepickerPopupConfig.html5Types[attrs.type];\n      isHtml5DateInput = true;\n    } else {\n      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n          // Invalidate the $modelValue to ensure that formatters re-run\n          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n          if (newDateFormat !== dateFormat) {\n            dateFormat = newDateFormat;\n            ngModel.$modelValue = null;\n\n            if (!dateFormat) {\n              throw new Error('uibDatepickerPopup must have a date format specified.');\n            }\n          }\n      });\n    }\n\n    if (!dateFormat) {\n      throw new Error('uibDatepickerPopup must have a date format specified.');\n    }\n\n    if (isHtml5DateInput && attrs.datepickerPopup) {\n      throw new Error('HTML5 date input types do not support custom formats.');\n    }\n\n    // popup element used to display calendar\n    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n    popupEl.attr({\n      'ng-model': 'date',\n      'ng-change': 'dateSelection(date)',\n      'template-url': datepickerPopupTemplateUrl\n    });\n\n    // datepicker element\n    datepickerEl = angular.element(popupEl.children()[0]);\n    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\n    if (isHtml5DateInput) {\n      if (attrs.type === 'month') {\n        datepickerEl.attr('datepicker-mode', '\"month\"');\n        datepickerEl.attr('min-mode', 'month');\n      }\n    }\n\n    if (attrs.datepickerOptions) {\n      var options = scope.$parent.$eval(attrs.datepickerOptions);\n      if (options && options.initDate) {\n        scope.initDate = options.initDate;\n        datepickerEl.attr('init-date', 'initDate');\n        delete options.initDate;\n      }\n      angular.forEach(options, function(value, option) {\n        datepickerEl.attr(cameltoDash(option), value);\n      });\n    }\n\n    angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {\n      if (attrs[key]) {\n        var getAttribute = $parse(attrs[key]);\n        scope.$parent.$watch(getAttribute, function(value) {\n          scope.watchData[key] = value;\n          if (key === 'minDate' || key === 'maxDate') {\n            cache[key] = new Date(value);\n          }\n        });\n        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\n        // Propagate changes from datepicker to outside\n        if (key === 'datepickerMode') {\n          var setAttribute = getAttribute.assign;\n          scope.$watch('watchData.' + key, function(value, oldvalue) {\n            if (angular.isFunction(setAttribute) && value !== oldvalue) {\n              setAttribute(scope.$parent, value);\n            }\n          });\n        }\n      }\n    });\n    if (attrs.dateDisabled) {\n      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n    }\n\n    if (attrs.showWeeks) {\n      datepickerEl.attr('show-weeks', attrs.showWeeks);\n    }\n\n    if (attrs.customClass) {\n      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n    }\n\n    if (!isHtml5DateInput) {\n      // Internal API to maintain the correct ng-invalid-[key] class\n      ngModel.$$parserName = 'date';\n      ngModel.$validators.date = validator;\n      ngModel.$parsers.unshift(parseDate);\n      ngModel.$formatters.push(function(value) {\n        scope.date = value;\n        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);\n      });\n    } else {\n      ngModel.$formatters.push(function(value) {\n        scope.date = value;\n        return value;\n      });\n    }\n\n    // Detect changes in the view from the text box\n    ngModel.$viewChangeListeners.push(function() {\n      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);\n    });\n\n    element.bind('keydown', inputKeydownBind);\n\n    $popup = $compile(popupEl)(scope);\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\n    popupEl.remove();\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    scope.$on('$destroy', function() {\n      if (scope.isOpen === true) {\n        if (!$rootScope.$$phase) {\n          scope.$apply(function() {\n            scope.isOpen = false;\n          });\n        }\n      }\n\n      $popup.remove();\n      element.unbind('keydown', inputKeydownBind);\n      $document.unbind('click', documentClickBind);\n    });\n  };\n\n  scope.getText = function(key) {\n    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n  };\n\n  scope.isDisabled = function(date) {\n    if (date === 'today') {\n      date = new Date();\n    }\n\n    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||\n      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));\n  };\n\n  scope.compare = function(date1, date2) {\n    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));\n  };\n\n  // Inner change\n  scope.dateSelection = function(dt) {\n    if (angular.isDefined(dt)) {\n      scope.date = dt;\n    }\n    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n    element.val(date);\n    ngModel.$setViewValue(date);\n\n    if (closeOnDateSelection) {\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.keydown = function(evt) {\n    if (evt.which === 27) {\n      scope.isOpen = false;\n      element[0].focus();\n    }\n  };\n\n  scope.select = function(date) {\n    if (date === 'today') {\n      var today = new Date();\n      if (angular.isDate(scope.date)) {\n        date = new Date(scope.date);\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n      } else {\n        date = new Date(today.setHours(0, 0, 0, 0));\n      }\n    }\n    scope.dateSelection(date);\n  };\n\n  scope.close = function() {\n    scope.isOpen = false;\n    element[0].focus();\n  };\n\n  scope.$watch('isOpen', function(value) {\n    if (value) {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top = scope.position.top + element.prop('offsetHeight');\n\n      $timeout(function() {\n        if (onOpenFocus) {\n          scope.$broadcast('uib:datepicker.focus');\n        }\n        $document.bind('click', documentClickBind);\n      }, 0, false);\n    } else {\n      $document.unbind('click', documentClickBind);\n    }\n  });\n\n  function cameltoDash(string) {\n    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n  }\n\n  function parseDate(viewValue) {\n    if (angular.isNumber(viewValue)) {\n      // presumably timestamp to date object\n      viewValue = new Date(viewValue);\n    }\n\n    if (!viewValue) {\n      return null;\n    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n      return viewValue;\n    } else if (angular.isString(viewValue)) {\n      var date = dateParser.parse(viewValue, dateFormat, scope.date);\n      if (isNaN(date)) {\n        return undefined;\n      } else {\n        return date;\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  function validator(modelValue, viewValue) {\n    var value = modelValue || viewValue;\n\n    if (!attrs.ngRequired && !value) {\n      return true;\n    }\n\n    if (angular.isNumber(value)) {\n      value = new Date(value);\n    }\n    if (!value) {\n      return true;\n    } else if (angular.isDate(value) && !isNaN(value)) {\n      return true;\n    } else if (angular.isString(value)) {\n      var date = dateParser.parse(value, dateFormat);\n      return !isNaN(date);\n    } else {\n      return false;\n    }\n  }\n\n  function documentClickBind(event) {\n    var popup = $popup[0];\n    var dpContainsTarget = element[0].contains(event.target);\n    // The popup node may not be an element node\n    // In some browsers (IE) only element nodes have the 'contains' function\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n    }\n  }\n\n  function inputKeydownBind(evt) {\n    if (evt.which === 27 && scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = false;\n      });\n      element[0].focus();\n    } else if (evt.which === 40 && !scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      scope.$apply(function() {\n        scope.isOpen = true;\n      });\n    }\n  }\n}])\n\n.directive('uibDatepickerPopup', function() {\n  return {\n    require: ['ngModel', 'uibDatepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&',\n      customClass: '&'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n})\n\n.directive('uibDatepickerPopupWrap', function() {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/popup.html';\n    }\n  };\n});\n\n/* Deprecated datepicker below */\n\nangular.module('ui.bootstrap.datepicker')\n\n.value('$datepickerSuppressWarning', false)\n\n.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {\n  if (!$datepickerSuppressWarning) {\n    $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');\n  }\n\n  var self = this,\n    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;\n\n  this.modes = ['day', 'month', 'year'];\n\n  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',\n    'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {\n    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];\n  });\n\n  angular.forEach(['minDate', 'maxDate'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = value ? new Date(value) : null;\n        self.refreshView();\n      });\n    } else {\n      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;\n    }\n  });\n\n  angular.forEach(['minMode', 'maxMode'], function(key) {\n    if ($attrs[key]) {\n      $scope.$parent.$watch($parse($attrs[key]), function(value) {\n        self[key] = angular.isDefined(value) ? value : $attrs[key];\n        $scope[key] = self[key];\n        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {\n          $scope.datepickerMode = self[key];\n        }\n      });\n    } else {\n      self[key] = datepickerConfig[key] || null;\n      $scope[key] = self[key];\n    }\n  });\n\n  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  if (angular.isDefined($attrs.initDate)) {\n    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();\n    $scope.$parent.$watch($attrs.initDate, function(initDate) {\n      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n        self.activeDate = initDate;\n        self.refreshView();\n      }\n    });\n  } else {\n    this.activeDate = new Date();\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n        isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = date;\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      this._refreshView();\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    return {\n      date: date,\n      label: dateFilter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date)\n    };\n  };\n\n  this.isDisabled = function(date) {\n    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  this.fixTimeZone = function(date) {\n    var hours = date.getHours();\n    date.setHours(hours === 23 ? hours + 2 : 0);\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n      month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {\n      return;\n    }\n\n    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n}])\n\n.directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerMode: '=?',\n      dateDisabled: '&',\n      customClass: '&',\n      shortcutPropagation: '&?'\n    },\n    require: ['datepicker', '^ngModel'],\n    controller: 'DatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');\n      }\n\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n}])\n\n.directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: 'template/datepicker/day.html',\n    require: ['^datepicker', 'daypicker'],\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');\n      }\n\n      var datepickerCtrl = ctrls[0],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n}])\n\n.directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: 'template/datepicker/month.html',\n    require: ['^datepicker', 'monthpicker'],\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');\n      }\n\n      var datepickerCtrl = ctrls[0],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n}])\n\n.directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    templateUrl: 'template/datepicker/year.html',\n    require: ['^datepicker', 'yearpicker'],\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');\n      }\n\n      var ctrl = ctrls[0];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n}])\n\n.directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    require: ['ngModel', 'datepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&',\n      customClass: '&'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');\n      }\n\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n}])\n\n.directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/datepicker/popup.html';\n    },\n    link: function() {\n      if (!$datepickerSuppressWarning) {\n        $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\n.constant('uibDropdownConfig', {\n  openClass: 'open'\n})\n\n.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n  var openScope = null;\n\n  this.open = function(dropdownScope) {\n    if (!openScope) {\n      $document.bind('click', closeDropdown);\n      $document.bind('keydown', keybindFilter);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function(dropdownScope) {\n    if (openScope === dropdownScope) {\n      openScope = null;\n      $document.unbind('click', closeDropdown);\n      $document.unbind('keydown', keybindFilter);\n    }\n  };\n\n  var closeDropdown = function(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope) { return; }\n\n    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  var keybindFilter = function(evt) {\n    if (evt.which === 27) {\n      openScope.focusToggleElement();\n      closeDropdown();\n    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      openScope.focusDropdownEntry(evt.which);\n    }\n  };\n}])\n\n.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    keynavEnabled =false,\n    selectedOption = null;\n\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\n    if (appendToBody && self.dropdownMenu) {\n      $document.find('body').append(self.dropdownMenu);\n      $element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      (angular.element(self.dropdownMenu).find('a')) :\n      (angular.element($element).find('ul').eq(0).find('a'));\n\n    switch (keyCode) {\n      case (40): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = (self.selectedOption === elems.length - 1 ?\n            self.selectedOption :\n            self.selectedOption + 1);\n        }\n        break;\n      }\n      case (38): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    if (appendToBody && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n      var css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n        toggleInvoker($scope, { open: !!isOpen });\n      }\n    });\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    if (scope.getAutoClose() !== 'disabled') {\n      scope.isOpen = false;\n    }\n  });\n\n  var offDestroy = $scope.$on('$destroy', function() {\n    scope.$destroy();\n  });\n  scope.$on('$destroy', offDestroy);\n}])\n\n.directive('uibDropdown', function() {\n  return {\n    controller: 'UibDropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init();\n    }\n  };\n})\n\n.directive('uibDropdownMenu', function() {\n  return {\n    restrict: 'AC',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n})\n\n.directive('uibKeyboardNav', function() {\n  return {\n    restrict: 'A',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      element.bind('keydown', function(e) {\n        if ([38, 40].indexOf(e.which) !== -1) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          var elems = dropdownCtrl.dropdownMenu.find('a');\n\n          switch (e.which) {\n            case (40): { // Down\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = 0;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n              }\n              break;\n            }\n            case (38): { // Up\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = elems.length - 1;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n                  0 : dropdownCtrl.selectedOption - 1;\n              }\n              break;\n            }\n          }\n          elems[dropdownCtrl.selectedOption].focus();\n        }\n      });\n    }\n  };\n})\n\n.directive('uibDropdownToggle', function() {\n  return {\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n});\n\n/* Deprecated dropdown below */\n\nangular.module('ui.bootstrap.dropdown')\n\n.value('$dropdownSuppressWarning', false)\n\n.service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {\n  if (!$dropdownSuppressWarning) {\n    $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');\n  }\n\n  angular.extend(this, uibDropdownService);\n}])\n\n.controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {\n  if (!$dropdownSuppressWarning) {\n    $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');\n  }\n\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    keynavEnabled =false,\n    selectedOption = null;\n\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);\n\n    if (appendToBody && self.dropdownMenu) {\n      $document.find('body').append(self.dropdownMenu);\n      $element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      (angular.element(self.dropdownMenu).find('a')) :\n      (angular.element($element).find('ul').eq(0).find('a'));\n\n    switch (keyCode) {\n      case (40): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = (self.selectedOption === elems.length -1 ?\n            self.selectedOption :\n          self.selectedOption + 1);\n        }\n        break;\n      }\n      case (38): {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    if (appendToBody && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);\n      var css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {\n      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n        toggleInvoker($scope, { open: !!isOpen });\n      }\n    });\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    if (scope.getAutoClose() !== 'disabled') {\n      scope.isOpen = false;\n    }\n  });\n\n  var offDestroy = $scope.$on('$destroy', function() {\n    scope.$destroy();\n  });\n  scope.$on('$destroy', offDestroy);\n}])\n\n.directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    controller: 'DropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');\n      }\n\n      dropdownCtrl.init();\n    }\n  };\n}])\n\n.directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    restrict: 'AC',\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      if (!$dropdownSuppressWarning) {\n        $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n}])\n\n.directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    restrict: 'A',\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');\n      }\n\n      element.bind('keydown', function(e) {\n        if ([38, 40].indexOf(e.which) !== -1) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          var elems = dropdownCtrl.dropdownMenu.find('a');\n\n          switch (e.which) {\n            case (40): { // Down\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = 0;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?\n                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;\n              }\n              break;\n            }\n            case (38): { // Up\n              if (!angular.isNumber(dropdownCtrl.selectedOption)) {\n                dropdownCtrl.selectedOption = elems.length - 1;\n              } else {\n                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?\n                  0 : dropdownCtrl.selectedOption - 1;\n              }\n              break;\n            }\n          }\n          elems[dropdownCtrl.selectedOption].focus();\n        }\n      });\n    }\n  };\n}])\n\n.directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {\n  return {\n    require: '?^dropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!$dropdownSuppressWarning) {\n        $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');\n      }\n\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.stackedMap', [])\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function() {\n    return {\n      createNew: function() {\n        var stack = [];\n\n        return {\n          add: function(key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function(key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function() {\n            return stack[stack.length - 1];\n          },\n          remove: function(key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key == stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function() {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function() {\n            return stack.length;\n          }\n        };\n      }\n    };\n  });\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n/**\n * A helper, internal data structure that stores all references attached to key\n */\n  .factory('$$multiMap', function() {\n    return {\n      createNew: function() {\n        var map = {};\n\n        return {\n          entries: function() {\n            return Object.keys(map).map(function(key) {\n              return {\n                key: key,\n                value: map[key]\n              };\n            });\n          },\n          get: function(key) {\n            return map[key];\n          },\n          hasKey: function(key) {\n            return !!map[key];\n          },\n          keys: function() {\n            return Object.keys(map);\n          },\n          put: function(key, value) {\n            if (!map[key]) {\n              map[key] = [];\n            }\n\n            map[key].push(value);\n          },\n          remove: function(key, value) {\n            var values = map[key];\n\n            if (!values) {\n              return;\n            }\n\n            var idx = values.indexOf(value);\n\n            if (idx !== -1) {\n              values.splice(idx, 1);\n            }\n\n            if (!values.length) {\n              delete map[key];\n            }\n          }\n        };\n      }\n    };\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('uibModalBackdrop', [\n           '$animate', '$injector', '$uibModalStack',\n  function($animate ,  $injector,   $modalStack) {\n    var $animateCss = null;\n\n    if ($injector.has('$animateCss')) {\n      $animateCss = $injector.get('$animateCss');\n    }\n\n    return {\n      replace: true,\n      templateUrl: 'template/modal/backdrop.html',\n      compile: function(tElement, tAttrs) {\n        tElement.addClass(tAttrs.backdropClass);\n        return linkFn;\n      }\n    };\n\n    function linkFn(scope, element, attrs) {\n      // Temporary fix for prefixing\n      element.addClass('modal-backdrop');\n\n      if (attrs.modalInClass) {\n        if ($animateCss) {\n          $animateCss(element, {\n            addClass: attrs.modalInClass\n          }).start();\n        } else {\n          $animate.addClass(element, attrs.modalInClass);\n        }\n\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n          var done = setIsAsync();\n          if ($animateCss) {\n            $animateCss(element, {\n              removeClass: attrs.modalInClass\n            }).start().then(done);\n          } else {\n            $animate.removeClass(element, attrs.modalInClass).then(done);\n          }\n        });\n      }\n    }\n  }])\n\n  .directive('uibModalWindow', [\n           '$uibModalStack', '$q', '$animate', '$injector',\n  function($modalStack ,  $q ,  $animate,   $injector) {\n    var $animateCss = null;\n\n    if ($injector.has('$animateCss')) {\n      $animateCss = $injector.get('$animateCss');\n    }\n\n    return {\n      scope: {\n        index: '@'\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'template/modal/window.html';\n      },\n      link: function(scope, element, attrs) {\n        element.addClass(attrs.windowClass || '');\n        element.addClass(attrs.windowTopClass || '');\n        scope.size = attrs.size;\n\n        scope.close = function(evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n\n        // moved from template to fix issue #2280\n        element.on('click', scope.close);\n\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n        // We can detect that by using this property in the template associated with this directive and then use\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n        scope.$isRendered = true;\n\n        // Deferred object that will be resolved when this modal is render.\n        var modalRenderDeferObj = $q.defer();\n        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n        attrs.$observe('modalRender', function(value) {\n          if (value == 'true') {\n            modalRenderDeferObj.resolve();\n          }\n        });\n\n        modalRenderDeferObj.promise.then(function() {\n          var animationPromise = null;\n\n          if (attrs.modalInClass) {\n            if ($animateCss) {\n              animationPromise = $animateCss(element, {\n                addClass: attrs.modalInClass\n              }).start();\n            } else {\n              animationPromise = $animate.addClass(element, attrs.modalInClass);\n            }\n\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n              var done = setIsAsync();\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: attrs.modalInClass\n                }).start().then(done);\n              } else {\n                $animate.removeClass(element, attrs.modalInClass).then(done);\n              }\n            });\n          }\n\n\n          $q.when(animationPromise).then(function() {\n            var inputWithAutofocus = element[0].querySelector('[autofocus]');\n            /**\n             * Auto-focusing of a freshly-opened modal element causes any child elements\n             * with the autofocus attribute to lose focus. This is an issue on touch\n             * based devices which will show and then hide the onscreen keyboard.\n             * Attempts to refocus the autofocus element via JavaScript will not reopen\n             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n             * the modal element if the modal does not contain an autofocus element.\n             */\n            if (inputWithAutofocus) {\n              inputWithAutofocus.focus();\n            } else {\n              element[0].focus();\n            }\n          });\n\n          // Notify {@link $modalStack} that modal is rendered.\n          var modal = $modalStack.getTop();\n          if (modal) {\n            $modalStack.modalRendered(modal.key);\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('uibModalAnimationClass', function() {\n    return {\n      compile: function(tElement, tAttrs) {\n        if (tAttrs.modalAnimation) {\n          tElement.addClass(tAttrs.uibModalAnimationClass);\n        }\n      }\n    };\n  })\n\n  .directive('uibModalTransclude', function() {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  })\n\n  .factory('$uibModalStack', [\n             '$animate', '$timeout', '$document', '$compile', '$rootScope',\n             '$q',\n             '$injector',\n             '$$multiMap',\n             '$$stackedMap',\n    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n              $q,\n              $injector,\n              $$multiMap,\n              $$stackedMap) {\n      var $animateCss = null;\n\n      if ($injector.has('$animateCss')) {\n        $animateCss = $injector.get('$animateCss');\n      }\n\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var openedClasses = $$multiMap.createNew();\n      var $modalStack = {\n        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n      };\n\n      //Modal focus behavior\n      var focusableElementList;\n      var focusIndex = 0;\n      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n        var body = $document.find('body').eq(0);\n        var modalWindow = openedWindows.get(modalInstance).value;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n          openedClasses.remove(modalBodyClass, modalInstance);\n          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n          toggleTopWindowClass(true);\n        });\n        checkRemoveBackdrop();\n\n        //move focus to specified element if available, or else to body\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n          elementToReceiveFocus.focus();\n        } else {\n          body.focus();\n        }\n      }\n\n      // Add or remove \"windowTopClass\" from the top window in the stack\n      function toggleTopWindowClass(toggleSwitch) {\n        var modalWindow;\n\n        if (openedWindows.length() > 0) {\n          modalWindow = openedWindows.top().value;\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n        }\n      }\n\n      function checkRemoveBackdrop() {\n        //remove backdrop if no longer needed\n        if (backdropDomEl && backdropIndex() == -1) {\n          var backdropScopeRef = backdropScope;\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n            backdropScopeRef = null;\n          });\n          backdropDomEl = undefined;\n          backdropScope = undefined;\n        }\n      }\n\n      function removeAfterAnimate(domEl, scope, done) {\n        var asyncDeferred;\n        var asyncPromise = null;\n        var setIsAsync = function() {\n          if (!asyncDeferred) {\n            asyncDeferred = $q.defer();\n            asyncPromise = asyncDeferred.promise;\n          }\n\n          return function asyncDone() {\n            asyncDeferred.resolve();\n          };\n        };\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\n        // Note that it's intentional that asyncPromise might be null.\n        // That's when setIsAsync has not been called during the\n        // NOW_CLOSING_EVENT broadcast.\n        return $q.when(asyncPromise).then(afterAnimating);\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          if ($animateCss) {\n            $animateCss(domEl, {\n              event: 'leave'\n            }).start().then(function() {\n              domEl.remove();\n            });\n          } else {\n            $animate.leave(domEl);\n          }\n          scope.$destroy();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.bind('keydown', function(evt) {\n        if (evt.isDefaultPrevented()) {\n          return evt;\n        }\n\n        var modal = openedWindows.top();\n        if (modal && modal.value.keyboard) {\n          switch (evt.which) {\n            case 27: {\n              evt.preventDefault();\n              $rootScope.$apply(function() {\n                $modalStack.dismiss(modal.key, 'escape key press');\n              });\n              break;\n            }\n            case 9: {\n              $modalStack.loadFocusElementList(modal);\n              var focusChanged = false;\n              if (evt.shiftKey) {\n                if ($modalStack.isFocusInFirstItem(evt)) {\n                  focusChanged = $modalStack.focusLastFocusableElement();\n                }\n              } else {\n                if ($modalStack.isFocusInLastItem(evt)) {\n                  focusChanged = $modalStack.focusFirstFocusableElement();\n                }\n              }\n\n              if (focusChanged) {\n                evt.preventDefault();\n                evt.stopPropagation();\n              }\n              break;\n            }\n          }\n        }\n      });\n\n      $modalStack.open = function(modalInstance, modal) {\n        var modalOpener = $document[0].activeElement,\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\n        toggleTopWindowClass(false);\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          renderDeferred: modal.renderDeferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard,\n          openedClass: modal.openedClass,\n          windowTopClass: modal.windowTopClass\n        });\n\n        openedClasses.put(modalBodyClass, modalInstance);\n\n        var body = $document.find('body').eq(0),\n            currBackdropIndex = backdropIndex();\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.index = currBackdropIndex;\n          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);\n          if (modal.animation) {\n            angularBackgroundDomEl.attr('modal-animation', 'true');\n          }\n          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);\n          body.append(backdropDomEl);\n        }\n\n        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n        angularDomEl.attr({\n          'template-url': modal.windowTemplateUrl,\n          'window-class': modal.windowClass,\n          'window-top-class': modal.windowTopClass,\n          'size': modal.size,\n          'index': openedWindows.length() - 1,\n          'animate': 'animate'\n        }).html(modal.content);\n        if (modal.animation) {\n          angularDomEl.attr('modal-animation', 'true');\n        }\n\n        var modalDomEl = $compile(angularDomEl)(modal.scope);\n        openedWindows.top().value.modalDomEl = modalDomEl;\n        openedWindows.top().value.modalOpener = modalOpener;\n        body.append(modalDomEl);\n        body.addClass(modalBodyClass);\n\n        $modalStack.clearFocusListCache();\n      };\n\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\n        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n      }\n\n      $modalStack.close = function(modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismiss = function(modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismissAll = function(reason) {\n        var topModal = this.getTop();\n        while (topModal && this.dismiss(topModal.key, reason)) {\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function() {\n        return openedWindows.top();\n      };\n\n      $modalStack.modalRendered = function(modalInstance) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.renderDeferred.resolve();\n        }\n      };\n\n      $modalStack.focusFirstFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[0].focus();\n          return true;\n        }\n        return false;\n      };\n      $modalStack.focusLastFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[focusableElementList.length - 1].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInFirstItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) == focusableElementList[0];\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInLastItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];\n        }\n        return false;\n      };\n\n      $modalStack.clearFocusListCache = function() {\n        focusableElementList = [];\n        focusIndex = 0;\n      };\n\n      $modalStack.loadFocusElementList = function(modalWindow) {\n        if (focusableElementList === undefined || !focusableElementList.length) {\n          if (modalWindow) {\n            var modalDomE1 = modalWindow.value.modalDomEl;\n            if (modalDomE1 && modalDomE1.length) {\n              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n            }\n          }\n        }\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$uibModal', function() {\n    var $modalProvider = {\n      options: {\n        animation: true,\n        backdrop: true, //can also be false or 'static'\n        keyboard: true\n      },\n      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log',\n        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);\n          }\n\n          function getResolvePromises(resolves) {\n            var promisesArr = [];\n            angular.forEach(resolves, function(value) {\n              if (angular.isFunction(value) || angular.isArray(value)) {\n                promisesArr.push($q.when($injector.invoke(value)));\n              } else if (angular.isString(value)) {\n                promisesArr.push($q.when($injector.get(value)));\n              } else {\n                promisesArr.push($q.when(value));\n              }\n            });\n            return promisesArr;\n          }\n\n          var promiseChain = null;\n          $modal.getPromiseChain = function() {\n            return promiseChain;\n          };\n\n          $modal.open = function(modalOptions) {\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n            var modalRenderDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              rendered: modalRenderDeferred.promise,\n              close: function (result) {\n                return $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                return $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));\n\n            function resolveWithTemplate() {\n              return templateAndResolvePromise;\n            }\n\n            // Wait for the resolution of the existing promise chain.\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n            // Then add to $modalStack and resolve opened.\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n            var samePromise;\n            samePromise = promiseChain = $q.all([promiseChain])\n              .then(resolveWithTemplate, resolveWithTemplate)\n              .then(function resolveSuccess(tplAndVars) {\n\n                var modalScope = (modalOptions.scope || $rootScope).$new();\n                modalScope.$close = modalInstance.close;\n                modalScope.$dismiss = modalInstance.dismiss;\n\n                modalScope.$on('$destroy', function() {\n                  if (!modalScope.$$uibDestructionScheduled) {\n                    modalScope.$dismiss('$uibUnscheduledDestruction');\n                  }\n                });\n\n                var ctrlInstance, ctrlLocals = {};\n                var resolveIter = 1;\n\n                //controllers\n                if (modalOptions.controller) {\n                  ctrlLocals.$scope = modalScope;\n                  ctrlLocals.$uibModalInstance = modalInstance;\n                  Object.defineProperty(ctrlLocals, '$modalInstance', {\n                    get: function() {\n                      if (!$modalSuppressWarning) {\n                        $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');\n                      }\n\n                      return modalInstance;\n                    }\n                  });\n                  angular.forEach(modalOptions.resolve, function(value, key) {\n                    ctrlLocals[key] = tplAndVars[resolveIter++];\n                  });\n\n                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n                  if (modalOptions.controllerAs) {\n                    if (modalOptions.bindToController) {\n                      angular.extend(ctrlInstance, modalScope);\n                    }\n\n                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n                  }\n                }\n\n                $modalStack.open(modalInstance, {\n                  scope: modalScope,\n                  deferred: modalResultDeferred,\n                  renderDeferred: modalRenderDeferred,\n                  content: tplAndVars[0],\n                  animation: modalOptions.animation,\n                  backdrop: modalOptions.backdrop,\n                  keyboard: modalOptions.keyboard,\n                  backdropClass: modalOptions.backdropClass,\n                  windowTopClass: modalOptions.windowTopClass,\n                  windowClass: modalOptions.windowClass,\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n                  size: modalOptions.size,\n                  openedClass: modalOptions.openedClass\n                });\n                modalOpenedDeferred.resolve(true);\n\n            }, function resolveError(reason) {\n              modalOpenedDeferred.reject(reason);\n              modalResultDeferred.reject(reason);\n            })\n            .finally(function() {\n              if (promiseChain === samePromise) {\n                promiseChain = null;\n              }\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }\n      ]\n    };\n\n    return $modalProvider;\n  });\n\n/* deprecated modal below */\n\nangular.module('ui.bootstrap.modal')\n\n  .value('$modalSuppressWarning', false)\n\n  /**\n   * A helper directive for the $modal service. It creates a backdrop element.\n   */\n  .directive('modalBackdrop', [\n    '$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning',\n    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {\n      var $animateCss = null;\n\n      if ($injector.has('$animateCss')) {\n        $animateCss = $injector.get('$animateCss');\n      }\n\n      return {\n        replace: true,\n        templateUrl: 'template/modal/backdrop.html',\n        compile: function(tElement, tAttrs) {\n          tElement.addClass(tAttrs.backdropClass);\n          return linkFn;\n        }\n      };\n\n      function linkFn(scope, element, attrs) {\n        if (!$modalSuppressWarning) {\n          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');\n        }\n        element.addClass('modal-backdrop');\n\n        if (attrs.modalInClass) {\n          if ($animateCss) {\n            $animateCss(element, {\n              addClass: attrs.modalInClass\n            }).start();\n          } else {\n            $animate.addClass(element, attrs.modalInClass);\n          }\n\n          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n            var done = setIsAsync();\n            if ($animateCss) {\n              $animateCss(element, {\n                removeClass: attrs.modalInClass\n              }).start().then(done);\n            } else {\n              $animate.removeClass(element, attrs.modalInClass).then(done);\n            }\n          });\n        }\n      }\n    }])\n\n  .directive('modalWindow', [\n    '$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning',\n    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {\n      var $animateCss = null;\n\n      if ($injector.has('$animateCss')) {\n        $animateCss = $injector.get('$animateCss');\n      }\n\n      return {\n        scope: {\n          index: '@'\n        },\n        replace: true,\n        transclude: true,\n        templateUrl: function(tElement, tAttrs) {\n          return tAttrs.templateUrl || 'template/modal/window.html';\n        },\n        link: function(scope, element, attrs) {\n          if (!$modalSuppressWarning) {\n            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');\n          }\n          element.addClass(attrs.windowClass || '');\n          element.addClass(attrs.windowTopClass || '');\n          scope.size = attrs.size;\n\n          scope.close = function(evt) {\n            var modal = $modalStack.getTop();\n            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {\n              evt.preventDefault();\n              evt.stopPropagation();\n              $modalStack.dismiss(modal.key, 'backdrop click');\n            }\n          };\n\n          // moved from template to fix issue #2280\n          element.on('click', scope.close);\n\n          // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n          // We can detect that by using this property in the template associated with this directive and then use\n          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n          scope.$isRendered = true;\n\n          // Deferred object that will be resolved when this modal is render.\n          var modalRenderDeferObj = $q.defer();\n          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n          attrs.$observe('modalRender', function(value) {\n            if (value == 'true') {\n              modalRenderDeferObj.resolve();\n            }\n          });\n\n          modalRenderDeferObj.promise.then(function() {\n            var animationPromise = null;\n\n            if (attrs.modalInClass) {\n              if ($animateCss) {\n                animationPromise = $animateCss(element, {\n                  addClass: attrs.modalInClass\n                }).start();\n              } else {\n                animationPromise = $animate.addClass(element, attrs.modalInClass);\n              }\n\n              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n                var done = setIsAsync();\n                if ($animateCss) {\n                  $animateCss(element, {\n                    removeClass: attrs.modalInClass\n                  }).start().then(done);\n                } else {\n                  $animate.removeClass(element, attrs.modalInClass).then(done);\n                }\n              });\n            }\n\n\n            $q.when(animationPromise).then(function() {\n              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n              /**\n               * Auto-focusing of a freshly-opened modal element causes any child elements\n               * with the autofocus attribute to lose focus. This is an issue on touch\n               * based devices which will show and then hide the onscreen keyboard.\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n               * the modal element if the modal does not contain an autofocus element.\n               */\n              if (inputWithAutofocus) {\n                inputWithAutofocus.focus();\n              } else {\n                element[0].focus();\n              }\n            });\n\n            // Notify {@link $modalStack} that modal is rendered.\n            var modal = $modalStack.getTop();\n            if (modal) {\n              $modalStack.modalRendered(modal.key);\n            }\n          });\n        }\n      };\n    }])\n\n  .directive('modalAnimationClass', [\n    '$log', '$modalSuppressWarning',\n    function ($log, $modalSuppressWarning) {\n      return {\n        compile: function(tElement, tAttrs) {\n          if (!$modalSuppressWarning) {\n            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');\n          }\n          if (tAttrs.modalAnimation) {\n            tElement.addClass(tAttrs.modalAnimationClass);\n          }\n        }\n      };\n    }])\n\n  .directive('modalTransclude', [\n    '$log', '$modalSuppressWarning',\n    function ($log, $modalSuppressWarning) {\n    return {\n      link: function($scope, $element, $attrs, controller, $transclude) {\n        if (!$modalSuppressWarning) {\n          $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');\n        }\n        $transclude($scope.$parent, function(clone) {\n          $element.empty();\n          $element.append(clone);\n        });\n      }\n    };\n  }])\n\n  .service('$modalStack', [\n    '$animate', '$timeout', '$document', '$compile', '$rootScope',\n    '$q',\n    '$injector',\n    '$$multiMap',\n    '$$stackedMap',\n    '$uibModalStack',\n    '$log',\n    '$modalSuppressWarning',\n    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,\n             $q,\n             $injector,\n             $$multiMap,\n             $$stackedMap,\n             $uibModalStack,\n             $log,\n             $modalSuppressWarning) {\n      if (!$modalSuppressWarning) {\n        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');\n      }\n\n      angular.extend(this, $uibModalStack);\n    }])\n\n  .provider('$modal', ['$uibModalProvider', function($uibModalProvider) {\n    angular.extend(this, $uibModalProvider);\n\n    this.$get = ['$injector', '$log', '$modalSuppressWarning',\n      function ($injector, $log, $modalSuppressWarning) {\n        if (!$modalSuppressWarning) {\n          $log.warn('$modal is now deprecated. Use $uibModal instead.');\n        }\n\n        return $injector.invoke($uibModalProvider.$get);\n      }];\n  }]);\n\nangular.module('ui.bootstrap.pagination', [])\n.controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n\n    $scope.$watch('totalItems', function() {\n      $scope.totalPages = self.calculateTotalPages();\n    });\n\n    $scope.$watch('totalPages', function(value) {\n      setNumPages($scope.$parent, value); // Readonly variable\n\n      if ( $scope.page > value ) {\n        $scope.selectPage(value);\n      } else {\n        ngModelCtrl.$render();\n      }\n    });\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page, evt) {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    var clickAllowed = !$scope.ngDisabled || !evt;\n    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      if (evt && evt.target) {\n        evt.target.blur();\n      }\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || self.config[key + 'Text'];\n  };\n\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n}])\n\n.constant('uibPaginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true\n})\n\n.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['uibPagination', '?ngModel'],\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pagination.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n        // recompute if maxSize\n        if (isMaxSized) {\n          if (rotate) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if (isMaxSized && ! rotate) {\n          if (startPage > 1) {\n            var previousPageSet = makePage(startPage - 1, '...', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if (endPage < totalPages) {\n            var nextPageSet = makePage(endPage + 1, '...', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.constant('uibPagerConfig', {\n  itemsPerPage: 10,\n  previousText: ' Previous',\n  nextText: 'Next ',\n  align: true\n})\n\n.directive('uibPager', ['uibPagerConfig', function(pagerConfig) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['uibPager', '?ngModel'],\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pager.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/* Deprecated Pagination Below */\n\nangular.module('ui.bootstrap.pagination')\n.value('$paginationSuppressWarning', false)\n.controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {\n  if (!$paginationSuppressWarning) {\n    $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');\n  }\n\n  var self = this,\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n  this.init = function(ngModelCtrl_, config) {\n    ngModelCtrl = ngModelCtrl_;\n    this.config = config;\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n\n    if ($attrs.itemsPerPage) {\n      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {\n        self.itemsPerPage = parseInt(value, 10);\n        $scope.totalPages = self.calculateTotalPages();\n      });\n    } else {\n      this.itemsPerPage = config.itemsPerPage;\n    }\n\n    $scope.$watch('totalItems', function() {\n      $scope.totalPages = self.calculateTotalPages();\n    });\n\n    $scope.$watch('totalPages', function(value) {\n      setNumPages($scope.$parent, value); // Readonly variable\n\n      if ( $scope.page > value ) {\n        $scope.selectPage(value);\n      } else {\n        ngModelCtrl.$render();\n      }\n    });\n  };\n\n  this.calculateTotalPages = function() {\n    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  };\n\n  this.render = function() {\n    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n  };\n\n  $scope.selectPage = function(page, evt) {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    var clickAllowed = !$scope.ngDisabled || !evt;\n    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n      if (evt && evt.target) {\n        evt.target.blur();\n      }\n      ngModelCtrl.$setViewValue(page);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || self.config[key + 'Text'];\n  };\n\n  $scope.noPrevious = function() {\n    return $scope.page === 1;\n  };\n\n  $scope.noNext = function() {\n    return $scope.page === $scope.totalPages;\n  };\n}])\n.directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['pagination', '?ngModel'],\n    controller: 'PaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pagination.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$paginationSuppressWarning) {\n        $log.warn('pagination is now deprecated. Use uib-pagination instead.');\n      }\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      // Setup configuration parameters\n      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n      paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n      if (attrs.maxSize) {\n        scope.$parent.$watch($parse(attrs.maxSize), function(value) {\n          maxSize = parseInt(value, 10);\n          paginationCtrl.render();\n        });\n      }\n\n      // Create page object used in template\n      function makePage(number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      }\n\n      function getPages(currentPage, totalPages) {\n        var pages = [];\n\n        // Default page limits\n        var startPage = 1, endPage = totalPages;\n        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n        // recompute if maxSize\n        if (isMaxSized) {\n          if (rotate) {\n            // Current page is displayed in the middle of the visible ones\n            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);\n            endPage   = startPage + maxSize - 1;\n\n            // Adjust if limit is exceeded\n            if (endPage > totalPages) {\n              endPage   = totalPages;\n              startPage = endPage - maxSize + 1;\n            }\n          } else {\n            // Visible pages are paginated with maxSize\n            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n            // Adjust last page if limit is exceeded\n            endPage = Math.min(startPage + maxSize - 1, totalPages);\n          }\n        }\n\n        // Add page number links\n        for (var number = startPage; number <= endPage; number++) {\n          var page = makePage(number, number, number === currentPage);\n          pages.push(page);\n        }\n\n        // Add links to move between page sets\n        if (isMaxSized && ! rotate) {\n          if (startPage > 1) {\n            var previousPageSet = makePage(startPage - 1, '...', false);\n            pages.unshift(previousPageSet);\n          }\n\n          if (endPage < totalPages) {\n            var nextPageSet = makePage(endPage + 1, '...', false);\n            pages.push(nextPageSet);\n          }\n        }\n\n        return pages;\n      }\n\n      var originalRender = paginationCtrl.render;\n      paginationCtrl.render = function() {\n        originalRender();\n        if (scope.page > 0 && scope.page <= scope.totalPages) {\n          scope.pages = getPages(scope.page, scope.totalPages);\n        }\n      };\n    }\n  };\n}])\n\n.directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {\n  return {\n    restrict: 'EA',\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['pager', '?ngModel'],\n    controller: 'PaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/pagination/pager.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$paginationSuppressWarning) {\n        $log.warn('pager is now deprecated. Use uib-pager instead.');\n      }\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n      paginationCtrl.init(ngModelCtrl, pagerConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider('$uibTooltip', function() {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    animation: true,\n    popupDelay: 0,\n    popupCloseDelay: 0,\n    useContentExp: false\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'focus': 'blur',\n    'none': ''\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function(value) {\n\t\tangular.extend(globalOptions, value);\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n   */\n  this.setTriggers = function setTriggers(triggers) {\n    angular.extend(triggerMap, triggers);\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake-case.\n   */\n  function snake_case(name) {\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n    var openedTooltips = $$stackedMap.createNew();\n    $document.on('keypress', function(e) {\n      if (e.which === 27) {\n        var last = openedTooltips.top();\n        if (last) {\n          last.value.close();\n          openedTooltips.removeTop();\n          last = null;\n        }\n      }\n    });\n\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n      options = angular.extend({}, defaultOptions, globalOptions, options);\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers(trigger) {\n        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n        var hide = show.map(function(trigger) {\n          return triggerMap[trigger] || trigger;\n        });\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case(ttType);\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName + '-popup '+\n          'title=\"' + startSym + 'title' + endSym + '\" '+\n          (options.useContentExp ?\n            'content-exp=\"contentExp()\" ' :\n            'content=\"' + startSym + 'content' + endSym + '\" ') +\n          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n          'animation=\"animation\" ' +\n          'is-open=\"isOpen\"' +\n          'origin-scope=\"origScope\" ' +\n          'style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"' +\n          '>' +\n        '</div>';\n\n      return {\n        compile: function(tElem, tAttrs) {\n          var tooltipLinker = $compile(template);\n\n          return function link(scope, element, attrs, tooltipCtrl) {\n            var tooltip;\n            var tooltipLinkedScope;\n            var transitionTimeout;\n            var showTimeout;\n            var hideTimeout;\n            var positionTimeout;\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n            var triggers = getTriggers(undefined);\n            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n            var ttScope = scope.$new(true);\n            var repositionScheduled = false;\n            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n            var observers = [];\n\n            var positionTooltip = function() {\n              // check if tooltip exists and is not empty\n              if (!tooltip || !tooltip.html()) { return; }\n\n              if (!positionTimeout) {\n                positionTimeout = $timeout(function() {\n                  // Reset the positioning.\n                  tooltip.css({ top: 0, left: 0 });\n\n                  // Now set the calculated positioning.\n                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n                  ttCss.top += 'px';\n                  ttCss.left += 'px';\n                  ttCss.visibility = 'visible';\n                  tooltip.css(ttCss);\n\n                  positionTimeout = null;\n                }, 0, false);\n              }\n            };\n\n            // Set up the correct scope to allow transclusion later\n            ttScope.origScope = scope;\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            ttScope.isOpen = false;\n            openedTooltips.add(ttScope, {\n              close: hide\n            });\n\n            function toggleTooltipBind() {\n              if (!ttScope.isOpen) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n                return;\n              }\n\n              cancelHide();\n              prepareTooltip();\n\n              if (ttScope.popupDelay) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!showTimeout) {\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n                }\n              } else {\n                show();\n              }\n            }\n\n            function hideTooltipBind() {\n              cancelShow();\n\n              if (ttScope.popupCloseDelay) {\n                if (!hideTimeout) {\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n                }\n              } else {\n                hide();\n              }\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n              cancelShow();\n              cancelHide();\n\n              // Don't show empty tooltips.\n              if (!ttScope.content) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // And show the tooltip.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = true;\n                assignIsOpen(true);\n                positionTooltip();\n              });\n            }\n\n            function cancelShow() {\n              if (showTimeout) {\n                $timeout.cancel(showTimeout);\n                showTimeout = null;\n              }\n\n              if (positionTimeout) {\n                $timeout.cancel(positionTimeout);\n                positionTimeout = null;\n              }\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              cancelShow();\n              cancelHide();\n\n              if (!ttScope) {\n                return;\n              }\n\n              // First things first: we don't show it anymore.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = false;\n                assignIsOpen(false);\n                // And now we remove it from the DOM. However, if we have animation, we\n                // need to wait for it to expire beforehand.\n                // FIXME: this is a placeholder for a port of the transitions library.\n                // The fade transition in TWBS is 150ms.\n                if (ttScope.animation) {\n                  if (!transitionTimeout) {\n                    transitionTimeout = $timeout(removeTooltip, 150, false);\n                  }\n                } else {\n                  removeTooltip();\n                }\n              });\n            }\n\n            function cancelHide() {\n              if (hideTimeout) {\n                $timeout.cancel(hideTimeout);\n                hideTimeout = null;\n              }\n              if (transitionTimeout) {\n                $timeout.cancel(transitionTimeout);\n                transitionTimeout = null;\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                return;\n              }\n\n              tooltipLinkedScope = ttScope.$new();\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n                if (appendToBody) {\n                  $document.find('body').append(tooltip);\n                } else {\n                  element.after(tooltip);\n                }\n              });\n\n              prepObservers();\n            }\n\n            function removeTooltip() {\n              unregisterObservers();\n\n              transitionTimeout = null;\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n              if (tooltipLinkedScope) {\n                tooltipLinkedScope.$destroy();\n                tooltipLinkedScope = null;\n              }\n            }\n\n            /**\n             * Set the inital scope values. Once\n             * the tooltip is created, the observers\n             * will be added to keep things in synch.\n             */\n            function prepareTooltip() {\n              ttScope.title = attrs[prefix + 'Title'];\n              if (contentParse) {\n                ttScope.content = contentParse(scope);\n              } else {\n                ttScope.content = attrs[ttType];\n              }\n\n              ttScope.popupClass = attrs[prefix + 'Class'];\n              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\n              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n            }\n\n            function assignIsOpen(isOpen) {\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n                isOpenParse.assign(scope, isOpen);\n              }\n            }\n\n            ttScope.contentExp = function() {\n              return ttScope.content;\n            };\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe('disabled', function(val) {\n              if (val) {\n                cancelShow();\n              }\n\n              if (val && ttScope.isOpen) {\n                hide();\n              }\n            });\n\n            if (isOpenParse) {\n              scope.$watch(isOpenParse, function(val) {\n                /*jshint -W018 */\n                if (ttScope && !val === ttScope.isOpen) {\n                  toggleTooltipBind();\n                }\n                /*jshint +W018 */\n              });\n            }\n\n            function prepObservers() {\n              observers.length = 0;\n\n              if (contentParse) {\n                observers.push(\n                  scope.$watch(contentParse, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    }\n                  })\n                );\n\n                observers.push(\n                  tooltipLinkedScope.$watch(function() {\n                    if (!repositionScheduled) {\n                      repositionScheduled = true;\n                      tooltipLinkedScope.$$postDigest(function() {\n                        repositionScheduled = false;\n                        if (ttScope && ttScope.isOpen) {\n                          positionTooltip();\n                        }\n                      });\n                    }\n                  })\n                );\n              } else {\n                observers.push(\n                  attrs.$observe(ttType, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    } else {\n                      positionTooltip();\n                    }\n                  })\n                );\n              }\n\n              observers.push(\n                attrs.$observe(prefix + 'Title', function(val) {\n                  ttScope.title = val;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n\n              observers.push(\n                attrs.$observe(prefix + 'Placement', function(val) {\n                  ttScope.placement = val ? val : options.placement;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n            }\n\n            function unregisterObservers() {\n              if (observers.length) {\n                angular.forEach(observers, function(observer) {\n                  observer();\n                });\n                observers.length = 0;\n              }\n            }\n\n            var unregisterTriggers = function() {\n              triggers.show.forEach(function(trigger) {\n                element.unbind(trigger, showTooltipBind);\n              });\n              triggers.hide.forEach(function(trigger) {\n                trigger.split(' ').forEach(function(hideTrigger) {\n                  element[0].removeEventListener(hideTrigger, hideTooltipBind);\n                });\n              });\n            };\n\n            function prepTriggers() {\n              var val = attrs[prefix + 'Trigger'];\n              unregisterTriggers();\n\n              triggers = getTriggers(val);\n\n              if (triggers.show !== 'none') {\n                triggers.show.forEach(function(trigger, idx) {\n                  // Using raw addEventListener due to jqLite/jQuery bug - #4060\n                  if (trigger === triggers.hide[idx]) {\n                    element[0].addEventListener(trigger, toggleTooltipBind);\n                  } else if (trigger) {\n                    element[0].addEventListener(trigger, showTooltipBind);\n                    triggers.hide[idx].split(' ').forEach(function(trigger) {\n                      element[0].addEventListener(trigger, hideTooltipBind);\n                    });\n                  }\n\n                  element.on('keypress', function(e) {\n                    if (e.which === 27) {\n                      hideTooltipBind();\n                    }\n                  });\n                });\n              }\n            }\n\n            prepTriggers();\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\n            // if a tooltip is attached to <body> we need to remove it on\n            // location change as its parent scope will probably not be destroyed\n            // by the change.\n            if (appendToBody) {\n              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {\n                if (ttScope.isOpen) {\n                  hide();\n                }\n              });\n            }\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              cancelShow();\n              cancelHide();\n              unregisterTriggers();\n              removeTooltip();\n              openedTooltips.remove(ttScope);\n              ttScope = null;\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n// This is mostly ngInclude code but with a custom scope\n.directive('uibTooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest',\nfunction ($animate ,  $sce ,  $compile ,  $templateRequest) {\n  return {\n    link: function(scope, elem, attrs) {\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n/**\n * Note that it's intentional that these classes are *not* applied through $animate.\n * They must not be animated as they're expected to be present on the tooltip on\n * initialization.\n */\n.directive('uibTooltipClasses', function() {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      if (scope.placement) {\n        element.addClass(scope.placement);\n      }\n\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n})\n\n.directive('uibTooltipPopup', function() {\n  return {\n    replace: true,\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-popup.html',\n    link: function(scope, element) {\n      element.addClass('tooltip');\n    }\n  };\n})\n\n.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('uibTooltipTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n    link: function(scope, element) {\n      element.addClass('tooltip');\n    }\n  };\n})\n\n.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibTooltipHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n    link: function(scope, element) {\n      element.addClass('tooltip');\n    }\n  };\n})\n\n.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/* Deprecated tooltip below */\n\nangular.module('ui.bootstrap.tooltip')\n\n.value('$tooltipSuppressWarning', false)\n\n.provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {\n  angular.extend(this, $uibTooltipProvider);\n\n  this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {\n    if (!$tooltipSuppressWarning) {\n      $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');\n    }\n\n    return $injector.invoke($uibTooltipProvider.$get);\n  }];\n}])\n\n// This is mostly ngInclude code but with a custom scope\n.directive('tooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning',\nfunction ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {\n  return {\n    link: function(scope, elem, attrs) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');\n      }\n\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n.directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');\n      }\n\n      if (scope.placement) {\n        element.addClass(scope.placement);\n      }\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n}])\n\n.directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-popup.html',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');\n      }\n\n      element.addClass('tooltip');\n    }\n  };\n}])\n\n.directive('tooltip', ['$tooltip', function($tooltip) {\n  return $tooltip('tooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/tooltip/tooltip-template-popup.html',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');\n      }\n\n      element.addClass('tooltip');\n    }\n  };\n}])\n\n.directive('tooltipTemplate', ['$tooltip', function($tooltip) {\n  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/tooltip/tooltip-html-popup.html',\n    link: function(scope, element) {\n      if (!$tooltipSuppressWarning) {\n        $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');\n      }\n\n      element.addClass('tooltip');\n    }\n  };\n}])\n\n.directive('tooltipHtml', ['$tooltip', function($tooltip) {\n  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, and selector delegatation.\n */\nangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\n.directive('uibPopoverTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/popover/popover-template.html',\n    link: function(scope, element) {\n      element.addClass('popover');\n    }\n  };\n})\n\n.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover-html.html',\n    link: function(scope, element) {\n      element.addClass('popover');\n    }\n  };\n})\n\n.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverPopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover.html',\n    link: function(scope, element) {\n      element.addClass('popover');\n    }\n  };\n})\n\n.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopover', 'popover', 'click');\n}]);\n\n/* Deprecated popover below */\n\nangular.module('ui.bootstrap.popover')\n\n.value('$popoverSuppressWarning', false)\n\n.directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'template/popover/popover-template.html',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');\n      }\n\n      element.addClass('popover');\n    }\n  };\n}])\n\n.directive('popoverTemplate', ['$tooltip', function($tooltip) {\n  return $tooltip('popoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover-html.html',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');\n      }\n\n      element.addClass('popover');\n    }\n  };\n}])\n\n.directive('popoverHtml', ['$tooltip', function($tooltip) {\n  return $tooltip('popoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {\n  return {\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'template/popover/popover.html',\n    link: function(scope, element) {\n      if (!$popoverSuppressWarning) {\n        $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');\n      }\n\n      element.addClass('popover');\n    }\n  };\n}])\n\n.directive('popover', ['$tooltip', function($tooltip) {\n\n  return $tooltip('popover', 'popover', 'click');\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('uibProgressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n  var self = this,\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = $scope.max;\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n    this.bars.forEach(function (bar) {\n      bar.recalculatePercentage();\n    });\n  };\n\n  $scope.$watch('max', function(max) {\n    self.bars.forEach(function(bar) {\n      bar.max = $scope.max;\n      bar.recalculatePercentage();\n    });\n  });\n}])\n\n.directive('uibProgress', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    require: 'uibProgress',\n    scope: {\n      max: '=?'\n    },\n    templateUrl: 'template/progressbar/progress.html'\n  };\n})\n\n.directive('uibBar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^uibProgress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, element, attrs);\n    }\n  };\n})\n\n.directive('uibProgressbar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    scope: {\n      value: '=',\n      max: '=?',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n});\n\n/* Deprecated progressbar below */\n\nangular.module('ui.bootstrap.progressbar')\n\n.value('$progressSuppressWarning', false)\n\n.controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {\n  if (!$progressSuppressWarning) {\n    $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');\n  }\n\n  var self = this,\n    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = $scope.max;\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n  };\n\n  $scope.$watch('max', function(max) {\n    self.bars.forEach(function(bar) {\n      bar.max = $scope.max;\n      bar.recalculatePercentage();\n    });\n  });\n}])\n\n.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'ProgressController',\n    require: 'progress',\n    scope: {\n      max: '=?',\n      title: '@?'\n    },\n    templateUrl: 'template/progressbar/progress.html',\n    link: function() {\n      if (!$progressSuppressWarning) {\n        $log.warn('progress is now deprecated. Use uib-progress instead.');\n      }\n    }\n  };\n}])\n\n.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^progress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      if (!$progressSuppressWarning) {\n        $log.warn('bar is now deprecated. Use uib-bar instead.');\n      }\n      progressCtrl.addBar(scope, element);\n    }\n  };\n}])\n\n.directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'ProgressController',\n    scope: {\n      value: '=',\n      max: '=?',\n      type: '@'\n    },\n    templateUrl: 'template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      if (!$progressSuppressWarning) {\n        $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');\n      }\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.rating', [])\n\n.constant('uibRatingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null,\n  titles : ['one', 'two', 'three', 'four', 'five']\n})\n\n.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl  = { $setViewValue: angular.noop };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.push(function(value) {\n      if (angular.isNumber(value) && value << 0 !== value) {\n        value = Math.round(value);\n      }\n      return value;\n    });\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n      tmpTitles : ratingConfig.titles;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n      $scope.$parent.$eval($attrs.ratingStates) :\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n    }\n    return states;\n  };\n\n  this.getTitle = function(index) {\n    if (index >= this.titles.length) {\n      return index + 1;\n    } else {\n      return this.titles[index];\n    }\n  };\n\n  $scope.rate = function(value) {\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if (!$scope.readonly) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n  };\n}])\n\n.directive('uibRating', function() {\n  return {\n    require: ['uibRating', 'ngModel'],\n    scope: {\n      readonly: '=?',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'UibRatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n});\n\n/* Deprecated rating below */\n\nangular.module('ui.bootstrap.rating')\n\n.value('$ratingSuppressWarning', false)\n\n.controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {\n  if (!$ratingSuppressWarning) {\n    $log.warn('RatingController is now deprecated. Use UibRatingController instead.');\n  }\n\n  angular.extend(this, $controller('UibRatingController', {\n    $scope: $scope,\n    $attrs: $attrs\n  }));\n}])\n\n.directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {\n  return {\n    require: ['rating', 'ngModel'],\n    scope: {\n      readonly: '=?',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'RatingController',\n    templateUrl: 'template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      if (!$ratingSuppressWarning) {\n        $log.warn('rating is now deprecated. Use uib-rating instead.');\n      }\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n}]);\n\n\n/**\n * @ngdoc overview\n * @name ui.bootstrap.tabs\n *\n * @description\n * AngularJS version of the tabs directive.\n */\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('UibTabsetController', ['$scope', function ($scope) {\n  var ctrl = this,\n      tabs = ctrl.tabs = $scope.tabs = [];\n\n  ctrl.select = function(selectedTab) {\n    angular.forEach(tabs, function(tab) {\n      if (tab.active && tab !== selectedTab) {\n        tab.active = false;\n        tab.onDeselect();\n        selectedTab.selectCalled = false;\n      }\n    });\n    selectedTab.active = true;\n    // only call select if it has not already been called\n    if (!selectedTab.selectCalled) {\n      selectedTab.onSelect();\n      selectedTab.selectCalled = true;\n    }\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    tabs.push(tab);\n    // we can't run the select function on the first tab\n    // since that would select it twice\n    if (tabs.length === 1 && tab.active !== false) {\n      tab.active = true;\n    } else if (tab.active) {\n      ctrl.select(tab);\n    } else {\n      tab.active = false;\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index = tabs.indexOf(tab);\n    //Select a new tab if the tab to be removed is selected and not destroyed\n    if (tab.active && tabs.length > 1 && !destroyed) {\n      //If this is the last tab, select the previous tab. else, the next tab.\n      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;\n      ctrl.select(tabs[newActiveIndex]);\n    }\n    tabs.splice(index, 1);\n  };\n\n  var destroyed;\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n}])\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabset\n * @restrict EA\n *\n * @description\n * Tabset is the outer container for the tabs directive\n *\n * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.\n * @param {boolean=} justified Whether or not to use justified styling for the tabs.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <uib-tabset>\n      <uib-tab heading=\"Tab 1\"><b>First</b> Content!</uib-tab>\n      <uib-tab heading=\"Tab 2\"><i>Second</i> Content!</uib-tab>\n    </uib-tabset>\n    <hr />\n    <uib-tabset vertical=\"true\">\n      <uib-tab heading=\"Vertical Tab 1\"><b>First</b> Vertical Content!</uib-tab>\n      <uib-tab heading=\"Vertical Tab 2\"><i>Second</i> Vertical Content!</uib-tab>\n    </uib-tabset>\n    <uib-tabset justified=\"true\">\n      <uib-tab heading=\"Justified Tab 1\"><b>First</b> Justified Content!</uib-tab>\n      <uib-tab heading=\"Justified Tab 2\"><i>Second</i> Justified Content!</uib-tab>\n    </uib-tabset>\n  </file>\n</example>\n */\n.directive('uibTabset', function() {\n  return {\n    restrict: 'EA',\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@'\n    },\n    controller: 'UibTabsetController',\n    templateUrl: 'template/tabs/tabset.html',\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tab\n * @restrict EA\n *\n * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.\n * @param {string=} select An expression to evaluate when the tab is selected.\n * @param {boolean=} active A binding, telling whether or not this tab is selected.\n * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.\n *\n * @description\n * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <div ng-controller=\"TabsDemoCtrl\">\n      <button class=\"btn btn-small\" ng-click=\"items[0].active = true\">\n        Select item 1, using active binding\n      </button>\n      <button class=\"btn btn-small\" ng-click=\"items[1].disabled = !items[1].disabled\">\n        Enable/disable item 2, using disabled binding\n      </button>\n      <br />\n      <uib-tabset>\n        <uib-tab heading=\"Tab 1\">First Tab</uib-tab>\n        <uib-tab select=\"alertMe()\">\n          <uib-tab-heading><i class=\"icon-bell\"></i> Alert me!</tab-heading>\n          Second Tab, with alert callback and html heading!\n        </uib-tab>\n        <uib-tab ng-repeat=\"item in items\"\n          heading=\"{{item.title}}\"\n          disabled=\"item.disabled\"\n          active=\"item.active\">\n          {{item.content}}\n        </uib-tab>\n      </uib-tabset>\n    </div>\n  </file>\n  <file name=\"script.js\">\n    function TabsDemoCtrl($scope) {\n      $scope.items = [\n        { title:\"Dynamic Title 1\", content:\"Dynamic Item 0\" },\n        { title:\"Dynamic Title 2\", content:\"Dynamic Item 1\", disabled: true }\n      ];\n\n      $scope.alertMe = function() {\n        setTimeout(function() {\n          alert(\"You've selected the alert tab!\");\n        });\n      };\n    };\n  </file>\n</example>\n */\n\n/**\n * @ngdoc directive\n * @name ui.bootstrap.tabs.directive:tabHeading\n * @restrict EA\n *\n * @description\n * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.\n *\n * @example\n<example module=\"ui.bootstrap\">\n  <file name=\"index.html\">\n    <uib-tabset>\n      <uib-tab>\n        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>\n        And some content, too!\n      </uib-tab>\n      <uib-tab>\n        <uib-tab-heading><i class=\"icon-heart\"></i> Icon heading?!?</tab-heading>\n        That's right.\n      </uib-tab>\n    </uib-tabset>\n  </file>\n</example>\n */\n.directive('uibTab', ['$parse', function($parse) {\n  return {\n    require: '^uibTabset',\n    restrict: 'EA',\n    replace: true,\n    templateUrl: 'template/tabs/tab.html',\n    transclude: true,\n    scope: {\n      active: '=?',\n      heading: '@',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n      scope.$watch('active', function(active) {\n        if (active) {\n          tabsetCtrl.select(scope);\n        }\n      });\n\n      scope.disabled = false;\n      if (attrs.disable) {\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\n          scope.disabled = !! value;\n        });\n      }\n\n      scope.select = function() {\n        if (!scope.disabled) {\n          scope.active = true;\n        }\n      };\n\n      tabsetCtrl.addTab(scope);\n      scope.$on('$destroy', function() {\n        tabsetCtrl.removeTab(scope);\n      });\n\n      //We need to transclude later, once the content container is ready.\n      //when this link happens, we're inside a tab heading.\n      scope.$transcludeFn = transclude;\n    }\n  };\n}])\n\n.directive('uibTabHeadingTransclude', function() {\n  return {\n    restrict: 'A',\n    require: ['?^uibTab', '?^tab'], // TODO: change to '^uibTab' after deprecation removal\n    link: function(scope, elm) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n})\n\n.directive('uibTabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: ['?^uibTabset', '?^tabset'], // TODO: change to '^uibTabset' after deprecation removal\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.uibTabContentTransclude);\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n\n  function isTabHeading(node) {\n    return node.tagName && (\n      node.hasAttribute('tab-heading') || // TODO: remove after deprecation removal\n      node.hasAttribute('data-tab-heading') || // TODO: remove after deprecation removal\n      node.hasAttribute('x-tab-heading') || // TODO: remove after deprecation removal\n      node.hasAttribute('uib-tab-heading') ||\n      node.hasAttribute('data-uib-tab-heading') ||\n      node.hasAttribute('x-uib-tab-heading') ||\n      node.tagName.toLowerCase() === 'tab-heading' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === 'data-tab-heading' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === 'x-tab-heading' || // TODO: remove after deprecation removal\n      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n    );\n  }\n});\n\n/* deprecated tabs below */\n\nangular.module('ui.bootstrap.tabs')\n\n  .value('$tabsSuppressWarning', false)\n\n  .controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {\n    if (!$tabsSuppressWarning) {\n      $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');\n    }\n\n    angular.extend(this, $controller('UibTabsetController', {\n      $scope: $scope\n    }));\n  }])\n\n  .directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: 'EA',\n      transclude: true,\n      replace: true,\n      scope: {\n        type: '@'\n      },\n      controller: 'TabsetController',\n      templateUrl: 'template/tabs/tabset.html',\n      link: function(scope, element, attrs) {\n\n        if (!$tabsSuppressWarning) {\n          $log.warn('tabset is now deprecated. Use uib-tabset instead.');\n        }\n        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;\n        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;\n      }\n    };\n  }])\n\n  .directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {\n    return {\n      require: '^tabset',\n      restrict: 'EA',\n      replace: true,\n      templateUrl: 'template/tabs/tab.html',\n      transclude: true,\n      scope: {\n        active: '=?',\n        heading: '@',\n        onSelect: '&select', //This callback is called in contentHeadingTransclude\n        //once it inserts the tab's content into the dom\n        onDeselect: '&deselect'\n      },\n      controller: function() {\n        //Empty controller so other directives can require being 'under' a tab\n      },\n      link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n        if (!$tabsSuppressWarning) {\n          $log.warn('tab is now deprecated. Use uib-tab instead.');\n        }\n\n        scope.$watch('active', function(active) {\n          if (active) {\n            tabsetCtrl.select(scope);\n          }\n        });\n\n        scope.disabled = false;\n        if (attrs.disable) {\n          scope.$parent.$watch($parse(attrs.disable), function(value) {\n            scope.disabled = !!value;\n          });\n        }\n\n        scope.select = function() {\n          if (!scope.disabled) {\n            scope.active = true;\n          }\n        };\n\n        tabsetCtrl.addTab(scope);\n        scope.$on('$destroy', function() {\n          tabsetCtrl.removeTab(scope);\n        });\n\n        //We need to transclude later, once the content container is ready.\n        //when this link happens, we're inside a tab heading.\n        scope.$transcludeFn = transclude;\n      }\n    };\n  }])\n\n  .directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: 'A',\n      require: '^tab',\n      link: function(scope, elm) {\n        if (!$tabsSuppressWarning) {\n          $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');\n        }\n\n        scope.$watch('headingElement', function updateHeadingElement(heading) {\n          if (heading) {\n            elm.html('');\n            elm.append(heading);\n          }\n        });\n      }\n    };\n  }])\n\n  .directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {\n    return {\n      restrict: 'A',\n      require: '^tabset',\n      link: function(scope, elm, attrs) {\n        if (!$tabsSuppressWarning) {\n          $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');\n        }\n\n        var tab = scope.$eval(attrs.tabContentTransclude);\n\n        //Now our tab is ready to be transcluded: both the tab heading area\n        //and the tab content area are loaded.  Transclude 'em both.\n        tab.$transcludeFn(tab.$parent, function(contents) {\n          angular.forEach(contents, function(node) {\n            if (isTabHeading(node)) {\n              //Let tabHeadingTransclude know.\n              tab.headingElement = node;\n            }\n            else {\n              elm.append(node);\n            }\n          });\n        });\n      }\n    };\n\n    function isTabHeading(node) {\n      return node.tagName && (\n          node.hasAttribute('tab-heading') ||\n          node.hasAttribute('data-tab-heading') ||\n          node.hasAttribute('x-tab-heading') ||\n          node.tagName.toLowerCase() === 'tab-heading' ||\n          node.tagName.toLowerCase() === 'data-tab-heading' ||\n          node.tagName.toLowerCase() === 'x-tab-heading'\n        );\n    }\n  }]);\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('uibTimepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  showMeridian: true,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true,\n  arrowkeys: true,\n  showSpinners: true\n})\n\n.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var selected = new Date(),\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n  $element.removeAttr('tabindex');\n\n  this.init = function(ngModelCtrl_, inputs) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\n      return modelValue ? new Date(modelValue) : null;\n    });\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1);\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n    if (mousewheel) {\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);\n    }\n\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n    if (arrowkeys) {\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents(hoursInputEl, minutesInputEl);\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = parseInt(value, 10);\n    });\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = parseInt(value, 10);\n    });\n  }\n\n  var min;\n  $scope.$parent.$watch($parse($attrs.min), function(value) {\n    var dt = new Date(value);\n    min = isNaN(dt) ? undefined : dt;\n  });\n\n  var max;\n  $scope.$parent.$watch($parse($attrs.max), function(value) {\n    var dt = new Date(value);\n    max = isNaN(dt) ? undefined : dt;\n  });\n\n  $scope.noIncrementHours = function() {\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\n    return incrementedSelected > max ||\n      (incrementedSelected < selected && incrementedSelected < min);\n  };\n\n  $scope.noDecrementHours = function() {\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n    return decrementedSelected < min ||\n      (decrementedSelected > selected && decrementedSelected > max);\n  };\n\n  $scope.noIncrementMinutes = function() {\n    var incrementedSelected = addMinutes(selected, minuteStep);\n    return incrementedSelected > max ||\n      (incrementedSelected < selected && incrementedSelected < min);\n  };\n\n  $scope.noDecrementMinutes = function() {\n    var decrementedSelected = addMinutes(selected, -minuteStep);\n    return decrementedSelected < min ||\n      (decrementedSelected > selected && decrementedSelected > max);\n  };\n\n  $scope.noToggleMeridian = function() {\n    if (selected.getHours() < 13) {\n      return addMinutes(selected, 12 * 60) > max;\n    } else {\n      return addMinutes(selected, -12 * 60) < min;\n    }\n  };\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if (ngModelCtrl.$error.time) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n          selected.setHours(hours);\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    });\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate() {\n    var hours = parseInt($scope.hours, 10);\n    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);\n    if (!valid) {\n      return undefined;\n    }\n\n    if ($scope.showMeridian) {\n      if (hours === 12) {\n        hours = 0;\n      }\n      if ($scope.meridian === meridians[1]) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = parseInt($scope.minutes, 10);\n    return (minutes >= 0 && minutes < 60) ? minutes : undefined;\n  }\n\n  function pad(value) {\n    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;\n      return (e.detail || delta > 0);\n    };\n\n    hoursInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n      e.preventDefault();\n    });\n\n    minutesInputEl.bind('mousewheel wheel', function(e) {\n      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n      e.preventDefault();\n    });\n\n  };\n\n  // Respond on up/down arrowkeys\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {\n    hoursInputEl.bind('keydown', function(e) {\n      if (e.which === 38) { // up\n        e.preventDefault();\n        $scope.incrementHours();\n        $scope.$apply();\n      } else if (e.which === 40) { // down\n        e.preventDefault();\n        $scope.decrementHours();\n        $scope.$apply();\n      }\n    });\n\n    minutesInputEl.bind('keydown', function(e) {\n      if (e.which === 38) { // up\n        e.preventDefault();\n        $scope.incrementMinutes();\n        $scope.$apply();\n      } else if (e.which === 40) { // down\n        e.preventDefault();\n        $scope.decrementMinutes();\n        $scope.$apply();\n      }\n    });\n  };\n\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {\n    if ($scope.readonlyInput) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes) {\n      ngModelCtrl.$setViewValue(null);\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n      }\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate(),\n        minutes = getMinutesFromTemplate();\n\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n        selected.setHours(hours);\n        if (selected < min || selected > max) {\n          invalidate(true);\n        } else {\n          refresh('h');\n        }\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.bind('blur', function(e) {\n      if (!$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply(function() {\n          $scope.hours = pad($scope.hours);\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(undefined, true);\n        } else {\n          refresh('m');\n        }\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.bind('blur', function(e) {\n      if (!$scope.invalidMinutes && $scope.minutes < 10) {\n        $scope.$apply(function() {\n          $scope.minutes = pad($scope.minutes);\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$viewValue;\n\n    if (isNaN(date)) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if (date) {\n        selected = date;\n      }\n\n      if (selected < min || selected > max) {\n        ngModelCtrl.$setValidity('time', false);\n        $scope.invalidHours = true;\n        $scope.invalidMinutes = true;\n      } else {\n        makeValid();\n      }\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh(keyboardChange) {\n    makeValid();\n    ngModelCtrl.$setViewValue(new Date(selected));\n    updateTemplate(keyboardChange);\n  }\n\n  function makeValid() {\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n  }\n\n  function updateTemplate(keyboardChange) {\n    var hours = selected.getHours(), minutes = selected.getMinutes();\n\n    if ($scope.showMeridian) {\n      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system\n    }\n\n    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n    if (keyboardChange !== 'm') {\n      $scope.minutes = pad(minutes);\n    }\n    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n  }\n\n  function addMinutes(date, minutes) {\n    var dt = new Date(date.getTime() + minutes * 60000);\n    var newDate = new Date(date);\n    newDate.setHours(dt.getHours(), dt.getMinutes());\n    return newDate;\n  }\n\n  function addMinutesToSelected(minutes) {\n    selected = addMinutes(selected, minutes);\n    refresh();\n  }\n\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\n  $scope.incrementHours = function() {\n    if (!$scope.noIncrementHours()) {\n      addMinutesToSelected(hourStep * 60);\n    }\n  };\n\n  $scope.decrementHours = function() {\n    if (!$scope.noDecrementHours()) {\n      addMinutesToSelected(-hourStep * 60);\n    }\n  };\n\n  $scope.incrementMinutes = function() {\n    if (!$scope.noIncrementMinutes()) {\n      addMinutesToSelected(minuteStep);\n    }\n  };\n\n  $scope.decrementMinutes = function() {\n    if (!$scope.noDecrementMinutes()) {\n      addMinutesToSelected(-minuteStep);\n    }\n  };\n\n  $scope.toggleMeridian = function() {\n    if (!$scope.noToggleMeridian()) {\n      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));\n    }\n  };\n}])\n\n.directive('uibTimepicker', function() {\n  return {\n    restrict: 'EA',\n    require: ['uibTimepicker', '?^ngModel'],\n    controller: 'UibTimepickerController',\n    controllerAs: 'timepicker',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n});\n\n/* Deprecated timepicker below */\n\nangular.module('ui.bootstrap.timepicker')\n\n.value('$timepickerSuppressWarning', false)\n\n.controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {\n  if (!$timepickerSuppressWarning) {\n    $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');\n  }\n\n  angular.extend(this, $controller('UibTimepickerController', {\n    $scope: $scope,\n    $element: $element,\n    $attrs: $attrs\n  }));\n}])\n\n.directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {\n  return {\n    restrict: 'EA',\n    require: ['timepicker', '?^ngModel'],\n    controller: 'TimepickerController',\n    controllerAs: 'timepicker',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'template/timepicker/timepicker.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      if (!$timepickerSuppressWarning) {\n        $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');\n      }\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n    return {\n      parse: function(input) {\n        var match = input.match(TYPEAHEAD_REGEXP);\n        if (!match) {\n          throw new Error(\n            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n              ' but got \"' + input + '\".');\n        }\n\n        return {\n          itemName: match[3],\n          source: $parse(match[4]),\n          viewMapper: $parse(match[2] || match[1]),\n          modelMapper: $parse(match[1])\n        };\n      }\n    };\n  }])\n\n  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser',\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    var modelCtrl, ngModelOptions;\n    //SUPPORTED ATTRIBUTES (OPTIONS)\n\n    //minimal no of characters that needs to be entered before typeahead kicks-in\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n    if (!minLength && minLength !== 0) {\n      minLength = 1;\n    }\n\n    //minimal wait time after last character typed before typeahead kicks-in\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n    //should it restrict model values to the ones selected from the popup only?\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n    //binding to a variable that indicates if matches are being retrieved asynchronously\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n    //a callback executed when a match is selected\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n    //should it select highlighted popup value when losing focus?\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n    //binding to a variable that indicates if there were no results after the query is completed\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n    var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n    //If input matches an item of the list exactly, select it automatically\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n    //INTERNAL VARIABLES\n\n    //model setter executed upon match selection\n    var parsedModel = $parse(attrs.ngModel);\n    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n    var $setModelValue = function(scope, newValue) {\n      if (angular.isFunction(parsedModel(originalScope)) &&\n        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n        return invokeModelSetter(scope, {$$$p: newValue});\n      } else {\n        return parsedModel.assign(scope, newValue);\n      }\n    };\n\n    //expressions used by typeahead\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\n    var hasFocus;\n\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n    //mousedown & mouseup events\n    //Issue #3699\n    var selected;\n\n    //create a child scope for the typeahead directive so we are not polluting original scope\n    //with typeahead-specific data (matches, query etc.)\n    var scope = originalScope.$new();\n    var offDestroy = originalScope.$on('$destroy', function() {\n      scope.$destroy();\n    });\n    scope.$on('$destroy', offDestroy);\n\n    // WAI-ARIA\n    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n    element.attr({\n      'aria-autocomplete': 'list',\n      'aria-expanded': false,\n      'aria-owns': popupId\n    });\n\n    //pop-up element used to display matches\n    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n    popUpEl.attr({\n      id: popupId,\n      matches: 'matches',\n      active: 'activeIdx',\n      select: 'select(activeIdx)',\n      'move-in-progress': 'moveInProgress',\n      query: 'query',\n      position: 'position'\n    });\n    //custom item template\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n    }\n\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n    }\n\n    var resetMatches = function() {\n      scope.matches = [];\n      scope.activeIdx = -1;\n      element.attr('aria-expanded', false);\n    };\n\n    var getMatchId = function(index) {\n      return popupId + '-option-' + index;\n    };\n\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n    // This attribute is added or removed automatically when the `activeIdx` changes.\n    scope.$watch('activeIdx', function(index) {\n      if (index < 0) {\n        element.removeAttr('aria-activedescendant');\n      } else {\n        element.attr('aria-activedescendant', getMatchId(index));\n      }\n    });\n\n    var inputIsExactMatch = function(inputValue, index) {\n      if (scope.matches.length > index && inputValue) {\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n      }\n\n      return false;\n    };\n\n    var getMatchesAsync = function(inputValue) {\n      var locals = {$viewValue: inputValue};\n      isLoadingSetter(originalScope, true);\n      isNoResultsSetter(originalScope, false);\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n        //it might happen that several async queries were in progress if a user were typing fast\n        //but we are interested only in responses that correspond to the current view value\n        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n        if (onCurrentRequest && hasFocus) {\n          if (matches && matches.length > 0) {\n            scope.activeIdx = focusFirst ? 0 : -1;\n            isNoResultsSetter(originalScope, false);\n            scope.matches.length = 0;\n\n            //transform labels\n            for (var i = 0; i < matches.length; i++) {\n              locals[parserResult.itemName] = matches[i];\n              scope.matches.push({\n                id: getMatchId(i),\n                label: parserResult.viewMapper(scope, locals),\n                model: matches[i]\n              });\n            }\n\n            scope.query = inputValue;\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n            //due to other elements being rendered\n            recalculatePosition();\n\n            element.attr('aria-expanded', true);\n\n            //Select the single remaining option if user input matches\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n              scope.select(0);\n            }\n          } else {\n            resetMatches();\n            isNoResultsSetter(originalScope, true);\n          }\n        }\n        if (onCurrentRequest) {\n          isLoadingSetter(originalScope, false);\n        }\n      }, function() {\n        resetMatches();\n        isLoadingSetter(originalScope, false);\n        isNoResultsSetter(originalScope, true);\n      });\n    };\n\n    // bind events only if appendToBody params exist - performance feature\n    if (appendToBody) {\n      angular.element($window).bind('resize', fireRecalculating);\n      $document.find('body').bind('scroll', fireRecalculating);\n    }\n\n    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutEventPromise;\n\n    // Default progress type\n    scope.moveInProgress = false;\n\n    function fireRecalculating() {\n      if (!scope.moveInProgress) {\n        scope.moveInProgress = true;\n        scope.$digest();\n      }\n\n      // Cancel previous timeout\n      if (timeoutEventPromise) {\n        $timeout.cancel(timeoutEventPromise);\n      }\n\n      // Debounced executing recalculate after events fired\n      timeoutEventPromise = $timeout(function() {\n        // if popup is visible\n        if (scope.matches.length) {\n          recalculatePosition();\n        }\n\n        scope.moveInProgress = false;\n      }, eventDebounceTime);\n    }\n\n    // recalculate actual position and set new values to scope\n    // after digest loop is popup in right position\n    function recalculatePosition() {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top += element.prop('offsetHeight');\n    }\n\n    //we need to propagate user's query so we can higlight matches\n    scope.query = undefined;\n\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutPromise;\n\n    var scheduleSearchWithTimeout = function(inputValue) {\n      timeoutPromise = $timeout(function() {\n        getMatchesAsync(inputValue);\n      }, waitTime);\n    };\n\n    var cancelPreviousTimeout = function() {\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n    };\n\n    resetMatches();\n\n    scope.select = function(activeIdx) {\n      //called from within the $digest() cycle\n      var locals = {};\n      var model, item;\n\n      selected = true;\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n      model = parserResult.modelMapper(originalScope, locals);\n      $setModelValue(originalScope, model);\n      modelCtrl.$setValidity('editable', true);\n      modelCtrl.$setValidity('parse', true);\n\n      onSelectCallback(originalScope, {\n        $item: item,\n        $model: model,\n        $label: parserResult.viewMapper(originalScope, locals)\n      });\n\n      resetMatches();\n\n      //return focus to the input element if a match was selected via a mouse click event\n      // use timeout to avoid $rootScope:inprog error\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n        $timeout(function() { element[0].focus(); }, 0, false);\n      }\n    };\n\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n    element.bind('keydown', function(evt) {\n      //typeahead is open and an \"interesting\" key was pressed\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n        return;\n      }\n\n      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n        resetMatches();\n        scope.$digest();\n        return;\n      }\n\n      evt.preventDefault();\n\n      if (evt.which === 40) {\n        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n        scope.$digest();\n      } else if (evt.which === 38) {\n        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n        scope.$digest();\n      } else if (evt.which === 13 || evt.which === 9) {\n        scope.$apply(function () {\n          scope.select(scope.activeIdx);\n        });\n      } else if (evt.which === 27) {\n        evt.stopPropagation();\n\n        resetMatches();\n        scope.$digest();\n      }\n    });\n\n    element.bind('blur', function() {\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n        selected = true;\n        scope.$apply(function() {\n          scope.select(scope.activeIdx);\n        });\n      }\n      hasFocus = false;\n      selected = false;\n    });\n\n    // Keep reference to click handler to unbind it.\n    var dismissClickHandler = function(evt) {\n      // Issue #3973\n      // Firefox treats right click as a click on document\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n        resetMatches();\n        if (!$rootScope.$$phase) {\n          scope.$digest();\n        }\n      }\n    };\n\n    $document.bind('click', dismissClickHandler);\n\n    originalScope.$on('$destroy', function() {\n      $document.unbind('click', dismissClickHandler);\n      if (appendToBody || appendToElementId) {\n        $popup.remove();\n      }\n\n      if (appendToBody) {\n        angular.element($window).unbind('resize', fireRecalculating);\n        $document.find('body').unbind('scroll', fireRecalculating);\n      }\n      // Prevent jQuery cache memory leak\n      popUpEl.remove();\n    });\n\n    var $popup = $compile(popUpEl)(scope);\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else if (appendToElementId !== false) {\n      angular.element($document[0].getElementById(appendToElementId)).append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    this.init = function(_modelCtrl, _ngModelOptions) {\n      modelCtrl = _modelCtrl;\n      ngModelOptions = _ngModelOptions;\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function(inputValue) {\n        hasFocus = true;\n\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        } else {\n          if (!inputValue) {\n            // Reset in case user had typed something previously.\n            modelCtrl.$setValidity('editable', true);\n            return null;\n          } else {\n            modelCtrl.$setValidity('editable', false);\n            return undefined;\n          }\n        }\n      });\n\n      modelCtrl.$formatters.push(function(modelValue) {\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        // The validity may be set to false via $parsers (see above) if\n        // the model is restricted to selected values. If the model\n        // is set manually it is considered to be valid.\n        if (!isEditable) {\n          modelCtrl.$setValidity('editable', true);\n        }\n\n        if (inputFormatter) {\n          locals.$model = modelValue;\n          return inputFormatter(originalScope, locals);\n        } else {\n          //it might happen that we don't have enough info to properly render input value\n          //we need to check for this situation and simply return model value if we can't apply custom formatting\n          locals[parserResult.itemName] = modelValue;\n          candidateViewValue = parserResult.viewMapper(originalScope, locals);\n          locals[parserResult.itemName] = undefined;\n          emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n        }\n      });\n    };\n  }])\n\n  .directive('uibTypeahead', function() {\n    return {\n      controller: 'UibTypeaheadController',\n      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n      link: function(originalScope, element, attrs, ctrls) {\n        ctrls[2].init(ctrls[0], ctrls[1]);\n      }\n    };\n  })\n\n  .directive('uibTypeaheadPopup', function() {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  })\n\n  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n    return {\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link:function(scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          $compile(tplContent.trim())(scope, function(clonedElement) {\n            element.replaceWith(clonedElement);\n          });\n        });\n      }\n    };\n  }])\n\n  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n      return matchItem;\n    };\n  }]);\n\n/* Deprecated typeahead below */\n  \nangular.module('ui.bootstrap.typeahead')\n  .value('$typeaheadSuppressWarning', false)\n  .service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {\n    if (!$typeaheadSuppressWarning) {\n      $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');\n    }\n\n    return uibTypeaheadParser;\n  }])\n\n  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning',\n    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    return {\n      require: ['ngModel', '^?ngModelOptions'],\n      link: function(originalScope, element, attrs, ctrls) {\n        if (!$typeaheadSuppressWarning) {\n          $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');\n        }\n        var modelCtrl = ctrls[0];\n        var ngModelOptions = ctrls[1];\n        //SUPPORTED ATTRIBUTES (OPTIONS)\n\n        //minimal no of characters that needs to be entered before typeahead kicks-in\n        var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n        if (!minLength && minLength !== 0) {\n          minLength = 1;\n        }\n\n        //minimal wait time after last character typed before typeahead kicks-in\n        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n        //should it restrict model values to the ones selected from the popup only?\n        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\n        //binding to a variable that indicates if matches are being retrieved asynchronously\n        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n        //a callback executed when a match is selected\n        var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n        //should it select highlighted popup value when losing focus?\n        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n        //binding to a variable that indicates if there were no results after the query is completed\n        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n        var appendToElementId =  attrs.typeaheadAppendToElementId || false;\n\n        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n        //If input matches an item of the list exactly, select it automatically\n        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n        //INTERNAL VARIABLES\n\n        //model setter executed upon match selection\n        var parsedModel = $parse(attrs.ngModel);\n        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n        var $setModelValue = function(scope, newValue) {\n          if (angular.isFunction(parsedModel(originalScope)) &&\n            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n            return invokeModelSetter(scope, {$$$p: newValue});\n          } else {\n            return parsedModel.assign(scope, newValue);\n          }\n        };\n\n        //expressions used by typeahead\n        var parserResult = typeaheadParser.parse(attrs.typeahead);\n\n        var hasFocus;\n\n        //Used to avoid bug in iOS webview where iOS keyboard does not fire\n        //mousedown & mouseup events\n        //Issue #3699\n        var selected;\n\n        //create a child scope for the typeahead directive so we are not polluting original scope\n        //with typeahead-specific data (matches, query etc.)\n        var scope = originalScope.$new();\n        var offDestroy = originalScope.$on('$destroy', function() {\n\t\t\t    scope.$destroy();\n        });\n        scope.$on('$destroy', offDestroy);\n\n        // WAI-ARIA\n        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n        element.attr({\n          'aria-autocomplete': 'list',\n          'aria-expanded': false,\n          'aria-owns': popupId\n        });\n\n        //pop-up element used to display matches\n        var popUpEl = angular.element('<div typeahead-popup></div>');\n        popUpEl.attr({\n          id: popupId,\n          matches: 'matches',\n          active: 'activeIdx',\n          select: 'select(activeIdx)',\n          'move-in-progress': 'moveInProgress',\n          query: 'query',\n          position: 'position'\n        });\n        //custom item template\n        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n        }\n\n        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n        }\n\n        var resetMatches = function() {\n          scope.matches = [];\n          scope.activeIdx = -1;\n          element.attr('aria-expanded', false);\n        };\n\n        var getMatchId = function(index) {\n          return popupId + '-option-' + index;\n        };\n\n        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n        // This attribute is added or removed automatically when the `activeIdx` changes.\n        scope.$watch('activeIdx', function(index) {\n          if (index < 0) {\n            element.removeAttr('aria-activedescendant');\n          } else {\n            element.attr('aria-activedescendant', getMatchId(index));\n          }\n        });\n\n        var inputIsExactMatch = function(inputValue, index) {\n          if (scope.matches.length > index && inputValue) {\n            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n          }\n\n          return false;\n        };\n\n        var getMatchesAsync = function(inputValue) {\n          var locals = {$viewValue: inputValue};\n          isLoadingSetter(originalScope, true);\n          isNoResultsSetter(originalScope, false);\n          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n            //it might happen that several async queries were in progress if a user were typing fast\n            //but we are interested only in responses that correspond to the current view value\n            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);\n            if (onCurrentRequest && hasFocus) {\n              if (matches && matches.length > 0) {\n                scope.activeIdx = focusFirst ? 0 : -1;\n                isNoResultsSetter(originalScope, false);\n                scope.matches.length = 0;\n\n                //transform labels\n                for (var i = 0; i < matches.length; i++) {\n                  locals[parserResult.itemName] = matches[i];\n                  scope.matches.push({\n                    id: getMatchId(i),\n                    label: parserResult.viewMapper(scope, locals),\n                    model: matches[i]\n                  });\n                }\n\n                scope.query = inputValue;\n                //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n                //due to other elements being rendered\n                recalculatePosition();\n\n                element.attr('aria-expanded', true);\n\n                //Select the single remaining option if user input matches\n                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n                  scope.select(0);\n                }\n              } else {\n                resetMatches();\n                isNoResultsSetter(originalScope, true);\n              }\n            }\n            if (onCurrentRequest) {\n              isLoadingSetter(originalScope, false);\n            }\n          }, function() {\n            resetMatches();\n            isLoadingSetter(originalScope, false);\n            isNoResultsSetter(originalScope, true);\n          });\n        };\n\n        // bind events only if appendToBody params exist - performance feature\n        if (appendToBody) {\n          angular.element($window).bind('resize', fireRecalculating);\n          $document.find('body').bind('scroll', fireRecalculating);\n        }\n\n        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n        var timeoutEventPromise;\n\n        // Default progress type\n        scope.moveInProgress = false;\n\n        function fireRecalculating() {\n          if (!scope.moveInProgress) {\n            scope.moveInProgress = true;\n            scope.$digest();\n          }\n\n          // Cancel previous timeout\n          if (timeoutEventPromise) {\n            $timeout.cancel(timeoutEventPromise);\n          }\n\n          // Debounced executing recalculate after events fired\n          timeoutEventPromise = $timeout(function() {\n            // if popup is visible\n            if (scope.matches.length) {\n              recalculatePosition();\n            }\n\n            scope.moveInProgress = false;\n          }, eventDebounceTime);\n        }\n\n        // recalculate actual position and set new values to scope\n        // after digest loop is popup in right position\n        function recalculatePosition() {\n          scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n          scope.position.top += element.prop('offsetHeight');\n        }\n\n        resetMatches();\n\n        //we need to propagate user's query so we can higlight matches\n        scope.query = undefined;\n\n        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n        var timeoutPromise;\n\n        var scheduleSearchWithTimeout = function(inputValue) {\n          timeoutPromise = $timeout(function() {\n            getMatchesAsync(inputValue);\n          }, waitTime);\n        };\n\n        var cancelPreviousTimeout = function() {\n          if (timeoutPromise) {\n            $timeout.cancel(timeoutPromise);\n          }\n        };\n\n        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n        modelCtrl.$parsers.unshift(function(inputValue) {\n          hasFocus = true;\n\n          if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n            if (waitTime > 0) {\n              cancelPreviousTimeout();\n              scheduleSearchWithTimeout(inputValue);\n            } else {\n              getMatchesAsync(inputValue);\n            }\n          } else {\n            isLoadingSetter(originalScope, false);\n            cancelPreviousTimeout();\n            resetMatches();\n          }\n\n          if (isEditable) {\n            return inputValue;\n          } else {\n            if (!inputValue) {\n              // Reset in case user had typed something previously.\n              modelCtrl.$setValidity('editable', true);\n              return null;\n            } else {\n              modelCtrl.$setValidity('editable', false);\n              return undefined;\n            }\n          }\n        });\n\n        modelCtrl.$formatters.push(function(modelValue) {\n          var candidateViewValue, emptyViewValue;\n          var locals = {};\n\n          // The validity may be set to false via $parsers (see above) if\n          // the model is restricted to selected values. If the model\n          // is set manually it is considered to be valid.\n          if (!isEditable) {\n            modelCtrl.$setValidity('editable', true);\n          }\n\n          if (inputFormatter) {\n            locals.$model = modelValue;\n            return inputFormatter(originalScope, locals);\n          } else {\n            //it might happen that we don't have enough info to properly render input value\n            //we need to check for this situation and simply return model value if we can't apply custom formatting\n            locals[parserResult.itemName] = modelValue;\n            candidateViewValue = parserResult.viewMapper(originalScope, locals);\n            locals[parserResult.itemName] = undefined;\n            emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n          }\n        });\n\n        scope.select = function(activeIdx) {\n          //called from within the $digest() cycle\n          var locals = {};\n          var model, item;\n\n          selected = true;\n          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n          model = parserResult.modelMapper(originalScope, locals);\n          $setModelValue(originalScope, model);\n          modelCtrl.$setValidity('editable', true);\n          modelCtrl.$setValidity('parse', true);\n\n          onSelectCallback(originalScope, {\n            $item: item,\n            $model: model,\n            $label: parserResult.viewMapper(originalScope, locals)\n          });\n\n          resetMatches();\n\n          //return focus to the input element if a match was selected via a mouse click event\n          // use timeout to avoid $rootScope:inprog error\n          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n            $timeout(function() { element[0].focus(); }, 0, false);\n          }\n        };\n\n        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n        element.bind('keydown', function(evt) {\n          //typeahead is open and an \"interesting\" key was pressed\n          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n            return;\n          }\n\n          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results\n          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {\n            resetMatches();\n            scope.$digest();\n            return;\n          }\n\n          evt.preventDefault();\n\n          if (evt.which === 40) {\n            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n            scope.$digest();\n          } else if (evt.which === 38) {\n            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n            scope.$digest();\n          } else if (evt.which === 13 || evt.which === 9) {\n            scope.$apply(function () {\n              scope.select(scope.activeIdx);\n            });\n          } else if (evt.which === 27) {\n            evt.stopPropagation();\n\n            resetMatches();\n            scope.$digest();\n          }\n        });\n\n        element.bind('blur', function() {\n          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n            selected = true;\n            scope.$apply(function() {\n              scope.select(scope.activeIdx);\n            });\n          }\n          hasFocus = false;\n          selected = false;\n        });\n\n        // Keep reference to click handler to unbind it.\n        var dismissClickHandler = function(evt) {\n          // Issue #3973\n          // Firefox treats right click as a click on document\n          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n            resetMatches();\n            if (!$rootScope.$$phase) {\n              scope.$digest();\n            }\n          }\n        };\n\n        $document.bind('click', dismissClickHandler);\n\n        originalScope.$on('$destroy', function() {\n          $document.unbind('click', dismissClickHandler);\n          if (appendToBody || appendToElementId) {\n            $popup.remove();\n          }\n\n          if (appendToBody) {\n            angular.element($window).unbind('resize', fireRecalculating);\n            $document.find('body').unbind('scroll', fireRecalculating);\n          }\n          // Prevent jQuery cache memory leak\n          popUpEl.remove();\n        });\n\n        var $popup = $compile(popUpEl)(scope);\n\n        if (appendToBody) {\n          $document.find('body').append($popup);\n        } else if (appendToElementId !== false) {\n          angular.element($document[0].getElementById(appendToElementId)).append($popup);\n        } else {\n          element.after($popup);\n        }\n      }\n    };\n  }])\n  \n  .directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        \n        if (!$typeaheadSuppressWarning) {\n          $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');\n        }\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          return scope.matches.length > 0;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active == matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx) {\n          scope.select({activeIdx:activeIdx});\n        };\n      }\n    };\n  }])\n  \n  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {\n    return {\n      restrict: 'EA',\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link:function(scope, element, attrs) {\n        if (!$typeaheadSuppressWarning) {\n          $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');\n        }\n\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          $compile(tplContent.trim())(scope, function(clonedElement) {\n            element.replaceWith(clonedElement);\n          });\n        });\n      }\n    };\n  }])\n  \n  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!$typeaheadSuppressWarning) {\n        $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');\n      }\n\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n\n      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n\n      return matchItem;\n    };\n  }]);\n\nangular.module(\"template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion-group.html\",\n    \"<div class=\\\"panel {{panelClass || 'panel-default'}}\\\">\\n\" +\n    \"  <div class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n    \"      <a href tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n    \"    </h4>\\n\" +\n    \"  </div>\\n\" +\n    \"  <div class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n    \"\t  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/accordion/accordion.html\",\n    \"<div class=\\\"panel-group\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/alert/alert.html\",\n    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n    \"    </button>\\n\" +\n    \"    <div ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/carousel/carousel.html\",\n    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ol>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/carousel/slide.html\",\n    \"<div ng-class=\\\"{\\n\" +\n    \"    'active': active\\n\" +\n    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/datepicker.html\",\n    \"<div ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n    \"</div>\");\n}]);\n\nangular.module(\"template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/day.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default btn-sm\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/month.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" dropdown-nested ng-if=\\\"isOpen\\\" style=\\\"display: block\\\" ng-style=\\\"{top: position.top+'px', left: position.left+'px'}\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"\t<li ng-transclude></li>\\n\" +\n    \"\t<li ng-if=\\\"showButtonBar\\\" style=\\\"padding:10px 9px 2px\\\">\\n\" +\n    \"\t\t<span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-info\\\" ng-click=\\\"select('today')\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"\t\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger\\\" ng-click=\\\"select(null)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"\t\t</span>\\n\" +\n    \"\t\t<button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right\\\" ng-click=\\\"close()\\\">{{ getText('close') }}</button>\\n\" +\n    \"\t</li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/datepicker/year.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"3\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\" style=\\\"width:100%;\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row track by dt.date\\\" class=\\\"text-center\\\" role=\\\"gridcell\\\" id=\\\"{{::dt.uid}}\\\" ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" style=\\\"min-width:100%;\\\" class=\\\"btn btn-default\\\" ng-class=\\\"{'btn-info': dt.selected, active: isActive(dt)}\\\" ng-click=\\\"select(dt.date)\\\" ng-disabled=\\\"dt.disabled\\\" tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/backdrop.html\",\n    \"<div uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"     modal-in-class=\\\"in\\\"\\n\" +\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n    \"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/modal/window.html\",\n    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"    modal-in-class=\\\"in\\\"\\n\" +\n    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n    \"    <div class=\\\"modal-dialog\\\" ng-class=\\\"size ? 'modal-' + size : ''\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/pagination/pagination.html\",\n    \"<ul class=\\\"pagination\\\">\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-html-popup.html\",\n    \"<div\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-popup.html\",\n    \"<div\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tooltip/tooltip-template-popup.html\",\n    \"<div\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover-html.html\",\n    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover-template.html\",\n    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\"\\n\" +\n    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/popover/popover.html\",\n    \"<div tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/bar.html\",\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n}]);\n\nangular.module(\"template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\">\\n\" +\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" style=\\\"min-width: 0;\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tab.html\",\n    \"<li ng-class=\\\"{active: active, disabled: disabled}\\\">\\n\" +\n    \"  <a href ng-click=\\\"select()\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/tabs/tabset.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"nav nav-{{type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n    \"  <div class=\\\"tab-content\\\">\\n\" +\n    \"    <div class=\\\"tab-pane\\\" \\n\" +\n    \"         ng-repeat=\\\"tab in tabs\\\" \\n\" +\n    \"         ng-class=\\\"{active: tab.active}\\\"\\n\" +\n    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/timepicker/timepicker.html\",\n    \"<table>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td>:</td>\\n\" +\n    \"      <td class=\\\"form-group\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-match.html\",\n    \"<a href tabindex=\\\"-1\\\" ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"></a>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" style=\\\"display: block;\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n!angular.$$csp() && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/ui-bootstrap-tpls.js\n ** module id = 15\n ** module chunks = 1\n **/"],"sourceRoot":""}