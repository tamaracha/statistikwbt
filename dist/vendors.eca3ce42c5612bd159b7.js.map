{"version":3,"sources":["webpack:///vendors.eca3ce42c5612bd159b7.js","webpack:///webpack/bootstrap eca3ce42c5612bd159b7","webpack:///external \"angular\"","webpack:///./~/api-check/dist/api-check.js","webpack:///./~/angular-formly/dist/formly.js","webpack:///./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js","webpack:///./~/angular-permission/dist/angular-permission.js","webpack:///./~/angular-ui-bootstrap/index.js","webpack:///./~/angular-ui-router.statehelper/statehelper.js","webpack:///./~/angular-ui-router/release/angular-ui-router.js","webpack:///./~/ngstorage/ngStorage.js","webpack:///./~/oclazyload/dist/ocLazyLoad.js","webpack:///./~/utf8/utf8.js","webpack:///./src/angular-locale_de-de.js","webpack:///./~/angular-ui-bootstrap/dist/ui-bootstrap-tpls.js","webpack:///(webpack)/buildin/module.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","_m","args","slice","templateId","a","b","c","this","concat","shift",1,"e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","0","2","3","appendChild","m","Object","prototype","hasOwnProperty","fn","angular","root","factory","_interopRequireDefault","obj","__esModule","default","defineProperty","value","_apiCheck","_apiCheck2","getApiCheckInstance","apiCheck","api","output","config","disabled","globalConfig","apiTypes","argTypes","passed","message","failed","checkApiCheckApi","arguments","Array","isArray","messages","checkEnoughArgs","checkApiWithArgs","returnObject","getTypes","getErrorMessage","checkApiArgs","isArrayOrArgs","Error","prefix","errors","apiCheckApis","handleErrorMessage","getApiCheck","shouldThrow","result","console","warn","getPrefix","onlyPrefix","gOut","trim","getSuffix","s","onlySuffix","suffix","getUrl","u","url","docsBaseUrl","urlSuffix","join","passedAndShouldHavePassed","buildMessageFromApiAndArgs","replaceFunctionWithName","each","val","name","replacedItems","indexOf","displayName","getObjectString","types","stringify","generateMessage","n","useS","keys","newLine","passedArgs","_getTypes","copy","arrayify","map","checker","index","specified","getCheckerDisplay","terse","verbose","addHelpers","arg","getArgDisplay","extraCheckers","apiCheckApiCheck","getApiCheckInstanceCheckers","additionalProperties","throw","utils","apiCheckUtil","wrapper","checkers","getCheckers","checkerIndex","argIndex","res","lastChecker","argName","argFailed","skipPreviousChecker","isOptional","isError","getCheckerErrorMessage","t","checkerTypeType","checkerType","location","apiCheckDataChecker","shape","string","optional","bool","asFunc","func","withProperties","__apiCheckData","asShape","wrongShape","oneOfType","getError","checkerHelp","getCheckerHelp","_ref","help","requiredArgs","filter","gottenArgs","hasKeys","getDisplayIfNotGotten","getDisplay","cName","constructor","typeOf","properties","argDisplay","v","k","getApiCheckApis","os","checkerFnChecker","shortType","notOptional","notRequired","strict","objectOf","typeOrArrayOf","any","VERSION","internalChecker","getSerialize","decycle","seen","key","getPath","ret","path","unshift","spaces","JSON","_defineProperty","enumerable","configurable","writable","daCopy","RegExp","options","display","short","getCheckerType","typeTypes","iterator","context","eachArry","eachObj","hasOwn","list","arry","finalJoin","last","pop","stringType","nAtL","tName","tLocation","thing","undef","setupChecker","getNoop","isNoop","prop","getRequiredVersion","notNullable","addNullable","addOptional","requiredChecker","copyProps","originalChecker","optionalCheck","fixType","nullableCheck","isNullable","nullable","checkerCopy","dest","noop","checkerHelpers","typeOfCheckGetter","lType","toLowerCase","funcCheckGetter","functionChecker","apiError","shapeChecker","notFunction","objectCheckGetter","nullType","objectNullOkChecker","objectChecker","nullOk","instanceCheckGetter","classToCheck","oneOfCheckGetter","enums","enum","enm","some","oneOfTypeCheckGetter","typeCheckers","checkersDisplay","arrayOfCheckGetter","shortCheckerDisplay","array","every","item","objectOfCheckGetter","checkerDisplay","notObject","object","allTypesSuccess","typeOrArrayOfCheckGetter","arrayOf","getShapeCheckGetter","shapeCheckGetter","nonObject","modifyTypeDisplayToHelpOut","theRet","required","addHelper","property","objectMessage","stringMessage","error","toUpperCase","parentRequired","strictType","shapeTypes","isObject","shapePropError","shapeError","allowedProperties","extraProps","getRequiredIfNotChecker","all","otherProps","propChecker","props","ifProps","description","getTypeForShapeChild","propName","propExists","iteration","otherPropsExist","otherProp","ifNot","onlyIf","othersPresent","requiredIfNot","argumentsCheckerGetter","number","anyCheckGetter","nullCheckGetter","rangeCheckGetter","min","max","lessThanCheckGetter","greaterThanCheckGetter","emptyObjectCheckGetter","emptyObject","instanceOf","oneOf","range","lessThan","greaterThan","null","_require",5,"__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_5__","_indexCommon","_indexCommon2","_angularFix","_angularFix2","_providersFormlyApiCheck","_providersFormlyApiCheck2","_otherDocsBaseUrl","_otherDocsBaseUrl2","_providersFormlyUsability","_providersFormlyUsability2","_providersFormlyConfig","_providersFormlyConfig2","_providersFormlyValidationMessages","_providersFormlyValidationMessages2","_servicesFormlyUtil","_servicesFormlyUtil2","_servicesFormlyWarn","_servicesFormlyWarn2","_directivesFormlyCustomValidation","_directivesFormlyCustomValidation2","_directivesFormlyField","_directivesFormlyField2","_directivesFormlyFocus","_directivesFormlyFocus2","_directivesFormlyForm","_directivesFormlyForm2","_runFormlyNgModelAttrsManipulator","_runFormlyNgModelAttrsManipulator2","_runFormlyCustomTags","_runFormlyCustomTags2","ngModuleName","ngModule","constant","provider","directive","run","version","shapeRequiredIfNot","shapeRequiredIfNotDefinition","formlyExpression","specifyWrapperType","apiCheckProperty","apiCheckInstanceProperty","apiCheckFunctionProperty","formlyWrapperType","template","templateUrl","overwriteOk","apiCheckInstance","apiCheckFunction","apiCheckOptions","expressionProperties","expression","modelChecker","templateManipulators","preWrapper","postWrapper","validatorChecker","watcherChecker","listener","runFieldExpressions","fieldOptionsApiShape","$$hashKey","model","originalModel","className","extras","validateOnModelChange","skipNgModelAttrsManipulator","data","templateOptions","modelOptions","updateOn","debounce","allowInvalid","getterSetter","timezone","watcher","validators","asyncValidators","parsers","formatters","noFormControl","hide","hideExpression","ngModelElAttrs","ngModelAttrs","statement","attribute","bound","boolean","elementAttributes","optionsTypes","link","controller","validation","show","errorExistsAndShouldBeVisible","formControl","runExpressions","resetModel","updateInitialValue","initialValue","defaultValue","formlyFieldOptions","formOptionsApi","formState","removeChromeAutoComplete","manualModelWatcher","watchAllExpressions","fieldTransform","fieldGroup","form","typeOptionsDefaultOptions","formlyTypeOptions","defaultOptions","extends","extend","formlyUsability","formlyApiCheck","formlyErrorAndWarningsUrlPrefix","getFieldError","errorInfoSlug","field","toJson","getFormlyError","checkWrapper","checkWrapperTemplate","additionalInfo","formlyTransclude","_this","$get","$inject","_toConsumableArray","arr","arr2","from","formlyConfig","formlyUsabilityProvider","setType","checkType","extendTypeOptions","typeMap","_ret","allTypes","forEach","checkOverwrite","extendsType","getType","extendTypeControllerFunction","extendTypeLinkFunction","extendTypeDefaultOptions","_otherUtils2","reverseDeepMerge","extendTemplate","extendsCtrl","isDefined","optionsCtrl","$scope","$controller","extendsFn","optionsFn","extendsDO","optionsDO","optionsDOIsFn","isFunction","extendsDOIsFn","opts","scope","extendsDefaultOptions","mergedDefaultOptions","extenderOptionsDefaultOptions","newDefaultOptions","throwError","errorContext","getTypeHeritage","parent","heritage","isString","setWrapper","_x","_x2","_again","wrapperOptions","getOptionsTypes","getOptionsName","checkWrapperAPI","templateWrappersMap","defaultWrapperName","checkWrapperTypes","newValue","objectName","getWrapper","getWrapperByType","wrappers","_name","removeWrapperByName","removeWrappersForType","disableWarnings","warnInfoSlug","_this2","disableNgModelAttrsManipulator","ngModelAttrsManipulatorPreferUnbound","defaultHideDirective","getFieldId","_otherUtils","containsSelector","containsSpecialChar","formlyEval","$modelValue","$viewValue","extraLocals","$eval","formId","objAndSameType","obj1","obj2","getPrototypeOf","findByNodeName","el","nodeName","element","children","node","extendFunction","_len","fns","_key","extendArray","primary","secondary","startsWith","str","search","substring","contains","formlyValidationMessages","addTemplateOptionValueMessage","alternate","validationMessages","templateOptionValue","addStringMessage","viewValue","modelValue","formlyUtil","formlyWarn","$log","formlyCustomValidation","restrict","require","attrs","ctrl","addValidatorToPipeline","isAsync","validator","setupMessage","useNewValidatorsApi","setupWithValidators","setupWithParsers","validatorCollection","inFlightValidator","$parsers","isValid","$pending","then","$setValidity","bind","formlyField","$http","$q","$compile","$templateCache","$interpolate","FormlyFieldController","$timeout","$parse","currentValue","valueGetterSetter","setter","assign","promise","when","watchExpressions","formOptions","$watch","newVal","parseSet","parseGet","shouldNotUseParseKey","isNumber","simplifyLife","to","setFieldIdAndName","formName","$name","setDefaultValue","setInitialValue","mergeFieldOptionsWithTypeDefaults","mergeOptions","properOrder","reverse","typeName","extraOptions","extendOptionsWithDefaults","resetFormControl","$setUntouched","$setPristine","isMultiNgModel","$setViewValue","$render","$root","$$phase","$digest","addValidationMessages","invokeControllers","setupFieldGroup","fieldType","getFieldType","checkApi","fieldLink","formlyFormCtrl","setFieldGroupTemplate","checkFieldGroupApi","addClass","extraAttributes","getTemplate","transcludeInWrappers","setElementTemplate","addAttributes","attr","addClasses","templateString","html","asHtml","contents","watchFormControl","watchFieldNameOrExistence","nameExpressionRegex","nameExpression","exec","watchFieldExistence","fieldCount","fc","stopWatchingShowError","addShowMessagesWatcher","addParsers","addFormatters","customExpression","errorExistsAndShouldBeVisibleExpression","formControls","$invalid","noTouchedButDirty","isUndefined","$touched","$dirty","showError","setParsersOrFormatters","formWasPristine","$pristine","$formatters","formatter","which","getThingsFromType","theType","typeThings","getDefaultOptionsProperty","getThingsFromOptionsTypes","getDefaultOptionsOptionsTypes","optionsTypesThings","optionsTypeName","getFormlyExpressionThing","formlyExpressionParserOrFormatterFunction","originalThingProp","things","ngModelCtrls","ngModelCtrl","_ngModelCtrl","templateEl","ngModelNodes","querySelectorAll","ngModelNode","getAttribute","callLinkFunctions","thusly","runManipulators","manipulators","templateToManipulate","chain","manipulator","newTemplate","fieldManipulators","getManipulators","getFieldTemplate","append","addManipulators","_ref$preWrapper","pre","_ref$postWrapper","post","fromOptionsOrType","isUrl","templatePromise","_ret3","httpOptions","cache","get","response","getWrapperOption","aWrapper","runApiCheck","promises","w","wrappersTemplates","wrapperTemplate","totalWrapper","doTransclusion","superWrapper","transcludeEl","find","replaceWith","typeWrappers","formWrappers","defaultWrapper","_ref2","forType","runApiCheckForType","instance","checkerObjects","checkOptions","transclude","fields","formlyFocus","$document","previousEl","doc","$observe","activeElement","focus","focusWait","blur","formlyForm","formlyFormGetTemplate","getRootEl","rootEl","getFieldRootEl","fieldRootEl","getHideDirective","hideDirective","getTrackBy","trackBy","getFormName","bindName","minor","startSymbol","endSymbol","getTranscludeClass","transcludeClass","copyAttributes","attributes","excluded","arrayAttrs","toKebabCase","currentFormId","parentFormAttributes","hasClass","FormlyFormController","onModelOrFormStateChange","runFieldExpressionProperties","validateFormControl","validate","$validate","evalCloseToFormlyExpression","setupFields","checkDeprecatedOptions","fieldTransforms","setupModels","setupHideExpressionWatcher","attachKey","setupWatchers","setupOptions","isFieldGroup","watchedModels","isNewModel","initModel","referencesCurrentlyWatchedModel","watchers","watchExpression","getWatchExpression","watchListener","getWatchListener","stopWatching","watchDeep","toString","split","originalExpression","modifyArgs","_slice","originalListener","originalArgs","getFormlyFieldLikeLocals","formlyFormLink","setFormController","theFormlyForm","getter","parentForm","$parent","$removeControl","removeData","fixChromeAutocomplete","global","offInstance","onInstance","input","setAttribute","replace","$1","addFormlyNgModelAttrsManipulator","ngModelAttrsManipulator","addValidation","addIfNotPresent","modelNodes","alterNgModelAttr","isPropertyAccessor","addRegardlessOfPresence","addModelOptions","addTemplateOptionsAttrs","ep","ngModelAttributes","getBuiltInAttributes","attrVal","attrName","ref","toVal","epVal","getEpValue","inTo","inEp","addNgModelElAttrs","skip","innerHTML","getNgModelNodes","selectorNot","skipNot","query","getNgModelNodesFallback","allNgModelNodes","matchingNgModelNodes","hasAttribute","nodeMatches","selector","div","outerHTML","querySelector","boundOnly","bothBooleanAndBound","bothAttributeAndBound","statementOnly","attributeOnly","substr","nodes","addCustomTags","documentMode","customElements",7,"__WEBPACK_EXTERNAL_MODULE_4__","addWrappers","formlyConfigProvider","check","label","labelSrOnly","addCheckboxType","labelProp","valueProp","checkValidity","expressionValue","valid","setModel","multiCheckbox","checked","checkbox","$setTouched","change","newModelValue","newOptionsValues","unwatchFormControl","addInputType","addRadioType","addSelectType","ngOptions","optionsAttr","groupProp","addTextareaType","rows","cols","_addons","_addons2","_description","_description2","addAddonsManipulator","formlyBootstrapApiCheck","addonTemplate","addonChecker","class","text","onClick","addonLeft","addonRight","addDescriptionManipulator","modelEls",8,"permission","$stateProvider","decorator","state","parentFn","self","getState","$rootScope","$state","Authorization","PermissionMap","$on","event","toState","toParams","fromState","fromParams","areSetStatePermissions","permissions","setStateAuthorizationStatus","status","$$isAuthorizationFinished","areStateEventsDefaultPrevented","isStateChangePermissionStartDefaultPrevented","isStateChangeStartDefaultPrevented","compensatePermissionMap","statePermissionMap","permissionMap","redirectTo","toStatePath","extendPermissionMap","authorizeForState","authorize","$broadcast","goToState","rejectedPermission","redirectToState","go","notify","defaultPrevented","preventDefault","compensatedPermissionMap","only","resolvePermissionMapProperty","except","handleFunctionRedirect","redirectFunction","redirectState","TypeError","handleStringRedirect","handleObjectRedirect","redirectObject","ReferenceError","rejectedPermissionName","Permission","permissionName","validationFunction","validateConstructor","wrapInPromise","dfd","defer","resolve","reject","validatePermission","validationResult","PermissionStore","Role","roleName","permissionNames","defineManyPermissions","validateRole","hasPermissionDefinition","getPermissionDefinition","service","definePermission","permissionStore","removePermissionDefinition","getStore","clearStore","defineRole","roleStore","removeRoleDefinition","hasRoleDefinition","getRoleDefinition","removeClass","RoleStore","permissionsMap","handleAuthorization","deferred","exceptPromises","findMatchingPermissions","rejectedPermissions","onlyPromises","resolvedPermissions","handleRoleValidation","handlePermissionValidation","role",9,10,"fixStateName","addSiblings","childState","idx","nextSibling","previousSibling","keepOriginalNames","siblingTraversal","setNestedState",11,"inherit","extra","merge","dst","ancestors","first","second","objectKeys","Number","len","Math","ceil","floor","inheritParams","currentParams","newParams","$current","$to","parentParams","parents","inherited","inheritList","params","j","equalForKeys","filterByKeys","values","filtered","pick","omit","collection","$Resolve","$injector","VISIT_IN_PROGRESS","VISIT_DONE","NOTHING","NO_DEPENDENCIES","NO_LOCALS","NO_PARENT","$$promises","$$values","study","invocables","visit","visited","cycle","splice","plan","annotate","param","isResolve","invocableKeys","locals","done","wait","merged","$$inheritedValues","resolution","fail","reason","$$failure","invoke","invocable","onfailure","invocation","proceed","waitParams","dep","ii","$TemplateFactory","fromConfig","fromString","fromUrl","templateProvider","fromProvider","headers","Accept","UrlMatcher","pattern","parentMatcher","addParameter","paramNames","test","$$UMFP","Param","quoteRegExp","squash","surroundPattern","matchDetails","isSearch","regexp","segment","cfg","caseInsensitive","placeholder","searchPlaceholder","compiled","segments","$$new","ParamSet","source","lastIndex","sourceSearch","sourcePath","$$paramNames","Type","$UrlMatcherFactory","valToString","valFromString","getDefaultConfig","isStrictMode","isCaseInsensitive","isInjectable","flushTypeQueue","typeQueue","$types","injector","def","defaultSquashPolicy","enqueue","defaultTypes","encode","decode","is","int","parseInt","date","getFullYear","getMonth","getDate","match","capture","Date","isNaN","valueOf","equals","toISOString","json","fromJson","identity","$$getDefaultValue","strictMode","compile","isMatcher","o","definition","definitionFn","unwrapShorthand","isShorthand","$$fn","urlType","getArrayMode","arrayDefaults","arrayParamNomenclature","getSquashPolicy","getReplace","arrayMode","configuredKeys","defaultPolicy","$value","hasReplaceVal","$replace","replacement","$normalize","$asArray","dynamic","$$parent","$$keys","ignore","paramset","paramValues","$$equals","paramValues1","paramValues2","equal","left","right","$$validates","rawVal","normalized","encoded","$UrlRouterProvider","$locationProvider","$urlMatcherFactory","regExpPrefix","re","interpolate","what","handleIfMatch","handler","$match","$location","$browser","$sniffer","appendBasePath","isHtml5","absolute","baseHref","update","evt","rule","handled","lastPushedUrl","rules","otherwise","listen","interceptDeferred","sync","read","urlMatcher","format","$$avoidResync","href","validates","html5Mode","enabled","history","hashPrefix","slash","port","protocol","host","redirect","handlerIsString","strategies","matcher","regex","sticky","deferIntercept","$StateProvider","$urlRouterProvider","isRelative","stateName","findState","stateOrName","base","isStr","rel","pathLength","current","states","queueState","parentName","queue","flushQueuedChildren","queued","registerState","lastIndexOf","stateBuilder","$delegates","abstractKey","$stateParams","navigable","transitionTo","isGlob","doesStateMatchGlob","glob","globSegments","l","MAX_VALUE","$view","$resolve","$urlRouter","handleRedirect","TransitionAborted","retry","$retry","TransitionFailed","retryTransition","transition","TransitionSuperseded","resolveState","paramsAreFiltered","resolveViews","viewsPromises","views","view","injectables","$template","load","globals","controllerProvider","injectLocals","$$controller","$$state","$$controllerAs","controllerAs","TransitionPrevented","reload","relative","fromPath","hash","redirectResult","toPath","keep","toLocals","reloadState","ownParams","shouldSkipReload","resolved","entering","exiting","onExit","onEnter","includes","lossy","nav","nonSearchParamsEqual","fromAndToState","notSearchParam","nonQueryParamKeys","nonQueryParams","nonQueryParamSet","reloadOnSearch","compositeName","charAt","","abstract","$ViewProvider","$templateFactory","defaults","$ViewScrollProvider","useAnchorScroll","$anchorScroll","$element","scrollIntoView","$ViewDirective","$uiViewScroll","getService","has","getRenderer","animEnabled","ngMajorVer","ngMinorVer","$animate","$animator","statics","enter","target","cb","after","leave","remove","noanimation","animate","terminal","priority","tElement","tAttrs","$transclude","cleanupLastView","cleanOld","_previousEl","_currentScope","$destroy","currentScope","_willBeDestroyed","currentEl","renderer","updateView","firstTime","newScope","getUiViewName","previousLocals","latestLocals","$new","$emit","clone","autoScrollExp","onloadExp","onload","autoscroll","$ViewDirectiveFill","initial","uiView","inheritedData","parseStateRef","parsed","preparsed","paramExpr","stateContext","stateData","getTypeInfo","isSvg","isForm","isAnchor","clickable","clickHook","button","ctrlKey","metaKey","shiftKey","ignorePreventDefaultCount","cancel","defaultOpts","$StateRefDirective","uiSrefActive","uiSref","active","uiSrefOpts","$$addStateInfo","$set","$StateRefDynamicDirective","runStateRefLink","group","uiState","uiStateParams","uiStateOpts","watch","$StateRefActiveDirective","$attrs","addState","stateParams","activeClass","stateHash","createStateHash","activeClasses","anyMatch","exactMatch","activeEqClass","uiSrefActiveEq","newState","$IsStateFilter","isFilter","$stateful","$IncludedByStateFilter","includesFilter","defaultConfig","searchParams","decodePathArray","reverseString","unquoteDashes","allReversed","paramName","parameters","nTotal","nPath","paramVal","encodeDashes","encodeURIComponent","charCodeAt","isPathParam","isDefaultValue","nextSegment","isFinalPathParam","$subPattern","sub","mode","ArrayType","bindTo","callbackName","arrayWrap","arrayUnwrap","falsey","arrayHandler","allTruthyMode","arrayEqualsHandler","val1","val2","$arrayMode","major",12,"__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_storageProvider","storageType","storageKeyPrefix","setKeyPrefix","serializer","deserializer","setSerializer","setDeserializer","d","getItem","set","setItem","$window","isStorageSupported","supported","err","round","random","localStorage","removeItem","_last$storage","_debounce","prefixLength","webStorage","$storage","$default","items","$sync","$reset","$apply","temp$storage","addEventListener","hasFocus",13,"regModules","regInvokes","regConfigs","modulesToLoad","realModules","recordDeclarations","broadcast","runBlocks","justLoaded","ocLazyLoad","$controllerProvider","$provide","$compileProvider","$filterProvider","$animateProvider","_register","providers","registerModules","moduleName","moduleFn","tempRunBlocks","getModuleName","newModule","ngModuleFct","requires","_runBlocks","rerun","_invokeQueue","reconfig","_configBlocks","instanceInjector","getInstanceInjector","_registerInvokeList","checkHashes","potentialNew","invokes","newHash","isNew","signature","hashCode","invokeList","newInvoke","onInvoke","invokeName","callInvoke","fct","invoked","jlen","moduleExists","debug","events","moduleCache","modulePromises","moduleConfig","_init","elements","names","NG_APP_CLASS_REGEXP","elm","getElementById","jasmine","mocha","mock","addReg","mainModule","chr","$rootElement","$cacheFactory","filesCache","eventName","info","_broadcast","_$log","_getFilesCache","toggleWatch","getModuleConfig","setModuleConfig","getModules","isLoaded","modulesNames","moduleLoaded","_getModuleName","_getModule","_loadDependencies","localParams","loadedModule","diff","promisesList","getRequires","requireEntry","files","filesLoader","entry","inject","real","_addToLoadList","loadNext","requireModule","_unregister","bootstrapFct","bootstrap","force","configFn","$ocLazyLoad","content","$attr","$delegate","$interval","uaCssChecked","useCssLoadPatch","anchor","buildElement","cacheBuster","dc","getTime","put","onerror","serie","insertBeforeElem","lastChild","insertBefore","jQuery","parentNode","ua","navigator","userAgent","platform","appVersion","iOSVersion","parseFloat","androidVersion","versionMatch","tries","interval","sheet","cssRules","cssFiles","templatesFiles","jsFiles","cachePromise","pushFile","file_type","jsLoader","cssDeferred","cssLoader","templatesDeferred","templatesLoader","jsDeferred","originalModule","errText","originalParams","deferredList","paths","ocLazyLoadLoader","success","searchElement","fromIndex","O","abs","Infinity",14,"ucs2decode","counter","ucs2encode","stringFromCharCode","checkScalarValue","codePoint","createByte","encodeCodePoint","symbol","utf8encode","codePoints","byteString","readContinuationByte","byteIndex","byteCount","continuationByte","byteArray","decodeSymbol","byte1","byte2","byte3","byte4","utf8decode","tmp","freeExports","freeGlobal","String","fromCharCode","utf8",15,"getDecimals","getVF","opt_precision","pow","f","PLURAL_CATEGORY","ZERO","ONE","TWO","FEW","MANY","OTHER","DATETIME_FORMATS","AMPMS","DAY","ERANAMES","ERAS","FIRSTDAYOFWEEK","MONTH","SHORTDAY","SHORTMONTH","STANDALONEMONTH","WEEKENDRANGE","fullDate","longDate","medium","mediumDate","mediumTime","shortDate","shortTime","NUMBER_FORMATS","CURRENCY_SYM","DECIMAL_SEP","GROUP_SEP","PATTERNS","gSize","lgSize","maxFrac","minFrac","minInt","negPre","negSuf","posPre","posSuf","pluralCat","vf",16,"$animateCss","expand","expandingExpr","easing","height","scrollHeight","start","expandDone","css","expandedExpr","collapse","collapsingExpr","collapseDone","collapsedExpr","expanding","expanded","collapsing","collapsed","uibCollapse","shouldCollapse","closeOthers","accordionConfig","groups","openGroup","isOpen","addGroup","groupScope","that","removeGroup","heading","isDisabled","setHeading","accordionCtrl","openClass","panelClass","toggleClass","toggleOpen","$event","$id","headingId","panelId","accordionGroupCtrl","uibAccordionTransclude","elem","closeable","close","dismissOnTimeout","toggleEvent","buttonConfig","ctrls","buttonsCtrl","uncheckableExpr","uibUncheckable","uibBtnRadio","on","isActive","uncheckable","getTrueValue","getCheckboxValue","btnCheckboxTrue","getFalseValue","btnCheckboxFalse","clearBufferedTransitions","bufferedTransitions","setActive","slides","slide","goNext","direction","destroyed","currentIndex","$currentTransition","SLIDE_DIRECTION","currentIdx","getCurrentIndex","phase","off","nextSlide","nextIndex","nextDirection","restartTimer","findSlideIndex","resetTimer","currentInterval","resetTransition","timerFn","isPlaying","next","pause","addSlide","sort","select","play","newIndex","noWrap","prev","removeSlide","bufferedIndex","indexOfSlide","noPause","noTransition","$watchCollection","actual","carouselCtrl","animation","beforeAddClass","stopped","directionClass","removeClassFn","beforeRemoveClass","$locale","dateFilter","orderByFilter","createParser","quoteIndex","inLiteral","formatCodeToRegex","year","month","toInt","toTimezone","convertTimezoneToLocal","fromTimezone","timezoneToOffset","fallback","requestedTimezoneOffset","parse","addDateMinutes","minutes","setMinutes","getMinutes","timezoneOffset","getTimezoneOffset","localeId","SPECIAL_CHARACTERS_REGEXP","init","_date","setFullYear","hours","milliseconds","seconds","matches","sign","isDate","parser","_format","reduce","mapper","endStr","baseDate","results","tzOffset","dt","getHours","getSeconds","getMilliseconds","datesetter","setUTCFullYear","timesetter","setUTCHours","setHours","ON_REGEXP","IS_REGEXP","linkFn","linkedScopes","instances","exps","exp","addForExp","removeScope","clazz","compareWithExp","expToData","watchFn","compareWithVal","newActivated","thisVal","onExp","lastActivated","removedScope","targetScope","newWatchScope","onExpMatches","uibIsClass","expsStr","SCROLLBAR_WIDTH","OVERFLOW_REGEX","normal","hidden","PLACEMENT_REGEX","auto","vertical","getRawNode","parseStyle","isFinite","offsetParent","isStaticPositioned","getComputedStyle","position","documentElement","scrollbarWidth","scrollElem","offsetWidth","clientWidth","isScrollable","includeHidden","overflowRegex","elemStyle","overflow","overflowY","overflowX","scrollParent","documentEl","excludeStatic","parentElement","spStyle","includeMagins","elemOffset","offset","top","marginTop","marginLeft","parentOffset","clientTop","scrollTop","clientLeft","scrollLeft","width","offsetHeight","elemBCR","getBoundingClientRect","pageYOffset","pageXOffset","viewportOffset","useDocument","includePadding","offsetBCR","bottom","offsetParentBCR","clientHeight","offsetParentStyle","paddingTop","paddingBottom","paddingLeft","paddingRight","parsePlacement","placement","autoPlace","positionElements","hostElem","targetElem","appendToBody","targetWidth","targetHeight","hostElemPos","targetElemPos","targetElemStyle","adjustedSize","marginRight","marginBottom","xOverflow","yOverflow","positionArrow","innerElem","isTooltip","arrowElem","arrowCss","borderProp","borderWidth","borderRadiusProp","borderRadius","datepickerMode","formatDay","formatMonth","formatYear","formatDayHeader","formatDayTitle","formatMonthTitle","maxDate","maxMode","minDate","minMode","ngModelOptions","shortcutPropagation","showWeeks","yearColumns","yearRows","datepickerConfig","$datepickerSuppressError","datepickerAttributeWarning","dateParser","setMode","optionsUsed","datepickerOptions","watchListeners","modes","startingDay","refreshView","initDate","activeDate","$isEmpty","uniqueId","ngDisabled","dateObject","compare","activeDateId","uid","ngModelCtrl_","$options","render","selectedDt","_refreshView","activeDt","createDateObject","selected","customClass","dateDisabled","size","arrays","move","step","years","months","toggleMode",32,33,34,35,36,37,38,39,40,"focusElement","keydown","altKey","stopPropagation","handleKeyDown","getDaysInMonth","DAYS_IN_MONTH","getISO8601WeekNumber","checkDate","setDate","getDay","time","setMonth","getDates","startDate","dates","firstDayOfMonth","difference","numDisplayedFromPreviousMonth","firstDate","days","labels","abbr","full","title","weekNumbers","thursdayIndex","numWeeks","curWeek","date1","date2","_date1","_date2","getStartingYear","columns","yearpickerInit","datepickerCtrl","daypickerCtrl","monthpickerCtrl","altInputFormats","clearText","closeOnDateSelection","closeText","currentText","datepickerPopup","datepickerPopupTemplateUrl","datepickerTemplateUrl","html5Types","datetime-local","onOpenFocus","showButtonBar","$position","datepickerPopupConfig","datepickerPopupAttributeWarning","cameltoDash","parseDateString","dateFormat","parseDate","ngModel","ngRequired","documentClickBind","popup","$popup","dpContainsTarget","popupContainsTarget","inputKeydownBind","positionPopup","dpElement","popupPlacement","popupEl","datepickerEl","scrollParentEl","isHtml5DateInput","watchData","_ngModel_","datepickerAppendToBody","uibDatepickerPopup","oldValue","newDateFormat","updateOnDefault","ng-model","ng-model-options","ng-change","template-url","propConfig","$$parserName","$validators","$viewChangeListeners","getText","dateSelection","today","debounceTime","timeoutPromise","appendToOpenClass","openScope","open","dropdownScope","closeDropdown","keybindFilter","getAutoClose","toggleElement","getToggleElement","dropdownElement","getDropdownElement","focusToggleElement","isKeynavEnabled","focusDropdownEntry","dropdownConfig","uibDropdownService","$templateRequest","templateScope","getIsOpen","setIsOpen","toggleInvoker","onToggle","appendTo","keynavEnabled","body","dropdownAppendTo","appendToEl","dropdownAppendToBody","keyboardNav","dropdownMenu","toggle","autoClose","getElement","keyCode","elems","eq","selectedOption","wasOpen","rightalign","pos","innerWidth","appendOffset","openContainer","hasOpenClass","dropdownMenuTemplateUrl","tplContent","newEl","dropdownCtrl","dropdownNested","tplUrl","toggleDropdown","aria-haspopup","aria-expanded","unbind","createNew","stack","add","removeTop","entries","hasKey","resolver","setResolver","resolves","resolveObj","resolveIter","$modalStack","modalInClass","NOW_CLOSING_EVENT","setIsAsync","modalOptions","backdropClass","windowClass","windowTopClass","modal","getTop","backdrop","currentTarget","dismiss","$isRendered","modalRenderDeferObj","animationPromise","modalRendered","inputWithAutofocus","modalAnimation","uibModalAnimationClass","empty","$$multiMap","$$stackedMap","backdropIndex","topBackdropIndex","opened","openedWindows","removeModalWindow","modalInstance","elementToReceiveFocus","modalWindow","appendToElement","removeAfterAnimate","modalDomEl","modalScope","modalBodyClass","openedClass","OPENED_MODAL_CLASS","openedClasses","toggleTopWindowClass","closedDeferred","checkRemoveBackdrop","toggleSwitch","backdropDomEl","backdropScopeRef","backdropScope","domEl","afterAnimating","asyncDeferred","asyncPromise","keydownListener","isDefaultPrevented","keyboard","loadFocusElementList","focusChanged","isFocusInFirstItem","isModalFocused","focusLastFocusableElement","isFocusInLastItem","focusFirstFocusableElement","broadcastClosing","resultOrReason","closing","focusableElementList","focusIndex","tababbleSelector","newBackdropIndex","modalOpener","renderDeferred","currBackdropIndex","angularDomEl","windowTemplateUrl","window-class","window-top-class","$$uibDestructionScheduled","clearFocusListCache","dismissAll","topModal","srcElement","modalDomE1","$modalProvider","$uibResolve","getTemplatePromise","$modal","promiseChain","getPromiseChain","resolveWithTemplate","templateAndResolvePromise","modalResultDeferred","modalOpenedDeferred","modalClosedDeferred","modalRenderDeferred","closed","rendered","samePromise","tplAndVars","providedScope","$close","$dismiss","ctrlInstance","ctrlLocals","$uibModalInstance","bindToController","$onInit","create","setNumPages","numPages","_watchers","itemsPerPage","totalPages","calculateTotalPages","updatePage","newTotal","oldTotal","totalItems","page","selectPage","clickAllowed","noPrevious","noNext","uibPaging","uibPagerConfig","align","previousText","nextText","paginationCtrl","uibPaginationConfig","makePage","getPages","currentPage","pages","startPage","endPage","isMaxSized","maxSize","rotate","pageLabel","forceEllipses","boundaryLinkNumbers","previousPageSet","secondPageLink","firstPageLink","nextPageSet","secondToLastPageLink","lastPageLink","$page","boundaryLinks","directionLinks","originalRender","firstText","lastText","snake_case","separator","letter","placementClassPrefix","popupDelay","popupCloseDelay","useContentExp","triggerMap","mouseenter","click","outsideClick","none","globalOptions","setTriggers","triggers","keypressListener","openedTooltips","ttType","defaultTriggerShow","getTriggers","trigger","directiveName","startSym","endSym","tElem","tooltipLinker","tooltipCtrl","toggleTooltipBind","ttScope","hideTooltipBind","showTooltipBind","hasEnableExp","cancelHide","prepareTooltip","showTimeout","cancelShow","hideTimeout","createTooltip","$evalAsync","assignIsOpen","positionTooltip","positionTimeout","transitionTimeout","removeTooltip","tooltip","tooltipLinkedScope","prepObservers","unregisterObservers","contentParse","popupClass","lastPlacement","delay","closeDelay","isOpenParse","observers","repositionScheduled","$$postDigest","observer","bodyHideTooltipBind","prepTriggers","unregisterTriggers","ttPosition","origScope","contentExp","appendToBodyVal","appendKey","$sce","previousElement","currentElement","tooltipTemplateTranscludeScope","changeCounter","cleanupLastIncludeContent","parseAsResourceUrl","uibTooltipTemplateTransclude","thisChangeId","$uibPosition","tooltipAnimationClass","$uibTooltip","originScope","progressConfig","getMaxOrDefault","maxParam","bars","addBar","bar","recalculatePercentage","totalPercentage","total","percent","toFixed","removeBar","progressCtrl","stateOn","stateOff","titles","ratingConfig","tmpTitles","ratingStates","buildTemplateObjects","getTitle","rate","readonly","onHover","reset","onLeave","onKeydown","ratingCtrl","findTabIndex","tabs","oldIndex","previousIndex","previousSelected","tab","onDeselect","onSelect","addTab","t1","t2","newActiveIndex","removeTab","newActiveTabIndex","justified","classes","tabsetCtrl","disable","$transcludeFn","isTabHeading","tagName","uibTabContentTransclude","headingElement","hourStep","minuteStep","secondStep","showMeridian","showSeconds","meridians","readonlyInput","mousewheel","arrowkeys","showSpinners","timepickerConfig","getHoursFromTemplate","meridian","getMinutesFromTemplate","getSecondsFromTemplate","pad","refresh","keyboardChange","makeValid","updateTemplate","invalidHours","invalidMinutes","invalidSeconds","addSecondsToSelected","addSeconds","addMinutes","newDate","tabindex","removeAttr","inputs","hoursInputEl","minutesInputEl","secondsInputEl","setupMousewheelEvents","setupArrowkeyEvents","setupInputEvents","noIncrementHours","incrementedSelected","noDecrementHours","decrementedSelected","noIncrementMinutes","noDecrementMinutes","noIncrementSeconds","noDecrementSeconds","noToggleMeridian","$error","isScrollingUp","originalEvent","delta","wheelDelta","deltaY","detail","incrementHours","decrementHours","incrementMinutes","decrementMinutes","incrementSeconds","decrementSeconds","updateHours","updateMinutes","updateSeconds","invalidate","$setDirty","setSeconds","toggleMeridian","uibTimepickerConfig","timepickerCtrl","TYPEAHEAD_REGEXP","itemName","viewMapper","modelMapper","originalScope","$$debounce","typeaheadParser","fireRecalculating","moveInProgress","debouncedRecalculate","recalculatePosition","modelCtrl","HOT_KEYS","eventDebounceTime","minLength","typeaheadMinLength","waitTime","typeaheadWaitMs","isEditable","typeaheadEditable","isLoadingSetter","typeaheadLoading","onSelectCallback","typeaheadOnSelect","isSelectOnBlur","typeaheadSelectOnBlur","isNoResultsSetter","typeaheadNoResults","inputFormatter","typeaheadInputFormatter","typeaheadAppendToBody","typeaheadAppendTo","focusFirst","typeaheadFocusFirst","selectOnExact","typeaheadSelectOnExact","isOpenSetter","typeaheadIsOpen","showHint","typeaheadShowHint","parsedModel","invokeModelSetter","$setModelValue","$$$p","parserResult","uibTypeahead","offDestroy","popupId","aria-autocomplete","aria-owns","inputsContainer","hintInputElem","border-color","box-shadow","opacity","background","color","vertical-align","background-color","popUpEl","move-in-progress","assign-is-open","typeaheadTemplateUrl","typeaheadPopupTemplateUrl","resetHint","resetMatches","activeIdx","getMatchId","inputIsExactMatch","inputValue","getMatchesAsync","onCurrentRequest","debounceUpdate","firstLabel","scheduleSearchWithTimeout","cancelPreviousTimeout","$item","$model","$label","typeaheadFocusOnSelect","offsetTop","editable","dismissClickHandler","_modelCtrl","_ngModelOptions","candidateViewValue","emptyViewValue","popupTemplateUrl","isDropdownOpen","matchIdx","selectActive","selectMatch","tplEl","escapeRegexp","queryToEscape","containsHtml","matchItem","isSanitizePresent","trustAsHtml","$$csp","noInlineStyle","prepend",134,"webpackPolyfill","deprecate"],"mappings":"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","file":"vendors.eca3ce42c5612bd159b7.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tvar _m = moreModules[moduleId];\n/******/\n/******/ \t\t\t// Check if module is deduplicated\n/******/ \t\t\tswitch(typeof _m) {\n/******/ \t\t\tcase \"object\":\n/******/ \t\t\t\t// Module can be created from a template\n/******/ \t\t\t\tmodules[moduleId] = (function(_m) {\n/******/ \t\t\t\t\tvar args = _m.slice(1), templateId = _m[0];\n/******/ \t\t\t\t\treturn function (a,b,c) {\n/******/ \t\t\t\t\t\tmodules[templateId].apply(this, [a,b,c].concat(args));\n/******/ \t\t\t\t\t};\n/******/ \t\t\t\t}(_m));\n/******/ \t\t\t\tbreak;\n/******/ \t\t\tcase \"function\":\n/******/ \t\t\t\t// Normal module\n/******/ \t\t\t\tmodules[moduleId] = _m;\n/******/ \t\t\t\tbreak;\n/******/ \t\t\tdefault:\n/******/ \t\t\t\t// Module is a copy of another module\n/******/ \t\t\t\tmodules[moduleId] = modules[_m];\n/******/ \t\t\t\tbreak;\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t1:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"chunk.\" + {\"0\":\"bea689d366ba2240570d\",\"2\":\"e50da52995f0151ae5fb\",\"3\":\"1d63a2e9ba095d06927b\"}[chunkId] + \".js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"function\": break;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(11);\n\t__webpack_require__(10);\n\t__webpack_require__(9);\n\t__webpack_require__(13);\n\t__webpack_require__(3);\n\t__webpack_require__(5);\n\t__webpack_require__(7);\n\t__webpack_require__(12);\n\t__webpack_require__(8);\n\t__webpack_require__(15);\n\tmodule.exports = __webpack_require__(14);\n\n\n/***/ },\n\n/***/ 2:\n/***/ function(module, exports) {\n\n\tmodule.exports = angular;\n\n/***/ },\n\n/***/ 3:\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! api-check version 7.5.5 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) (ó ì_í)=óò=(ì_í ò)\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"apiCheck\"] = factory();\n\t\telse\n\t\t\troot[\"apiCheck\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _apiCheck = __webpack_require__(1);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = _apiCheck2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar apiCheckUtil = __webpack_require__(3);\n\t\tvar each = apiCheckUtil.each;\n\t\tvar isError = apiCheckUtil.isError;\n\t\tvar t = apiCheckUtil.t;\n\t\tvar arrayify = apiCheckUtil.arrayify;\n\t\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\t\tvar typeOf = apiCheckUtil.typeOf;\n\t\tvar getError = apiCheckUtil.getError;\n\t\n\t\tvar checkers = __webpack_require__(4);\n\t\tvar apiCheckApis = getApiCheckApis();\n\t\n\t\tmodule.exports = getApiCheckInstance;\n\t\tmodule.exports.VERSION = (\"7.5.5\");\n\t\tmodule.exports.utils = apiCheckUtil;\n\t\tmodule.exports.globalConfig = {\n\t\t  verbose: false,\n\t\t  disabled: false\n\t\t};\n\t\n\t\tvar apiCheckApiCheck = getApiCheckInstance({\n\t\t  output: { prefix: 'apiCheck' }\n\t\t});\n\t\tmodule.exports.internalChecker = apiCheckApiCheck;\n\t\n\t\teach(checkers, function (checker, name) {\n\t\t  return module.exports[name] = checker;\n\t\t});\n\t\n\t\tfunction getApiCheckInstance() {\n\t\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t\t  /* eslint complexity:[2, 6] */\n\t\t  if (apiCheckApiCheck && arguments.length) {\n\t\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t\t      prefix: 'creating an apiCheck instance'\n\t\t    });\n\t\t  }\n\t\n\t\t  var additionalProperties = {\n\t\t    'throw': getApiCheck(true),\n\t\t    warn: getApiCheck(false),\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    handleErrorMessage: handleErrorMessage,\n\t\t    config: {\n\t\t      output: config.output || {\n\t\t        prefix: '',\n\t\t        suffix: '',\n\t\t        docsBaseUrl: ''\n\t\t      },\n\t\t      verbose: config.verbose || false,\n\t\t      disabled: config.disabled || false\n\t\t    },\n\t\t    utils: apiCheckUtil\n\t\t  };\n\t\n\t\t  each(additionalProperties, function (wrapper, name) {\n\t\t    return apiCheck[name] = wrapper;\n\t\t  });\n\t\n\t\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\t  each(extraCheckers, function (checker, name) {\n\t\t    return apiCheck[name] = checker;\n\t\t  });\n\t\n\t\t  return apiCheck;\n\t\n\t\t  /**\n\t\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t\t   * @param {Array} api - the checkers to check with\n\t\t   * @param {Array} args - the args to check\n\t\t   * @param {Object} output - output options\n\t\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t\t   */\n\t\t  function apiCheck(api, args, output) {\n\t\t    /* eslint complexity:[2, 8] */\n\t\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t\t      return {\n\t\t        apiTypes: {}, argTypes: {},\n\t\t        passed: true, message: '',\n\t\t        failed: false\n\t\t      }; // empty version of what is normally returned\n\t\t    }\n\t\t    checkApiCheckApi(arguments);\n\t\t    if (!Array.isArray(api)) {\n\t\t      api = [api];\n\t\t      args = [args];\n\t\t    } else {\n\t\t      // turn arguments into an array\n\t\t      args = Array.prototype.slice.call(args);\n\t\t    }\n\t\t    var messages = checkEnoughArgs(api, args);\n\t\t    if (!messages.length) {\n\t\t      // this is where we actually go perform the checks.\n\t\t      messages = checkApiWithArgs(api, args);\n\t\t    }\n\t\n\t\t    var returnObject = getTypes(api, args);\n\t\t    returnObject.args = args;\n\t\t    if (messages.length) {\n\t\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t\t      returnObject.failed = true;\n\t\t      returnObject.passed = false;\n\t\t    } else {\n\t\t      returnObject.message = '';\n\t\t      returnObject.failed = false;\n\t\t      returnObject.passed = true;\n\t\t    }\n\t\t    return returnObject;\n\t\t  }\n\t\n\t\t  /**\n\t\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t\t   */\n\t\t  function checkApiCheckApi(checkApiArgs) {\n\t\t    var api = checkApiArgs[0];\n\t\t    var args = checkApiArgs[1];\n\t\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\t\n\t\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t\t    }\n\t\t    // dog fooding here\n\t\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t\t    if (errors.length) {\n\t\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t\t        prefix: 'apiCheck'\n\t\t      });\n\t\t      apiCheck.handleErrorMessage(message, true);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getApiCheck(shouldThrow) {\n\t\t    return function apiCheckWrapper(api, args, output) {\n\t\t      var result = apiCheck(api, args, output);\n\t\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t\t      return result; // wont get here if an error is thrown\n\t\t    };\n\t\t  }\n\t\n\t\t  function handleErrorMessage(message, shouldThrow) {\n\t\t    if (shouldThrow && message) {\n\t\t      throw new Error(message);\n\t\t    } else if (message) {\n\t\t      /* eslint no-console:0 */\n\t\t      console.warn(message);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getErrorMessage(api, args) {\n\t\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\t\n\t\t    var gOut = apiCheck.config.output || {};\n\t\t    var prefix = getPrefix();\n\t\t    var suffix = getSuffix();\n\t\t    var url = getUrl();\n\t\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\t\n\t\t    function getPrefix() {\n\t\t      var p = output.onlyPrefix;\n\t\t      if (!p) {\n\t\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t\t      }\n\t\t      return p;\n\t\t    }\n\t\n\t\t    function getSuffix() {\n\t\t      var s = output.onlySuffix;\n\t\t      if (!s) {\n\t\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t\t      }\n\t\t      return s;\n\t\t    }\n\t\n\t\t    function getUrl() {\n\t\t      var u = output.url;\n\t\t      if (!u) {\n\t\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t\t      }\n\t\t      return u;\n\t\t    }\n\t\t  }\n\t\n\t\t  function buildMessageFromApiAndArgs(api, args) {\n\t\t    var _getTypes = getTypes(api, args);\n\t\n\t\t    var apiTypes = _getTypes.apiTypes;\n\t\t    var argTypes = _getTypes.argTypes;\n\t\n\t\t    var copy = Array.prototype.slice.call(args || []);\n\t\t    var replacedItems = [];\n\t\t    replaceFunctionWithName(copy);\n\t\t    var passedArgs = getObjectString(copy);\n\t\t    argTypes = getObjectString(argTypes);\n\t\t    apiTypes = getObjectString(apiTypes);\n\t\n\t\t    return generateMessage();\n\t\n\t\t    // functions\n\t\n\t\t    function replaceFunctionWithName(obj) {\n\t\t      each(obj, function (val, name) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        if (replacedItems.indexOf(val) === -1) {\n\t\t          // avoid recursive problems\n\t\t          replacedItems.push(val);\n\t\t          if (typeof val === 'object') {\n\t\t            replaceFunctionWithName(obj);\n\t\t          } else if (typeof val === 'function') {\n\t\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function getObjectString(types) {\n\t\t      if (!types || !types.length) {\n\t\t        return 'nothing';\n\t\t      } else if (types && types.length === 1) {\n\t\t        types = types[0];\n\t\t      }\n\t\t      return stringify(types, null, 2);\n\t\t    }\n\t\n\t\t    function generateMessage() {\n\t\t      var n = '\\n';\n\t\t      var useS = true;\n\t\t      if (args && args.length === 1) {\n\t\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t\t          useS = !!Object.keys(args[0]).length;\n\t\t        } else {\n\t\t          useS = false;\n\t\t        }\n\t\t      }\n\t\t      var types = 'type' + (useS ? 's' : '');\n\t\t      var newLine = n + n;\n\t\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypes(api, args) {\n\t\t    api = arrayify(api);\n\t\t    args = arrayify(args);\n\t\t    var apiTypes = api.map(function (checker, index) {\n\t\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t\t      return getCheckerDisplay(checker, {\n\t\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t\t        obj: args[index],\n\t\t        addHelpers: true\n\t\t      });\n\t\t    });\n\t\t    var argTypes = args.map(function (arg) {\n\t\t      return getArgDisplay(arg, []);\n\t\t    });\n\t\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t\t  }\n\t\t}\n\t\n\t\t// STATELESS FUNCTIONS\n\t\n\t\t/**\n\t\t * This is where the magic happens for actually checking the arguments with the api.\n\t\t * @param {Array} api - checkers\n\t\t * @param  {Array} args - and arguments object\n\t\t * @returns {Array} - the error messages\n\t\t */\n\t\tfunction checkApiWithArgs(api, args) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var messages = [];\n\t\t  var failed = false;\n\t\t  var checkerIndex = 0;\n\t\t  var argIndex = 0;\n\t\t  var arg = undefined,\n\t\t      checker = undefined,\n\t\t      res = undefined,\n\t\t      lastChecker = undefined,\n\t\t      argName = undefined,\n\t\t      argFailed = undefined,\n\t\t      skipPreviousChecker = undefined;\n\t\t  /* jshint -W084 */\n\t\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t\t    arg = args[argIndex++];\n\t\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t\t    res = checker(arg, 'value', argName);\n\t\t    argFailed = isError(res);\n\t\t    lastChecker = checkerIndex >= api.length;\n\t\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t\t      failed = true;\n\t\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t\t    } else if (argFailed && checker.isOptional) {\n\t\t      argIndex--;\n\t\t    } else {\n\t\t      messages.push(t(argName) + ' passed');\n\t\t    }\n\t\t  }\n\t\t  return failed ? messages : [];\n\t\t}\n\t\n\t\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\t\tfunction checkerTypeType(checkerType, name, location) {\n\t\t  var apiCheckDataChecker = checkers.shape({\n\t\t    type: checkers.string,\n\t\t    optional: checkers.bool\n\t\t  });\n\t\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t\t  if (isError(wrongShape)) {\n\t\t    return wrongShape;\n\t\t  }\n\t\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t\t    return getError(name, location, checkerTypeType.type);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerErrorMessage(res, checker, val) {\n\t\t  var checkerHelp = getCheckerHelp(checker, val);\n\t\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t\t  return res.message + checkerHelp;\n\t\t}\n\t\n\t\tfunction getCheckerHelp(_ref, val) {\n\t\t  var help = _ref.help;\n\t\n\t\t  if (!help) {\n\t\t    return '';\n\t\t  }\n\t\t  if (typeof help === 'function') {\n\t\t    help = help(val);\n\t\t  }\n\t\t  return help;\n\t\t}\n\t\n\t\tfunction checkEnoughArgs(api, args) {\n\t\t  var requiredArgs = api.filter(function (a) {\n\t\t    return !a.isOptional;\n\t\t  });\n\t\t  if (args.length < requiredArgs.length) {\n\t\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t\t  } else {\n\t\t    return [];\n\t\t  }\n\t\t}\n\t\n\t\tfunction getArgDisplay(arg, gottenArgs) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t\t  var type = typeOf(arg);\n\t\t  if (type === 'function') {\n\t\t    if (hasKeys()) {\n\t\t      var properties = stringify(getDisplayIfNotGotten());\n\t\t      return cName + ' (with properties: ' + properties + ')';\n\t\t    }\n\t\t    return cName;\n\t\t  }\n\t\n\t\t  if (arg === null) {\n\t\t    return 'null';\n\t\t  }\n\t\n\t\t  if (type !== 'array' && type !== 'object') {\n\t\t    return type;\n\t\t  }\n\t\n\t\t  if (hasKeys()) {\n\t\t    return getDisplayIfNotGotten();\n\t\t  }\n\t\n\t\t  return cName;\n\t\n\t\t  // utility functions\n\t\t  function hasKeys() {\n\t\t    return arg && Object.keys(arg).length;\n\t\t  }\n\t\n\t\t  function getDisplayIfNotGotten() {\n\t\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t\t      return '[Circular]';\n\t\t    }\n\t\t    gottenArgs.push(arg);\n\t\t    return getDisplay(arg, gottenArgs);\n\t\t  }\n\t\t}\n\t\n\t\tfunction getDisplay(obj, gottenArgs) {\n\t\t  var argDisplay = {};\n\t\t  each(obj, function (v, k) {\n\t\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t\t  });\n\t\t  return argDisplay;\n\t\t}\n\t\n\t\tfunction getApiCheckApis() {\n\t\t  var os = checkers.string.optional;\n\t\n\t\t  var checkerFnChecker = checkers.func.withProperties({\n\t\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t\t    displayName: checkers.string.optional,\n\t\t    shortType: checkers.string.optional,\n\t\t    notOptional: checkers.bool.optional,\n\t\t    notRequired: checkers.bool.optional\n\t\t  });\n\t\n\t\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t\t    output: checkers.shape({\n\t\t      prefix: checkers.string.optional,\n\t\t      suffix: checkers.string.optional,\n\t\t      docsBaseUrl: checkers.string.optional\n\t\t    }).strict.optional,\n\t\t    verbose: checkers.bool.optional,\n\t\t    disabled: checkers.bool.optional\n\t\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\t\n\t\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t\t  }).strict.optional];\n\t\n\t\t  return {\n\t\t    checkerFnChecker: checkerFnChecker,\n\t\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t\t    checkApiCheckApi: checkApiCheckApi\n\t\t  };\n\t\t}\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = stringify;\n\t\n\t\tfunction getSerialize (fn, decycle) {\n\t\t  var seen = [], keys = [];\n\t\t  decycle = decycle || function(key, value) {\n\t\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t\t  };\n\t\t  return function(key, value) {\n\t\t    var ret = value;\n\t\t    if (typeof value === 'object' && value) {\n\t\t      if (seen.indexOf(value) !== -1)\n\t\t        ret = decycle(key, value);\n\t\t      else {\n\t\t        seen.push(value);\n\t\t        keys.push(key);\n\t\t      }\n\t\t    }\n\t\t    if (fn) ret = fn(key, ret);\n\t\t    return ret;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getPath (value, seen, keys) {\n\t\t  var index = seen.indexOf(value);\n\t\t  var path = [ keys[index] ];\n\t\t  for (index--; index >= 0; index--) {\n\t\t    if (seen[index][ path[0] ] === value) {\n\t\t      value = seen[index];\n\t\t      path.unshift(keys[index]);\n\t\t    }\n\t\t  }\n\t\t  return '~' + path.join('.');\n\t\t}\n\t\n\t\tfunction stringify(obj, fn, spaces, decycle) {\n\t\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t\t}\n\t\n\t\tstringify.getSerialize = getSerialize;\n\t\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\tvar checkerHelpers = {\n\t\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t\t};\n\t\n\t\tmodule.exports = {\n\t\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t\t  noop: noop\n\t\t};\n\t\n\t\tfunction copy(obj) {\n\t\t  var type = typeOf(obj);\n\t\t  var daCopy = undefined;\n\t\t  if (type === 'array') {\n\t\t    daCopy = [];\n\t\t  } else if (type === 'object') {\n\t\t    daCopy = {};\n\t\t  } else {\n\t\t    return obj;\n\t\t  }\n\t\t  each(obj, function (val, key) {\n\t\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t\t  });\n\t\t  return daCopy;\n\t\t}\n\t\n\t\tfunction typeOf(obj) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return 'array';\n\t\t  } else if (obj instanceof RegExp) {\n\t\t    return 'object';\n\t\t  } else {\n\t\t    return typeof obj;\n\t\t  }\n\t\t}\n\t\n\t\tfunction getCheckerDisplay(checker, options) {\n\t\t  /* eslint complexity:[2, 7] */\n\t\t  var display = undefined;\n\t\t  var short = options && options.short;\n\t\t  if (short && checker.shortType) {\n\t\t    display = checker.shortType;\n\t\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t\t    display = getCheckerType(checker, options);\n\t\t  } else {\n\t\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t\t  }\n\t\t  return display;\n\t\t}\n\t\n\t\tfunction getCheckerType(_ref, options) {\n\t\t  var type = _ref.type;\n\t\n\t\t  if (typeof type === 'function') {\n\t\t    var __apiCheckData = type.__apiCheckData;\n\t\t    var typeTypes = type(options);\n\t\t    type = _defineProperty({\n\t\t      __apiCheckData: __apiCheckData\n\t\t    }, __apiCheckData.type, typeTypes);\n\t\t  }\n\t\t  return type;\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (!obj) {\n\t\t    return [];\n\t\t  } else if (Array.isArray(obj)) {\n\t\t    return obj;\n\t\t  } else {\n\t\t    return [obj];\n\t\t  }\n\t\t}\n\t\n\t\tfunction each(obj, iterator, context) {\n\t\t  if (Array.isArray(obj)) {\n\t\t    return eachArry(obj, iterator, context);\n\t\t  } else {\n\t\t    return eachObj(obj, iterator, context);\n\t\t  }\n\t\t}\n\t\n\t\tfunction eachObj(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t\t  for (var key in obj) {\n\t\t    if (hasOwn.call(obj, key)) {\n\t\t      ret = iterator.call(context, obj[key], key, obj);\n\t\t      if (ret === false) {\n\t\t        return ret;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction eachArry(obj, iterator, context) {\n\t\t  var ret = undefined;\n\t\t  var length = obj.length;\n\t\t  for (var i = 0; i < length; i++) {\n\t\t    ret = iterator.call(context, obj[i], i, obj);\n\t\t    if (ret === false) {\n\t\t      return ret;\n\t\t    }\n\t\t  }\n\t\t  return true;\n\t\t}\n\t\n\t\tfunction isError(obj) {\n\t\t  return obj instanceof Error;\n\t\t}\n\t\n\t\tfunction list(arry, join, finalJoin) {\n\t\t  arry = arrayify(arry);\n\t\t  var copy = arry.slice();\n\t\t  var last = copy.pop();\n\t\t  if (copy.length === 1) {\n\t\t    join = ' ';\n\t\t  }\n\t\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t\t}\n\t\n\t\tfunction getError(name, location, checkerType) {\n\t\t  if (typeof checkerType === 'function') {\n\t\t    checkerType = checkerType({ short: true });\n\t\t  }\n\t\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t\t}\n\t\n\t\tfunction nAtL(name, location) {\n\t\t  var tName = t(name || 'value');\n\t\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t\t  return '' + tName + tLocation;\n\t\t}\n\t\n\t\tfunction t(thing) {\n\t\t  return '`' + thing + '`';\n\t\t}\n\t\n\t\tfunction undef(thing) {\n\t\t  return typeof thing === 'undefined';\n\t\t}\n\t\n\t\t/**\n\t\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t\t * optional version\n\t\t *\n\t\t * @param {Function} checker - the checker to setup with properties\n\t\t * @param {Object} properties - properties to add to the checker\n\t\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t\t * @returns {Function} checker - the setup checker\n\t\t */\n\t\tfunction setupChecker(checker, properties, disabled) {\n\t\t  /* eslint complexity:[2, 9] */\n\t\t  if (disabled) {\n\t\t    // swap out the checker for its own copy of noop\n\t\t    checker = getNoop();\n\t\t    checker.isNoop = true;\n\t\t  }\n\t\n\t\t  if (typeof checker.type === 'string') {\n\t\t    checker.shortType = checker.type;\n\t\t  }\n\t\n\t\t  // assign all properties given\n\t\t  each(properties, function (prop, name) {\n\t\t    return checker[name] = prop;\n\t\t  });\n\t\n\t\t  if (!checker.displayName) {\n\t\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t\t  }\n\t\n\t\t  if (!checker.notRequired) {\n\t\t    checker = getRequiredVersion(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notNullable) {\n\t\t    addNullable(checker, disabled);\n\t\t  }\n\t\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker, disabled);\n\t\t  }\n\t\n\t\t  return checker;\n\t\t}\n\t\n\t\tfunction getRequiredVersion(checker, disabled) {\n\t\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t\t    if (undef(val) && !checker.isOptional) {\n\t\t      var tLocation = location ? ' in ' + t(location) : '';\n\t\t      var type = getCheckerDisplay(checker, { short: true });\n\t\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t\t    } else {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  copyProps(checker, requiredChecker);\n\t\t  requiredChecker.originalChecker = checker;\n\t\t  return requiredChecker;\n\t\t}\n\t\n\t\tfunction addOptional(checker, disabled) {\n\t\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t\t    if (!undef(val)) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, optionalCheck);\n\t\n\t\t  optionalCheck.isOptional = true;\n\t\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t\t  optionalCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .optional to the end of the checkers\n\t\t  checker.optional = optionalCheck;\n\t\n\t\t  fixType(checker, checker.optional);\n\t\t}\n\t\n\t\tfunction addNullable(checker, disabled) {\n\t\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t\t    if (val !== null) {\n\t\t      return checker(val, name, location, obj);\n\t\t    }\n\t\t  };\n\t\t  // inherit all properties on the original checker\n\t\t  copyProps(checker, nullableCheck);\n\t\n\t\t  nullableCheck.isNullable = true;\n\t\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t\t  nullableCheck.originalChecker = checker;\n\t\n\t\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t\t  checker.nullable = nullableCheck;\n\t\n\t\t  fixType(checker, checker.nullable);\n\t\t  if (!checker.notOptional) {\n\t\t    addOptional(checker.nullable, disabled);\n\t\t  }\n\t\t}\n\t\n\t\tfunction fixType(checker, checkerCopy) {\n\t\t  // fix type, because it's not a straight copy...\n\t\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t\t  // we also want to add \"(optional)\" to the types with a string\n\t\t  if (typeof checkerCopy.type === 'object') {\n\t\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t\t  } else if (typeof checkerCopy.type === 'function') {\n\t\t      checkerCopy.type = function () {\n\t\t        return checker.type.apply(checker, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      checkerCopy.type += ' (optional)';\n\t\t      return;\n\t\t    }\n\t\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t\t  checkerCopy.type.__apiCheckData.optional = true;\n\t\t}\n\t\n\t\t// UTILS\n\t\n\t\tfunction copyProps(src, dest) {\n\t\t  each(Object.keys(src), function (key) {\n\t\t    return dest[key] = src[key];\n\t\t  });\n\t\t}\n\t\n\t\tfunction noop() {}\n\t\n\t\tfunction getNoop() {\n\t\t  /* eslint no-shadow:0 */\n\t\t  /* istanbul ignore next */\n\t\t  return function noop() {};\n\t\t}\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tvar stringify = __webpack_require__(2);\n\t\n\t\tvar _require = __webpack_require__(3);\n\t\n\t\tvar typeOf = _require.typeOf;\n\t\tvar each = _require.each;\n\t\tvar copy = _require.copy;\n\t\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\t\tvar isError = _require.isError;\n\t\tvar arrayify = _require.arrayify;\n\t\tvar list = _require.list;\n\t\tvar getError = _require.getError;\n\t\tvar nAtL = _require.nAtL;\n\t\tvar t = _require.t;\n\t\tvar checkerHelpers = _require.checkerHelpers;\n\t\tvar undef = _require.undef;\n\t\tvar setupChecker = checkerHelpers.setupChecker;\n\t\n\t\tvar checkers = module.exports = getCheckers();\n\t\tmodule.exports.getCheckers = getCheckers;\n\t\n\t\tfunction getCheckers(disabled) {\n\t\t  return {\n\t\t    array: typeOfCheckGetter('Array'),\n\t\t    bool: typeOfCheckGetter('Boolean'),\n\t\t    number: typeOfCheckGetter('Number'),\n\t\t    string: typeOfCheckGetter('String'),\n\t\t    func: funcCheckGetter(),\n\t\t    object: objectCheckGetter(),\n\t\n\t\t    emptyObject: emptyObjectCheckGetter(),\n\t\n\t\t    instanceOf: instanceCheckGetter,\n\t\t    oneOf: oneOfCheckGetter,\n\t\t    oneOfType: oneOfTypeCheckGetter,\n\t\n\t\t    arrayOf: arrayOfCheckGetter,\n\t\t    objectOf: objectOfCheckGetter,\n\t\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\t\n\t\t    range: rangeCheckGetter,\n\t\t    lessThan: lessThanCheckGetter,\n\t\t    greaterThan: greaterThanCheckGetter,\n\t\n\t\t    shape: getShapeCheckGetter(),\n\t\t    args: argumentsCheckerGetter(),\n\t\n\t\t    any: anyCheckGetter(),\n\t\t    'null': nullCheckGetter()\n\t\n\t\t  };\n\t\n\t\t  function typeOfCheckGetter(type) {\n\t\t    var lType = type.toLowerCase();\n\t\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== lType) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function funcCheckGetter() {\n\t\t    var type = 'Function';\n\t\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'function') {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\n\t\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t\t      if (isError(apiError)) {\n\t\t        throw apiError;\n\t\t      }\n\t\t      var shapeChecker = checkers.shape(properties, true);\n\t\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\t\n\t\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t\t        var notFunction = checkers.func(val, name, location);\n\t\t        if (isError(notFunction)) {\n\t\t          return notFunction;\n\t\t        }\n\t\t        return shapeChecker(val, name, location);\n\t\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t\t    };\n\t\t    return functionChecker;\n\t\t  }\n\t\n\t\t  function objectCheckGetter() {\n\t\t    var type = 'Object';\n\t\t    var nullType = 'Object (null ok)';\n\t\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t\t      if (typeOf(val) !== 'object') {\n\t\t        return getError(name, location, nullType);\n\t\t      }\n\t\t    }, { type: nullType }, disabled);\n\t\n\t\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t\t        return getError(name, location, objectChecker.type);\n\t\t      }\n\t\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\t\n\t\t    return objectChecker;\n\t\t  }\n\t\n\t\t  function instanceCheckGetter(classToCheck) {\n\t\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t\t      if (!(val instanceof classToCheck)) {\n\t\t        return getError(name, location, classToCheck.name);\n\t\t      }\n\t\t    }, { type: classToCheck.name }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfCheckGetter(enums) {\n\t\t    var type = {\n\t\t      __apiCheckData: { optional: false, type: 'enum' },\n\t\t      'enum': enums\n\t\t    };\n\t\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t\t      return stringify(enm);\n\t\t    }).join(', ') + ']';\n\t\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t\t      if (!enums.some(function (enm) {\n\t\t        return enm === val;\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t\t      return getCheckerDisplay(checker, { short: true });\n\t\t    });\n\t\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return typeCheckers.map(function (checker) {\n\t\t        return getCheckerDisplay(checker, options);\n\t\t      });\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t\t      if (!typeCheckers.some(function (checker) {\n\t\t        return !isError(checker(val, name, location));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function arrayOfCheckGetter(checker) {\n\t\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\t\n\t\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t\t        return !isError(checker(item));\n\t\t      })) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function objectOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\t\n\t\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t\t      var notObject = checkers.object(val, name, location);\n\t\t      if (isError(notObject)) {\n\t\t        return notObject;\n\t\t      }\n\t\t      var allTypesSuccess = each(val, function (item, key) {\n\t\t        if (isError(checker(item, key, name))) {\n\t\t          return false;\n\t\t        }\n\t\t      });\n\t\t      if (!allTypesSuccess) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function typeOrArrayOfCheckGetter(checker) {\n\t\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\t\n\t\t    function type(options) {\n\t\t      if (options && options.short) {\n\t\t        return shortType;\n\t\t      }\n\t\t      return getCheckerDisplay(checker, options);\n\t\t    }\n\t\n\t\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t\t        return getError(name, location, shortType);\n\t\t      }\n\t\t    }, { type: type, shortType: shortType }, disabled);\n\t\t  }\n\t\n\t\t  function getShapeCheckGetter() {\n\t\t    function shapeCheckGetter(shape, nonObject) {\n\t\t      var shapeTypes = {};\n\t\t      each(shape, function (checker, prop) {\n\t\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t\t      });\n\t\t      function type() {\n\t\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t\t        var ret = {};\n\t\t        var terse = options.terse;\n\t\t        var obj = options.obj;\n\t\t        var addHelpers = options.addHelpers;\n\t\n\t\t        var parentRequired = options.required;\n\t\t        each(shape, function (checker, prop) {\n\t\t          /* eslint complexity:[2, 6] */\n\t\t          var specified = obj && obj.hasOwnProperty(prop);\n\t\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t\t          if (!terse || (specified || !checker.isOptional)) {\n\t\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t\t          }\n\t\t          if (addHelpers) {\n\t\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t\t          }\n\t\t        });\n\t\t        return ret;\n\t\n\t\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t\t          if (!specified && required && !checker.isOptional) {\n\t\t            var item = 'ITEM';\n\t\t            if (checker.type && checker.type.__apiCheckData) {\n\t\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t\t            }\n\t\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t\t          } else if (specified) {\n\t\t            var error = checker(obj[prop], prop, null, obj);\n\t\t            if (isError(error)) {\n\t\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t\t            }\n\t\t          }\n\t\n\t\t          function addHelper(property, objectMessage, stringMessage) {\n\t\t            if (typeof theRet[prop] === 'string') {\n\t\t              theRet[prop] += stringMessage;\n\t\t            } else {\n\t\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\n\t\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t\t        /* eslint complexity:[2, 6] */\n\t\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t\t        if (isError(isObject)) {\n\t\t          return isObject;\n\t\t        }\n\t\t        var shapePropError = undefined;\n\t\t        location = location ? location + (name ? '/' : '') : '';\n\t\t        name = name || '';\n\t\t        each(shape, function (checker, prop) {\n\t\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t\t            return !isError(shapePropError);\n\t\t          }\n\t\t        });\n\t\t        if (isError(shapePropError)) {\n\t\t          return shapePropError;\n\t\t        }\n\t\t      }, { type: type, shortType: 'shape' }, disabled);\n\t\n\t\t      function strictType() {\n\t\t        return type.apply(undefined, arguments);\n\t\t      }\n\t\n\t\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t\t      strictType.__apiCheckData.strict = true;\n\t\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t\t        var shapeError = shapeChecker(val, name, location);\n\t\t        if (isError(shapeError)) {\n\t\t          return shapeError;\n\t\t        }\n\t\t        var allowedProperties = Object.keys(shape);\n\t\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t\t          return allowedProperties.indexOf(prop) === -1;\n\t\t        });\n\t\t        if (extraProps.length) {\n\t\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t\t        }\n\t\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\t\n\t\t      return shapeChecker;\n\t\t    }\n\t\n\t\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t\t      } else {\n\t\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (propExists === otherPropsExist) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t\t      otherProps = arrayify(otherProps);\n\t\t      var description = undefined;\n\t\t      if (otherProps.length === 1) {\n\t\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t\t      } else {\n\t\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t\t      }\n\t\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t\t        var othersPresent = otherProps.every(function (property) {\n\t\t          return obj.hasOwnProperty(property);\n\t\t        });\n\t\t        if (!othersPresent) {\n\t\t          return getError(propName, location, type);\n\t\t        } else {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, shortType: shortType }, disabled);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        otherProps = [otherProps];\n\t\t      }\n\t\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t\t      if (!Array.isArray(otherProps)) {\n\t\t        throw new Error('requiredIfNot.all must be passed an array');\n\t\t      }\n\t\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t\t    };\n\t\n\t\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t\t      var props = t(otherProps.join(', '));\n\t\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t\t        var iteration = all ? 'every' : 'some';\n\t\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t\t          return obj && obj.hasOwnProperty(otherProp);\n\t\t        });\n\t\t        if (!otherPropsExist && !propExists) {\n\t\t          return getError(propName, location, type);\n\t\t        } else if (propExists) {\n\t\t          return propChecker(prop, propName, location, obj);\n\t\t        }\n\t\t      }, { type: type, notRequired: true }, disabled);\n\t\t    }\n\t\n\t\t    return shapeCheckGetter;\n\t\n\t\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t\t      function type(options) {\n\t\t        if (options && options.short) {\n\t\t          return shortType;\n\t\t        }\n\t\t        return getCheckerDisplay(propChecker);\n\t\t      }\n\t\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function argumentsCheckerGetter() {\n\t\t    var type = 'function arguments';\n\t\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function anyCheckGetter() {\n\t\t    return setupChecker(function anyCheckerDefinition() {\n\t\t      // don't do anything\n\t\t    }, { type: 'any' }, disabled);\n\t\t  }\n\t\n\t\t  function nullCheckGetter() {\n\t\t    var type = 'null';\n\t\t    return setupChecker(function nullChecker(val, name, location) {\n\t\t      if (val !== null) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function rangeCheckGetter(min, max) {\n\t\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t\t    return setupChecker(function rangeChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < min || val > max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function lessThanCheckGetter(min) {\n\t\t    var type = 'lessThan[' + min + ']';\n\t\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val > min) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function greaterThanCheckGetter(max) {\n\t\t    var type = 'greaterThan[' + max + ']';\n\t\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t\t      if (typeof val !== 'number' || val < max) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\n\t\t  function emptyObjectCheckGetter() {\n\t\t    var type = 'empty object';\n\t\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t\t        return getError(name, location, type);\n\t\t      }\n\t\t    }, { type: type }, disabled);\n\t\t  }\n\t\t}\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n\n/***/ 5:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t* angular-formly JavaScript Library v7.5.1\n\t*\n\t* @license MIT (http://license.angular-formly.com)\n\t*\n\t* built with ♥ by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n\t* (ó ì_í)=óò=(ì_í ò)\n\t*/\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _indexCommon = __webpack_require__(1);\n\t\n\t\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\t\n\t\texports['default'] = _indexCommon2['default'];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\t\n\t\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\t\n\t\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\t\n\t\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\t\n\t\tvar _providersFormlyUsability = __webpack_require__(7);\n\t\n\t\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\t\n\t\tvar _providersFormlyConfig = __webpack_require__(8);\n\t\n\t\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\t\n\t\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\t\n\t\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\t\n\t\tvar _servicesFormlyUtil = __webpack_require__(11);\n\t\n\t\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\t\n\t\tvar _servicesFormlyWarn = __webpack_require__(12);\n\t\n\t\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\t\n\t\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\t\n\t\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\t\n\t\tvar _directivesFormlyField = __webpack_require__(14);\n\t\n\t\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\t\n\t\tvar _directivesFormlyFocus = __webpack_require__(15);\n\t\n\t\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\t\n\t\tvar _directivesFormlyForm = __webpack_require__(16);\n\t\n\t\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\t\n\t\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\t\n\t\tvar _runFormlyCustomTags = __webpack_require__(18);\n\t\n\t\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\t\n\t\tvar ngModuleName = 'formly';\n\t\n\t\texports['default'] = ngModuleName;\n\t\n\t\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\t\n\t\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\t\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\t\tngModule.constant('formlyVersion', (\"7.5.1\")); // <-- webpack variable\n\t\n\t\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\t\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\t\n\t\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\t\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\t\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\t\n\t\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\t\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\t\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\t\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\t\n\t\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\t\tngModule.run(_runFormlyCustomTags2['default']);\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar angular = __webpack_require__(3);\n\t\n\t\t/* istanbul ignore next */\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\texports['default'] = angular;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\tvar apiCheck = (0, _apiCheck2['default'])({\n\t\t  output: {\n\t\t    prefix: 'angular-formly:',\n\t\t    docsBaseUrl: __webpack_require__(6)\n\t\t  }\n\t\t});\n\t\n\t\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t\t    otherProps = [otherProps];\n\t\t  }\n\t\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\t\n\t\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t\t      return obj && obj.hasOwnProperty(otherProp);\n\t\t    });\n\t\t    if (!otherPropsExist && !propExists) {\n\t\t      return apiCheck.utils.getError(propName, location, type);\n\t\t    } else if (propExists) {\n\t\t      return propChecker(prop, propName, location, obj);\n\t\t    }\n\t\t  }\n\t\n\t\t  shapeRequiredIfNotDefinition.type = type;\n\t\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t\t}\n\t\n\t\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\t\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\t\n\t\tvar apiCheckProperty = apiCheck.func;\n\t\n\t\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t\t  warn: apiCheck.func,\n\t\t  'throw': apiCheck.func,\n\t\t  shape: apiCheck.func\n\t\t}));\n\t\n\t\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\t\n\t\tvar formlyWrapperType = apiCheck.shape({\n\t\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  overwriteOk: apiCheck.bool.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\t\n\t\tvar templateManipulators = apiCheck.shape({\n\t\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t\t}).strict.nullable;\n\t\n\t\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t\t  expression: formlyExpression,\n\t\t  message: formlyExpression.optional\n\t\t}).strict]));\n\t\n\t\tvar watcherChecker = apiCheck.typeOrArrayOf(apiCheck.shape({\n\t\t  expression: formlyExpression.optional,\n\t\t  listener: formlyExpression.optional,\n\t\t  runFieldExpressions: apiCheck.bool.optional\n\t\t}));\n\t\n\t\tvar fieldOptionsApiShape = {\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  model: modelChecker.optional,\n\t\t  originalModel: modelChecker.optional,\n\t\t  className: apiCheck.string.optional,\n\t\t  id: apiCheck.string.optional,\n\t\t  name: apiCheck.string.optional,\n\t\t  expressionProperties: expressionProperties.optional,\n\t\t  extras: apiCheck.shape({\n\t\t    validateOnModelChange: apiCheck.bool.optional,\n\t\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t\t  }).strict.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  templateOptions: apiCheck.object.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  modelOptions: apiCheck.shape({\n\t\t    updateOn: apiCheck.string.optional,\n\t\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t\t    allowInvalid: apiCheck.bool.optional,\n\t\t    getterSetter: apiCheck.bool.optional,\n\t\t    timezone: apiCheck.string.optional\n\t\t  }).optional,\n\t\t  watcher: watcherChecker.optional,\n\t\t  validators: validatorChecker.optional,\n\t\t  asyncValidators: validatorChecker.optional,\n\t\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t\t  noFormControl: apiCheck.bool.optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t\t  }).strict).optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t\t  validation: apiCheck.shape({\n\t\t    show: apiCheck.bool.nullable.optional,\n\t\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t\t  }).optional,\n\t\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t\t  value: apiCheck.func.optional,\n\t\t  runExpressions: apiCheck.func.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  initialValue: apiCheck.any.optional,\n\t\t  defaultValue: apiCheck.any.optional\n\t\t};\n\t\n\t\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\t\n\t\tvar formOptionsApi = apiCheck.shape({\n\t\t  formState: apiCheck.object.optional,\n\t\t  resetModel: apiCheck.func.optional,\n\t\t  updateInitialValue: apiCheck.func.optional,\n\t\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t\t  templateManipulators: templateManipulators.optional,\n\t\t  manualModelWatcher: apiCheck.oneOfType([apiCheck.bool, apiCheck.func]).optional,\n\t\t  watchAllExpressions: apiCheck.bool.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t\t  data: apiCheck.object.optional\n\t\t}).strict;\n\t\n\t\tvar fieldGroup = apiCheck.shape({\n\t\t  $$hashKey: apiCheck.any.optional,\n\t\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t\t  // danger. Nested field groups wont get api-checked...\n\t\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t\t  className: apiCheck.string.optional,\n\t\t  options: formOptionsApi.optional,\n\t\t  templateOptions: apiCheck.object.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  watcher: watcherChecker.optional,\n\t\t  hide: apiCheck.bool.optional,\n\t\t  hideExpression: formlyExpression.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  model: modelChecker.optional,\n\t\t  form: apiCheck.object.optional,\n\t\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t\t}).strict;\n\t\n\t\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\t\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\t\n\t\tvar formlyTypeOptions = apiCheck.shape({\n\t\t  name: apiCheck.string,\n\t\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t\t  link: apiCheck.func.optional,\n\t\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t\t  'extends': apiCheck.string.optional,\n\t\t  wrapper: specifyWrapperType.optional,\n\t\t  data: apiCheck.object.optional,\n\t\t  apiCheck: apiCheckProperty.optional,\n\t\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t\t  apiCheckOptions: apiCheck.object.optional,\n\t\t  overwriteOk: apiCheck.bool.optional\n\t\t}).strict;\n\t\n\t\t_angularFix2['default'].extend(apiCheck, {\n\t\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t\t});\n\t\n\t\texports['default'] = apiCheck;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.5.1\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\t\tmodule.exports = exports[\"default\"];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyUsability;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t\t  var _this = this;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    getFormlyError: getFormlyError,\n\t\t    getFieldError: getFieldError,\n\t\t    checkWrapper: checkWrapper,\n\t\t    checkWrapperTemplate: checkWrapperTemplate,\n\t\t    getErrorMessage: getErrorMessage,\n\t\t    $get: function $get() {\n\t\t      return _this;\n\t\t    }\n\t\t  });\n\t\n\t\t  function getFieldError(errorInfoSlug, message, field) {\n\t\t    if (arguments.length < 3) {\n\t\t      field = message;\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t\t  }\n\t\n\t\t  function getFormlyError(errorInfoSlug, message) {\n\t\t    if (!message) {\n\t\t      message = errorInfoSlug;\n\t\t      errorInfoSlug = null;\n\t\t    }\n\t\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t\t  }\n\t\n\t\t  function getErrorMessage(errorInfoSlug, message) {\n\t\t    var url = '';\n\t\t    if (errorInfoSlug !== null) {\n\t\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t\t    }\n\t\t    return 'Formly Error: ' + message + '. ' + url;\n\t\t  }\n\t\n\t\t  function checkWrapper(wrapper) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t\t      prefix: 'formlyConfig.setWrapper',\n\t\t      urlSuffix: 'setwrapper-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function checkWrapperTemplate(template, additionalInfo) {\n\t\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t\t    if (template.indexOf(formlyTransclude) === -1) {\n\t\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyConfig;\n\t\n\t\t// @ngInject\n\t\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t\t  var _this2 = this;\n\t\n\t\t  var typeMap = {};\n\t\t  var templateWrappersMap = {};\n\t\t  var defaultWrapperName = 'default';\n\t\t  var _this = this;\n\t\t  var getError = formlyUsabilityProvider.getFormlyError;\n\t\n\t\t  _angularFix2['default'].extend(this, {\n\t\t    setType: setType,\n\t\t    getType: getType,\n\t\t    getTypeHeritage: getTypeHeritage,\n\t\t    setWrapper: setWrapper,\n\t\t    getWrapper: getWrapper,\n\t\t    getWrapperByType: getWrapperByType,\n\t\t    removeWrapperByName: removeWrapperByName,\n\t\t    removeWrappersForType: removeWrappersForType,\n\t\t    disableWarnings: false,\n\t\t    extras: {\n\t\t      disableNgModelAttrsManipulator: false,\n\t\t      fieldTransform: [],\n\t\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t\t      removeChromeAutoComplete: false,\n\t\t      defaultHideDirective: 'ng-if',\n\t\t      getFieldId: null\n\t\t    },\n\t\t    templateManipulators: {\n\t\t      preWrapper: [],\n\t\t      postWrapper: []\n\t\t    },\n\t\t    $get: function $get() {\n\t\t      return _this2;\n\t\t    }\n\t\t  });\n\t\n\t\t  function setType(options) {\n\t\t    if (_angularFix2['default'].isArray(options)) {\n\t\t      var _ret = (function () {\n\t\t        var allTypes = [];\n\t\t        _angularFix2['default'].forEach(options, function (item) {\n\t\t          allTypes.push(setType(item));\n\t\t        });\n\t\t        return {\n\t\t          v: allTypes\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret === 'object') return _ret.v;\n\t\t    } else if (_angularFix2['default'].isObject(options)) {\n\t\t      checkType(options);\n\t\t      if (options['extends']) {\n\t\t        extendTypeOptions(options);\n\t\t      }\n\t\t      typeMap[options.name] = options;\n\t\t      return typeMap[options.name];\n\t\t    } else {\n\t\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkType(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t\t      prefix: 'formlyConfig.setType',\n\t\t      url: 'settype-validation-failed'\n\t\t    });\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t\t    } else {\n\t\t      options.overwriteOk = undefined;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeOptions(options) {\n\t\t    var extendsType = getType(options['extends'], true, options);\n\t\t    extendTypeControllerFunction(options, extendsType);\n\t\t    extendTypeLinkFunction(options, extendsType);\n\t\t    extendTypeDefaultOptions(options, extendsType);\n\t\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t\t    extendTemplate(options, extendsType);\n\t\t  }\n\t\n\t\t  function extendTemplate(options, extendsType) {\n\t\t    if (options.template && extendsType.templateUrl) {\n\t\t      delete options.templateUrl;\n\t\t    } else if (options.templateUrl && extendsType.template) {\n\t\t      delete options.template;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeControllerFunction(options, extendsType) {\n\t\t    var extendsCtrl = extendsType.controller;\n\t\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsCtrl = options.controller;\n\t\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t\t      options.controller = function ($scope, $controller) {\n\t\t        $controller(extendsCtrl, { $scope: $scope });\n\t\t        $controller(optionsCtrl, { $scope: $scope });\n\t\t      };\n\t\t      options.controller.$inject = ['$scope', '$controller'];\n\t\t    } else {\n\t\t      options.controller = extendsCtrl;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeLinkFunction(options, extendsType) {\n\t\t    var extendsFn = extendsType.link;\n\t\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsFn = options.link;\n\t\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t\t      options.link = function () {\n\t\t        extendsFn.apply(undefined, arguments);\n\t\t        optionsFn.apply(undefined, arguments);\n\t\t      };\n\t\t    } else {\n\t\t      options.link = extendsFn;\n\t\t    }\n\t\t  }\n\t\n\t\t  function extendTypeDefaultOptions(options, extendsType) {\n\t\t    var extendsDO = extendsType.defaultOptions;\n\t\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t\t      return;\n\t\t    }\n\t\t    var optionsDO = options.defaultOptions;\n\t\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t\t    if (extendsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t\t        var mergedDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t\t        var extenderOptionsDefaultOptions = optionsDO;\n\t\t        if (optionsDOIsFn) {\n\t\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t\t        }\n\t\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t\t        return extendsDefaultOptions;\n\t\t      };\n\t\t    } else if (optionsDOIsFn) {\n\t\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t\t        var newDefaultOptions = {};\n\t\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t\t        return optionsDO(newDefaultOptions, scope);\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function getType(name, throwError, errorContext) {\n\t\t    if (!name) {\n\t\t      return undefined;\n\t\t    }\n\t\t    var type = typeMap[name];\n\t\t    if (!type && throwError === true) {\n\t\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t\t    } else {\n\t\t      return type;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getTypeHeritage(parent) {\n\t\t    var heritage = [];\n\t\t    var type = parent;\n\t\t    if (_angularFix2['default'].isString(type)) {\n\t\t      type = getType(parent);\n\t\t    }\n\t\t    parent = type['extends'];\n\t\t    while (parent) {\n\t\t      type = getType(parent);\n\t\t      heritage.push(type);\n\t\t      parent = type['extends'];\n\t\t    }\n\t\t    return heritage;\n\t\t  }\n\t\n\t\t  function setWrapper(_x, _x2) {\n\t\t    var _again = true;\n\t\n\t\t    _function: while (_again) {\n\t\t      var options = _x,\n\t\t          name = _x2;\n\t\t      _again = false;\n\t\n\t\t      if (_angularFix2['default'].isArray(options)) {\n\t\t        return options.map(function (wrapperOptions) {\n\t\t          return setWrapper(wrapperOptions);\n\t\t        });\n\t\t      } else if (_angularFix2['default'].isObject(options)) {\n\t\t        options.types = getOptionsTypes(options);\n\t\t        options.name = getOptionsName(options, name);\n\t\t        checkWrapperAPI(options);\n\t\t        templateWrappersMap[options.name] = options;\n\t\t        return options;\n\t\t      } else if (_angularFix2['default'].isString(options)) {\n\t\t        _x = {\n\t\t          template: options,\n\t\t          name: name\n\t\t        };\n\t\t        _x2 = undefined;\n\t\t        _again = true;\n\t\t        continue _function;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsTypes(options) {\n\t\t    if (_angularFix2['default'].isString(options.types)) {\n\t\t      return [options.types];\n\t\t    }\n\t\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t\t      return [];\n\t\t    } else {\n\t\t      return options.types;\n\t\t    }\n\t\t  }\n\t\n\t\t  function getOptionsName(options, name) {\n\t\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t\t  }\n\t\n\t\t  function checkWrapperAPI(options) {\n\t\t    formlyUsabilityProvider.checkWrapper(options);\n\t\t    if (options.template) {\n\t\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t\t    }\n\t\t    if (!options.overwriteOk) {\n\t\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t\t    } else {\n\t\t      delete options.overwriteOk;\n\t\t    }\n\t\t    checkWrapperTypes(options);\n\t\t  }\n\t\n\t\t  function checkWrapperTypes(options) {\n\t\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t\t    if (shouldThrow) {\n\t\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkOverwrite(property, object, newValue, objectName) {\n\t\t    if (object.hasOwnProperty(property)) {\n\t\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t\t    }\n\t\t  }\n\t\n\t\t  function getWrapper(name) {\n\t\t    return templateWrappersMap[name || defaultWrapperName];\n\t\t  }\n\t\n\t\t  function getWrapperByType(type) {\n\t\t    /* eslint prefer-const:0 */\n\t\t    var wrappers = [];\n\t\t    for (var _name in templateWrappersMap) {\n\t\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t\t          wrappers.push(templateWrappersMap[_name]);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return wrappers;\n\t\t  }\n\t\n\t\t  function removeWrapperByName(name) {\n\t\t    var wrapper = templateWrappersMap[name];\n\t\t    delete templateWrappersMap[name];\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function removeWrappersForType(type) {\n\t\t    var wrappers = getWrapperByType(type);\n\t\t    if (!wrappers) {\n\t\t      return undefined;\n\t\t    }\n\t\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t\t      return removeWrapperByName(wrappers.name);\n\t\t    } else {\n\t\t      wrappers.forEach(function (wrapper) {\n\t\t        return removeWrapperByName(wrapper.name);\n\t\t      });\n\t\t      return wrappers;\n\t\t    }\n\t\t  }\n\t\n\t\t  function warn() {\n\t\t    if (!_this.disableWarnings && console.warn) {\n\t\t      /* eslint no-console:0 */\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      console.warn.apply(console, _toConsumableArray(args));\n\t\t    }\n\t\t  }\n\t\t}\n\t\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = {\n\t\t  containsSelector: containsSelector, containsSpecialChar: containsSpecialChar, formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName,\n\t\t  arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t\t};\n\t\n\t\tfunction containsSelector(string) {\n\t\t  return containsSpecialChar(string, '.') || containsSpecialChar(string, '[') && containsSpecialChar(string, ']');\n\t\t}\n\t\n\t\tfunction containsSpecialChar(a, b) {\n\t\t  if (!a || !a.indexOf) {\n\t\t    return false;\n\t\t  }\n\t\t  return a.indexOf(b) !== -1;\n\t\t}\n\t\n\t\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t\t  if (_angularFix2['default'].isFunction(expression)) {\n\t\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t\t  } else {\n\t\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t\t  }\n\t\t}\n\t\n\t\tfunction getFieldId(formId, options, index) {\n\t\t  if (options.id) {\n\t\t    return options.id;\n\t\t  }\n\t\t  var type = options.type;\n\t\t  if (!type && options.template) {\n\t\t    type = 'template';\n\t\t  } else if (!type && options.templateUrl) {\n\t\t    type = 'templateUrl';\n\t\t  }\n\t\n\t\t  return [formId, type, options.key, index].join('_');\n\t\t}\n\t\n\t\tfunction reverseDeepMerge(dest) {\n\t\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t\t    if (!index) {\n\t\t      return;\n\t\t    }\n\t\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t\t        dest[prop] = _angularFix2['default'].copy(val);\n\t\t      } else if (objAndSameType(dest[prop], val)) {\n\t\t        reverseDeepMerge(dest[prop], val);\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t  return dest;\n\t\t}\n\t\n\t\tfunction objAndSameType(obj1, obj2) {\n\t\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t\t}\n\t\n\t\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\t\tfunction findByNodeName(el, nodeName) {\n\t\t  if (!el.prop) {\n\t\t    // not a jQuery or jqLite object -> wrap it\n\t\t    el = _angularFix2['default'].element(el);\n\t\t  }\n\t\n\t\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t\t    return el;\n\t\t  }\n\t\n\t\t  var c = el.children();\n\t\t  for (var i = 0; c && i < c.length; i++) {\n\t\t    var node = findByNodeName(c[i], nodeName);\n\t\t    if (node) {\n\t\t      return node;\n\t\t    }\n\t\t  }\n\t\t}\n\t\n\t\tfunction arrayify(obj) {\n\t\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t\t    obj = [obj];\n\t\t  } else if (!obj) {\n\t\t    obj = [];\n\t\t  }\n\t\t  return obj;\n\t\t}\n\t\n\t\tfunction extendFunction() {\n\t\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t    fns[_key] = arguments[_key];\n\t\t  }\n\t\n\t\t  return function extendedFunction() {\n\t\t    var args = arguments;\n\t\t    fns.forEach(function (fn) {\n\t\t      return fn.apply(null, args);\n\t\t    });\n\t\t  };\n\t\t}\n\t\n\t\tfunction extendArray(primary, secondary, property) {\n\t\t  if (property) {\n\t\t    primary = primary[property];\n\t\t    secondary = secondary[property];\n\t\t  }\n\t\t  if (secondary && primary) {\n\t\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t\t      if (primary.indexOf(item) === -1) {\n\t\t        primary.push(item);\n\t\t      }\n\t\t    });\n\t\t    return primary;\n\t\t  } else if (secondary) {\n\t\t    return secondary;\n\t\t  } else {\n\t\t    return primary;\n\t\t  }\n\t\t}\n\t\n\t\tfunction startsWith(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\n\t\tfunction contains(str, search) {\n\t\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t\t  } else {\n\t\t    return false;\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\texports['default'] = formlyValidationMessages;\n\t\n\t\t// @ngInject\n\t\tfunction formlyValidationMessages() {\n\t\n\t\t  var validationMessages = {\n\t\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t\t    addStringMessage: addStringMessage,\n\t\t    messages: {}\n\t\t  };\n\t\n\t\t  return validationMessages;\n\t\n\t\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t\t  }\n\t\n\t\t  function addStringMessage(name, string) {\n\t\t    validationMessages.messages[name] = function () {\n\t\t      return string;\n\t\t    };\n\t\t  }\n\t\n\t\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t\t      if (typeof scope.options.templateOptions[prop] !== 'undefined') {\n\t\t        return prefix + ' ' + scope.options.templateOptions[prop] + ' ' + suffix;\n\t\t      } else {\n\t\t        return alternate;\n\t\t      }\n\t\t    };\n\t\t  }\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\t\n\t\texports['default'] = formlyUtil;\n\t\n\t\t// @ngInject\n\t\tfunction formlyUtil() {\n\t\t  return _otherUtils2['default'];\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\texports['default'] = formlyWarn;\n\t\n\t\t// @ngInject\n\t\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t\t  return function warn() {\n\t\t    if (!formlyConfig.disableWarnings) {\n\t\t      var args = Array.prototype.slice.call(arguments);\n\t\t      var warnInfoSlug = args.shift();\n\t\t      args.unshift('Formly Warning:');\n\t\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t\t      $log.warn.apply($log, _toConsumableArray(args));\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyCustomValidation;\n\t\n\t\t// @ngInject\n\t\tfunction formlyCustomValidation(formlyUtil) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    require: 'ngModel',\n\t\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t\t      var opts = scope.options;\n\t\t      opts.validation.messages = opts.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t\t        opts.validation.messages[key] = function () {\n\t\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t        };\n\t\t      });\n\t\n\t\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\t\n\t\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t\t        setupMessage(validator, name);\n\t\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t\t        if (useNewValidatorsApi) {\n\t\t          setupWithValidators(validator, name, isAsync);\n\t\t        } else {\n\t\t          setupWithParsers(validator, name, isAsync);\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupMessage(validator, name) {\n\t\t        var message = validator.message;\n\t\t        if (message) {\n\t\t          opts.validation.messages[name] = function () {\n\t\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t\t          };\n\t\t        }\n\t\t      }\n\t\n\t\t      function setupWithValidators(validator, name, isAsync) {\n\t\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\t\n\t\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t\t        };\n\t\t      }\n\t\n\t\t      function setupWithParsers(validator, name, isAsync) {\n\t\t        var inFlightValidator = undefined;\n\t\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t\t          if (isAsync) {\n\t\t            ctrl.$pending = ctrl.$pending || {};\n\t\t            ctrl.$pending[name] = true;\n\t\t            inFlightValidator = isValid;\n\t\t            isValid.then(function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, true);\n\t\t              }\n\t\t            })['catch'](function () {\n\t\t              if (inFlightValidator === isValid) {\n\t\t                ctrl.$setValidity(name, false);\n\t\t              }\n\t\t            })['finally'](function () {\n\t\t              var $pending = ctrl.$pending || {};\n\t\t              if (Object.keys($pending).length === 1) {\n\t\t                delete ctrl.$pending;\n\t\t              } else {\n\t\t                delete ctrl.$pending[name];\n\t\t              }\n\t\t            });\n\t\t          } else {\n\t\t            ctrl.$setValidity(name, isValid);\n\t\t          }\n\t\t          return viewValue;\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _apiCheck = __webpack_require__(5);\n\t\n\t\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\t\n\t\texports['default'] = formlyField;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyField\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t\t  var arrayify = formlyUtil.arrayify;\n\t\n\t\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    transclude: true,\n\t\t    require: '?^formlyForm',\n\t\t    scope: {\n\t\t      options: '=',\n\t\t      model: '=',\n\t\t      originalModel: '=?',\n\t\t      formId: '@', // TODO remove formId in a breaking release\n\t\t      index: '=?',\n\t\t      fields: '=?',\n\t\t      formState: '=?',\n\t\t      formOptions: '=?',\n\t\t      form: '=?' },\n\t\t    // TODO require form in a breaking release\n\t\t    controller: FormlyFieldController,\n\t\t    link: fieldLink\n\t\t  };\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t\t    /* eslint max-statements:[2, 34] */\n\t\t    if ($scope.options.fieldGroup) {\n\t\t      setupFieldGroup();\n\t\t      return;\n\t\t    }\n\t\n\t\t    var fieldType = getFieldType($scope.options);\n\t\t    simplifyLife($scope.options);\n\t\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t\t    checkApi($scope.options);\n\t\t    // set field id to link labels and fields\n\t\n\t\t    // initalization\n\t\t    setFieldIdAndName();\n\t\t    setDefaultValue();\n\t\t    setInitialValue();\n\t\t    runExpressions();\n\t\t    watchExpressions();\n\t\t    addValidationMessages($scope.options);\n\t\t    invokeControllers($scope, $scope.options, fieldType);\n\t\n\t\t    // function definitions\n\t\t    function runExpressions() {\n\t\t      // must run on next tick to make sure that the current value is correct.\n\t\t      return $timeout(function runExpressionsOnNextTick() {\n\t\t        var field = $scope.options;\n\t\t        var currentValue = valueGetterSetter();\n\t\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t\t          var setter = $parse(prop).assign;\n\t\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t\t          promise.then(function setFieldValue(value) {\n\t\t            setter(field, value);\n\t\t          });\n\t\t        });\n\t\t      }, 0, false);\n\t\t    }\n\t\n\t\t    function watchExpressions() {\n\t\t      if ($scope.formOptions.watchAllExpressions) {\n\t\t        (function () {\n\t\t          var field = $scope.options;\n\t\t          var currentValue = valueGetterSetter();\n\t\t          _angularFix2['default'].forEach(field.expressionProperties, function watchExpression(expression, prop) {\n\t\t            var setter = $parse(prop).assign;\n\t\t            $scope.$watch(function expressionPropertyWatcher() {\n\t\t              return formlyUtil.formlyEval($scope, expression, currentValue, currentValue);\n\t\t            }, function expressionPropertyListener(value) {\n\t\t              setter(field, value);\n\t\t            }, true);\n\t\t          });\n\t\t        })();\n\t\t      }\n\t\t    }\n\t\n\t\t    function valueGetterSetter(newVal) {\n\t\t      if (!$scope.model || !$scope.options.key) {\n\t\t        return undefined;\n\t\t      }\n\t\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t\t        parseSet($scope.options.key, $scope.model, newVal);\n\t\t      }\n\t\t      return parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function shouldNotUseParseKey(key) {\n\t\t      return _angularFix2['default'].isNumber(key) || !formlyUtil.containsSelector(key);\n\t\t    }\n\t\n\t\t    function parseSet(key, model, newVal) {\n\t\t      // If either of these are null/undefined then just return undefined\n\t\t      if (!key || !model) {\n\t\t        return;\n\t\t      }\n\t\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t\t      if (shouldNotUseParseKey(key)) {\n\t\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t\t        model[key] = newVal;\n\t\t      } else {\n\t\t        var setter = $parse($scope.options.key).assign;\n\t\t        if (setter) {\n\t\t          setter($scope.model, newVal);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function parseGet(key, model) {\n\t\t      // If either of these are null/undefined then just return undefined\n\t\t      if (!key || !model) {\n\t\t        return undefined;\n\t\t      }\n\t\n\t\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t\t      if (shouldNotUseParseKey(key)) {\n\t\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t\t        return model[key];\n\t\t      } else {\n\t\t        return $parse(key)(model);\n\t\t      }\n\t\t    }\n\t\n\t\t    function simplifyLife(options) {\n\t\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t\t      formlyUtil.reverseDeepMerge(options, {\n\t\t        originalModel: options.model,\n\t\t        extras: {},\n\t\t        data: {},\n\t\t        templateOptions: {},\n\t\t        validation: {}\n\t\t      });\n\t\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t\t      $scope.to = $scope.options.templateOptions;\n\t\t      $scope.formOptions = $scope.formOptions || {};\n\t\t    }\n\t\n\t\t    function setFieldIdAndName() {\n\t\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t\t      } else {\n\t\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t\t      }\n\t\t      $scope.options.id = $scope.id;\n\t\t      $scope.name = $scope.options.name || $scope.options.id;\n\t\t      $scope.options.name = $scope.name;\n\t\t    }\n\t\n\t\t    function setDefaultValue() {\n\t\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined(parseGet($scope.options.key, $scope.model))) {\n\t\t        parseSet($scope.options.key, $scope.model, $scope.options.defaultValue);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setInitialValue() {\n\t\t      $scope.options.initialValue = $scope.model && parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t\t      if (type) {\n\t\t        mergeOptions(options, type.defaultOptions);\n\t\t      }\n\t\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t\t      });\n\t\t    }\n\t\n\t\t    function mergeOptions(options, extraOptions) {\n\t\t      if (extraOptions) {\n\t\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t\t          extraOptions = extraOptions(options, $scope);\n\t\t        }\n\t\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t\t      }\n\t\t    }\n\t\n\t\t    function extendOptionsWithDefaults(options, index) {\n\t\t      var key = options.key || index || 0;\n\t\t      _angularFix2['default'].extend(options, {\n\t\t        // attach the key in case the formly-field directive is used directly\n\t\t        key: key,\n\t\t        value: options.value || valueGetterSetter,\n\t\t        runExpressions: runExpressions,\n\t\t        resetModel: resetModel,\n\t\t        updateInitialValue: updateInitialValue\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      parseSet($scope.options.key, $scope.model, $scope.options.initialValue);\n\t\t      if ($scope.options.formControl) {\n\t\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t\t            resetFormControl(formControl, true);\n\t\t          });\n\t\t        } else {\n\t\t          resetFormControl($scope.options.formControl);\n\t\t        }\n\t\t      }\n\t\t      if ($scope.form) {\n\t\t        $scope.form.$setUntouched && $scope.form.$setUntouched();\n\t\t        $scope.form.$setPristine();\n\t\t      }\n\t\t    }\n\t\n\t\t    function resetFormControl(formControl, isMultiNgModel) {\n\t\t      if (!isMultiNgModel) {\n\t\t        formControl.$setViewValue(parseGet($scope.options.key, $scope.model));\n\t\t      }\n\t\n\t\t      formControl.$render();\n\t\t      formControl.$setUntouched && formControl.$setUntouched();\n\t\t      formControl.$setPristine();\n\t\n\t\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t\t      if (!$scope.$root.$$phase) {\n\t\t        $scope.$digest();\n\t\t      }\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      $scope.options.initialValue = parseGet($scope.options.key, $scope.model);\n\t\t    }\n\t\n\t\t    function addValidationMessages(options) {\n\t\t      options.validation.messages = options.validation.messages || {};\n\t\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t\t        if (!options.validation.messages[name]) {\n\t\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t\t          };\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function invokeControllers(scope) {\n\t\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t\t        if (controller) {\n\t\t          $controller(controller, { $scope: scope });\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupFieldGroup() {\n\t\t      $scope.options.options = $scope.options.options || {};\n\t\t      $scope.options.options.formState = $scope.formState;\n\t\t      $scope.to = $scope.options.templateOptions;\n\t\t    }\n\t\t  }\n\t\n\t\t  // link function\n\t\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t\t    if (scope.options.fieldGroup) {\n\t\t      setFieldGroupTemplate();\n\t\t      return;\n\t\t    }\n\t\n\t\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t\t    if (!formlyFormCtrl && scope.options.model) {\n\t\t      scope.$watch('options.model', function () {\n\t\t        return scope.options.runExpressions();\n\t\t      }, true);\n\t\t    }\n\t\n\t\t    addAttributes();\n\t\t    addClasses();\n\t\n\t\t    var type = getFieldType(scope.options);\n\t\t    var args = arguments;\n\t\t    var thusly = this;\n\t\t    var fieldCount = 0;\n\t\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t\t    });\n\t\n\t\t    function setFieldGroupTemplate() {\n\t\t      checkFieldGroupApi(scope.options);\n\t\t      el.addClass('formly-field-group');\n\t\t      var extraAttributes = '';\n\t\t      if (scope.options.elementAttributes) {\n\t\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t\t        }).join(' ');\n\t\t      }\n\t\t      var modelValue = 'model';\n\t\t      scope.options.form = scope.form;\n\t\t      if (scope.options.key) {\n\t\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t\t      }\n\t\t      getTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ').then(transcludeInWrappers(scope.options, scope.formOptions)).then(setElementTemplate);\n\t\t    }\n\t\n\t\t    function addAttributes() {\n\t\t      if (scope.options.elementAttributes) {\n\t\t        el.attr(scope.options.elementAttributes);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addClasses() {\n\t\t      if (scope.options.className) {\n\t\t        el.addClass(scope.options.className);\n\t\t      }\n\t\t      if (scope.options.type) {\n\t\t        el.addClass('formly-field-' + scope.options.type);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setElementTemplate(templateString) {\n\t\t      el.html(asHtml(templateString));\n\t\t      $compile(el.contents())(scope);\n\t\t      return templateString;\n\t\t    }\n\t\n\t\t    function watchFormControl(templateString) {\n\t\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t\t      if (scope.options.noFormControl) {\n\t\t        return;\n\t\t      }\n\t\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\t\n\t\t      if (ngModelNodes.length) {\n\t\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t\t          fieldCount++;\n\t\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t\t        });\n\t\t      }\n\t\n\t\t      function watchFieldNameOrExistence(name) {\n\t\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t\t        var nameExpression = nameExpressionRegex.exec(name);\n\t\t        if (nameExpression) {\n\t\t          name = $interpolate(name)(scope);\n\t\t        }\n\t\t        watchFieldExistence(name);\n\t\t      }\n\t\n\t\t      function watchFieldExistence(name) {\n\t\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t\t          if (formControl) {\n\t\t            if (fieldCount > 1) {\n\t\t              if (!scope.options.formControl) {\n\t\t                scope.options.formControl = [];\n\t\t              }\n\t\t              scope.options.formControl.push(formControl);\n\t\t            } else {\n\t\t              scope.options.formControl = formControl;\n\t\t            }\n\t\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t\t            stopWatchingShowError();\n\t\t            addShowMessagesWatcher();\n\t\t            addParsers();\n\t\t            addFormatters();\n\t\t          }\n\t\t        });\n\t\t      }\n\t\n\t\t      function addShowMessagesWatcher() {\n\t\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t\t          var options = scope.options;\n\t\t          var formControls = arrayify(scope.fc);\n\t\t          if (!formControls.some(function (fc) {\n\t\t            return fc.$invalid;\n\t\t          })) {\n\t\t            return false;\n\t\t          } else if (typeof options.validation.show === 'boolean') {\n\t\t            return options.validation.show;\n\t\t          } else if (customExpression) {\n\t\t            return formControls.some(function (fc) {\n\t\t              return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t\t            });\n\t\t          } else {\n\t\t            return formControls.some(function (fc) {\n\t\t              var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t\t              return fc.$touched || noTouchedButDirty;\n\t\t            });\n\t\t          }\n\t\t        }, function onShowValidationChange(show) {\n\t\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t\t          scope.showError = show; // shortcut for template authors\n\t\t        });\n\t\t      }\n\t\n\t\t      function addParsers() {\n\t\t        setParsersOrFormatters('parsers');\n\t\t      }\n\t\n\t\t      function addFormatters() {\n\t\t        setParsersOrFormatters('formatters');\n\t\t        var ctrl = scope.fc;\n\t\t        var formWasPristine = scope.form.$pristine;\n\t\t        if (scope.options.formatters) {\n\t\t          (function () {\n\t\t            var value = ctrl.$modelValue;\n\t\t            ctrl.$formatters.forEach(function (formatter) {\n\t\t              value = formatter(value);\n\t\t            });\n\t\n\t\t            ctrl.$setViewValue(value);\n\t\t            ctrl.$render();\n\t\t            ctrl.$setPristine();\n\t\t            if (formWasPristine) {\n\t\t              scope.form.$setPristine();\n\t\t            }\n\t\t          })();\n\t\t        }\n\t\t      }\n\t\n\t\t      function setParsersOrFormatters(which) {\n\t\t        var originalThingProp = 'originalParser';\n\t\t        if (which === 'formatters') {\n\t\t          originalThingProp = 'originalFormatter';\n\t\t        }\n\t\n\t\t        // init with type's parsers\n\t\t        var things = getThingsFromType(type);\n\t\n\t\t        // get optionsTypes things\n\t\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\t\n\t\t        // get field's things\n\t\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\t\n\t\t        // convert things into formlyExpression things\n\t\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t\t          things[index] = getFormlyExpressionThing(thing);\n\t\t        });\n\t\n\t\t        var ngModelCtrls = scope.fc;\n\t\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t\t          ngModelCtrls = [ngModelCtrls];\n\t\t        }\n\t\n\t\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t\t          var _ngModelCtrl;\n\t\n\t\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t\t        });\n\t\n\t\t        function getThingsFromType(theType) {\n\t\t          if (!theType) {\n\t\t            return [];\n\t\t          }\n\t\t          if (_angularFix2['default'].isString(theType)) {\n\t\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t\t          }\n\t\t          var typeThings = [];\n\t\n\t\t          // get things from parent\n\t\t          if (theType['extends']) {\n\t\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t\t          }\n\t\n\t\t          // get own type's things\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\t\n\t\t          // get things from optionsTypes\n\t\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\t\n\t\t          return typeThings;\n\t\t        }\n\t\n\t\t        function getThingsFromOptionsTypes() {\n\t\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\t\n\t\t          var optionsTypesThings = [];\n\t\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t\t          });\n\t\t          return optionsTypesThings;\n\t\t        }\n\t\n\t\t        function getFormlyExpressionThing(thing) {\n\t\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t\t          return formlyExpressionParserOrFormatterFunction;\n\t\n\t\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t\t            var $modelValue = scope.options.value();\n\t\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function callLinkFunctions() {\n\t\t      if (type && type.link) {\n\t\t        type.link.apply(thusly, args);\n\t\t      }\n\t\t      if (scope.options.link) {\n\t\t        scope.options.link.apply(thusly, args);\n\t\t      }\n\t\t    }\n\t\n\t\t    function runManipulators(manipulators) {\n\t\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t\t        var chain = $q.when(templateToManipulate);\n\t\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t\t          chain = chain.then(function (template) {\n\t\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t\t            });\n\t\t          });\n\t\t        });\n\t\t        return chain;\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  // sort-of stateless util functions\n\t\t  function asHtml(el) {\n\t\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t\t    return wrapper.append(el).html();\n\t\t  }\n\t\n\t\t  function getFieldType(options) {\n\t\t    return options.type && formlyConfig.getType(options.type);\n\t\t  }\n\t\n\t\t  function getManipulators(options, formOptions) {\n\t\t    var preWrapper = [];\n\t\t    var postWrapper = [];\n\t\t    addManipulators(options.templateManipulators);\n\t\t    addManipulators(formOptions.templateManipulators);\n\t\t    addManipulators(formlyConfig.templateManipulators);\n\t\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\t\n\t\t    function addManipulators(manipulators) {\n\t\t      /* eslint-disable */ // it doesn't understand this :-(\n\t\n\t\t      var _ref = manipulators || {};\n\t\n\t\t      var _ref$preWrapper = _ref.preWrapper;\n\t\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t\t      var _ref$postWrapper = _ref.postWrapper;\n\t\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\t\n\t\t      preWrapper = preWrapper.concat(pre);\n\t\t      postWrapper = postWrapper.concat(post);\n\t\t      /* eslint-enable */\n\t\t    }\n\t\t  }\n\t\n\t\t  function getFieldTemplate(options) {\n\t\t    function fromOptionsOrType(key, fieldType) {\n\t\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t\t        return options[key];\n\t\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t\t        return fieldType[key];\n\t\t      }\n\t\t    }\n\t\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    var template = fromOptionsOrType('template', type);\n\t\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t\t    }\n\t\n\t\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t\t  }\n\t\n\t\t  function getTemplate(template, isUrl, options) {\n\t\t    var templatePromise = undefined;\n\t\t    if (_angularFix2['default'].isFunction(template)) {\n\t\t      templatePromise = $q.when(template(options));\n\t\t    } else {\n\t\t      templatePromise = $q.when(template);\n\t\t    }\n\t\n\t\t    if (!isUrl) {\n\t\t      return templatePromise;\n\t\t    } else {\n\t\t      var _ret3 = (function () {\n\t\t        var httpOptions = { cache: $templateCache };\n\t\t        return {\n\t\t          v: templatePromise.then(function (url) {\n\t\t            return $http.get(url, httpOptions);\n\t\t          }).then(function (response) {\n\t\t            return response.data;\n\t\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t\t          })\n\t\t        };\n\t\t      })();\n\t\n\t\t      if (typeof _ret3 === 'object') return _ret3.v;\n\t\t    }\n\t\t  }\n\t\n\t\t  function transcludeInWrappers(options, formOptions) {\n\t\t    var wrapper = getWrapperOption(options, formOptions);\n\t\n\t\t    return function transcludeTemplate(template) {\n\t\t      if (!wrapper.length) {\n\t\t        return $q.when(template);\n\t\t      }\n\t\n\t\t      wrapper.forEach(function (aWrapper) {\n\t\t        formlyUsability.checkWrapper(aWrapper, options);\n\t\t        runApiCheck(aWrapper, options);\n\t\t      });\n\t\t      var promises = wrapper.map(function (w) {\n\t\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t\t      });\n\t\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t\t        });\n\t\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t\t        var totalWrapper = wrappersTemplates.shift();\n\t\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t\t        });\n\t\t        return doTransclusion(totalWrapper, template);\n\t\t      });\n\t\t    };\n\t\t  }\n\t\n\t\t  function doTransclusion(wrapper, template) {\n\t\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t\t    superWrapper.append(wrapper);\n\t\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t\t    if (!transcludeEl.length) {\n\t\t      // try it using our custom find function\n\t\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t\t    }\n\t\t    transcludeEl.replaceWith(template);\n\t\t    return superWrapper.html();\n\t\t  }\n\t\n\t\t  function getWrapperOption(options, formOptions) {\n\t\t    /* eslint complexity:[2, 6] */\n\t\t    var wrapper = options.wrapper;\n\t\t    // explicit null means no wrapper\n\t\t    if (wrapper === null) {\n\t\t      return [];\n\t\t    }\n\t\n\t\t    // nothing specified means use the default wrapper for the type\n\t\t    if (!wrapper) {\n\t\t      // get all wrappers that specify they apply to this type\n\t\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t\t    } else {\n\t\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t\t    }\n\t\n\t\t    // get all wrappers for that the type specified that it uses.\n\t\t    var type = formlyConfig.getType(options.type, true, options);\n\t\t    if (type && type.wrapper) {\n\t\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(typeWrappers);\n\t\t    }\n\t\n\t\t    // add form wrappers\n\t\t    if (formOptions.wrapper) {\n\t\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t\t      wrapper = wrapper.concat(formWrappers);\n\t\t    }\n\t\n\t\t    // add the default wrapper last\n\t\t    var defaultWrapper = formlyConfig.getWrapper();\n\t\t    if (defaultWrapper) {\n\t\t      wrapper.push(defaultWrapper);\n\t\t    }\n\t\t    return wrapper;\n\t\t  }\n\t\n\t\t  function checkApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t    // validate with the type\n\t\t    var type = options.type && formlyConfig.getType(options.type);\n\t\t    if (type) {\n\t\t      runApiCheck(type, options, true);\n\t\t    }\n\t\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t\t    }\n\t\t  }\n\t\n\t\t  function checkFieldGroupApi(options) {\n\t\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t\t      prefix: 'formly-field directive',\n\t\t      url: 'formly-field-directive-validation-failed'\n\t\t    });\n\t\t  }\n\t\n\t\t  function runApiCheck(_ref2, options, forType) {\n\t\t    var apiCheck = _ref2.apiCheck;\n\t\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\t\n\t\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t\t    if (forType && options.type) {\n\t\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t\t    /* eslint complexity:[2, 9] */\n\t\t    if (!apiCheck) {\n\t\t      return;\n\t\t    }\n\t\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t\t      return;\n\t\t    }\n\t\t    var fn = apiCheckFunction || 'warn';\n\t\t    // this is the new API\n\t\t    var checkerObjects = apiCheck(instance);\n\t\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t\t      var checker = instance.shape(shape);\n\t\t      var checkOptions = _angularFix2['default'].extend({\n\t\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t\t      }, apiCheckOptions);\n\t\t      instance[fn](checker, options[name], checkOptions);\n\t\t    });\n\t\t  }\n\t\t}\n\t\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\t\n\t\t// Stateless util functions\n\t\tfunction getDefaultOptionsOptionsTypes(type) {\n\t\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t\t}\n\t\n\t\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t\t}\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\texports['default'] = formlyFocus;\n\t\n\t\t// @ngInject\n\t\tfunction formlyFocus($timeout, $document) {\n\t\t  return {\n\t\t    restrict: 'A',\n\t\t    link: function formlyFocusLink(scope, element, attrs) {\n\t\t      var previousEl = null;\n\t\t      var el = element[0];\n\t\t      var doc = $document[0];\n\t\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t\t        if (value === 'true') {\n\t\t          $timeout(function setElementFocus() {\n\t\t            previousEl = doc.activeElement;\n\t\t            el.focus();\n\t\t          }, ~ ~attrs.focusWait);\n\t\t        } else if (value === 'false') {\n\t\t          if (doc.activeElement === el) {\n\t\t            el.blur();\n\t\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t\t              previousEl.focus();\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t  };\n\t\t}\n\t\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar _slice = Array.prototype.slice;\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = formlyForm;\n\t\n\t\t/**\n\t\t * @ngdoc directive\n\t\t * @name formlyForm\n\t\t * @restrict AE\n\t\t */\n\t\t// @ngInject\n\t\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t\t  var currentFormId = 1;\n\t\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t\t  return {\n\t\t    restrict: 'AE',\n\t\t    template: formlyFormGetTemplate,\n\t\t    replace: true,\n\t\t    transclude: true,\n\t\t    scope: {\n\t\t      fields: '=',\n\t\t      model: '=',\n\t\t      form: '=?',\n\t\t      options: '=?'\n\t\t    },\n\t\t    controller: FormlyFormController,\n\t\t    link: formlyFormLink\n\t\t  };\n\t\n\t\t  function formlyFormGetTemplate(el, attrs) {\n\t\t    var rootEl = getRootEl();\n\t\t    var fieldRootEl = getFieldRootEl();\n\t\t    var formId = 'formly_' + currentFormId++;\n\t\t    var parentFormAttributes = '';\n\t\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t\t    }\n\t\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\t\n\t\t    function getRootEl() {\n\t\t      return attrs.rootEl || 'ng-form';\n\t\t    }\n\t\n\t\t    function getFieldRootEl() {\n\t\t      return attrs.fieldRootEl || 'div';\n\t\t    }\n\t\n\t\t    function getHideDirective() {\n\t\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t\t    }\n\t\n\t\t    function getTrackBy() {\n\t\t      if (!attrs.trackBy) {\n\t\t        return '';\n\t\t      } else {\n\t\t        return 'track by ' + attrs.trackBy;\n\t\t      }\n\t\t    }\n\t\n\t\t    function getFormName() {\n\t\t      var formName = formId;\n\t\t      var bindName = attrs.bindName;\n\t\t      if (bindName) {\n\t\t        if (_angularFix2['default'].version.minor < 3) {\n\t\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t\t        }\n\t\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t\t      }\n\t\t      return formName;\n\t\t    }\n\t\n\t\t    function getTranscludeClass() {\n\t\t      return attrs.transcludeClass || '';\n\t\t    }\n\t\n\t\t    function copyAttributes(attributes) {\n\t\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t\t      var arrayAttrs = [];\n\t\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t\t        var nodeName = _ref.nodeName;\n\t\t        var value = _ref.value;\n\t\n\t\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t\t        }\n\t\t      });\n\t\t      return arrayAttrs.join(' ');\n\t\t    }\n\t\t  }\n\t\n\t\t  // @ngInject\n\t\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t\t    setupOptions();\n\t\t    $scope.model = $scope.model || {};\n\t\t    setupFields();\n\t\n\t\t    // watch the model and evaluate watch expressions that depend on it.\n\t\t    if (!$scope.options.manualModelWatcher) {\n\t\t      $scope.$watch('model', onModelOrFormStateChange, true);\n\t\t    } else if (_angularFix2['default'].isFunction($scope.options.manualModelWatcher)) {\n\t\t      $scope.$watch($scope.options.manualModelWatcher, onModelOrFormStateChange, true);\n\t\t    }\n\t\n\t\t    if ($scope.options.formState) {\n\t\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t\t    }\n\t\n\t\t    function onModelOrFormStateChange() {\n\t\t      _angularFix2['default'].forEach($scope.fields, runFieldExpressionProperties);\n\t\t    }\n\t\n\t\t    function validateFormControl(formControl, promise) {\n\t\t      var validate = formControl.$validate;\n\t\t      if (promise) {\n\t\t        promise.then(validate);\n\t\t      } else {\n\t\t        validate();\n\t\t      }\n\t\t    }\n\t\n\t\t    function runFieldExpressionProperties(field, index) {\n\t\t      var model = field.model || $scope.model;\n\t\t      var promise = field.runExpressions && field.runExpressions();\n\t\t      if (field.hideExpression) {\n\t\t        // can't use hide with expressionProperties reliably\n\t\t        var val = model[field.key];\n\t\t        field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t\t      }\n\t\t      if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t\t        if (_angularFix2['default'].isArray(field.formControl)) {\n\t\t          _angularFix2['default'].forEach(field.formControl, function (formControl) {\n\t\t            validateFormControl(formControl, promise);\n\t\t          });\n\t\t        } else {\n\t\t          validateFormControl(field.formControl, promise);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupFields() {\n\t\t      $scope.fields = $scope.fields || [];\n\t\n\t\t      checkDeprecatedOptions($scope.options);\n\t\n\t\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\t\n\t\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t\t        fieldTransforms = [fieldTransforms];\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t\t        if (fieldTransform) {\n\t\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t\t          if (!$scope.fields) {\n\t\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t\t          }\n\t\t        }\n\t\t      });\n\t\n\t\t      setupModels();\n\t\n\t\t      if ($scope.options.watchAllExpressions) {\n\t\t        _angularFix2['default'].forEach($scope.fields, setupHideExpressionWatcher);\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t\t    }\n\t\n\t\t    function checkDeprecatedOptions(options) {\n\t\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupOptions() {\n\t\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t\t      $scope.options = $scope.options || {};\n\t\t      $scope.options.formState = $scope.options.formState || {};\n\t\n\t\t      _angularFix2['default'].extend($scope.options, {\n\t\t        updateInitialValue: updateInitialValue,\n\t\t        resetModel: resetModel\n\t\t      });\n\t\t    }\n\t\n\t\t    function updateInitialValue() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.updateInitialValue();\n\t\t        } else {\n\t\t          field.updateInitialValue();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function resetModel() {\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        if (isFieldGroup(field) && field.options) {\n\t\t          field.options.resetModel();\n\t\t        } else if (field.resetModel) {\n\t\t          field.resetModel();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupModels() {\n\t\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t\t      var watchedModels = [$scope.model];\n\t\t      // we will not set up automatic model watchers if manual mode is set\n\t\t      var manualModelWatcher = $scope.options.manualModelWatcher;\n\t\n\t\t      if ($scope.options.formState) {\n\t\t        // $scope.options.formState will have its own watcher\n\t\t        watchedModels.push($scope.options.formState);\n\t\t      }\n\t\n\t\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t\t        var isNewModel = initModel(field);\n\t\n\t\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1 && !manualModelWatcher) {\n\t\t          $scope.$watch(function () {\n\t\t            return field.model;\n\t\t          }, onModelOrFormStateChange, true);\n\t\t          watchedModels.push(field.model);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function setupHideExpressionWatcher(field, index) {\n\t\t      if (field.hideExpression) {\n\t\t        (function () {\n\t\t          // can't use hide with expressionProperties reliably\n\t\t          var model = field.model || $scope.model;\n\t\t          $scope.$watch(function hideExpressionWatcher() {\n\t\t            var val = model[field.key];\n\t\t            return evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t\t          }, function (hide) {\n\t\t            return field.hide = hide;\n\t\t          }, true);\n\t\t        })();\n\t\t      }\n\t\t    }\n\t\n\t\t    function initModel(field) {\n\t\t      var isNewModel = true;\n\t\n\t\t      if (_angularFix2['default'].isString(field.model)) {\n\t\t        var expression = field.model;\n\t\t        var index = $scope.fields.indexOf(field);\n\t\n\t\t        isNewModel = !referencesCurrentlyWatchedModel(expression);\n\t\n\t\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t\t        if (!field.model) {\n\t\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t\t        }\n\t\t      }\n\t\t      return isNewModel;\n\t\t    }\n\t\n\t\t    function referencesCurrentlyWatchedModel(expression) {\n\t\t      return ['model', 'formState'].some(function (item) {\n\t\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t\t      });\n\t\t    }\n\t\n\t\t    function attachKey(field, index) {\n\t\t      if (!isFieldGroup(field)) {\n\t\t        field.key = field.key || index || 0;\n\t\t      }\n\t\t    }\n\t\n\t\t    function setupWatchers(field, index) {\n\t\t      if (!_angularFix2['default'].isDefined(field.watcher)) {\n\t\t        return;\n\t\t      }\n\t\t      var watchers = field.watcher;\n\t\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t\t        watchers = [watchers];\n\t\t      }\n\t\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t\t        if (!_angularFix2['default'].isDefined(watcher.listener) && !watcher.runFieldExpressions) {\n\t\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t\t        }\n\t\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t\t        var watchListener = getWatchListener(watcher, field, index);\n\t\n\t\t        var type = watcher.type || '$watch';\n\t\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t\t      });\n\t\t    }\n\t\n\t\t    function getWatchExpression(watcher, field, index) {\n\t\t      var watchExpression = undefined;\n\t\t      if (!_angularFix2['default'].isUndefined(watcher.expression)) {\n\t\t        watchExpression = watcher.expression;\n\t\t      } else if (field.key) {\n\t\t        watchExpression = 'model[\\'' + field.key.toString().split('.').join('\\'][\\'') + '\\']';\n\t\t      }\n\t\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t\t        (function () {\n\t\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalExpression = watchExpression;\n\t\t          watchExpression = function formlyWatchExpression() {\n\t\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t\t          };\n\t\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchExpression;\n\t\t    }\n\t\n\t\t    function getWatchListener(watcher, field, index) {\n\t\t      var watchListener = watcher.listener;\n\t\t      if (_angularFix2['default'].isFunction(watchListener) || watcher.runFieldExpressions) {\n\t\t        (function () {\n\t\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t\t          // and the stop function as the last arg as a helper\n\t\t          var originalListener = watchListener;\n\t\t          watchListener = function formlyWatchListener() {\n\t\t            var value = undefined;\n\t\t            if (originalListener) {\n\t\t              var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t\t              value = originalListener.apply(undefined, _toConsumableArray(args));\n\t\t            }\n\t\t            if (watcher.runFieldExpressions) {\n\t\t              runFieldExpressionProperties(field, index);\n\t\t            }\n\t\t            return value;\n\t\t          };\n\t\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t\t        })();\n\t\t      }\n\t\t      return watchListener;\n\t\t    }\n\t\n\t\t    function modifyArgs(watcher, index) {\n\t\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\t        originalArgs[_key - 2] = arguments[_key];\n\t\t      }\n\t\n\t\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t\t    }\n\t\n\t\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t\t    }\n\t\n\t\t    function getFormlyFieldLikeLocals(field, index) {\n\t\t      // this makes it closer to what a regular formlyExpression would be\n\t\t      return {\n\t\t        options: field,\n\t\t        index: index,\n\t\t        formState: $scope.options.formState,\n\t\t        originalModel: $scope.model,\n\t\t        formOptions: $scope.options,\n\t\t        formId: $scope.formId\n\t\t      };\n\t\t    }\n\t\t  }\n\t\n\t\t  function formlyFormLink(scope, el, attrs) {\n\t\t    setFormController();\n\t\t    fixChromeAutocomplete();\n\t\n\t\t    function setFormController() {\n\t\t      var formId = attrs.name;\n\t\t      scope.formId = formId;\n\t\t      scope.theFormlyForm = scope[formId];\n\t\t      if (attrs.form) {\n\t\t        var getter = $parse(attrs.form);\n\t\t        var setter = getter.assign;\n\t\t        var parentForm = getter(scope.$parent);\n\t\t        if (parentForm) {\n\t\t          scope.theFormlyForm = parentForm;\n\t\t          if (scope[formId]) {\n\t\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t\t          }\n\t\n\t\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t\t          // to children forms :-( This line was added to solve this issue:\n\t\t          // https://github.com/formly-js/angular-formly/issues/287\n\t\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t\t          // so I expect it will remain this way for the life of angular 1.x\n\t\t          el.removeData('$formController');\n\t\t        } else {\n\t\t          setter(scope.$parent, scope[formId]);\n\t\t        }\n\t\t      }\n\t\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t\t        /* eslint no-console:0 */\n\t\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t\t      }\n\t\t    }\n\t\n\t\t    /*\n\t\t     * chrome autocomplete lameness\n\t\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t\t     * ლ(ಠ益ಠლ)   (╯°□°)╯︵ ┻━┻    (◞‸◟；)\n\t\t     */\n\t\t    function fixChromeAutocomplete() {\n\t\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t\t      if (global && !offInstance || onInstance) {\n\t\t        var input = document.createElement('input');\n\t\t        input.setAttribute('autocomplete', 'address-level4');\n\t\t        input.setAttribute('hidden', 'true');\n\t\t        el[0].appendChild(input);\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  // stateless util functions\n\t\t  function toKebabCase(string) {\n\t\t    if (string) {\n\t\t      return string.replace(/([A-Z])/g, function ($1) {\n\t\t        return '-' + $1.toLowerCase();\n\t\t      });\n\t\t    } else {\n\t\t      return '';\n\t\t    }\n\t\t  }\n\t\n\t\t  function isFieldGroup(field) {\n\t\t    return field && !!field.fieldGroup;\n\t\t  }\n\t\t}\n\t\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\tvar _otherUtils = __webpack_require__(9);\n\t\n\t\texports['default'] = addFormlyNgModelAttrsManipulator;\n\t\n\t\t// @ngInject\n\t\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t\t    return;\n\t\t  }\n\t\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\t\n\t\t  function ngModelAttrsManipulator(template, options, scope) {\n\t\t    var node = document.createElement('div');\n\t\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t\t    if (skip === true) {\n\t\t      return template;\n\t\t    }\n\t\t    node.innerHTML = template;\n\t\n\t\t    var modelNodes = getNgModelNodes(node, skip);\n\t\t    if (!modelNodes || !modelNodes.length) {\n\t\t      return template;\n\t\t    }\n\t\n\t\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\t\n\t\t    addValidation();\n\t\t    alterNgModelAttr();\n\t\t    addModelOptions();\n\t\t    addTemplateOptionsAttrs();\n\t\t    addNgModelElAttrs();\n\t\n\t\t    return node.innerHTML;\n\t\n\t\t    function addValidation() {\n\t\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t\t      }\n\t\t    }\n\t\n\t\t    function alterNgModelAttr() {\n\t\t      if (isPropertyAccessor(options.key)) {\n\t\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t\t      }\n\t\t    }\n\t\n\t\t    function addModelOptions() {\n\t\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t\t        if (options.modelOptions.getterSetter) {\n\t\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t\t        }\n\t\t      }\n\t\t    }\n\t\n\t\t    function addTemplateOptionsAttrs() {\n\t\t      if (!options.templateOptions && !options.expressionProperties) {\n\t\t        // no need to run these if there are no templateOptions or expressionProperties\n\t\t        return;\n\t\t      }\n\t\t      var to = options.templateOptions || {};\n\t\t      var ep = options.expressionProperties || {};\n\t\n\t\t      var ngModelAttributes = getBuiltInAttributes();\n\t\n\t\t      // extend with the user's specifications winning\n\t\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\t\n\t\t      // Feel free to make this more simple :-)\n\t\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t\t        /* eslint complexity:[2, 14] */\n\t\t        var attrVal = undefined,\n\t\t            attrName = undefined;\n\t\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t\t        var toVal = to[name];\n\t\t        var epVal = getEpValue(ep, name);\n\t\n\t\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t\t        if (val.value) {\n\t\t          // I realize this looks backwards, but it's right, trust me...\n\t\t          attrName = val.value;\n\t\t          attrVal = name;\n\t\t        } else if (val.statement && inTo) {\n\t\t          attrName = val.statement;\n\t\t          if (_angularFix2['default'].isString(to[name])) {\n\t\t            attrVal = '$eval(' + ref + ')';\n\t\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t\t          } else {\n\t\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t\t          }\n\t\t        } else if (val.bound && inEp) {\n\t\t          attrName = val.bound;\n\t\t          attrVal = ref;\n\t\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t\t          attrName = val.attribute || val.boolean;\n\t\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t\t        } else if (val.attribute && inTo) {\n\t\t          attrName = val.attribute;\n\t\t          attrVal = toVal;\n\t\t        } else if (val.boolean) {\n\t\t          if (inTo && !inEp && toVal) {\n\t\t            attrName = val.boolean;\n\t\t            attrVal = true;\n\t\t          } else {\n\t\t            /* eslint no-empty:0 */\n\t\t            // empty to illustrate that a boolean will not be added via val.bound\n\t\t            // if you want it added via val.bound, then put it in expressionProperties\n\t\t          }\n\t\t        } else if (val.bound && inTo) {\n\t\t            attrName = val.bound;\n\t\t            attrVal = ref;\n\t\t          }\n\t\n\t\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t\t        }\n\t\t      });\n\t\t    }\n\t\n\t\t    function addNgModelElAttrs() {\n\t\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t\t        addRegardlessOfPresence(modelNodes, name, val);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\n\t\t  // Utility functions\n\t\t  function getNgModelNodes(node, skip) {\n\t\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t\t    try {\n\t\t      return node.querySelectorAll(query);\n\t\t    } catch (e) {\n\t\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t\t      //it should be removed when IE8 support is dropped\n\t\t      return getNgModelNodesFallback(node, skip);\n\t\t    }\n\t\t  }\n\t\n\t\t  function getNgModelNodesFallback(node, skip) {\n\t\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t\t    var matchingNgModelNodes = [];\n\t\n\t\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t\t    matchingNgModelNodes.item = function (i) {\n\t\t      return this[i];\n\t\t    };\n\t\n\t\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t\t      var ngModelNode = allNgModelNodes[i];\n\t\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t\t        matchingNgModelNodes.push(ngModelNode);\n\t\t      }\n\t\t    }\n\t\n\t\t    return matchingNgModelNodes;\n\t\t  }\n\t\n\t\t  function nodeMatches(node, selector) {\n\t\t    var div = document.createElement('div');\n\t\t    div.innerHTML = node.outerHTML;\n\t\t    return div.querySelector(selector);\n\t\t  }\n\t\n\t\t  function getBuiltInAttributes() {\n\t\t    var ngModelAttributes = {\n\t\t      focus: {\n\t\t        attribute: 'formly-focus'\n\t\t      }\n\t\t    };\n\t\t    var boundOnly = [];\n\t\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t\t    var attributeOnly = ['placeholder', 'min', 'max', 'step', 'tabindex', 'type'];\n\t\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t\t      bothAttributeAndBound.push('maxlength');\n\t\t    } else {\n\t\t      boundOnly.push('maxlength');\n\t\t    }\n\t\n\t\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t\t    });\n\t\n\t\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t\t      ngModelAttributes[item] = { attribute: item };\n\t\t    });\n\t\t    return ngModelAttributes;\n\t\t  }\n\t\n\t\t  function getEpValue(ep, name) {\n\t\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t\t  }\n\t\n\t\t  function addIfNotPresent(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      if (!node.getAttribute(attr)) {\n\t\t        node.setAttribute(attr, val);\n\t\t      }\n\t\t    });\n\t\t  }\n\t\n\t\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t\t      node.setAttribute(attr, val);\n\t\t    });\n\t\t  }\n\t\n\t\t  function isPropertyAccessor(key) {\n\t\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t\t  }\n\t\t}\n\t\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _angularFix = __webpack_require__(2);\n\t\n\t\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\t\n\t\texports['default'] = addCustomTags;\n\t\n\t\t// @ngInject\n\t\tfunction addCustomTags($document) {\n\t\t  // IE8 check ->\n\t\t  // https://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx\n\t\t  if ($document && $document.documentMode < 9) {\n\t\t    (function () {\n\t\t      var document = $document.get(0);\n\t\t      // add the custom elements that we need for formly\n\t\t      var customElements = ['formly-field', 'formly-form'];\n\t\t      _angularFix2['default'].forEach(customElements, function (el) {\n\t\t        document.createElement(el);\n\t\t      });\n\t\t    })();\n\t\t  }\n\t\t}\n\t\taddCustomTags.$inject = [\"$document\"];\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n\n/***/ 7:\n/***/ function(module, exports, __webpack_require__) {\n\n\t//! angular-formly-templates-bootstrap version 6.3.0 built with ♥ by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> (ó ì_í)=óò=(ì_í ò)\n\t\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(2), __webpack_require__(5), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\t\telse\n\t\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t\n\t\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\tvar ngModuleName = 'formlyBootstrap';\n\t\tvar angular = __webpack_require__(2);\n\t\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\t\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t\t  output: {\n\t\t    prefix: 'angular-formly-bootstrap'\n\t\t  }\n\t\t}));\n\t\tngModule.constant('formlyBootstrapVersion', (\"6.3.0\"));\n\t\n\t\t__webpack_require__(6)(ngModule);\n\t\t__webpack_require__(9)(ngModule);\n\t\t__webpack_require__(19)(ngModule);\n\t\n\t\texports['default'] = ngModuleName;\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t// some versions of angular don't export the angular module properly,\n\t\t// so we get it from window in this case.\n\t\t'use strict';\n\t\n\t\tvar angular = __webpack_require__(3);\n\t\tif (!angular.version) {\n\t\t  angular = window.angular;\n\t\t}\n\t\tmodule.exports = angular;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addWrappers);\n\t\n\t\t  function addWrappers(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setWrapper([{\n\t\t      name: 'bootstrapLabel',\n\t\t      template: __webpack_require__(7),\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string.optional,\n\t\t            required: check.bool.optional,\n\t\t            labelSrOnly: check.bool.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t\t  }\n\t\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  __webpack_require__(10)(ngModule);\n\t\t  __webpack_require__(12)(ngModule);\n\t\t  __webpack_require__(14)(ngModule);\n\t\t  __webpack_require__(15)(ngModule);\n\t\t  __webpack_require__(17)(ngModule);\n\t\t  __webpack_require__(18)(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'checkbox',\n\t\t      template: __webpack_require__(11),\n\t\t      wrapper: ['bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            label: check.string\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 12 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addCheckboxType);\n\t\n\t\t  function addCheckboxType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'multiCheckbox',\n\t\t      template: __webpack_require__(13),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      },\n\t\t      defaultOptions: {\n\t\t        noFormControl: false,\n\t\t        ngModelAttrs: {\n\t\t          required: {\n\t\t            attribute: '',\n\t\t            bound: ''\n\t\t          }\n\t\t        }\n\t\t      },\n\t\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t\t        var to = $scope.to;\n\t\t        var opts = $scope.options;\n\t\t        $scope.multiCheckbox = {\n\t\t          checked: [],\n\t\t          change: setModel\n\t\t        };\n\t\n\t\t        // initialize the checkboxes check property\n\t\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t\t          var modelValue, valueProp;\n\t\n\t\t          if (Object.keys(newModelValue).length) {\n\t\t            modelValue = newModelValue[opts.key];\n\t\n\t\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t\t                valueProp = to.valueProp || 'value';\n\t\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t\t                }\n\t\t              }\n\t\t            });\n\t\t          }\n\t\t        }, true);\n\t\n\t\t        function checkValidity(expressionValue) {\n\t\t          var valid;\n\t\n\t\t          if ($scope.to.required) {\n\t\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\t\n\t\t            $scope.fc.$setValidity('required', valid);\n\t\t          }\n\t\t        }\n\t\n\t\t        function setModel() {\n\t\t          $scope.model[opts.key] = [];\n\t\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t\t            if (checkbox) {\n\t\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t\t            }\n\t\t          });\n\t\n\t\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t\t          $scope.fc.$setTouched();\n\t\t          checkValidity(true);\n\t\t        }\n\t\n\t\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t\t          $scope.$watch(function () {\n\t\t            return $scope.to.required;\n\t\t          }, function (newValue) {\n\t\t            checkValidity(newValue);\n\t\t          });\n\t\t        }\n\t\n\t\t        if ($scope.to.required) {\n\t\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t\t            if (!newValue) {\n\t\t              return;\n\t\t            }\n\t\t            checkValidity(true);\n\t\t            unwatchFormControl();\n\t\t          });\n\t\t        }\n\t\t      }]\n\t\t    });\n\t\t  }\n\t\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 13 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 14 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addInputType);\n\t\n\t\t  function addInputType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'input',\n\t\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t\t    });\n\t\t  }\n\t\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 15 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addRadioType);\n\t\n\t\t  function addRadioType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'radio',\n\t\t      template: __webpack_require__(16),\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        noFormControl: false\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 16 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 17 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addSelectType);\n\t\n\t\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\t\n\t\t  function addSelectType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'select',\n\t\t      template: template,\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: function defaultOptions(options) {\n\t\t        /* jshint maxlen:195 */\n\t\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t\t        return {\n\t\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t\t          })\n\t\t        };\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            options: check.arrayOf(check.object),\n\t\t            optionsAttr: check.string.optional,\n\t\t            labelProp: check.string.optional,\n\t\t            valueProp: check.string.optional,\n\t\t            groupProp: check.string.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 18 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.config(addTextareaType);\n\t\n\t\t  function addTextareaType(formlyConfigProvider) {\n\t\t    formlyConfigProvider.setType({\n\t\t      name: 'textarea',\n\t\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t\t      defaultOptions: {\n\t\t        ngModelAttrs: {\n\t\t          rows: { attribute: 'rows' },\n\t\t          cols: { attribute: 'cols' }\n\t\t        }\n\t\t      },\n\t\t      apiCheck: function apiCheck(check) {\n\t\t        return {\n\t\t          templateOptions: {\n\t\t            rows: check.number.optional,\n\t\t            cols: check.number.optional\n\t\t          }\n\t\t        };\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 19 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\t\tvar _addons = __webpack_require__(20);\n\t\n\t\tvar _addons2 = _interopRequireDefault(_addons);\n\t\n\t\tvar _description = __webpack_require__(22);\n\t\n\t\tvar _description2 = _interopRequireDefault(_description);\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  (0, _addons2['default'])(ngModule);\n\t\t  (0, _description2['default'])(ngModule);\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 20 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addAddonsManipulator);\n\t\n\t\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t\t    var addonTemplate = __webpack_require__(21);\n\t\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t\t      'class': formlyBootstrapApiCheck.string.optional,\n\t\t      text: formlyBootstrapApiCheck.string.optional,\n\t\t      onClick: formlyBootstrapApiCheck.func.optional\n\t\t    }).strict.optional;\n\t\t    var api = formlyBootstrapApiCheck.shape({\n\t\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t\t        addonLeft: addonChecker,\n\t\t        addonRight: addonChecker\n\t\t      })\n\t\t    });\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t\t        return template;\n\t\t      }\n\t\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t\t    });\n\t\t  }\n\t\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ },\n\t/* 21 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this, $event)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this, $event)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\t\n\t/***/ },\n\t/* 22 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\n\t\tObject.defineProperty(exports, '__esModule', {\n\t\t  value: true\n\t\t});\n\t\n\t\texports['default'] = function (ngModule) {\n\t\t  ngModule.run(addDescriptionManipulator);\n\t\n\t\t  function addDescriptionManipulator(formlyConfig) {\n\t\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t\t      if (angular.isDefined(options.templateOptions.description)) {\n\t\t        var el = document.createElement('div');\n\t\t        el.appendChild(angular.element(template)[0]);\n\t\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t\t        if (modelEls) {\n\t\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t\t        }\n\t\t        return el.innerHTML;\n\t\t      } else {\n\t\t        return template;\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t\t};\n\t\n\t\tmodule.exports = exports['default'];\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\n/***/ },\n\n/***/ 8:\n/***/ function(module, exports) {\n\n\t/**\n\t * angular-permission\n\t * Route permission and access control as simple as it can get\n\t * @version v2.0.2 - 2016-02-03\n\t * @link http://www.rafaelvidaurre.com\n\t * @author Rafael Vidaurre <narzerus@gmail.com>\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  var permission = angular.module('permission', ['ui.router']);\n\t\n\t  /**\n\t   * This decorator is required to access full state object instead of it's configuration\n\t   * when trying to obtain full toState state object not it's configuration\n\t   * Can be removed when implemented https://github.com/angular-ui/ui-router/issues/13.\n\t   */\n\t  permission.config(['$stateProvider', function ($stateProvider) {\n\t    $stateProvider.decorator('parent', function (state, parentFn) {\n\t      state.self.getState = function () {\n\t        return state;\n\t      };\n\t      return parentFn(state);\n\t    });\n\t  }]);\n\t\n\t  permission.run(['$rootScope', '$state', '$q', 'Authorization', 'PermissionMap', function ($rootScope, $state, $q, Authorization, PermissionMap) {\n\t    $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams, options) {\n\t\n\t      if (toState.$$isAuthorizationFinished) {\n\t        return;\n\t      }\n\t\n\t      if (areSetStatePermissions(toState)) {\n\t        event.preventDefault();\n\t        setStateAuthorizationStatus(true);\n\t\n\t\n\t        if (!areStateEventsDefaultPrevented()) {\n\t          var compensatedPermissionMap = compensatePermissionMap(toState.data.permissions);\n\t          authorizeForState(compensatedPermissionMap);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Checks if state is qualified to be permission based verified\n\t       *\n\t       * @returns {boolean}\n\t       */\n\t      function areSetStatePermissions(state) {\n\t        return angular.isDefined(state.data) && angular.isDefined(state.data.permissions);\n\t      }\n\t\n\t      /**\n\t       * Sets internal state `$$finishedAuthorization` variable to prevent looping\n\t       *\n\t       * @param status {boolean} When true authorization has been already preceded\n\t       */\n\t      function setStateAuthorizationStatus(status) {\n\t        angular.extend(toState, {'$$isAuthorizationFinished': status});\n\t      }\n\t\n\t      /**\n\t       * Checks if state events are not prevented by default\n\t       *\n\t       * @returns {boolean}\n\t       */\n\t      function areStateEventsDefaultPrevented() {\n\t        return isStateChangePermissionStartDefaultPrevented() || isStateChangeStartDefaultPrevented();\n\t      }\n\t\n\t      /**\n\t       * Builds map of permissions resolving passed values to data.permissions and combine them with all its parents\n\t       * keeping the order of permissions from the newest (children) to the oldest (parent)\n\t       *\n\t       * @param statePermissionMap {Object} Current state permission map\n\t       * @returns {{only: Array, except: Array}} Permission map\n\t       */\n\t      function compensatePermissionMap(statePermissionMap) {\n\t        var permissionMap = new PermissionMap({redirectTo: statePermissionMap.redirectTo});\n\t\n\t        var toStatePath = $state\n\t          .get(toState.name)\n\t          .getState().path\n\t          .slice()\n\t          .reverse();\n\t\n\t        angular.forEach(toStatePath, function (state) {\n\t          if (areSetStatePermissions(state)) {\n\t            permissionMap.extendPermissionMap(new PermissionMap(state.data.permissions));\n\t          }\n\t        });\n\t\n\t        return permissionMap;\n\t      }\n\t\n\t      /**\n\t       * Handles state authorization\n\t       *\n\t       * @param permissions {Object} Map of \"only\" or \"except\" permission names\n\t       */\n\t      function authorizeForState(permissions) {\n\t        Authorization\n\t          .authorize(permissions, toParams)\n\t          .then(function () {\n\t            $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams, options);\n\t            goToState(toState.name);\n\t          })\n\t          .catch(function (rejectedPermission) {\n\t            $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams, options);\n\t            permissions.redirectToState(rejectedPermission);\n\t          });\n\t      }\n\t\n\t      /**\n\t       * Redirects to states when permissions are met\n\t       *\n\t       * If authorized, use call state.go without triggering the event.\n\t       * Then trigger $stateChangeSuccess manually to resume the rest of the process\n\t       * Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n\t       */\n\t      function goToState(name) {\n\t        $state\n\t          .go(name, toParams, angular.extend({}, options, {notify: false}))\n\t          .then(function () {\n\t            $rootScope.$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams, options);\n\t          });\n\t      }\n\t\n\t      /**\n\t       * Checks if event $stateChangeStart hasn't been disabled by default\n\t       *\n\t       * @returns {boolean}\n\t       */\n\t      function isStateChangeStartDefaultPrevented() {\n\t        return $rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams, options).defaultPrevented;\n\t      }\n\t\n\t      /**\n\t       * Checks if event $stateChangePermissionStart hasn't been disabled by default\n\t       *\n\t       * @returns {boolean}\n\t       */\n\t      function isStateChangePermissionStartDefaultPrevented() {\n\t        return $rootScope.$broadcast('$stateChangePermissionStart', toState, toParams, options).defaultPrevented;\n\t      }\n\t    });\n\t  }]);\n\t}());\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .factory('PermissionMap', ['$q', '$state', function ($q, $state) {\n\t\n\t      /**\n\t       * Constructs map object instructing authorization service how to handle authorizing\n\t       *\n\t       * @param permissionMap {Object} Map of permissions provided to authorization service\n\t       * @param permissionMap.only {Array} List of exclusive permission/role names allowed for authorization\n\t       * @param permissionMap.except {Array} List of exclusive permission/role names denied for authorization\n\t       * @param permissionMap.redirectTo {String|Function|Object|promise} Handling redirection when rejected\n\t       *   authorization\n\t       * @param [toState] {Object} UI-Router transition state object\n\t       * @param [toParams] {Object} UI-Router transition state params\n\t       * @param [options] {Object} UI-Router transition state options\n\t       * @constructor\n\t       */\n\t      function PermissionMap(permissionMap, toState, toParams, options) {\n\t        this.only = resolvePermissionMapProperty(permissionMap.only, toState, toParams, options);\n\t        this.except = resolvePermissionMapProperty(permissionMap.except, toState, toParams, options);\n\t        this.redirectTo = permissionMap.redirectTo;\n\t      }\n\t\n\t      /**\n\t       * Extends permission map by pushing to it state's permissions\n\t       *\n\t       * @param permissionMap {PermissionMap} Compensated permission map\n\t       */\n\t      PermissionMap.prototype.extendPermissionMap = function (permissionMap) {\n\t        this.only = this.only.concat(permissionMap.only);\n\t        this.except = this.except.concat(permissionMap.except);\n\t      };\n\t\n\t\n\t      /**\n\t       * Redirects to fallback states when permissions fail\n\t       *\n\t       * @param rejectedPermissionName {String} Permission name\n\t       */\n\t      PermissionMap.prototype.redirectToState = function (rejectedPermissionName) {\n\t        if (angular.isFunction(this.redirectTo)) {\n\t          handleFunctionRedirect(this.redirectTo, rejectedPermissionName);\n\t        }\n\t\n\t        if (angular.isObject(this.redirectTo)) {\n\t          handleObjectRedirect(this.redirectTo, rejectedPermissionName);\n\t        }\n\t\n\t        if (angular.isString(this.redirectTo)) {\n\t          handleStringRedirect(this.redirectTo, this.toParams, this.options);\n\t        }\n\t      };\n\t\n\t      /**\n\t       * Handles function based redirection for rejected permissions\n\t       *\n\t       * @param redirectFunction {Function} Redirection function\n\t       * @param permission {String} Rejected permission\n\t       */\n\t      function handleFunctionRedirect(redirectFunction, permission) {\n\t        $q.when(redirectFunction.call(null, permission))\n\t          .then(function (redirectState) {\n\t            if (!angular.isString(redirectState)) {\n\t              throw new TypeError('When used \"redirectTo\" as function, returned value must be string with state name');\n\t            }\n\t            handleStringRedirect(redirectState);\n\t          });\n\t      }\n\t\n\t      /**\n\t       * Handles object based redirection for rejected permissions\n\t       *\n\t       * @param redirectObject {Object} Redirection function\n\t       * @param permission {String} Rejected permission\n\t       */\n\t      function handleObjectRedirect(redirectObject, permission) {\n\t        if (!angular.isDefined(redirectObject['default'])) {\n\t          throw new ReferenceError('When used \"redirectTo\" as object, property \"default\" must be defined');\n\t        }\n\t\n\t        var redirectState = redirectObject[permission];\n\t\n\t        if (!angular.isDefined(redirectState)) {\n\t          redirectState = redirectObject['default'];\n\t        }\n\t\n\t        if (angular.isFunction(redirectState)) {\n\t          handleFunctionRedirect(redirectState, permission);\n\t        }\n\t\n\t        if (angular.isString(redirectState)) {\n\t          handleStringRedirect(redirectState);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Handles string based redirection for rejected permissions\n\t       */\n\t      function handleStringRedirect(state, toParams, options) {\n\t        $state.go(state, toParams, options);\n\t      }\n\t\n\t      /**\n\t       * Handles extraction of permission map \"only\" and \"except\" properties\n\t       * @private\n\t       *\n\t       * @param property {Array|Function|promise} Permission map property \"only\" or \"except\"\n\t       * @param [toState] {Object} UI-Router transition state object\n\t       * @param [toParams] {Object} UI-Router transition state params\n\t       * @param [options] {Object} UI-Router transition state options\n\t       * @returns {Array} Array of permission \"only\" or \"except\" names\n\t       */\n\t      function resolvePermissionMapProperty(property, toState, toParams, options) {\n\t        if (angular.isString(property)) {\n\t          return [property];\n\t        }\n\t\n\t        if (angular.isArray(property)) {\n\t          return property;\n\t        }\n\t\n\t        if (angular.isFunction(property)) {\n\t          return property.call(null, toState, toParams, options);\n\t        }\n\t\n\t        return [];\n\t      }\n\t\n\t      return PermissionMap;\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .factory('Permission', ['$q', function ($q) {\n\t\n\t      /**\n\t       * Permission definition object constructor\n\t       *\n\t       * @param permissionName {String} Name repressing permission\n\t       * @param validationFunction {Function} Function used to check if permission is valid\n\t       * @constructor\n\t       */\n\t      function Permission(permissionName, validationFunction) {\n\t        validateConstructor(permissionName, validationFunction);\n\t\n\t        this.permissionName = permissionName;\n\t        this.validationFunction = validationFunction;\n\t      }\n\t\n\t      /**\n\t       * Checks if permission is still valid\n\t       *\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Promise}\n\t       */\n\t      Permission.prototype.validatePermission = function (toParams) {\n\t        var validationResult = this.validationFunction.call(null, toParams, this.permissionName);\n\t\n\t        if (!angular.isFunction(validationResult.then)) {\n\t          validationResult = wrapInPromise(validationResult, this.permissionName);\n\t        }\n\t\n\t        return validationResult;\n\t      };\n\t\n\t      /**\n\t       * Converts a value into a promise, if the value is truthy it resolves it, otherwise it rejects it\n\t       * @private\n\t       *\n\t       * @param result {Boolean} Function to be wrapped into promise\n\t       * @param permissionName {String} Returned value in promise\n\t       * @return {Promise}\n\t       */\n\t      function wrapInPromise(result, permissionName) {\n\t        var dfd = $q.defer();\n\t\n\t        if (result) {\n\t          dfd.resolve(permissionName);\n\t        } else {\n\t          dfd.reject(permissionName);\n\t        }\n\t\n\t        return dfd.promise;\n\t      }\n\t\n\t      /**\n\t       * Checks if provided permission has accepted parameter types\n\t       * @private\n\t       */\n\t      function validateConstructor(permissionName, validationFunction) {\n\t        if (!angular.isString(permissionName)) {\n\t          throw new TypeError('Parameter \"permissionName\" name must be String');\n\t        }\n\t        if (!angular.isFunction(validationFunction)) {\n\t          throw new TypeError('Parameter \"validationFunction\" must be Function');\n\t        }\n\t      }\n\t\n\t      return Permission;\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .factory('Role', ['$q', 'PermissionStore', function ($q, PermissionStore) {\n\t\n\t      /**\n\t       * Role definition constructor\n\t       *\n\t       * @param roleName {String} Name representing role\n\t       * @param permissionNames {Array} List of permission names representing role\n\t       * @param [validationFunction] {Function} Optional function used to validate if permissions are still valid\n\t       * @constructor\n\t       */\n\t      function Role(roleName, permissionNames, validationFunction) {\n\t        validateConstructor(roleName, permissionNames, validationFunction);\n\t        this.roleName = roleName;\n\t        this.permissionNames = permissionNames || [];\n\t\n\t        if (validationFunction) {\n\t          PermissionStore.defineManyPermissions(permissionNames, validationFunction);\n\t        }\n\t      }\n\t\n\t      /**\n\t       * Checks if role is still valid\n\t       *\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Promise} $q.promise object\n\t       */\n\t      Role.prototype.validateRole = function (toParams) {\n\t\n\t        // When set permissions is provided check each of them\n\t        if (this.permissionNames.length) {\n\t          var promises = this.permissionNames.map(function (permissionName) {\n\t            if (PermissionStore.hasPermissionDefinition(permissionName)) {\n\t              var permission = PermissionStore.getPermissionDefinition(permissionName);\n\t              var validationResult = permission.validationFunction.call(null, toParams, permission.permissionName);\n\t\n\t              if (!angular.isFunction(validationResult.then)) {\n\t                validationResult = wrapInPromise(validationResult);\n\t              }\n\t\n\t              return validationResult;\n\t            }\n\t\n\t            return $q.reject(null);\n\t          });\n\t\n\t          return $q.all(promises);\n\t        }\n\t\n\t        // If not call validation function manually\n\t        var validationResult = this.validationFunction.call(null, toParams, this.roleName);\n\t        if (!angular.isFunction(validationResult.then)) {\n\t          validationResult = wrapInPromise(validationResult, this.roleName);\n\t        }\n\t\n\t        return $q.resolve(validationResult);\n\t\n\t      };\n\t\n\t      /**\n\t       * Converts a value into a promise, if the value is truthy it resolves it, otherwise it rejects it\n\t       * @private\n\t       *\n\t       * @param result {Boolean} Function to be wrapped into promise\n\t       * @param roleName {String} Returned value in promise\n\t       * @return {Promise}\n\t       */\n\t      function wrapInPromise(result, roleName) {\n\t        var dfd = $q.defer();\n\t\n\t        if (result) {\n\t          dfd.resolve(roleName);\n\t        } else {\n\t          dfd.reject(roleName);\n\t        }\n\t\n\t        return dfd.promise;\n\t      }\n\t\n\t      /**\n\t       * Checks if provided permission has accepted parameter types\n\t       * @private\n\t       */\n\t      function validateConstructor(roleName, permissionNames, validationFunction) {\n\t        if (!angular.isString(roleName)) {\n\t          throw new TypeError('Parameter \"roleName\" name must be String');\n\t        }\n\t\n\t        if (!angular.isArray(permissionNames)) {\n\t          throw new TypeError('Parameter \"permissionNames\" must be Array');\n\t        }\n\t\n\t        if (!permissionNames.length && !angular.isFunction(validationFunction)) {\n\t          throw new TypeError('Parameter \"validationFunction\" must be provided for empty \"permissionNames\" array');\n\t        }\n\t      }\n\t\n\t      return Role;\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .service('PermissionStore', ['Permission', function (Permission) {\n\t      var permissionStore = {};\n\t\n\t      this.definePermission = definePermission;\n\t      this.defineManyPermissions = defineManyPermissions;\n\t      this.removePermissionDefinition = removePermissionDefinition;\n\t      this.hasPermissionDefinition = hasPermissionDefinition;\n\t      this.getPermissionDefinition = getPermissionDefinition;\n\t      this.getStore = getStore;\n\t      this.clearStore = clearStore;\n\t\n\t      /**\n\t       * Allows to define permission on application configuration\n\t       *\n\t       * @param permissionName {String} Name of defined permission\n\t       * @param validationFunction {Function} Function used to validate if permission is valid\n\t       */\n\t      function definePermission(permissionName, validationFunction) {\n\t        permissionStore[permissionName] = new Permission(permissionName, validationFunction);\n\t      }\n\t\n\t      /**\n\t       * Allows to define set of permissionNames with shared validation function on application configuration\n\t       *\n\t       * @param permissionNames {Array} Set of permission names\n\t       * @param validationFunction {Function} Function used to validate if permission is valid\n\t       */\n\t      function defineManyPermissions(permissionNames, validationFunction) {\n\t        if (!angular.isArray(permissionNames)) {\n\t          throw new TypeError('Parameter \"permissionNames\" name must be Array');\n\t        }\n\t\n\t        angular.forEach(permissionNames, function (permissionName) {\n\t          definePermission(permissionName, validationFunction);\n\t        });\n\t      }\n\t\n\t      /**\n\t       * Deletes permission\n\t       *\n\t       * @param permissionName {String} Name of defined permission\n\t       */\n\t      function removePermissionDefinition(permissionName) {\n\t        delete permissionStore[permissionName];\n\t      }\n\t\n\t      /**\n\t       * Checks if permission exists\n\t       *\n\t       * @param permissionName {String} Name of defined permission\n\t       * @returns {Boolean}\n\t       */\n\t      function hasPermissionDefinition(permissionName) {\n\t        return angular.isDefined(permissionStore[permissionName]);\n\t      }\n\t\n\t      /**\n\t       * Returns permission by it's name\n\t       *\n\t       * @returns {Object} Permissions collection\n\t       */\n\t      function getPermissionDefinition(permissionName) {\n\t        return permissionStore[permissionName];\n\t      }\n\t\n\t      /**\n\t       * Returns all permissions\n\t       *\n\t       * @returns {Object} Permissions collection\n\t       */\n\t      function getStore() {\n\t        return permissionStore;\n\t      }\n\t\n\t      /**\n\t       * Removes all permissions\n\t       */\n\t      function clearStore() {\n\t        permissionStore = {};\n\t      }\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .service('RoleStore', ['Role', function (Role) {\n\t      var roleStore = {};\n\t\n\t      this.defineRole = defineRole;\n\t      this.getRoleDefinition = getRoleDefinition;\n\t      this.hasRoleDefinition = hasRoleDefinition;\n\t      this.removeRoleDefinition = removeRoleDefinition;\n\t      this.getStore = getStore;\n\t      this.clearStore = clearStore;\n\t\n\t      /**\n\t       * Allows to define role\n\t       *\n\t       * @param roleName {String} Name of defined role\n\t       * @param permissions {Array} Set of permission names\n\t       * @param [validationFunction] {Function} Function used to validate if permissions in role are valid\n\t       */\n\t      function defineRole(roleName, permissions, validationFunction) {\n\t        roleStore[roleName] = new Role(roleName, permissions, validationFunction);\n\t      }\n\t\n\t      /**\n\t       * Deletes role from store\n\t       *\n\t       * @param roleName {String} Name of defined permission\n\t       */\n\t      function removeRoleDefinition(roleName) {\n\t        delete roleStore[roleName];\n\t      }\n\t\n\t      /**\n\t       * Checks if role is defined in store\n\t       *\n\t       * @param roleName {String} Name of role\n\t       * @returns {Boolean}\n\t       */\n\t      function hasRoleDefinition(roleName) {\n\t        return angular.isDefined(roleStore[roleName]);\n\t      }\n\t\n\t      /**\n\t       * Returns role definition object by it's name\n\t       *\n\t       * @returns {Object} Role definition object\n\t       */\n\t      function getRoleDefinition(roleName) {\n\t        return roleStore[roleName];\n\t      }\n\t\n\t      /**\n\t       * Returns all role definitions\n\t       *\n\t       * @returns {Object} Defined roles collection\n\t       */\n\t      function getStore() {\n\t        return roleStore;\n\t      }\n\t\n\t      /**\n\t       * Removes all role definitions\n\t       */\n\t      function clearStore() {\n\t        roleStore = {};\n\t      }\n\t    }]);\n\t}());\n\t(function () {\n\t  'use strict';\n\t\n\t  /**\n\t   * Show/hide elements based on provided permissions\n\t   *\n\t   * @example\n\t   * <div permission only=\"'USER'\"></div>\n\t   * <div permission only=\"['USER','ADMIN']\" except=\"'MANAGER'\"></div>\n\t   * <div permission except=\"'MANAGER'\"></div>\n\t   */\n\t  angular\n\t    .module('permission')\n\t    .directive('permission', ['$log', 'Authorization', 'PermissionMap', function ($log, Authorization, PermissionMap) {\n\t      return {\n\t        restrict: 'A',\n\t        link: function (scope, element, attrs) {\n\t          try {\n\t            Authorization\n\t              .authorize(new PermissionMap({\n\t                only: scope.$eval(attrs.only),\n\t                except: scope.$eval(attrs.except)\n\t              }), null)\n\t              .then(function () {\n\t                element.removeClass('ng-hide');\n\t              })\n\t              .catch(function () {\n\t                element.addClass('ng-hide');\n\t              });\n\t          } catch (e) {\n\t            element.addClass('ng-hide');\n\t            $log.error(e.message);\n\t          }\n\t        }\n\t      };\n\t    }]);\n\t}());\n\t\n\t(function () {\n\t  'use strict';\n\t\n\t  angular\n\t    .module('permission')\n\t    .service('Authorization', ['$q', 'PermissionMap', 'PermissionStore', 'RoleStore', function ($q, PermissionMap, PermissionStore, RoleStore) {\n\t      this.authorize = authorize;\n\t\n\t      /**\n\t       * Checks if provided permissions are acceptable\n\t       *\n\t       * @param permissionsMap {PermissionMap} Map of permission names\n\t       * @param [toParams] {Object} UI-Router params object\n\t       * @returns {promise} $q.promise object\n\t       */\n\t      function authorize(permissionsMap, toParams) {\n\t        return handleAuthorization(permissionsMap, toParams);\n\t      }\n\t\n\t      /**\n\t       * Handles authorization based on provided permissions map\n\t       * @private\n\t       *\n\t       * @param permissionsMap {Object} Map of permission names\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {promise} $q.promise object\n\t       */\n\t      function handleAuthorization(permissionsMap, toParams) {\n\t        var deferred = $q.defer();\n\t\n\t        var exceptPromises = findMatchingPermissions(permissionsMap.except, toParams);\n\t\n\t        $q.all(exceptPromises)\n\t          .then(function (rejectedPermissions) {\n\t            // If any \"except\" permissions are found reject authorization\n\t            if (rejectedPermissions.length) {\n\t              deferred.reject(rejectedPermissions);\n\t            } else {\n\t              // If none go to checking \"only\" permissions\n\t              return $q.reject(null);\n\t            }\n\t          })\n\t          .catch(function () {\n\t            var onlyPromises = findMatchingPermissions(permissionsMap.only, toParams);\n\t            $q.all(onlyPromises)\n\t              .then(function (resolvedPermissions) {\n\t                deferred.resolve(resolvedPermissions);\n\t              })\n\t              .catch(function (rejectedPermission) {\n\t                deferred.reject(rejectedPermission);\n\t              });\n\t          });\n\t\n\t        return deferred.promise;\n\t      }\n\t\n\t      /**\n\t       * Performs iteration over list of defined permissions looking for matching roles\n\t       * @private\n\t       *\n\t       * @param permissionNames {Array} Set of permission names\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Array} Promise collection\n\t       */\n\t      function findMatchingPermissions(permissionNames, toParams) {\n\t        return permissionNames.map(function (permissionName) {\n\t          if (RoleStore.hasRoleDefinition(permissionName)) {\n\t            return handleRoleValidation(permissionName, toParams);\n\t          }\n\t\n\t          if (PermissionStore.hasPermissionDefinition(permissionName)) {\n\t            return handlePermissionValidation(permissionName, toParams);\n\t          }\n\t\n\t          if (permissionName) {\n\t            return $q.reject(permissionName);\n\t          }\n\t        });\n\t      }\n\t\n\t      /**\n\t       * Executes role validation checking\n\t       * @private\n\t       *\n\t       * @param roleName {String} Store permission key\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Promise}\n\t       */\n\t      function handleRoleValidation(roleName, toParams) {\n\t        var role = RoleStore.getRoleDefinition(roleName);\n\t        return role.validateRole(toParams);\n\t      }\n\t\n\t      /**\n\t       * Executes permission validation checking\n\t       * @private\n\t       *\n\t       * @param permissionName {String} Store permission key\n\t       * @param toParams {Object} UI-Router params object\n\t       * @returns {Promise}\n\t       */\n\t      function handlePermissionValidation(permissionName, toParams) {\n\t        var permission = PermissionStore.getPermissionDefinition(permissionName);\n\t        return permission.validatePermission(toParams);\n\t      }\n\t    }]);\n\t})();\n\n\n/***/ },\n\n/***/ 9:\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(16);\n\t\n\tmodule.exports = 'ui.bootstrap';\n\n\n/***/ },\n\n/***/ 10:\n/***/ function(module, exports) {\n\n\t/**\r\n\t * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n\t * @author Mark Lagendijk <mark@lagendijk.info>\r\n\t * @license MIT\r\n\t */\r\n\tangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n\t    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n\t        var self = this;\r\n\t\r\n\t        /**\r\n\t         * Recursively sets the states using $stateProvider.state.\r\n\t         * Child states are defined via a `children` property.\r\n\t         *\r\n\t         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n\t         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n\t         * 3. Sets `parent` property of the descendant states.\r\n\t         *\r\n\t         * @param {Object} state - A regular ui.router state object.\r\n\t         * @param {Array} [state.children] - An optional array of child states.\r\n\t         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n\t         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n\t         * @param {Object} [options] - An optional options object.\r\n\t         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n\t         *     prevents conversion of names to dot notation if true.\r\n\t         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n\t         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n\t         */\r\n\t        this.state = function(state){\r\n\t            var args = Array.prototype.slice.apply(arguments);\r\n\t            var options = {\r\n\t                keepOriginalNames: false,\r\n\t                siblingTraversal: false\r\n\t            };  \r\n\t\r\n\t            if (typeof args[1] === 'boolean') {\r\n\t                options.keepOriginalNames = args[1];\r\n\t            } \r\n\t            else if (typeof args[1] === 'object') {\r\n\t                angular.extend(options, args[1]);\r\n\t            }\r\n\t\r\n\t            if (!options.keepOriginalNames) {\r\n\t                fixStateName(state);\r\n\t            }\r\n\t\r\n\t            $stateProvider.state(state);\r\n\t\r\n\t            if(state.children && state.children.length){\r\n\t                state.children.forEach(function(childState){\r\n\t                    childState.parent = state;\r\n\t                    self.state(childState, options);\r\n\t                });\r\n\t\r\n\t                if (options.siblingTraversal) {\r\n\t                    addSiblings(state);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return self;\r\n\t        };\r\n\t\r\n\t        this.setNestedState = this.state;\r\n\t\r\n\t        self.$get = angular.noop;\r\n\t\r\n\t        /**\r\n\t         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n\t         * @param state\r\n\t         */\r\n\t        function fixStateName(state){\r\n\t            if(state.parent){\r\n\t                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        function addSiblings(state) {\r\n\t            state.children.forEach(function (childState, idx, array) {\r\n\t                if (array[idx + 1]) {\r\n\t                    childState.nextSibling = array[idx + 1].name;\r\n\t                }\r\n\t                if (array[idx - 1]) {\r\n\t                    childState.previousSibling = array[idx - 1].name;\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t    }]);\r\n\n\n/***/ },\n\n/***/ 11:\n/***/ function(module, exports) {\n\n\t/**\n\t * State-based routing for AngularJS\n\t * @version v0.2.18\n\t * @link http://angular-ui.github.com/\n\t * @license MIT License, http://www.opensource.org/licenses/MIT\n\t */\n\t\n\t/* commonjs package manager support (eg componentjs) */\n\tif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n\t  module.exports = 'ui.router';\n\t}\n\t\n\t(function (window, angular, undefined) {\n\t/*jshint globalstrict:true*/\n\t/*global angular:false*/\n\t'use strict';\n\t\n\tvar isDefined = angular.isDefined,\n\t    isFunction = angular.isFunction,\n\t    isString = angular.isString,\n\t    isObject = angular.isObject,\n\t    isArray = angular.isArray,\n\t    forEach = angular.forEach,\n\t    extend = angular.extend,\n\t    copy = angular.copy,\n\t    toJson = angular.toJson;\n\t\n\tfunction inherit(parent, extra) {\n\t  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n\t}\n\t\n\tfunction merge(dst) {\n\t  forEach(arguments, function(obj) {\n\t    if (obj !== dst) {\n\t      forEach(obj, function(value, key) {\n\t        if (!dst.hasOwnProperty(key)) dst[key] = value;\n\t      });\n\t    }\n\t  });\n\t  return dst;\n\t}\n\t\n\t/**\n\t * Finds the common ancestor path between two states.\n\t *\n\t * @param {Object} first The first state.\n\t * @param {Object} second The second state.\n\t * @return {Array} Returns an array of state names in descending order, not including the root.\n\t */\n\tfunction ancestors(first, second) {\n\t  var path = [];\n\t\n\t  for (var n in first.path) {\n\t    if (first.path[n] !== second.path[n]) break;\n\t    path.push(first.path[n]);\n\t  }\n\t  return path;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Object.keys()`.\n\t *\n\t * @param {Object} object A JavaScript object.\n\t * @return {Array} Returns the keys of the object as an array.\n\t */\n\tfunction objectKeys(object) {\n\t  if (Object.keys) {\n\t    return Object.keys(object);\n\t  }\n\t  var result = [];\n\t\n\t  forEach(object, function(val, key) {\n\t    result.push(key);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * IE8-safe wrapper for `Array.prototype.indexOf()`.\n\t *\n\t * @param {Array} array A JavaScript array.\n\t * @param {*} value A value to search the array for.\n\t * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n\t */\n\tfunction indexOf(array, value) {\n\t  if (Array.prototype.indexOf) {\n\t    return array.indexOf(value, Number(arguments[2]) || 0);\n\t  }\n\t  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n\t  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\t\n\t  if (from < 0) from += len;\n\t\n\t  for (; from < len; from++) {\n\t    if (from in array && array[from] === value) return from;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/**\n\t * Merges a set of parameters with all parameters inherited between the common parents of the\n\t * current state and a given destination state.\n\t *\n\t * @param {Object} currentParams The value of the current state parameters ($stateParams).\n\t * @param {Object} newParams The set of parameters which will be composited with inherited params.\n\t * @param {Object} $current Internal definition of object representing the current state.\n\t * @param {Object} $to Internal definition of object representing state to transition to.\n\t */\n\tfunction inheritParams(currentParams, newParams, $current, $to) {\n\t  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\t\n\t  for (var i in parents) {\n\t    if (!parents[i] || !parents[i].params) continue;\n\t    parentParams = objectKeys(parents[i].params);\n\t    if (!parentParams.length) continue;\n\t\n\t    for (var j in parentParams) {\n\t      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n\t      inheritList.push(parentParams[j]);\n\t      inherited[parentParams[j]] = currentParams[parentParams[j]];\n\t    }\n\t  }\n\t  return extend({}, inherited, newParams);\n\t}\n\t\n\t/**\n\t * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n\t *\n\t * @param {Object} a The first object.\n\t * @param {Object} b The second object.\n\t * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n\t *                     it defaults to the list of keys in `a`.\n\t * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n\t */\n\tfunction equalForKeys(a, b, keys) {\n\t  if (!keys) {\n\t    keys = [];\n\t    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n\t  }\n\t\n\t  for (var i=0; i<keys.length; i++) {\n\t    var k = keys[i];\n\t    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n\t  }\n\t  return true;\n\t}\n\t\n\t/**\n\t * Returns the subset of an object, based on a list of keys.\n\t *\n\t * @param {Array} keys\n\t * @param {Object} values\n\t * @return {Boolean} Returns a subset of `values`.\n\t */\n\tfunction filterByKeys(keys, values) {\n\t  var filtered = {};\n\t\n\t  forEach(keys, function (name) {\n\t    filtered[name] = values[name];\n\t  });\n\t  return filtered;\n\t}\n\t\n\t// like _.indexBy\n\t// when you know that your index values will be unique, or you want last-one-in to win\n\tfunction indexBy(array, propName) {\n\t  var result = {};\n\t  forEach(array, function(item) {\n\t    result[item[propName]] = item;\n\t  });\n\t  return result;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object only containing the whitelisted properties.\n\tfunction pick(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  forEach(keys, function(key) {\n\t    if (key in obj) copy[key] = obj[key];\n\t  });\n\t  return copy;\n\t}\n\t\n\t// extracted from underscore.js\n\t// Return a copy of the object omitting the blacklisted properties.\n\tfunction omit(obj) {\n\t  var copy = {};\n\t  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n\t  for (var key in obj) {\n\t    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n\t  }\n\t  return copy;\n\t}\n\t\n\tfunction pluck(collection, key) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = isFunction(key) ? key(val) : val[key];\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction filter(collection, callback) {\n\t  var array = isArray(collection);\n\t  var result = array ? [] : {};\n\t  forEach(collection, function(val, i) {\n\t    if (callback(val, i)) {\n\t      result[array ? result.length : i] = val;\n\t    }\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction map(collection, callback) {\n\t  var result = isArray(collection) ? [] : {};\n\t\n\t  forEach(collection, function(val, i) {\n\t    result[i] = callback(val, i);\n\t  });\n\t  return result;\n\t}\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.util\n\t *\n\t * @description\n\t * # ui.router.util sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t *\n\t */\n\tangular.module('ui.router.util', ['ng']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.router\n\t * \n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.router sub-module\n\t *\n\t * This module is a dependency of other sub-modules. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t */\n\tangular.module('ui.router.router', ['ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router.state\n\t * \n\t * @requires ui.router.router\n\t * @requires ui.router.util\n\t *\n\t * @description\n\t * # ui.router.state sub-module\n\t *\n\t * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n\t * in your angular app (use {@link ui.router} module instead).\n\t * \n\t */\n\tangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\t\n\t/**\n\t * @ngdoc overview\n\t * @name ui.router\n\t *\n\t * @requires ui.router.state\n\t *\n\t * @description\n\t * # ui.router\n\t * \n\t * ## The main module for ui.router \n\t * There are several sub-modules included with the ui.router module, however only this module is needed\n\t * as a dependency within your angular app. The other modules are for organization purposes. \n\t *\n\t * The modules are:\n\t * * ui.router - the main \"umbrella\" module\n\t * * ui.router.router - \n\t * \n\t * *You'll need to include **only** this module as the dependency within your angular app.*\n\t * \n\t * <pre>\n\t * <!doctype html>\n\t * <html ng-app=\"myApp\">\n\t * <head>\n\t *   <script src=\"js/angular.js\"></script>\n\t *   <!-- Include the ui-router script -->\n\t *   <script src=\"js/angular-ui-router.min.js\"></script>\n\t *   <script>\n\t *     // ...and add 'ui.router' as a dependency\n\t *     var myApp = angular.module('myApp', ['ui.router']);\n\t *   </script>\n\t * </head>\n\t * <body>\n\t * </body>\n\t * </html>\n\t * </pre>\n\t */\n\tangular.module('ui.router', ['ui.router.state']);\n\t\n\tangular.module('ui.router.compat', ['ui.router']);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$resolve\n\t *\n\t * @requires $q\n\t * @requires $injector\n\t *\n\t * @description\n\t * Manages resolution of (acyclic) graphs of promises.\n\t */\n\t$Resolve.$inject = ['$q', '$injector'];\n\tfunction $Resolve(  $q,    $injector) {\n\t  \n\t  var VISIT_IN_PROGRESS = 1,\n\t      VISIT_DONE = 2,\n\t      NOTHING = {},\n\t      NO_DEPENDENCIES = [],\n\t      NO_LOCALS = NOTHING,\n\t      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n\t  \n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#study\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Studies a set of invocables that are likely to be used multiple times.\n\t   * <pre>\n\t   * $resolve.study(invocables)(locals, parent, self)\n\t   * </pre>\n\t   * is equivalent to\n\t   * <pre>\n\t   * $resolve.resolve(invocables, locals, parent, self)\n\t   * </pre>\n\t   * but the former is more efficient (in fact `resolve` just calls `study` \n\t   * internally).\n\t   *\n\t   * @param {object} invocables Invocable objects\n\t   * @return {function} a function to pass in locals, parent and self\n\t   */\n\t  this.study = function (invocables) {\n\t    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n\t    var invocableKeys = objectKeys(invocables || {});\n\t    \n\t    // Perform a topological sort of invocables to build an ordered plan\n\t    var plan = [], cycle = [], visited = {};\n\t    function visit(value, key) {\n\t      if (visited[key] === VISIT_DONE) return;\n\t      \n\t      cycle.push(key);\n\t      if (visited[key] === VISIT_IN_PROGRESS) {\n\t        cycle.splice(0, indexOf(cycle, key));\n\t        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n\t      }\n\t      visited[key] = VISIT_IN_PROGRESS;\n\t      \n\t      if (isString(value)) {\n\t        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n\t      } else {\n\t        var params = $injector.annotate(value);\n\t        forEach(params, function (param) {\n\t          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n\t        });\n\t        plan.push(key, value, params);\n\t      }\n\t      \n\t      cycle.pop();\n\t      visited[key] = VISIT_DONE;\n\t    }\n\t    forEach(invocables, visit);\n\t    invocables = cycle = visited = null; // plan is all that's required\n\t    \n\t    function isResolve(value) {\n\t      return isObject(value) && value.then && value.$$promises;\n\t    }\n\t    \n\t    return function (locals, parent, self) {\n\t      if (isResolve(locals) && self === undefined) {\n\t        self = parent; parent = locals; locals = null;\n\t      }\n\t      if (!locals) locals = NO_LOCALS;\n\t      else if (!isObject(locals)) {\n\t        throw new Error(\"'locals' must be an object\");\n\t      }       \n\t      if (!parent) parent = NO_PARENT;\n\t      else if (!isResolve(parent)) {\n\t        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n\t      }\n\t      \n\t      // To complete the overall resolution, we have to wait for the parent\n\t      // promise and for the promise for each invokable in our plan.\n\t      var resolution = $q.defer(),\n\t          result = resolution.promise,\n\t          promises = result.$$promises = {},\n\t          values = extend({}, locals),\n\t          wait = 1 + plan.length/3,\n\t          merged = false;\n\t          \n\t      function done() {\n\t        // Merge parent values we haven't got yet and publish our own $$values\n\t        if (!--wait) {\n\t          if (!merged) merge(values, parent.$$values); \n\t          result.$$values = values;\n\t          result.$$promises = result.$$promises || true; // keep for isResolve()\n\t          delete result.$$inheritedValues;\n\t          resolution.resolve(values);\n\t        }\n\t      }\n\t      \n\t      function fail(reason) {\n\t        result.$$failure = reason;\n\t        resolution.reject(reason);\n\t      }\n\t\n\t      // Short-circuit if parent has already failed\n\t      if (isDefined(parent.$$failure)) {\n\t        fail(parent.$$failure);\n\t        return result;\n\t      }\n\t      \n\t      if (parent.$$inheritedValues) {\n\t        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n\t      }\n\t\n\t      // Merge parent values if the parent has already resolved, or merge\n\t      // parent promises and wait if the parent resolve is still in progress.\n\t      extend(promises, parent.$$promises);\n\t      if (parent.$$values) {\n\t        merged = merge(values, omit(parent.$$values, invocableKeys));\n\t        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n\t        done();\n\t      } else {\n\t        if (parent.$$inheritedValues) {\n\t          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n\t        }        \n\t        parent.then(done, fail);\n\t      }\n\t      \n\t      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n\t      for (var i=0, ii=plan.length; i<ii; i+=3) {\n\t        if (locals.hasOwnProperty(plan[i])) done();\n\t        else invoke(plan[i], plan[i+1], plan[i+2]);\n\t      }\n\t      \n\t      function invoke(key, invocable, params) {\n\t        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n\t        var invocation = $q.defer(), waitParams = 0;\n\t        function onfailure(reason) {\n\t          invocation.reject(reason);\n\t          fail(reason);\n\t        }\n\t        // Wait for any parameter that we have a promise for (either from parent or from this\n\t        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n\t        forEach(params, function (dep) {\n\t          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n\t            waitParams++;\n\t            promises[dep].then(function (result) {\n\t              values[dep] = result;\n\t              if (!(--waitParams)) proceed();\n\t            }, onfailure);\n\t          }\n\t        });\n\t        if (!waitParams) proceed();\n\t        function proceed() {\n\t          if (isDefined(result.$$failure)) return;\n\t          try {\n\t            invocation.resolve($injector.invoke(invocable, self, values));\n\t            invocation.promise.then(function (result) {\n\t              values[key] = result;\n\t              done();\n\t            }, onfailure);\n\t          } catch (e) {\n\t            onfailure(e);\n\t          }\n\t        }\n\t        // Publish promise synchronously; invocations further down in the plan may depend on it.\n\t        promises[key] = invocation.promise;\n\t      }\n\t      \n\t      return result;\n\t    };\n\t  };\n\t  \n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$resolve#resolve\n\t   * @methodOf ui.router.util.$resolve\n\t   *\n\t   * @description\n\t   * Resolves a set of invocables. An invocable is a function to be invoked via \n\t   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n\t   * An invocable can either return a value directly,\n\t   * or a `$q` promise. If a promise is returned it will be resolved and the \n\t   * resulting value will be used instead. Dependencies of invocables are resolved \n\t   * (in this order of precedence)\n\t   *\n\t   * - from the specified `locals`\n\t   * - from another invocable that is part of this `$resolve` call\n\t   * - from an invocable that is inherited from a `parent` call to `$resolve` \n\t   *   (or recursively\n\t   * - from any ancestor `$resolve` of that parent).\n\t   *\n\t   * The return value of `$resolve` is a promise for an object that contains \n\t   * (in this order of precedence)\n\t   *\n\t   * - any `locals` (if specified)\n\t   * - the resolved return values of all injectables\n\t   * - any values inherited from a `parent` call to `$resolve` (if specified)\n\t   *\n\t   * The promise will resolve after the `parent` promise (if any) and all promises \n\t   * returned by injectables have been resolved. If any invocable \n\t   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n\t   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n\t   * same error. A rejection of a `parent` promise (if specified) will likewise be \n\t   * propagated immediately. Once the `$resolve` promise has been rejected, no \n\t   * further invocables will be called.\n\t   * \n\t   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n\t   * to throw an error. As a special case, an injectable can depend on a parameter \n\t   * with the same name as the injectable, which will be fulfilled from the `parent` \n\t   * injectable of the same name. This allows inherited values to be decorated. \n\t   * Note that in this case any other injectable in the same `$resolve` with the same\n\t   * dependency would see the decorated value, not the inherited value.\n\t   *\n\t   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n\t   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n\t   * exception.\n\t   *\n\t   * Invocables are invoked eagerly as soon as all dependencies are available. \n\t   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n\t   *\n\t   * As a special case, an invocable can be a string, in which case it is taken to \n\t   * be a service name to be passed to `$injector.get()`. This is supported primarily \n\t   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n\t   * routes.\n\t   *\n\t   * @param {object} invocables functions to invoke or \n\t   * `$injector` services to fetch.\n\t   * @param {object} locals  values to make available to the injectables\n\t   * @param {object} parent  a promise returned by another call to `$resolve`.\n\t   * @param {object} self  the `this` for the invoked methods\n\t   * @return {object} Promise for an object that contains the resolved return value\n\t   * of all invocables, as well as any inherited and local values.\n\t   */\n\t  this.resolve = function (invocables, locals, parent, self) {\n\t    return this.study(invocables)(locals, parent, self);\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$resolve', $Resolve);\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$templateFactory\n\t *\n\t * @requires $http\n\t * @requires $templateCache\n\t * @requires $injector\n\t *\n\t * @description\n\t * Service. Manages loading of templates.\n\t */\n\t$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\n\tfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromConfig\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a configuration object. \n\t   *\n\t   * @param {object} config Configuration object for which to load a template. \n\t   * The following properties are search in the specified order, and the first one \n\t   * that is defined is used to create the template:\n\t   *\n\t   * @param {string|object} config.template html string template or function to \n\t   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n\t   * @param {string|object} config.templateUrl url to load or a function returning \n\t   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n\t   * @param {Function} config.templateProvider function to invoke via \n\t   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n\t   * @param {object} params  Parameters to pass to the template function.\n\t   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n\t   * via a `templateProvider`. Defaults to `{ params: params }`.\n\t   *\n\t   * @return {string|object}  The template html as a string, or a promise for \n\t   * that string,or `null` if no template is configured.\n\t   */\n\t  this.fromConfig = function (config, params, locals) {\n\t    return (\n\t      isDefined(config.template) ? this.fromString(config.template, params) :\n\t      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n\t      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n\t      null\n\t    );\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromString\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template from a string or a function returning a string.\n\t   *\n\t   * @param {string|object} template html template as a string or function that \n\t   * returns an html template as a string.\n\t   * @param {object} params Parameters to pass to the template function.\n\t   *\n\t   * @return {string|object} The template html as a string, or a promise for that \n\t   * string.\n\t   */\n\t  this.fromString = function (template, params) {\n\t    return isFunction(template) ? template(params) : template;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromUrl\n\t   * @methodOf ui.router.util.$templateFactory\n\t   * \n\t   * @description\n\t   * Loads a template from the a URL via `$http` and `$templateCache`.\n\t   *\n\t   * @param {string|Function} url url of the template to load, or a function \n\t   * that returns a url.\n\t   * @param {Object} params Parameters to pass to the url function.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromUrl = function (url, params) {\n\t    if (isFunction(url)) url = url(params);\n\t    if (url == null) return null;\n\t    else return $http\n\t        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n\t        .then(function(response) { return response.data; });\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$templateFactory#fromProvider\n\t   * @methodOf ui.router.util.$templateFactory\n\t   *\n\t   * @description\n\t   * Creates a template by invoking an injectable provider function.\n\t   *\n\t   * @param {Function} provider Function to invoke via `$injector.invoke`\n\t   * @param {Object} params Parameters for the template.\n\t   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n\t   * `{ params: params }`.\n\t   * @return {string|Promise.<string>} The template html as a string, or a promise \n\t   * for that string.\n\t   */\n\t  this.fromProvider = function (provider, params, locals) {\n\t    return $injector.invoke(provider, null, locals || { params: params });\n\t  };\n\t}\n\t\n\tangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\t\n\tvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Matches URLs against patterns and extracts named parameters from the path or the search\n\t * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n\t * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n\t * do not influence whether or not a URL is matched, but their values are passed through into\n\t * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n\t *\n\t * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n\t * syntax, which optionally allows a regular expression for the parameter to be specified:\n\t *\n\t * * `':'` name - colon placeholder\n\t * * `'*'` name - catch-all placeholder\n\t * * `'{' name '}'` - curly placeholder\n\t * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n\t *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n\t *\n\t * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n\t * must be unique within the pattern (across both path and search parameters). For colon\n\t * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n\t * number of characters other than '/'. For catch-all placeholders the path parameter matches\n\t * any number of characters.\n\t *\n\t * Examples:\n\t *\n\t * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n\t *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n\t * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n\t *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n\t * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n\t * * `'/user/{id:[^/]*}'` - Same as the previous example.\n\t * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n\t *   parameter consists of 1 to 8 hex digits.\n\t * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n\t *   path into the parameter 'path'.\n\t * * `'/files/*path'` - ditto.\n\t * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n\t *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n\t *\n\t * @param {string} pattern  The pattern to compile into a matcher.\n\t * @param {Object} config  A configuration object hash:\n\t * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n\t *   an existing UrlMatcher\n\t *\n\t * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n\t * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n\t *\n\t * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n\t *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n\t *   non-null) will start with this prefix.\n\t *\n\t * @property {string} source  The pattern that was passed into the constructor\n\t *\n\t * @property {string} sourcePath  The path portion of the source property\n\t *\n\t * @property {string} sourceSearch  The search portion of the source property\n\t *\n\t * @property {string} regex  The constructed regex that will be used to match against the url when\n\t *   it is time to determine which url will match.\n\t *\n\t * @returns {Object}  New `UrlMatcher` object\n\t */\n\tfunction UrlMatcher(pattern, config, parentMatcher) {\n\t  config = extend({ params: {} }, isObject(config) ? config : {});\n\t\n\t  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n\t  //   '*' name\n\t  //   ':' name\n\t  //   '{' name '}'\n\t  //   '{' name ':' regexp '}'\n\t  // The regular expression is somewhat complicated due to the need to allow curly braces\n\t  // inside the regular expression. The placeholder regexp breaks down as follows:\n\t  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n\t  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n\t  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n\t  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n\t  //    \\\\.                            - a backslash escape\n\t  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\t  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n\t      compiled = '^', last = 0, m,\n\t      segments = this.segments = [],\n\t      parentParams = parentMatcher ? parentMatcher.params : {},\n\t      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n\t      paramNames = [];\n\t\n\t  function addParameter(id, type, config, location) {\n\t    paramNames.push(id);\n\t    if (parentParams[id]) return parentParams[id];\n\t    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n\t    params[id] = new $$UMFP.Param(id, type, config, location);\n\t    return params[id];\n\t  }\n\t\n\t  function quoteRegExp(string, pattern, squash, optional) {\n\t    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n\t    if (!pattern) return result;\n\t    switch(squash) {\n\t      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n\t      case true:\n\t        result = result.replace(/\\/$/, '');\n\t        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n\t      break;\n\t      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n\t    }\n\t    return result + surroundPattern[0] + pattern + surroundPattern[1];\n\t  }\n\t\n\t  this.source = pattern;\n\t\n\t  // Split into static segments separated by path parameter placeholders.\n\t  // The number of segments is always 1 more than the number of parameters.\n\t  function matchDetails(m, isSearch) {\n\t    var id, regexp, segment, type, cfg, arrayMode;\n\t    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n\t    cfg         = config.params[id];\n\t    segment     = pattern.substring(last, m.index);\n\t    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\t\n\t    if (regexp) {\n\t      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n\t    }\n\t\n\t    return {\n\t      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n\t    };\n\t  }\n\t\n\t  var p, param, segment;\n\t  while ((m = placeholder.exec(pattern))) {\n\t    p = matchDetails(m, false);\n\t    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\t\n\t    param = addParameter(p.id, p.type, p.cfg, \"path\");\n\t    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n\t    segments.push(p.segment);\n\t    last = placeholder.lastIndex;\n\t  }\n\t  segment = pattern.substring(last);\n\t\n\t  // Find any search parameter names and remove them from the last segment\n\t  var i = segment.indexOf('?');\n\t\n\t  if (i >= 0) {\n\t    var search = this.sourceSearch = segment.substring(i);\n\t    segment = segment.substring(0, i);\n\t    this.sourcePath = pattern.substring(0, last + i);\n\t\n\t    if (search.length > 0) {\n\t      last = 0;\n\t      while ((m = searchPlaceholder.exec(search))) {\n\t        p = matchDetails(m, true);\n\t        param = addParameter(p.id, p.type, p.cfg, \"search\");\n\t        last = placeholder.lastIndex;\n\t        // check if ?&\n\t      }\n\t    }\n\t  } else {\n\t    this.sourcePath = pattern;\n\t    this.sourceSearch = '';\n\t  }\n\t\n\t  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n\t  segments.push(segment);\n\t\n\t  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n\t  this.prefix = segments[0];\n\t  this.$$paramNames = paramNames;\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#concat\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns a new matcher for a pattern constructed by appending the path part and adding the\n\t * search parameters of the specified pattern to this pattern. The current pattern is not\n\t * modified. This can be understood as creating a pattern for URLs that are relative to (or\n\t * suffixes of) the current pattern.\n\t *\n\t * @example\n\t * The following two matchers are equivalent:\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').concat('/details?date');\n\t * new UrlMatcher('/user/{id}/details?q&date');\n\t * </pre>\n\t *\n\t * @param {string} pattern  The pattern to append.\n\t * @param {Object} config  An object hash of the configuration for the matcher.\n\t * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n\t */\n\tUrlMatcher.prototype.concat = function (pattern, config) {\n\t  // Because order of search parameters is irrelevant, we can add our own search\n\t  // parameters to the end of the new pattern. Parse the new pattern by itself\n\t  // and then join the bits together, but it's much easier to do this on a string level.\n\t  var defaultConfig = {\n\t    caseInsensitive: $$UMFP.caseInsensitive(),\n\t    strict: $$UMFP.strictMode(),\n\t    squash: $$UMFP.defaultSquashPolicy()\n\t  };\n\t  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n\t};\n\t\n\tUrlMatcher.prototype.toString = function () {\n\t  return this.source;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#exec\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Tests the specified path against this matcher, and returns an object containing the captured\n\t * parameter values, or null if the path does not match. The returned object contains the values\n\t * of any search parameters that are mentioned in the pattern, but their value may be null if\n\t * they are not present in `searchParams`. This means that search parameters are always treated\n\t * as optional.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n\t *   x: '1', q: 'hello'\n\t * });\n\t * // returns { id: 'bob', q: 'hello', r: null }\n\t * </pre>\n\t *\n\t * @param {string} path  The URL path to match, e.g. `$location.path()`.\n\t * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n\t * @returns {Object}  The captured parameter values.\n\t */\n\tUrlMatcher.prototype.exec = function (path, searchParams) {\n\t  var m = this.regexp.exec(path);\n\t  if (!m) return null;\n\t  searchParams = searchParams || {};\n\t\n\t  var paramNames = this.parameters(), nTotal = paramNames.length,\n\t    nPath = this.segments.length - 1,\n\t    values = {}, i, j, cfg, paramName;\n\t\n\t  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\t\n\t  function decodePathArray(string) {\n\t    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n\t    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\t\n\t    var split = reverseString(string).split(/-(?!\\\\)/);\n\t    var allReversed = map(split, reverseString);\n\t    return map(allReversed, unquoteDashes).reverse();\n\t  }\n\t\n\t  var param, paramVal;\n\t  for (i = 0; i < nPath; i++) {\n\t    paramName = paramNames[i];\n\t    param = this.params[paramName];\n\t    paramVal = m[i+1];\n\t    // if the param value matches a pre-replace pair, replace the value before decoding.\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t  for (/**/; i < nTotal; i++) {\n\t    paramName = paramNames[i];\n\t    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n\t    param = this.params[paramName];\n\t    paramVal = searchParams[paramName];\n\t    for (j = 0; j < param.replace.length; j++) {\n\t      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n\t    }\n\t    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n\t    values[paramName] = param.value(paramVal);\n\t  }\n\t\n\t  return values;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#parameters\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Returns the names of all path and search parameters of this pattern in an unspecified order.\n\t *\n\t * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n\t *    pattern has no parameters, an empty array is returned.\n\t */\n\tUrlMatcher.prototype.parameters = function (param) {\n\t  if (!isDefined(param)) return this.$$paramNames;\n\t  return this.params[param] || null;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#validates\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Checks an object hash of parameters to validate their correctness according to the parameter\n\t * types of this `UrlMatcher`.\n\t *\n\t * @param {Object} params The object hash of parameters to validate.\n\t * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n\t */\n\tUrlMatcher.prototype.validates = function (params) {\n\t  return this.params.$$validates(params);\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:UrlMatcher#format\n\t * @methodOf ui.router.util.type:UrlMatcher\n\t *\n\t * @description\n\t * Creates a URL that matches this pattern by substituting the specified values\n\t * for the path and search parameters. Null values for path parameters are\n\t * treated as empty strings.\n\t *\n\t * @example\n\t * <pre>\n\t * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n\t * // returns '/user/bob?q=yes'\n\t * </pre>\n\t *\n\t * @param {Object} values  the values to substitute for the parameters in this pattern.\n\t * @returns {string}  the formatted URL (path and optionally search part).\n\t */\n\tUrlMatcher.prototype.format = function (values) {\n\t  values = values || {};\n\t  var segments = this.segments, params = this.parameters(), paramset = this.params;\n\t  if (!this.validates(values)) return null;\n\t\n\t  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\t\n\t  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n\t    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n\t  }\n\t\n\t  for (i = 0; i < nTotal; i++) {\n\t    var isPathParam = i < nPath;\n\t    var name = params[i], param = paramset[name], value = param.value(values[name]);\n\t    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n\t    var squash = isDefaultValue ? param.squash : false;\n\t    var encoded = param.type.encode(value);\n\t\n\t    if (isPathParam) {\n\t      var nextSegment = segments[i + 1];\n\t      var isFinalPathParam = i + 1 === nPath;\n\t\n\t      if (squash === false) {\n\t        if (encoded != null) {\n\t          if (isArray(encoded)) {\n\t            result += map(encoded, encodeDashes).join(\"-\");\n\t          } else {\n\t            result += encodeURIComponent(encoded);\n\t          }\n\t        }\n\t        result += nextSegment;\n\t      } else if (squash === true) {\n\t        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n\t        result += nextSegment.match(capture)[1];\n\t      } else if (isString(squash)) {\n\t        result += squash + nextSegment;\n\t      }\n\t\n\t      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n\t    } else {\n\t      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n\t      if (!isArray(encoded)) encoded = [ encoded ];\n\t      if (encoded.length === 0) continue;\n\t      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n\t      result += (search ? '&' : '?') + (name + '=' + encoded);\n\t      search = true;\n\t    }\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.type:Type\n\t *\n\t * @description\n\t * Implements an interface to define custom parameter types that can be decoded from and encoded to\n\t * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n\t * objects when matching or formatting URLs, or comparing or validating parameter values.\n\t *\n\t * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n\t * information on registering custom types.\n\t *\n\t * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n\t *        properties will override the default methods and/or pattern in `Type`'s public interface.\n\t * @example\n\t * <pre>\n\t * {\n\t *   decode: function(val) { return parseInt(val, 10); },\n\t *   encode: function(val) { return val && val.toString(); },\n\t *   equals: function(a, b) { return this.is(a) && a === b; },\n\t *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n\t *   pattern: /\\d+/\n\t * }\n\t * </pre>\n\t *\n\t * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n\t *           coming from a substring of a URL.\n\t *\n\t * @returns {Object}  Returns a new `Type` object.\n\t */\n\tfunction Type(config) {\n\t  extend(this, config);\n\t}\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#is\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Detects whether a value is of a particular type. Accepts a native (decoded) value\n\t * and determines whether it matches the current `Type` object.\n\t *\n\t * @param {*} val  The value to check.\n\t * @param {string} key  Optional. If the type check is happening in the context of a specific\n\t *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n\t *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n\t * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n\t */\n\tType.prototype.is = function(val, key) {\n\t  return true;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#encode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n\t * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n\t * only needs to be a representation of `val` that has been coerced to a string.\n\t *\n\t * @param {*} val  The value to encode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n\t */\n\tType.prototype.encode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#decode\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Converts a parameter value (from URL string or transition param) to a custom/native value.\n\t *\n\t * @param {string} val  The URL parameter value to decode.\n\t * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n\t *        meta-programming of `Type` objects.\n\t * @returns {*}  Returns a custom representation of the URL parameter value.\n\t */\n\tType.prototype.decode = function(val, key) {\n\t  return val;\n\t};\n\t\n\t/**\n\t * @ngdoc function\n\t * @name ui.router.util.type:Type#equals\n\t * @methodOf ui.router.util.type:Type\n\t *\n\t * @description\n\t * Determines whether two decoded values are equivalent.\n\t *\n\t * @param {*} a  A value to compare against.\n\t * @param {*} b  A value to compare against.\n\t * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n\t */\n\tType.prototype.equals = function(a, b) {\n\t  return a == b;\n\t};\n\t\n\tType.prototype.$subPattern = function() {\n\t  var sub = this.pattern.toString();\n\t  return sub.substr(1, sub.length - 2);\n\t};\n\t\n\tType.prototype.pattern = /.*/;\n\t\n\tType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\t\n\t/** Given an encoded string, or a decoded object, returns a decoded object */\n\tType.prototype.$normalize = function(val) {\n\t  return this.is(val) ? val : this.decode(val);\n\t};\n\t\n\t/*\n\t * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n\t * e.g.:\n\t * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n\t * - url: \"/path?queryParam=1&queryParam=2\n\t * - $stateParams.queryParam will be [1, 2]\n\t * if `mode` is \"auto\", then\n\t * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n\t * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n\t */\n\tType.prototype.$asArray = function(mode, isSearch) {\n\t  if (!mode) return this;\n\t  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\t\n\t  function ArrayType(type, mode) {\n\t    function bindTo(type, callbackName) {\n\t      return function() {\n\t        return type[callbackName].apply(type, arguments);\n\t      };\n\t    }\n\t\n\t    // Wrap non-array value as array\n\t    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n\t    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n\t    function arrayUnwrap(val) {\n\t      switch(val.length) {\n\t        case 0: return undefined;\n\t        case 1: return mode === \"auto\" ? val[0] : val;\n\t        default: return val;\n\t      }\n\t    }\n\t    function falsey(val) { return !val; }\n\t\n\t    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n\t    function arrayHandler(callback, allTruthyMode) {\n\t      return function handleArray(val) {\n\t        if (isArray(val) && val.length === 0) return val;\n\t        val = arrayWrap(val);\n\t        var result = map(val, callback);\n\t        if (allTruthyMode === true)\n\t          return filter(result, falsey).length === 0;\n\t        return arrayUnwrap(result);\n\t      };\n\t    }\n\t\n\t    // Wraps type (.equals) functions to operate on each value of an array\n\t    function arrayEqualsHandler(callback) {\n\t      return function handleArray(val1, val2) {\n\t        var left = arrayWrap(val1), right = arrayWrap(val2);\n\t        if (left.length !== right.length) return false;\n\t        for (var i = 0; i < left.length; i++) {\n\t          if (!callback(left[i], right[i])) return false;\n\t        }\n\t        return true;\n\t      };\n\t    }\n\t\n\t    this.encode = arrayHandler(bindTo(type, 'encode'));\n\t    this.decode = arrayHandler(bindTo(type, 'decode'));\n\t    this.is     = arrayHandler(bindTo(type, 'is'), true);\n\t    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n\t    this.pattern = type.pattern;\n\t    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n\t    this.name = type.name;\n\t    this.$arrayMode = mode;\n\t  }\n\t\n\t  return new ArrayType(this, mode);\n\t};\n\t\n\t\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.util.$urlMatcherFactory\n\t *\n\t * @description\n\t * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n\t * is also available to providers under the name `$urlMatcherFactoryProvider`.\n\t */\n\tfunction $UrlMatcherFactory() {\n\t  $$UMFP = this;\n\t\n\t  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\t\n\t  // Use tildes to pre-encode slashes.\n\t  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n\t  // and bidirectional encoding/decoding fails.\n\t  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n\t  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n\t  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\t\n\t  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n\t    \"string\": {\n\t      encode: valToString,\n\t      decode: valFromString,\n\t      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n\t      // In 0.2.x, string params are optional by default for backwards compat\n\t      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n\t      pattern: /[^/]*/\n\t    },\n\t    \"int\": {\n\t      encode: valToString,\n\t      decode: function(val) { return parseInt(val, 10); },\n\t      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n\t      pattern: /\\d+/\n\t    },\n\t    \"bool\": {\n\t      encode: function(val) { return val ? 1 : 0; },\n\t      decode: function(val) { return parseInt(val, 10) !== 0; },\n\t      is: function(val) { return val === true || val === false; },\n\t      pattern: /0|1/\n\t    },\n\t    \"date\": {\n\t      encode: function (val) {\n\t        if (!this.is(val))\n\t          return undefined;\n\t        return [ val.getFullYear(),\n\t          ('0' + (val.getMonth() + 1)).slice(-2),\n\t          ('0' + val.getDate()).slice(-2)\n\t        ].join(\"-\");\n\t      },\n\t      decode: function (val) {\n\t        if (this.is(val)) return val;\n\t        var match = this.capture.exec(val);\n\t        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n\t      },\n\t      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n\t      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n\t      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n\t      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n\t    },\n\t    \"json\": {\n\t      encode: angular.toJson,\n\t      decode: angular.fromJson,\n\t      is: angular.isObject,\n\t      equals: angular.equals,\n\t      pattern: /[^/]*/\n\t    },\n\t    \"any\": { // does not encode/decode\n\t      encode: angular.identity,\n\t      decode: angular.identity,\n\t      equals: angular.equals,\n\t      pattern: /.*/\n\t    }\n\t  };\n\t\n\t  function getDefaultConfig() {\n\t    return {\n\t      strict: isStrictMode,\n\t      caseInsensitive: isCaseInsensitive\n\t    };\n\t  }\n\t\n\t  function isInjectable(value) {\n\t    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n\t  }\n\t\n\t  /**\n\t   * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t   */\n\t  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n\t    if (!isInjectable(config.value)) return config.value;\n\t    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t    return injector.invoke(config.value);\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n\t   *\n\t   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n\t   * @returns {boolean} the current value of caseInsensitive\n\t   */\n\t  this.caseInsensitive = function(value) {\n\t    if (isDefined(value))\n\t      isCaseInsensitive = value;\n\t    return isCaseInsensitive;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#strictMode\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n\t   *\n\t   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n\t   * @returns {boolean} the current value of strictMode\n\t   */\n\t  this.strictMode = function(value) {\n\t    if (isDefined(value))\n\t      isStrictMode = value;\n\t    return isStrictMode;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Sets the default behavior when generating or matching URLs with default parameter values.\n\t   *\n\t   * @param {string} value A string that defines the default parameter URL squashing behavior.\n\t   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n\t   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n\t   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n\t   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n\t   *             the parameter value from the URL and replace it with this string.\n\t   */\n\t  this.defaultSquashPolicy = function(value) {\n\t    if (!isDefined(value)) return defaultSquashPolicy;\n\t    if (value !== true && value !== false && !isString(value))\n\t      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n\t    defaultSquashPolicy = value;\n\t    return value;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#compile\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n\t   *\n\t   * @param {string} pattern  The URL pattern.\n\t   * @param {Object} config  The config object hash.\n\t   * @returns {UrlMatcher}  The UrlMatcher.\n\t   */\n\t  this.compile = function (pattern, config) {\n\t    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#isMatcher\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n\t   *\n\t   * @param {Object} object  The object to perform the type check against.\n\t   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n\t   *          implementing all the same methods.\n\t   */\n\t  this.isMatcher = function (o) {\n\t    if (!isObject(o)) return false;\n\t    var result = true;\n\t\n\t    forEach(UrlMatcher.prototype, function(val, name) {\n\t      if (isFunction(val)) {\n\t        result = result && (isDefined(o[name]) && isFunction(o[name]));\n\t      }\n\t    });\n\t    return result;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.util.$urlMatcherFactory#type\n\t   * @methodOf ui.router.util.$urlMatcherFactory\n\t   *\n\t   * @description\n\t   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n\t   * generate URLs with typed parameters.\n\t   *\n\t   * @param {string} name  The type name.\n\t   * @param {Object|Function} definition   The type definition. See\n\t   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n\t   *        runtime starts.  The result of this function is merged into the existing `definition`.\n\t   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n\t   *\n\t   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n\t   *\n\t   * @example\n\t   * This is a simple example of a custom type that encodes and decodes items from an\n\t   * array, using the array index as the URL-encoded value:\n\t   *\n\t   * <pre>\n\t   * var list = ['John', 'Paul', 'George', 'Ringo'];\n\t   *\n\t   * $urlMatcherFactoryProvider.type('listItem', {\n\t   *   encode: function(item) {\n\t   *     // Represent the list item in the URL using its corresponding index\n\t   *     return list.indexOf(item);\n\t   *   },\n\t   *   decode: function(item) {\n\t   *     // Look up the list item by index\n\t   *     return list[parseInt(item, 10)];\n\t   *   },\n\t   *   is: function(item) {\n\t   *     // Ensure the item is valid by checking to see that it appears\n\t   *     // in the list\n\t   *     return list.indexOf(item) > -1;\n\t   *   }\n\t   * });\n\t   *\n\t   * $stateProvider.state('list', {\n\t   *   url: \"/list/{item:listItem}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     console.log($stateParams.item);\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n\t   * $state.go('list', { item: \"Ringo\" });\n\t   * </pre>\n\t   *\n\t   * This is a more complex example of a type that relies on dependency injection to\n\t   * interact with services, and uses the parameter name from the URL to infer how to\n\t   * handle encoding and decoding parameter values:\n\t   *\n\t   * <pre>\n\t   * // Defines a custom type that gets a value from a service,\n\t   * // where each service gets different types of values from\n\t   * // a backend API:\n\t   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n\t   *\n\t   *   // Matches up services to URL parameter names\n\t   *   var services = {\n\t   *     user: Users,\n\t   *     post: Posts\n\t   *   };\n\t   *\n\t   *   return {\n\t   *     encode: function(object) {\n\t   *       // Represent the object in the URL using its unique ID\n\t   *       return object.id;\n\t   *     },\n\t   *     decode: function(value, key) {\n\t   *       // Look up the object by ID, using the parameter\n\t   *       // name (key) to call the correct service\n\t   *       return services[key].findById(value);\n\t   *     },\n\t   *     is: function(object, key) {\n\t   *       // Check that object is a valid dbObject\n\t   *       return angular.isObject(object) && object.id && services[key];\n\t   *     }\n\t   *     equals: function(a, b) {\n\t   *       // Check the equality of decoded objects by comparing\n\t   *       // their unique IDs\n\t   *       return a.id === b.id;\n\t   *     }\n\t   *   };\n\t   * });\n\t   *\n\t   * // In a config() block, you can then attach URLs with\n\t   * // type-annotated parameters:\n\t   * $stateProvider.state('users', {\n\t   *   url: \"/users\",\n\t   *   // ...\n\t   * }).state('users.item', {\n\t   *   url: \"/{user:dbObject}\",\n\t   *   controller: function($scope, $stateParams) {\n\t   *     // $stateParams.user will now be an object returned from\n\t   *     // the Users service\n\t   *   },\n\t   *   // ...\n\t   * });\n\t   * </pre>\n\t   */\n\t  this.type = function (name, definition, definitionFn) {\n\t    if (!isDefined(definition)) return $types[name];\n\t    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\t\n\t    $types[name] = new Type(extend({ name: name }, definition));\n\t    if (definitionFn) {\n\t      typeQueue.push({ name: name, def: definitionFn });\n\t      if (!enqueue) flushTypeQueue();\n\t    }\n\t    return this;\n\t  };\n\t\n\t  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n\t  function flushTypeQueue() {\n\t    while(typeQueue.length) {\n\t      var type = typeQueue.shift();\n\t      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n\t      angular.extend($types[type.name], injector.invoke(type.def));\n\t    }\n\t  }\n\t\n\t  // Register default types. Store them in the prototype of $types.\n\t  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n\t  $types = inherit($types, {});\n\t\n\t  /* No need to document $get, since it returns this */\n\t  this.$get = ['$injector', function ($injector) {\n\t    injector = $injector;\n\t    enqueue = false;\n\t    flushTypeQueue();\n\t\n\t    forEach(defaultTypes, function(type, name) {\n\t      if (!$types[name]) $types[name] = new Type(type);\n\t    });\n\t    return this;\n\t  }];\n\t\n\t  this.Param = function Param(id, type, config, location) {\n\t    var self = this;\n\t    config = unwrapShorthand(config);\n\t    type = getType(config, type, location);\n\t    var arrayMode = getArrayMode();\n\t    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n\t    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n\t      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n\t    var isOptional = config.value !== undefined;\n\t    var squash = getSquashPolicy(config, isOptional);\n\t    var replace = getReplace(config, arrayMode, isOptional, squash);\n\t\n\t    function unwrapShorthand(config) {\n\t      var keys = isObject(config) ? objectKeys(config) : [];\n\t      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n\t                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n\t      if (isShorthand) config = { value: config };\n\t      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n\t      return config;\n\t    }\n\t\n\t    function getType(config, urlType, location) {\n\t      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n\t      if (urlType) return urlType;\n\t      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\t\n\t      if (angular.isString(config.type))\n\t        return $types[config.type];\n\t      if (config.type instanceof Type)\n\t        return config.type;\n\t      return new Type(config.type);\n\t    }\n\t\n\t    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n\t    function getArrayMode() {\n\t      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n\t      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\t      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n\t    }\n\t\n\t    /**\n\t     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n\t     */\n\t    function getSquashPolicy(config, isOptional) {\n\t      var squash = config.squash;\n\t      if (!isOptional || squash === false) return false;\n\t      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n\t      if (squash === true || isString(squash)) return squash;\n\t      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n\t    }\n\t\n\t    function getReplace(config, arrayMode, isOptional, squash) {\n\t      var replace, configuredKeys, defaultPolicy = [\n\t        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n\t        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n\t      ];\n\t      replace = isArray(config.replace) ? config.replace : [];\n\t      if (isString(squash))\n\t        replace.push({ from: squash, to: undefined });\n\t      configuredKeys = map(replace, function(item) { return item.from; } );\n\t      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n\t    }\n\t\n\t    /**\n\t     * [Internal] Get the default value of a parameter, which may be an injectable function.\n\t     */\n\t    function $$getDefaultValue() {\n\t      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n\t      var defaultValue = injector.invoke(config.$$fn);\n\t      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n\t        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n\t      return defaultValue;\n\t    }\n\t\n\t    /**\n\t     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n\t     * default value, which may be the result of an injectable function.\n\t     */\n\t    function $value(value) {\n\t      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n\t      function $replace(value) {\n\t        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n\t        return replacement.length ? replacement[0] : value;\n\t      }\n\t      value = $replace(value);\n\t      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n\t    }\n\t\n\t    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\t\n\t    extend(this, {\n\t      id: id,\n\t      type: type,\n\t      location: location,\n\t      array: arrayMode,\n\t      squash: squash,\n\t      replace: replace,\n\t      isOptional: isOptional,\n\t      value: $value,\n\t      dynamic: undefined,\n\t      config: config,\n\t      toString: toString\n\t    });\n\t  };\n\t\n\t  function ParamSet(params) {\n\t    extend(this, params || {});\n\t  }\n\t\n\t  ParamSet.prototype = {\n\t    $$new: function() {\n\t      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n\t    },\n\t    $$keys: function () {\n\t      var keys = [], chain = [], parent = this,\n\t        ignore = objectKeys(ParamSet.prototype);\n\t      while (parent) { chain.push(parent); parent = parent.$$parent; }\n\t      chain.reverse();\n\t      forEach(chain, function(paramset) {\n\t        forEach(objectKeys(paramset), function(key) {\n\t            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n\t        });\n\t      });\n\t      return keys;\n\t    },\n\t    $$values: function(paramValues) {\n\t      var values = {}, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        values[key] = self[key].value(paramValues && paramValues[key]);\n\t      });\n\t      return values;\n\t    },\n\t    $$equals: function(paramValues1, paramValues2) {\n\t      var equal = true, self = this;\n\t      forEach(self.$$keys(), function(key) {\n\t        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n\t        if (!self[key].type.equals(left, right)) equal = false;\n\t      });\n\t      return equal;\n\t    },\n\t    $$validates: function $$validate(paramValues) {\n\t      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n\t      for (i = 0; i < keys.length; i++) {\n\t        param = this[keys[i]];\n\t        rawVal = paramValues[keys[i]];\n\t        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n\t          break; // There was no parameter value, but the param is optional\n\t        normalized = param.type.$normalize(rawVal);\n\t        if (!param.type.is(normalized))\n\t          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n\t        encoded = param.type.encode(normalized);\n\t        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n\t          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n\t      }\n\t      return true;\n\t    },\n\t    $$parent: undefined\n\t  };\n\t\n\t  this.ParamSet = ParamSet;\n\t}\n\t\n\t// Register as a provider so it's available to other providers\n\tangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\n\tangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.router.$urlRouterProvider\n\t *\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t * @requires $locationProvider\n\t *\n\t * @description\n\t * `$urlRouterProvider` has the responsibility of watching `$location`. \n\t * When `$location` changes it runs through a list of rules one by one until a \n\t * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n\t * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n\t *\n\t * There are several methods on `$urlRouterProvider` that make it useful to use directly\n\t * in your module config.\n\t */\n\t$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\n\tfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n\t  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\t\n\t  // Returns a string that is a prefix of all strings matching the RegExp\n\t  function regExpPrefix(re) {\n\t    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n\t    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n\t  }\n\t\n\t  // Interpolates matched values into a String.replace()-style pattern\n\t  function interpolate(pattern, match) {\n\t    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n\t      return match[what === '$' ? 0 : Number(what)];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#rule\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines rules that are used by `$urlRouterProvider` to find matches for\n\t   * specific URLs.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // Here's an example of how you might allow case insensitive urls\n\t   *   $urlRouterProvider.rule(function ($injector, $location) {\n\t   *     var path = $location.path(),\n\t   *         normalized = path.toLowerCase();\n\t   *\n\t   *     if (path !== normalized) {\n\t   *       return normalized;\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {function} rule Handler function that takes `$injector` and `$location`\n\t   * services as arguments. You can use them to return a valid path as a string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.rule = function (rule) {\n\t    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    rules.push(rule);\n\t    return this;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouterProvider#otherwise\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Defines a path that is used when an invalid route is requested.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   // if the path doesn't match any of the urls you configured\n\t   *   // otherwise will take care of routing the user to the\n\t   *   // specified url\n\t   *   $urlRouterProvider.otherwise('/index');\n\t   *\n\t   *   // Example of using function rule as param\n\t   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n\t   *     return '/a/valid/url';\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|function} rule The url path you want to redirect to or a function \n\t   * rule that returns the url path. The function version is passed two params: \n\t   * `$injector` and `$location` services, and must return a url string.\n\t   *\n\t   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n\t   */\n\t  this.otherwise = function (rule) {\n\t    if (isString(rule)) {\n\t      var redirect = rule;\n\t      rule = function () { return redirect; };\n\t    }\n\t    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n\t    otherwise = rule;\n\t    return this;\n\t  };\n\t\n\t\n\t  function handleIfMatch($injector, handler, match) {\n\t    if (!match) return false;\n\t    var result = $injector.invoke(handler, handler, { $match: match });\n\t    return isDefined(result) ? result : true;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#when\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Registers a handler for a given url matching. \n\t   * \n\t   * If the handler is a string, it is\n\t   * treated as a redirect, and is interpolated according to the syntax of match\n\t   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n\t   *\n\t   * If the handler is a function, it is injectable. It gets invoked if `$location`\n\t   * matches. You have the option of inject the match object as `$match`.\n\t   *\n\t   * The handler can return\n\t   *\n\t   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n\t   *   will continue trying to find another one that matches.\n\t   * - **string** which is treated as a redirect and passed to `$location.url()`\n\t   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n\t   *     if ($state.$current.navigable !== state ||\n\t   *         !equalForKeys($match, $stateParams) {\n\t   *      $state.transitionTo(state, $match, false);\n\t   *     }\n\t   *   });\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {string|object} what The incoming path that you want to redirect.\n\t   * @param {string|function} handler The path you want to redirect your user to.\n\t   */\n\t  this.when = function (what, handler) {\n\t    var redirect, handlerIsString = isString(handler);\n\t    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\t\n\t    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n\t      throw new Error(\"invalid 'handler' in when()\");\n\t\n\t    var strategies = {\n\t      matcher: function (what, handler) {\n\t        if (handlerIsString) {\n\t          redirect = $urlMatcherFactory.compile(handler);\n\t          handler = ['$match', function ($match) { return redirect.format($match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n\t        }, {\n\t          prefix: isString(what.prefix) ? what.prefix : ''\n\t        });\n\t      },\n\t      regex: function (what, handler) {\n\t        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\t\n\t        if (handlerIsString) {\n\t          redirect = handler;\n\t          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n\t        }\n\t        return extend(function ($injector, $location) {\n\t          return handleIfMatch($injector, handler, what.exec($location.path()));\n\t        }, {\n\t          prefix: regExpPrefix(what)\n\t        });\n\t      }\n\t    };\n\t\n\t    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\t\n\t    for (var n in check) {\n\t      if (check[n]) return this.rule(strategies[n](what, handler));\n\t    }\n\t\n\t    throw new Error(\"invalid 'what' in when()\");\n\t  };\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.router.$urlRouterProvider#deferIntercept\n\t   * @methodOf ui.router.router.$urlRouterProvider\n\t   *\n\t   * @description\n\t   * Disables (or enables) deferring location change interception.\n\t   *\n\t   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n\t   * defer a transition but maintain the current URL), call this method at configuration time.\n\t   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n\t   * `$locationChangeSuccess` event handler.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * var app = angular.module('app', ['ui.router.router']);\n\t   *\n\t   * app.config(function ($urlRouterProvider) {\n\t   *\n\t   *   // Prevent $urlRouter from automatically intercepting URL changes;\n\t   *   // this allows you to configure custom behavior in between\n\t   *   // location changes and route synchronization:\n\t   *   $urlRouterProvider.deferIntercept();\n\t   *\n\t   * }).run(function ($rootScope, $urlRouter, UserService) {\n\t   *\n\t   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n\t   *     // UserService is an example service for managing user state\n\t   *     if (UserService.isLoggedIn()) return;\n\t   *\n\t   *     // Prevent $urlRouter's default handler from firing\n\t   *     e.preventDefault();\n\t   *\n\t   *     UserService.handleLogin().then(function() {\n\t   *       // Once the user has logged in, sync the current URL\n\t   *       // to the router:\n\t   *       $urlRouter.sync();\n\t   *     });\n\t   *   });\n\t   *\n\t   *   // Configures $urlRouter's listener *after* your custom listener\n\t   *   $urlRouter.listen();\n\t   * });\n\t   * </pre>\n\t   *\n\t   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n\t            no parameter is equivalent to `true`.\n\t   */\n\t  this.deferIntercept = function (defer) {\n\t    if (defer === undefined) defer = true;\n\t    interceptDeferred = defer;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.router.$urlRouter\n\t   *\n\t   * @requires $location\n\t   * @requires $rootScope\n\t   * @requires $injector\n\t   * @requires $browser\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n\t  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\t\n\t    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\t\n\t    function appendBasePath(url, isHtml5, absolute) {\n\t      if (baseHref === '/') return url;\n\t      if (isHtml5) return baseHref.slice(0, -1) + url;\n\t      if (absolute) return baseHref.slice(1) + url;\n\t      return url;\n\t    }\n\t\n\t    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n\t    function update(evt) {\n\t      if (evt && evt.defaultPrevented) return;\n\t      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n\t      lastPushedUrl = undefined;\n\t      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n\t      //if (ignoreUpdate) return true;\n\t\n\t      function check(rule) {\n\t        var handled = rule($injector, $location);\n\t\n\t        if (!handled) return false;\n\t        if (isString(handled)) $location.replace().url(handled);\n\t        return true;\n\t      }\n\t      var n = rules.length, i;\n\t\n\t      for (i = 0; i < n; i++) {\n\t        if (check(rules[i])) return;\n\t      }\n\t      // always check otherwise last to allow dynamic updates to the set of rules\n\t      if (otherwise) check(otherwise);\n\t    }\n\t\n\t    function listen() {\n\t      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n\t      return listener;\n\t    }\n\t\n\t    if (!interceptDeferred) listen();\n\t\n\t    return {\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#sync\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n\t       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n\t       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n\t       * with the transition by calling `$urlRouter.sync()`.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * angular.module('app', ['ui.router'])\n\t       *   .run(function($rootScope, $urlRouter) {\n\t       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n\t       *       // Halt state change from even starting\n\t       *       evt.preventDefault();\n\t       *       // Perform custom logic\n\t       *       var meetsRequirement = ...\n\t       *       // Continue with the update and state transition if logic allows\n\t       *       if (meetsRequirement) $urlRouter.sync();\n\t       *     });\n\t       * });\n\t       * </pre>\n\t       */\n\t      sync: function() {\n\t        update();\n\t      },\n\t\n\t      listen: function() {\n\t        return listen();\n\t      },\n\t\n\t      update: function(read) {\n\t        if (read) {\n\t          location = $location.url();\n\t          return;\n\t        }\n\t        if ($location.url() === location) return;\n\t\n\t        $location.url(location);\n\t        $location.replace();\n\t      },\n\t\n\t      push: function(urlMatcher, params, options) {\n\t         var url = urlMatcher.format(params || {});\n\t\n\t        // Handle the special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t            url += '#' + params['#'];\n\t        }\n\t\n\t        $location.url(url);\n\t        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n\t        if (options && options.replace) $location.replace();\n\t      },\n\t\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.router.$urlRouter#href\n\t       * @methodOf ui.router.router.$urlRouter\n\t       *\n\t       * @description\n\t       * A URL generation method that returns the compiled URL for a given\n\t       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n\t       *\n\t       * @example\n\t       * <pre>\n\t       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n\t       *   person: \"bob\"\n\t       * });\n\t       * // $bob == \"/about/bob\";\n\t       * </pre>\n\t       *\n\t       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n\t       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n\t       * @param {object=} options Options object. The options are:\n\t       *\n\t       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t       *\n\t       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n\t       */\n\t      href: function(urlMatcher, params, options) {\n\t        if (!urlMatcher.validates(params)) return null;\n\t\n\t        var isHtml5 = $locationProvider.html5Mode();\n\t        if (angular.isObject(isHtml5)) {\n\t          isHtml5 = isHtml5.enabled;\n\t        }\n\t\n\t        isHtml5 = isHtml5 && $sniffer.history;\n\t        \n\t        var url = urlMatcher.format(params);\n\t        options = options || {};\n\t\n\t        if (!isHtml5 && url !== null) {\n\t          url = \"#\" + $locationProvider.hashPrefix() + url;\n\t        }\n\t\n\t        // Handle special hash param, if needed\n\t        if (url !== null && params && params['#']) {\n\t          url += '#' + params['#'];\n\t        }\n\t\n\t        url = appendBasePath(url, isHtml5, options.absolute);\n\t\n\t        if (!options.absolute || !url) {\n\t          return url;\n\t        }\n\t\n\t        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n\t        port = (port === 80 || port === 443 ? '' : ':' + port);\n\t\n\t        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$stateProvider\n\t *\n\t * @requires ui.router.router.$urlRouterProvider\n\t * @requires ui.router.util.$urlMatcherFactoryProvider\n\t *\n\t * @description\n\t * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n\t * on state.\n\t *\n\t * A state corresponds to a \"place\" in the application in terms of the overall UI and\n\t * navigation. A state describes (via the controller / template / view properties) what\n\t * the UI looks like and does at that place.\n\t *\n\t * States often have things in common, and the primary way of factoring out these\n\t * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n\t * nested states.\n\t *\n\t * The `$stateProvider` provides interfaces to declare these states for your app.\n\t */\n\t$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\n\tfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\t\n\t  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\t\n\t  // Builds state properties from definition passed to registerState()\n\t  var stateBuilder = {\n\t\n\t    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n\t    // state.children = [];\n\t    // if (parent) parent.children.push(state);\n\t    parent: function(state) {\n\t      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n\t      // regex matches any valid composite state name\n\t      // would match \"contact.list\" but not \"contacts\"\n\t      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n\t      return compositeName ? findState(compositeName[1]) : root;\n\t    },\n\t\n\t    // inherit 'data' from parent and override by own values (if any)\n\t    data: function(state) {\n\t      if (state.parent && state.parent.data) {\n\t        state.data = state.self.data = inherit(state.parent.data, state.data);\n\t      }\n\t      return state.data;\n\t    },\n\t\n\t    // Build a URLMatcher if necessary, either via a relative or absolute URL\n\t    url: function(state) {\n\t      var url = state.url, config = { params: state.params || {} };\n\t\n\t      if (isString(url)) {\n\t        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n\t        return (state.parent.navigable || root).url.concat(url, config);\n\t      }\n\t\n\t      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n\t      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n\t    },\n\t\n\t    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n\t    navigable: function(state) {\n\t      return state.url ? state : (state.parent ? state.parent.navigable : null);\n\t    },\n\t\n\t    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n\t    ownParams: function(state) {\n\t      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n\t      forEach(state.params || {}, function(config, id) {\n\t        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n\t      });\n\t      return params;\n\t    },\n\t\n\t    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n\t    params: function(state) {\n\t      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n\t      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n\t    },\n\t\n\t    // If there is no explicit multi-view configuration, make one up so we don't have\n\t    // to handle both cases in the view directive later. Note that having an explicit\n\t    // 'views' property will mean the default unnamed view properties are ignored. This\n\t    // is also a good time to resolve view names to absolute names, so everything is a\n\t    // straight lookup at link time.\n\t    views: function(state) {\n\t      var views = {};\n\t\n\t      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n\t        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n\t        views[name] = view;\n\t      });\n\t      return views;\n\t    },\n\t\n\t    // Keep a full path from the root down to this state as this is needed for state activation.\n\t    path: function(state) {\n\t      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n\t    },\n\t\n\t    // Speed up $state.contains() as it's used a lot\n\t    includes: function(state) {\n\t      var includes = state.parent ? extend({}, state.parent.includes) : {};\n\t      includes[state.name] = true;\n\t      return includes;\n\t    },\n\t\n\t    $delegates: {}\n\t  };\n\t\n\t  function isRelative(stateName) {\n\t    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n\t  }\n\t\n\t  function findState(stateOrName, base) {\n\t    if (!stateOrName) return undefined;\n\t\n\t    var isStr = isString(stateOrName),\n\t        name  = isStr ? stateOrName : stateOrName.name,\n\t        path  = isRelative(name);\n\t\n\t    if (path) {\n\t      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n\t      base = findState(base);\n\t      \n\t      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\t\n\t      for (; i < pathLength; i++) {\n\t        if (rel[i] === \"\" && i === 0) {\n\t          current = base;\n\t          continue;\n\t        }\n\t        if (rel[i] === \"^\") {\n\t          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n\t          current = current.parent;\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t      rel = rel.slice(i).join(\".\");\n\t      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n\t    }\n\t    var state = states[name];\n\t\n\t    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n\t      return state;\n\t    }\n\t    return undefined;\n\t  }\n\t\n\t  function queueState(parentName, state) {\n\t    if (!queue[parentName]) {\n\t      queue[parentName] = [];\n\t    }\n\t    queue[parentName].push(state);\n\t  }\n\t\n\t  function flushQueuedChildren(parentName) {\n\t    var queued = queue[parentName] || [];\n\t    while(queued.length) {\n\t      registerState(queued.shift());\n\t    }\n\t  }\n\t\n\t  function registerState(state) {\n\t    // Wrap a new object around the state so we can store our private details easily.\n\t    state = inherit(state, {\n\t      self: state,\n\t      resolve: state.resolve || {},\n\t      toString: function() { return this.name; }\n\t    });\n\t\n\t    var name = state.name;\n\t    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n\t    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\t\n\t    // Get parent name\n\t    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n\t        : (isString(state.parent)) ? state.parent\n\t        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n\t        : '';\n\t\n\t    // If parent is not registered yet, add state to queue and register later\n\t    if (parentName && !states[parentName]) {\n\t      return queueState(parentName, state.self);\n\t    }\n\t\n\t    for (var key in stateBuilder) {\n\t      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n\t    }\n\t    states[name] = state;\n\t\n\t    // Register the state in the global state list and with $urlRouter if necessary.\n\t    if (!state[abstractKey] && state.url) {\n\t      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n\t        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n\t          $state.transitionTo(state, $match, { inherit: true, location: false });\n\t        }\n\t      }]);\n\t    }\n\t\n\t    // Register any queued children\n\t    flushQueuedChildren(name);\n\t\n\t    return state;\n\t  }\n\t\n\t  // Checks text to see if it looks like a glob.\n\t  function isGlob (text) {\n\t    return text.indexOf('*') > -1;\n\t  }\n\t\n\t  // Returns true if glob matches current $state name.\n\t  function doesStateMatchGlob (glob) {\n\t    var globSegments = glob.split('.'),\n\t        segments = $state.$current.name.split('.');\n\t\n\t    //match single stars\n\t    for (var i = 0, l = globSegments.length; i < l; i++) {\n\t      if (globSegments[i] === '*') {\n\t        segments[i] = '*';\n\t      }\n\t    }\n\t\n\t    //match greedy starts\n\t    if (globSegments[0] === '**') {\n\t       segments = segments.slice(indexOf(segments, globSegments[1]));\n\t       segments.unshift('**');\n\t    }\n\t    //match greedy ends\n\t    if (globSegments[globSegments.length - 1] === '**') {\n\t       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n\t       segments.push('**');\n\t    }\n\t\n\t    if (globSegments.length != segments.length) {\n\t      return false;\n\t    }\n\t\n\t    return segments.join('') === globSegments.join('');\n\t  }\n\t\n\t\n\t  // Implicit root state that is always active\n\t  root = registerState({\n\t    name: '',\n\t    url: '^',\n\t    views: null,\n\t    'abstract': true\n\t  });\n\t  root.navigable = null;\n\t\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#decorator\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Allows you to extend (carefully) or override (at your own peril) the \n\t   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n\t   * to add custom functionality to ui-router, for example inferring templateUrl \n\t   * based on the state name.\n\t   *\n\t   * When passing only a name, it returns the current (original or decorated) builder\n\t   * function that matches `name`.\n\t   *\n\t   * The builder functions that can be decorated are listed below. Though not all\n\t   * necessarily have a good use case for decoration, that is up to you to decide.\n\t   *\n\t   * In addition, users can attach custom decorators, which will generate new \n\t   * properties within the state's internal definition. There is currently no clear \n\t   * use-case for this beyond accessing internal states (i.e. $state.$current), \n\t   * however, expect this to become increasingly relevant as we introduce additional \n\t   * meta-programming features.\n\t   *\n\t   * **Warning**: Decorators should not be interdependent because the order of \n\t   * execution of the builder functions in non-deterministic. Builder functions \n\t   * should only be dependent on the state definition object and super function.\n\t   *\n\t   *\n\t   * Existing builder functions and current return values:\n\t   *\n\t   * - **parent** `{object}` - returns the parent state object.\n\t   * - **data** `{object}` - returns state data, including any inherited data that is not\n\t   *   overridden by own values (if any).\n\t   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n\t   *   or `null`.\n\t   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n\t   *   navigable).\n\t   * - **params** `{object}` - returns an array of state params that are ensured to \n\t   *   be a super-set of parent's params.\n\t   * - **views** `{object}` - returns a views object where each key is an absolute view \n\t   *   name (i.e. \"viewName@stateName\") and each value is the config object \n\t   *   (template, controller) for the view. Even when you don't use the views object \n\t   *   explicitly on a state config, one is still created for you internally.\n\t   *   So by decorating this builder function you have access to decorating template \n\t   *   and controller properties.\n\t   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n\t   *   not including any params defined by ancestor states.\n\t   * - **path** `{string}` - returns the full path from the root down to this state. \n\t   *   Needed for state activation.\n\t   * - **includes** `{object}` - returns an object that includes every state that \n\t   *   would pass a `$state.includes()` test.\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Override the internal 'views' builder with a function that takes the state\n\t   * // definition, and a reference to the internal function being overridden:\n\t   * $stateProvider.decorator('views', function (state, parent) {\n\t   *   var result = {},\n\t   *       views = parent(state);\n\t   *\n\t   *   angular.forEach(views, function (config, name) {\n\t   *     var autoName = (state.name + '.' + name).replace('.', '/');\n\t   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n\t   *     result[name] = config;\n\t   *   });\n\t   *   return result;\n\t   * });\n\t   *\n\t   * $stateProvider.state('home', {\n\t   *   views: {\n\t   *     'contact.list': { controller: 'ListController' },\n\t   *     'contact.item': { controller: 'ItemController' }\n\t   *   }\n\t   * });\n\t   *\n\t   * // ...\n\t   *\n\t   * $state.go('home');\n\t   * // Auto-populates list and item views with /partials/home/contact/list.html,\n\t   * // and /partials/home/contact/item.html, respectively.\n\t   * </pre>\n\t   *\n\t   * @param {string} name The name of the builder function to decorate. \n\t   * @param {object} func A function that is responsible for decorating the original \n\t   * builder function. The function receives two parameters:\n\t   *\n\t   *   - `{object}` - state - The state config object.\n\t   *   - `{object}` - super - The original builder function.\n\t   *\n\t   * @return {object} $stateProvider - $stateProvider instance\n\t   */\n\t  this.decorator = decorator;\n\t  function decorator(name, func) {\n\t    /*jshint validthis: true */\n\t    if (isString(name) && !isDefined(func)) {\n\t      return stateBuilder[name];\n\t    }\n\t    if (!isFunction(func) || !isString(name)) {\n\t      return this;\n\t    }\n\t    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n\t      stateBuilder.$delegates[name] = stateBuilder[name];\n\t    }\n\t    stateBuilder[name] = func;\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$stateProvider#state\n\t   * @methodOf ui.router.state.$stateProvider\n\t   *\n\t   * @description\n\t   * Registers a state configuration under a given state name. The stateConfig object\n\t   * has the following acceptable properties.\n\t   *\n\t   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n\t   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n\t   * @param {object} stateConfig State configuration object.\n\t   * @param {string|function=} stateConfig.template\n\t   * <a id='template'></a>\n\t   *   html template as a string or a function that returns\n\t   *   an html template as a string which should be used by the uiView directives. This property \n\t   *   takes precedence over templateUrl.\n\t   *   \n\t   *   If `template` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n\t   *     applying the current state\n\t   *\n\t   * <pre>template:\n\t   *   \"<h1>inline template definition</h1>\" +\n\t   *   \"<div ui-view></div>\"</pre>\n\t   * <pre>template: function(params) {\n\t   *       return \"<h1>generated template</h1>\"; }</pre>\n\t   * </div>\n\t   *\n\t   * @param {string|function=} stateConfig.templateUrl\n\t   * <a id='templateUrl'></a>\n\t   *\n\t   *   path or function that returns a path to an html\n\t   *   template that should be used by uiView.\n\t   *   \n\t   *   If `templateUrl` is a function, it will be called with the following parameters:\n\t   *\n\t   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n\t   *     applying the current state\n\t   *\n\t   * <pre>templateUrl: \"home.html\"</pre>\n\t   * <pre>templateUrl: function(params) {\n\t   *     return myTemplates[params.pageId]; }</pre>\n\t   *\n\t   * @param {function=} stateConfig.templateProvider\n\t   * <a id='templateProvider'></a>\n\t   *    Provider function that returns HTML content string.\n\t   * <pre> templateProvider:\n\t   *       function(MyTemplateService, params) {\n\t   *         return MyTemplateService.getTemplate(params.pageId);\n\t   *       }</pre>\n\t   *\n\t   * @param {string|function=} stateConfig.controller\n\t   * <a id='controller'></a>\n\t   *\n\t   *  Controller fn that should be associated with newly\n\t   *   related scope or the name of a registered controller if passed as a string.\n\t   *   Optionally, the ControllerAs may be declared here.\n\t   * <pre>controller: \"MyRegisteredController\"</pre>\n\t   * <pre>controller:\n\t   *     \"MyRegisteredController as fooCtrl\"}</pre>\n\t   * <pre>controller: function($scope, MyService) {\n\t   *     $scope.data = MyService.getData(); }</pre>\n\t   *\n\t   * @param {function=} stateConfig.controllerProvider\n\t   * <a id='controllerProvider'></a>\n\t   *\n\t   * Injectable provider function that returns the actual controller or string.\n\t   * <pre>controllerProvider:\n\t   *   function(MyResolveData) {\n\t   *     if (MyResolveData.foo)\n\t   *       return \"FooCtrl\"\n\t   *     else if (MyResolveData.bar)\n\t   *       return \"BarCtrl\";\n\t   *     else return function($scope) {\n\t   *       $scope.baz = \"Qux\";\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {string=} stateConfig.controllerAs\n\t   * <a id='controllerAs'></a>\n\t   * \n\t   * A controller alias name. If present the controller will be\n\t   *   published to scope under the controllerAs name.\n\t   * <pre>controllerAs: \"myCtrl\"</pre>\n\t   *\n\t   * @param {string|object=} stateConfig.parent\n\t   * <a id='parent'></a>\n\t   * Optionally specifies the parent state of this state.\n\t   *\n\t   * <pre>parent: 'parentState'</pre>\n\t   * <pre>parent: parentState // JS variable</pre>\n\t   *\n\t   * @param {object=} stateConfig.resolve\n\t   * <a id='resolve'></a>\n\t   *\n\t   * An optional map&lt;string, function&gt; of dependencies which\n\t   *   should be injected into the controller. If any of these dependencies are promises, \n\t   *   the router will wait for them all to be resolved before the controller is instantiated.\n\t   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n\t   *   and the values of the resolved promises are injected into any controllers that reference them.\n\t   *   If any  of the promises are rejected the $stateChangeError event is fired.\n\t   *\n\t   *   The map object is:\n\t   *   \n\t   *   - key - {string}: name of dependency to be injected into controller\n\t   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n\t   *     it is injected and return value it treated as dependency. If result is a promise, it is \n\t   *     resolved before its value is injected into controller.\n\t   *\n\t   * <pre>resolve: {\n\t   *     myResolve1:\n\t   *       function($http, $stateParams) {\n\t   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n\t   *       }\n\t   *     }</pre>\n\t   *\n\t   * @param {string=} stateConfig.url\n\t   * <a id='url'></a>\n\t   *\n\t   *   A url fragment with optional parameters. When a state is navigated or\n\t   *   transitioned to, the `$stateParams` service will be populated with any \n\t   *   parameters that were passed.\n\t   *\n\t   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n\t   *   more details on acceptable patterns )\n\t   *\n\t   * examples:\n\t   * <pre>url: \"/home\"\n\t   * url: \"/users/:userid\"\n\t   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n\t   * url: \"/books/{categoryid:int}\"\n\t   * url: \"/books/{publishername:string}/{categoryid:int}\"\n\t   * url: \"/messages?before&after\"\n\t   * url: \"/messages?{before:date}&{after:date}\"\n\t   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n\t   * </pre>\n\t   *\n\t   * @param {object=} stateConfig.views\n\t   * <a id='views'></a>\n\t   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n\t   * manually/explicitly.\n\t   *\n\t   * Examples:\n\t   *\n\t   * Targets three named `ui-view`s in the parent state's template\n\t   * <pre>views: {\n\t   *     header: {\n\t   *       controller: \"headerCtrl\",\n\t   *       templateUrl: \"header.html\"\n\t   *     }, body: {\n\t   *       controller: \"bodyCtrl\",\n\t   *       templateUrl: \"body.html\"\n\t   *     }, footer: {\n\t   *       controller: \"footCtrl\",\n\t   *       templateUrl: \"footer.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n\t   * <pre>views: {\n\t   *     'header@top': {\n\t   *       controller: \"msgHeaderCtrl\",\n\t   *       templateUrl: \"msgHeader.html\"\n\t   *     }, 'body': {\n\t   *       controller: \"messagesCtrl\",\n\t   *       templateUrl: \"messages.html\"\n\t   *     }\n\t   *   }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.abstract=false]\n\t   * <a id='abstract'></a>\n\t   * An abstract state will never be directly activated,\n\t   *   but can provide inherited properties to its common children states.\n\t   * <pre>abstract: true</pre>\n\t   *\n\t   * @param {function=} stateConfig.onEnter\n\t   * <a id='onEnter'></a>\n\t   *\n\t   * Callback function for when a state is entered. Good way\n\t   *   to trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onEnter: function(MyService, $stateParams) {\n\t   *     MyService.foo($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {function=} stateConfig.onExit\n\t   * <a id='onExit'></a>\n\t   *\n\t   * Callback function for when a state is exited. Good way to\n\t   *   trigger an action or dispatch an event, such as opening a dialog.\n\t   * If minifying your scripts, make sure to explicitly annotate this function,\n\t   * because it won't be automatically annotated by your build tools.\n\t   *\n\t   * <pre>onExit: function(MyService, $stateParams) {\n\t   *     MyService.cleanup($stateParams.myParam);\n\t   * }</pre>\n\t   *\n\t   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n\t   * <a id='reloadOnSearch'></a>\n\t   *\n\t   * If `false`, will not retrigger the same state\n\t   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n\t   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n\t   * <pre>reloadOnSearch: false</pre>\n\t   *\n\t   * @param {object=} stateConfig.data\n\t   * <a id='data'></a>\n\t   *\n\t   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n\t   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n\t   *   the entire subtree via prototypal inheritance.\n\t   *\n\t   * <pre>data: {\n\t   *     requiredRole: 'foo'\n\t   * } </pre>\n\t   *\n\t   * @param {object=} stateConfig.params\n\t   * <a id='params'></a>\n\t   *\n\t   * A map which optionally configures parameters declared in the `url`, or\n\t   *   defines additional non-url parameters.  For each parameter being\n\t   *   configured, add a configuration object keyed to the name of the parameter.\n\t   *\n\t   *   Each parameter configuration object may contain the following properties:\n\t   *\n\t   *   - ** value ** - {object|function=}: specifies the default value for this\n\t   *     parameter.  This implicitly sets this parameter as optional.\n\t   *\n\t   *     When UI-Router routes to a state and no value is\n\t   *     specified for this parameter in the URL or transition, the\n\t   *     default value will be used instead.  If `value` is a function,\n\t   *     it will be injected and invoked, and the return value used.\n\t   *\n\t   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n\t   *     is treated as \"the default value is `null`\".\n\t   *\n\t   *     *Shorthand*: If you only need to configure the default value of the\n\t   *     parameter, you may use a shorthand syntax.   In the **`params`**\n\t   *     map, instead mapping the param name to a full parameter configuration\n\t   *     object, simply set map it to the default parameter value, e.g.:\n\t   *\n\t   * <pre>// define a parameter's default value\n\t   * params: {\n\t   *     param1: { value: \"defaultValue\" }\n\t   * }\n\t   * // shorthand default values\n\t   * params: {\n\t   *     param1: \"defaultValue\",\n\t   *     param2: \"param2Default\"\n\t   * }</pre>\n\t   *\n\t   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n\t   *     treated as an array of values.  If you specified a Type, the value will be\n\t   *     treated as an array of the specified Type.  Note: query parameter values\n\t   *     default to a special `\"auto\"` mode.\n\t   *\n\t   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n\t   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n\t   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n\t   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n\t   *     value (e.g.: `{ foo: '1' }`).\n\t   *\n\t   * <pre>params: {\n\t   *     param1: { array: true }\n\t   * }</pre>\n\t   *\n\t   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n\t   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n\t   *     configured default squash policy.\n\t   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n\t   *\n\t   *   There are three squash settings:\n\t   *\n\t   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n\t   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n\t   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n\t   *       This can allow for cleaner looking URLs.\n\t   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n\t   *\n\t   * <pre>params: {\n\t   *     param1: {\n\t   *       value: \"defaultId\",\n\t   *       squash: true\n\t   * } }\n\t   * // squash \"defaultValue\" to \"~\"\n\t   * params: {\n\t   *     param1: {\n\t   *       value: \"defaultValue\",\n\t   *       squash: \"~\"\n\t   * } }\n\t   * </pre>\n\t   *\n\t   *\n\t   * @example\n\t   * <pre>\n\t   * // Some state name examples\n\t   *\n\t   * // stateName can be a single top-level name (must be unique).\n\t   * $stateProvider.state(\"home\", {});\n\t   *\n\t   * // Or it can be a nested state name. This state is a child of the\n\t   * // above \"home\" state.\n\t   * $stateProvider.state(\"home.newest\", {});\n\t   *\n\t   * // Nest states as deeply as needed.\n\t   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n\t   *\n\t   * // state() returns $stateProvider, so you can chain state declarations.\n\t   * $stateProvider\n\t   *   .state(\"home\", {})\n\t   *   .state(\"about\", {})\n\t   *   .state(\"contacts\", {});\n\t   * </pre>\n\t   *\n\t   */\n\t  this.state = state;\n\t  function state(name, definition) {\n\t    /*jshint validthis: true */\n\t    if (isObject(name)) definition = name;\n\t    else definition.name = name;\n\t    registerState(definition);\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$state\n\t   *\n\t   * @requires $rootScope\n\t   * @requires $q\n\t   * @requires ui.router.state.$view\n\t   * @requires $injector\n\t   * @requires ui.router.util.$resolve\n\t   * @requires ui.router.state.$stateParams\n\t   * @requires ui.router.router.$urlRouter\n\t   *\n\t   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n\t   * you'd like to test against the current active state.\n\t   * @property {object} current A reference to the state's config object. However \n\t   * you passed it in. Useful for accessing custom data.\n\t   * @property {object} transition Currently pending transition. A promise that'll \n\t   * resolve or reject.\n\t   *\n\t   * @description\n\t   * `$state` service is responsible for representing states as well as transitioning\n\t   * between them. It also provides interfaces to ask for current state or even states\n\t   * you're coming from.\n\t   */\n\t  this.$get = $get;\n\t  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n\t  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\t\n\t    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n\t    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n\t    var TransitionAborted = $q.reject(new Error('transition aborted'));\n\t    var TransitionFailed = $q.reject(new Error('transition failed'));\n\t\n\t    // Handles the case where a state which is the target of a transition is not found, and the user\n\t    // can optionally retry or defer the transition\n\t    function handleRedirect(redirect, state, params, options) {\n\t      /**\n\t       * @ngdoc event\n\t       * @name ui.router.state.$state#$stateNotFound\n\t       * @eventOf ui.router.state.$state\n\t       * @eventType broadcast on root scope\n\t       * @description\n\t       * Fired when a requested state **cannot be found** using the provided state name during transition.\n\t       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n\t       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n\t       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n\t       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n\t       *\n\t       * @param {Object} event Event object.\n\t       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n\t       * @param {State} fromState Current state object.\n\t       * @param {Object} fromParams Current state params.\n\t       *\n\t       * @example\n\t       *\n\t       * <pre>\n\t       * // somewhere, assume lazy.state has not been defined\n\t       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n\t       *\n\t       * // somewhere else\n\t       * $scope.$on('$stateNotFound',\n\t       * function(event, unfoundState, fromState, fromParams){\n\t       *     console.log(unfoundState.to); // \"lazy.state\"\n\t       *     console.log(unfoundState.toParams); // {a:1, b:2}\n\t       *     console.log(unfoundState.options); // {inherit:false} + default options\n\t       * })\n\t       * </pre>\n\t       */\n\t      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\t\n\t      if (evt.defaultPrevented) {\n\t        $urlRouter.update();\n\t        return TransitionAborted;\n\t      }\n\t\n\t      if (!evt.retry) {\n\t        return null;\n\t      }\n\t\n\t      // Allow the handler to return a promise to defer state lookup retry\n\t      if (options.$retry) {\n\t        $urlRouter.update();\n\t        return TransitionFailed;\n\t      }\n\t      var retryTransition = $state.transition = $q.when(evt.retry);\n\t\n\t      retryTransition.then(function() {\n\t        if (retryTransition !== $state.transition) return TransitionSuperseded;\n\t        redirect.options.$retry = true;\n\t        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n\t      }, function() {\n\t        return TransitionAborted;\n\t      });\n\t      $urlRouter.update();\n\t\n\t      return retryTransition;\n\t    }\n\t\n\t    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\t\n\t    $state = {\n\t      params: {},\n\t      current: root.self,\n\t      $current: root,\n\t      transition: null\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#reload\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method that force reloads the current state. All resolves are re-resolved,\n\t     * controllers reinstantiated, and events re-fired.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     $state.reload();\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n\t     * @example\n\t     * <pre>\n\t     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n\t     * //and current state is 'contacts.detail.item'\n\t     * var app angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.reload = function(){\n\t     *     //will reload 'contact.detail' and 'contact.detail.item' states\n\t     *     $state.reload('contact.detail');\n\t     *   }\n\t     * });\n\t     * </pre>\n\t     *\n\t     * `reload()` is just an alias for:\n\t     * <pre>\n\t     * $state.transitionTo($state.current, $stateParams, { \n\t     *   reload: true, inherit: false, notify: true\n\t     * });\n\t     * </pre>\n\t\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.reload = function reload(state) {\n\t      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#go\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Convenience method for transitioning to a new state. `$state.go` calls \n\t     * `$state.transitionTo` internally but automatically sets options to \n\t     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n\t     * This allows you to easily use an absolute or relative to path and specify \n\t     * only the parameters you'd like to update (while letting unspecified parameters \n\t     * inherit from the currently active ancestor states).\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.go('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n\t     *\n\t     * @param {string} to Absolute state name or relative state path. Some examples:\n\t     *\n\t     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n\t     * - `$state.go('^')` - will go to a parent state\n\t     * - `$state.go('^.sibling')` - will go to a sibling state\n\t     * - `$state.go('.child.grandchild')` - will go to grandchild state\n\t     *\n\t     * @param {object=} params A map of the parameters that will be sent to the state, \n\t     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n\t     * defined parameters. Only parameters specified in the state definition can be overridden, new \n\t     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n\t     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n\t     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n\t     * will get you all current parameters, etc.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n\t     *    have changed.  It will reload the resolves and views of the current state and parent states.\n\t     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n\t     *    the transition reloads the resolves and views for that matched state, and all its children states.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition.\n\t     *\n\t     * Possible success values:\n\t     *\n\t     * - $state.current\n\t     *\n\t     * <br/>Possible rejection values:\n\t     *\n\t     * - 'transition superseded' - when a newer transition has been started after this one\n\t     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n\t     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n\t     *   when a `$stateNotFound` `event.retry` promise errors.\n\t     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n\t     * - *resolve error* - when an error has occurred with a `resolve`\n\t     *\n\t     */\n\t    $state.go = function go(to, params, options) {\n\t      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#transitionTo\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n\t     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * var app = angular.module('app', ['ui.router']);\n\t     *\n\t     * app.controller('ctrl', function ($scope, $state) {\n\t     *   $scope.changeState = function () {\n\t     *     $state.transitionTo('contact.detail');\n\t     *   };\n\t     * });\n\t     * </pre>\n\t     *\n\t     * @param {string} to State name.\n\t     * @param {object=} toParams A map of the parameters that will be sent to the state,\n\t     * will populate $stateParams.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n\t     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n\t     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n\t     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n\t     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n\t     *    use this when you want to force a reload when *everything* is the same, including search params.\n\t     *    if String, then will reload the state with the name given in reload, and any children.\n\t     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n\t     *\n\t     * @returns {promise} A promise representing the state of the new transition. See\n\t     * {@link ui.router.state.$state#methods_go $state.go}.\n\t     */\n\t    $state.transitionTo = function transitionTo(to, toParams, options) {\n\t      toParams = toParams || {};\n\t      options = extend({\n\t        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n\t      }, options || {});\n\t\n\t      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n\t      var evt, toState = findState(to, options.relative);\n\t\n\t      // Store the hash param for later (since it will be stripped out by various methods)\n\t      var hash = toParams['#'];\n\t\n\t      if (!isDefined(toState)) {\n\t        var redirect = { to: to, toParams: toParams, options: options };\n\t        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\t\n\t        if (redirectResult) {\n\t          return redirectResult;\n\t        }\n\t\n\t        // Always retry once if the $stateNotFound was not prevented\n\t        // (handles either redirect changed or state lazy-definition)\n\t        to = redirect.to;\n\t        toParams = redirect.toParams;\n\t        options = redirect.options;\n\t        toState = findState(to, options.relative);\n\t\n\t        if (!isDefined(toState)) {\n\t          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n\t          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n\t        }\n\t      }\n\t      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n\t      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n\t      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\t\n\t      toParams = toState.params.$$values(toParams);\n\t      to = toState;\n\t\n\t      var toPath = to.path;\n\t\n\t      // Starting from the root of the path, keep all levels that haven't changed\n\t      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\t\n\t      if (!options.reload) {\n\t        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      } else if (isString(options.reload) || isObject(options.reload)) {\n\t        if (isObject(options.reload) && !options.reload.name) {\n\t          throw new Error('Invalid reload state object');\n\t        }\n\t        \n\t        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n\t        if (options.reload && !reloadState) {\n\t          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n\t        }\n\t\n\t        while (state && state === fromPath[keep] && state !== reloadState) {\n\t          locals = toLocals[keep] = state.locals;\n\t          keep++;\n\t          state = toPath[keep];\n\t        }\n\t      }\n\t\n\t      // If we're going to the same state and all locals are kept, we've got nothing to do.\n\t      // But clear 'transition', as we still want to cancel any other pending transitions.\n\t      // TODO: We may not want to bump 'transition' if we're called from a location change\n\t      // that we've initiated ourselves, because we might accidentally abort a legitimate\n\t      // transition initiated from code?\n\t      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n\t        if (hash) toParams['#'] = hash;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n\t        if (options.location && to.navigable && to.navigable.url) {\n\t          $urlRouter.push(to.navigable.url, toParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t          $urlRouter.update(true);\n\t        }\n\t        $state.transition = null;\n\t        return $q.when($state.current);\n\t      }\n\t\n\t      // Filter parameters before we pass them to event handlers etc.\n\t      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n\t      \n\t      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n\t      if (hash) toParams['#'] = hash;\n\t      \n\t      // Broadcast start event and cancel the transition if requested\n\t      if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeStart\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n\t         * to prevent the transition from happening and then the transition promise will be\n\t         * rejected with a `'transition prevented'` value.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         *\n\t         * @example\n\t         *\n\t         * <pre>\n\t         * $rootScope.$on('$stateChangeStart',\n\t         * function(event, toState, toParams, fromState, fromParams){\n\t         *     event.preventDefault();\n\t         *     // transitionTo() promise will be rejected with\n\t         *     // a 'transition prevented' error\n\t         * })\n\t         * </pre>\n\t         */\n\t        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n\t          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n\t          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n\t          if ($state.transition == null) $urlRouter.update();\n\t          return TransitionPrevented;\n\t        }\n\t      }\n\t\n\t      // Resolve locals for the remaining states, but don't update any global state just\n\t      // yet -- if anything fails to resolve the current state needs to remain untouched.\n\t      // We also set up an inheritance chain for the locals here. This allows the view directive\n\t      // to quickly look up the correct definition for each view in the current state. Even\n\t      // though we create the locals object itself outside resolveState(), it is initially\n\t      // empty and gets filled asynchronously. We need to keep track of the promise for the\n\t      // (fully resolved) current locals, and pass this down the chain.\n\t      var resolved = $q.when(locals);\n\t\n\t      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n\t        locals = toLocals[l] = inherit(locals);\n\t        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n\t      }\n\t\n\t      // Once everything is resolved, we are ready to perform the actual transition\n\t      // and return a promise for the new state. We also keep track of what the\n\t      // current promise is, so that we can detect overlapping transitions and\n\t      // keep only the outcome of the last transition.\n\t      var transition = $state.transition = resolved.then(function () {\n\t        var l, entering, exiting;\n\t\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Exit 'from' states not kept\n\t        for (l = fromPath.length - 1; l >= keep; l--) {\n\t          exiting = fromPath[l];\n\t          if (exiting.self.onExit) {\n\t            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n\t          }\n\t          exiting.locals = null;\n\t        }\n\t\n\t        // Enter 'to' states not kept\n\t        for (l = keep; l < toPath.length; l++) {\n\t          entering = toPath[l];\n\t          entering.locals = toLocals[l];\n\t          if (entering.self.onEnter) {\n\t            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n\t          }\n\t        }\n\t\n\t        // Run it again, to catch any transitions in callbacks\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        // Update globals in $state\n\t        $state.$current = to;\n\t        $state.current = to.self;\n\t        $state.params = toParams;\n\t        copy($state.params, $stateParams);\n\t        $state.transition = null;\n\t\n\t        if (options.location && to.navigable) {\n\t          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n\t            $$avoidResync: true, replace: options.location === 'replace'\n\t          });\n\t        }\n\t\n\t        if (options.notify) {\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeSuccess\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired once the state transition is **complete**.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         */\n\t          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n\t        }\n\t        $urlRouter.update(true);\n\t\n\t        return $state.current;\n\t      }, function (error) {\n\t        if ($state.transition !== transition) return TransitionSuperseded;\n\t\n\t        $state.transition = null;\n\t        /**\n\t         * @ngdoc event\n\t         * @name ui.router.state.$state#$stateChangeError\n\t         * @eventOf ui.router.state.$state\n\t         * @eventType broadcast on root scope\n\t         * @description\n\t         * Fired when an **error occurs** during transition. It's important to note that if you\n\t         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n\t         * they will not throw traditionally. You must listen for this $stateChangeError event to\n\t         * catch **ALL** errors.\n\t         *\n\t         * @param {Object} event Event object.\n\t         * @param {State} toState The state being transitioned to.\n\t         * @param {Object} toParams The params supplied to the `toState`.\n\t         * @param {State} fromState The current state, pre-transition.\n\t         * @param {Object} fromParams The params supplied to the `fromState`.\n\t         * @param {Error} error The resolve error object.\n\t         */\n\t        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\t\n\t        if (!evt.defaultPrevented) {\n\t            $urlRouter.update();\n\t        }\n\t\n\t        return $q.reject(error);\n\t      });\n\t\n\t      return transition;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#is\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n\t     * but only checks for the full state name. If params is supplied then it will be\n\t     * tested for strict equality against the current active params object, so all params\n\t     * must match with none missing and no extras.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // absolute name\n\t     * $state.is('contact.details.item'); // returns true\n\t     * $state.is(contactDetailItemStateObject); // returns true\n\t     *\n\t     * // relative name (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n\t     * to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n\t     * test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it is the state.\n\t     */\n\t    $state.is = function is(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) { return undefined; }\n\t      if ($state.$current !== state) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#includes\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A method to determine if the current active state is equal to or is the child of the\n\t     * state stateName. If any params are passed then they will be tested for a match as well.\n\t     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n\t     *\n\t     * @example\n\t     * Partial and relative names\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item';\n\t     *\n\t     * // Using partial names\n\t     * $state.includes(\"contacts\"); // returns true\n\t     * $state.includes(\"contacts.details\"); // returns true\n\t     * $state.includes(\"contacts.details.item\"); // returns true\n\t     * $state.includes(\"contacts.list\"); // returns false\n\t     * $state.includes(\"about\"); // returns false\n\t     *\n\t     * // Using relative names (. and ^), typically from a template\n\t     * // E.g. from the 'contacts.details' template\n\t     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n\t     * </pre>\n\t     *\n\t     * Basic globbing patterns\n\t     * <pre>\n\t     * $state.$current.name = 'contacts.details.item.url';\n\t     *\n\t     * $state.includes(\"*.details.*.*\"); // returns true\n\t     * $state.includes(\"*.details.**\"); // returns true\n\t     * $state.includes(\"**.item.**\"); // returns true\n\t     * $state.includes(\"*.details.item.url\"); // returns true\n\t     * $state.includes(\"*.details.*.url\"); // returns true\n\t     * $state.includes(\"*.details.*\"); // returns false\n\t     * $state.includes(\"item.**\"); // returns false\n\t     * </pre>\n\t     *\n\t     * @param {string} stateOrName A partial name, relative name, or glob pattern\n\t     * to be searched for within the current state name.\n\t     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n\t     * that you'd like to test against the current active state.\n\t     * @param {object=} options An options object.  The options are:\n\t     *\n\t     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n\t     * .includes will test relative to `options.relative` state (or name).\n\t     *\n\t     * @returns {boolean} Returns true if it does include the state\n\t     */\n\t    $state.includes = function includes(stateOrName, params, options) {\n\t      options = extend({ relative: $state.$current }, options || {});\n\t      if (isString(stateOrName) && isGlob(stateOrName)) {\n\t        if (!doesStateMatchGlob(stateOrName)) {\n\t          return false;\n\t        }\n\t        stateOrName = $state.$current.name;\n\t      }\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t      if (!isDefined(state)) { return undefined; }\n\t      if (!isDefined($state.$current.includes[state.name])) { return false; }\n\t      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n\t    };\n\t\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#href\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * A url generation method that returns the compiled url for the given state populated with the given params.\n\t     *\n\t     * @example\n\t     * <pre>\n\t     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n\t     * </pre>\n\t     *\n\t     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n\t     * @param {object=} params An object of parameter values to fill the state's required parameters.\n\t     * @param {object=} options Options object. The options are:\n\t     *\n\t     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n\t     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n\t     *    ancestor with a valid url).\n\t     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n\t     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n\t     *    defines which state to be relative from.\n\t     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n\t     * \n\t     * @returns {string} compiled state url\n\t     */\n\t    $state.href = function href(stateOrName, params, options) {\n\t      options = extend({\n\t        lossy:    true,\n\t        inherit:  true,\n\t        absolute: false,\n\t        relative: $state.$current\n\t      }, options || {});\n\t\n\t      var state = findState(stateOrName, options.relative);\n\t\n\t      if (!isDefined(state)) return null;\n\t      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n\t      \n\t      var nav = (state && options.lossy) ? state.navigable : state;\n\t\n\t      if (!nav || nav.url === undefined || nav.url === null) {\n\t        return null;\n\t      }\n\t      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n\t        absolute: options.absolute\n\t      });\n\t    };\n\t\n\t    /**\n\t     * @ngdoc function\n\t     * @name ui.router.state.$state#get\n\t     * @methodOf ui.router.state.$state\n\t     *\n\t     * @description\n\t     * Returns the state configuration object for any specific state or all states.\n\t     *\n\t     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n\t     * the requested state. If not provided, returns an array of ALL state configs.\n\t     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n\t     * @returns {Object|Array} State configuration object or array of all objects.\n\t     */\n\t    $state.get = function (stateOrName, context) {\n\t      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n\t      var state = findState(stateOrName, context || $state.$current);\n\t      return (state && state.self) ? state.self : null;\n\t    };\n\t\n\t    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n\t      // Make a restricted $stateParams with only the parameters that apply to this state if\n\t      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n\t      // we also need $stateParams to be available for any $injector calls we make during the\n\t      // dependency resolution process.\n\t      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n\t      var locals = { $stateParams: $stateParams };\n\t\n\t      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n\t      // We're also including $stateParams in this; that way the parameters are restricted\n\t      // to the set that should be visible to the state, and are independent of when we update\n\t      // the global $state and $stateParams values.\n\t      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n\t      var promises = [dst.resolve.then(function (globals) {\n\t        dst.globals = globals;\n\t      })];\n\t      if (inherited) promises.push(inherited);\n\t\n\t      function resolveViews() {\n\t        var viewsPromises = [];\n\t\n\t        // Resolve template and dependencies for all views.\n\t        forEach(state.views, function (view, name) {\n\t          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n\t          injectables.$template = [ function () {\n\t            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n\t          }];\n\t\n\t          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n\t            // References to the controller (only instantiated at link time)\n\t            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n\t              var injectLocals = angular.extend({}, injectables, dst.globals);\n\t              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n\t            } else {\n\t              result.$$controller = view.controller;\n\t            }\n\t            // Provide access to the state itself for internal use\n\t            result.$$state = state;\n\t            result.$$controllerAs = view.controllerAs;\n\t            dst[name] = result;\n\t          }));\n\t        });\n\t\n\t        return $q.all(viewsPromises).then(function(){\n\t          return dst.globals;\n\t        });\n\t      }\n\t\n\t      // Wait for all the promises and then return the activation object\n\t      return $q.all(promises).then(resolveViews).then(function (values) {\n\t        return dst;\n\t      });\n\t    }\n\t\n\t    return $state;\n\t  }\n\t\n\t  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n\t    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n\t    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n\t      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n\t      function notSearchParam(key) {\n\t        return fromAndToState.params[key].location != \"search\";\n\t      }\n\t      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n\t      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n\t      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n\t      return nonQueryParamSet.$$equals(fromParams, toParams);\n\t    }\n\t\n\t    // If reload was not explicitly requested\n\t    // and we're transitioning to the same state we're already in\n\t    // and    the locals didn't change\n\t    //     or they changed in a way that doesn't merit reloading\n\t    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n\t    // Then return true.\n\t    if (!options.reload && to === from &&\n\t      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n\t      return true;\n\t    }\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .factory('$stateParams', function () { return {}; })\n\t  .provider('$state', $StateProvider);\n\t\n\t\n\t$ViewProvider.$inject = [];\n\tfunction $ViewProvider() {\n\t\n\t  this.$get = $get;\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$view\n\t   *\n\t   * @requires ui.router.util.$templateFactory\n\t   * @requires $rootScope\n\t   *\n\t   * @description\n\t   *\n\t   */\n\t  $get.$inject = ['$rootScope', '$templateFactory'];\n\t  function $get(   $rootScope,   $templateFactory) {\n\t    return {\n\t      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n\t      /**\n\t       * @ngdoc function\n\t       * @name ui.router.state.$view#load\n\t       * @methodOf ui.router.state.$view\n\t       *\n\t       * @description\n\t       *\n\t       * @param {string} name name\n\t       * @param {object} options option object.\n\t       */\n\t      load: function load(name, options) {\n\t        var result, defaults = {\n\t          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n\t        };\n\t        options = extend(defaults, options);\n\t\n\t        if (options.view) {\n\t          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n\t        }\n\t        return result;\n\t      }\n\t    };\n\t  }\n\t}\n\t\n\tangular.module('ui.router.state').provider('$view', $ViewProvider);\n\t\n\t/**\n\t * @ngdoc object\n\t * @name ui.router.state.$uiViewScrollProvider\n\t *\n\t * @description\n\t * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n\t */\n\tfunction $ViewScrollProvider() {\n\t\n\t  var useAnchorScroll = false;\n\t\n\t  /**\n\t   * @ngdoc function\n\t   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n\t   * @methodOf ui.router.state.$uiViewScrollProvider\n\t   *\n\t   * @description\n\t   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n\t   * scrolling based on the url anchor.\n\t   */\n\t  this.useAnchorScroll = function () {\n\t    useAnchorScroll = true;\n\t  };\n\t\n\t  /**\n\t   * @ngdoc object\n\t   * @name ui.router.state.$uiViewScroll\n\t   *\n\t   * @requires $anchorScroll\n\t   * @requires $timeout\n\t   *\n\t   * @description\n\t   * When called with a jqLite element, it scrolls the element into view (after a\n\t   * `$timeout` so the DOM has time to refresh).\n\t   *\n\t   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n\t   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n\t   */\n\t  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n\t    if (useAnchorScroll) {\n\t      return $anchorScroll;\n\t    }\n\t\n\t    return function ($element) {\n\t      return $timeout(function () {\n\t        $element[0].scrollIntoView();\n\t      }, 0, false);\n\t    };\n\t  }];\n\t}\n\t\n\tangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\t\n\tvar ngMajorVer = angular.version.major;\n\tvar ngMinorVer = angular.version.minor;\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-view\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $compile\n\t * @requires $controller\n\t * @requires $injector\n\t * @requires ui.router.state.$uiViewScroll\n\t * @requires $document\n\t *\n\t * @restrict ECA\n\t *\n\t * @description\n\t * The ui-view directive tells $state where to place your templates.\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states.\n\t *\n\t * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n\t * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n\t * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n\t * scroll ui-view elements into view when they are populated during a state activation.\n\t *\n\t * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n\t * will be applied to the ui-view)\n\t *\n\t * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n\t * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n\t *\n\t * @param {string=} onload Expression to evaluate whenever the view updates.\n\t * \n\t * @example\n\t * A view can be unnamed or named. \n\t * <pre>\n\t * <!-- Unnamed -->\n\t * <div ui-view></div> \n\t * \n\t * <!-- Named -->\n\t * <div ui-view=\"viewName\"></div>\n\t * </pre>\n\t *\n\t * You can only have one unnamed view within any template (or root html). If you are only using a \n\t * single view and it is unnamed then you can populate it like so:\n\t * <pre>\n\t * <div ui-view></div> \n\t * $stateProvider.state(\"home\", {\n\t *   template: \"<h1>HELLO!</h1>\"\n\t * })\n\t * </pre>\n\t * \n\t * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n\t * config property, by name, in this case an empty name:\n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * But typically you'll only use the views property if you name your view or have more than one view \n\t * in the same template. There's not really a compelling reason to name a view if its the only one, \n\t * but you could if you wanted, like so:\n\t * <pre>\n\t * <div ui-view=\"main\"></div>\n\t * </pre> \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"main\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t * \n\t * Really though, you'll use views to set up multiple views:\n\t * <pre>\n\t * <div ui-view></div>\n\t * <div ui-view=\"chart\"></div> \n\t * <div ui-view=\"data\"></div> \n\t * </pre>\n\t * \n\t * <pre>\n\t * $stateProvider.state(\"home\", {\n\t *   views: {\n\t *     \"\": {\n\t *       template: \"<h1>HELLO!</h1>\"\n\t *     },\n\t *     \"chart\": {\n\t *       template: \"<chart_thing/>\"\n\t *     },\n\t *     \"data\": {\n\t *       template: \"<data_thing/>\"\n\t *     }\n\t *   }    \n\t * })\n\t * </pre>\n\t *\n\t * Examples for `autoscroll`:\n\t *\n\t * <pre>\n\t * <!-- If autoscroll present with no expression,\n\t *      then scroll ui-view into view -->\n\t * <ui-view autoscroll/>\n\t *\n\t * <!-- If autoscroll present with valid expression,\n\t *      then scroll ui-view into view if expression evaluates to true -->\n\t * <ui-view autoscroll='true'/>\n\t * <ui-view autoscroll='false'/>\n\t * <ui-view autoscroll='scopeVariable'/>\n\t * </pre>\n\t */\n\t$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\n\tfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\t\n\t  function getService() {\n\t    return ($injector.has) ? function(service) {\n\t      return $injector.has(service) ? $injector.get(service) : null;\n\t    } : function(service) {\n\t      try {\n\t        return $injector.get(service);\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    };\n\t  }\n\t\n\t  var service = getService(),\n\t      $animator = service('$animator'),\n\t      $animate = service('$animate');\n\t\n\t  // Returns a set of DOM manipulation functions based on which Angular version\n\t  // it should use\n\t  function getRenderer(attrs, scope) {\n\t    var statics = {\n\t      enter: function (element, target, cb) { target.after(element); cb(); },\n\t      leave: function (element, cb) { element.remove(); cb(); }\n\t    };\n\t\n\t    if (!!attrs.noanimation) return statics;\n\t\n\t    function animEnabled(element) {\n\t      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n\t      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n\t      return (!!$animator);\n\t    }\n\t\n\t    // ng 1.2+\n\t    if ($animate) {\n\t      return {\n\t        enter: function(element, target, cb) {\n\t          if (!animEnabled(element)) {\n\t            statics.enter(element, target, cb);\n\t          } else if (angular.version.minor > 2) {\n\t            $animate.enter(element, null, target).then(cb);\n\t          } else {\n\t            $animate.enter(element, null, target, cb);\n\t          }\n\t        },\n\t        leave: function(element, cb) {\n\t          if (!animEnabled(element)) {\n\t            statics.leave(element, cb);\n\t          } else if (angular.version.minor > 2) {\n\t            $animate.leave(element).then(cb);\n\t          } else {\n\t            $animate.leave(element, cb);\n\t          }\n\t        }\n\t      };\n\t    }\n\t\n\t    // ng 1.1.5\n\t    if ($animator) {\n\t      var animate = $animator && $animator(scope, attrs);\n\t\n\t      return {\n\t        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n\t        leave: function(element, cb) { animate.leave(element); cb(); }\n\t      };\n\t    }\n\t\n\t    return statics;\n\t  }\n\t\n\t  var directive = {\n\t    restrict: 'ECA',\n\t    terminal: true,\n\t    priority: 400,\n\t    transclude: 'element',\n\t    compile: function (tElement, tAttrs, $transclude) {\n\t      return function (scope, $element, attrs) {\n\t        var previousEl, currentEl, currentScope, latestLocals,\n\t            onloadExp     = attrs.onload || '',\n\t            autoScrollExp = attrs.autoscroll,\n\t            renderer      = getRenderer(attrs, scope);\n\t\n\t        scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        updateView(true);\n\t\n\t        function cleanupLastView() {\n\t          var _previousEl = previousEl;\n\t          var _currentScope = currentScope;\n\t\n\t          if (_currentScope) {\n\t            _currentScope._willBeDestroyed = true;\n\t          }\n\t\n\t          function cleanOld() {\n\t            if (_previousEl) {\n\t              _previousEl.remove();\n\t            }\n\t\n\t            if (_currentScope) {\n\t              _currentScope.$destroy();\n\t            }\n\t          }\n\t\n\t          if (currentEl) {\n\t            renderer.leave(currentEl, function() {\n\t              cleanOld();\n\t              previousEl = null;\n\t            });\n\t\n\t            previousEl = currentEl;\n\t          } else {\n\t            cleanOld();\n\t            previousEl = null;\n\t          }\n\t\n\t          currentEl = null;\n\t          currentScope = null;\n\t        }\n\t\n\t        function updateView(firstTime) {\n\t          var newScope,\n\t              name            = getUiViewName(scope, attrs, $element, $interpolate),\n\t              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\t\n\t          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n\t          newScope = scope.$new();\n\t          latestLocals = $state.$current.locals[name];\n\t\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoading\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           *\n\t           * Fired once the view **begins loading**, *before* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          newScope.$emit('$viewContentLoading', name);\n\t\n\t          var clone = $transclude(newScope, function(clone) {\n\t            renderer.enter(clone, $element, function onUiViewEnter() {\n\t              if(currentScope) {\n\t                currentScope.$emit('$viewContentAnimationEnded');\n\t              }\n\t\n\t              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n\t                $uiViewScroll(clone);\n\t              }\n\t            });\n\t            cleanupLastView();\n\t          });\n\t\n\t          currentEl = clone;\n\t          currentScope = newScope;\n\t          /**\n\t           * @ngdoc event\n\t           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n\t           * @eventOf ui.router.state.directive:ui-view\n\t           * @eventType emits on ui-view directive scope\n\t           * @description\n\t           * Fired once the view is **loaded**, *after* the DOM is rendered.\n\t           *\n\t           * @param {Object} event Event object.\n\t           * @param {string} viewName Name of the view.\n\t           */\n\t          currentScope.$emit('$viewContentLoaded', name);\n\t          currentScope.$eval(onloadExp);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  return directive;\n\t}\n\t\n\t$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\n\tfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n\t  return {\n\t    restrict: 'ECA',\n\t    priority: -400,\n\t    compile: function (tElement) {\n\t      var initial = tElement.html();\n\t      return function (scope, $element, attrs) {\n\t        var current = $state.$current,\n\t            name = getUiViewName(scope, attrs, $element, $interpolate),\n\t            locals  = current && current.locals[name];\n\t\n\t        if (! locals) {\n\t          return;\n\t        }\n\t\n\t        $element.data('$uiView', { name: name, state: locals.$$state });\n\t        $element.html(locals.$template ? locals.$template : initial);\n\t\n\t        var link = $compile($element.contents());\n\t\n\t        if (locals.$$controller) {\n\t          locals.$scope = scope;\n\t          locals.$element = $element;\n\t          var controller = $controller(locals.$$controller, locals);\n\t          if (locals.$$controllerAs) {\n\t            scope[locals.$$controllerAs] = controller;\n\t          }\n\t          $element.data('$ngControllerController', controller);\n\t          $element.children().data('$ngControllerController', controller);\n\t        }\n\t\n\t        link(scope);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * Shared ui-view code for both directives:\n\t * Given scope, element, and its attributes, return the view's name\n\t */\n\tfunction getUiViewName(scope, attrs, element, $interpolate) {\n\t  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n\t  var inherited = element.inheritedData('$uiView');\n\t  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n\t}\n\t\n\tangular.module('ui.router.state').directive('uiView', $ViewDirective);\n\tangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\t\n\tfunction parseStateRef(ref, current) {\n\t  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n\t  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n\t  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n\t  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n\t  return { state: parsed[1], paramExpr: parsed[3] || null };\n\t}\n\t\n\tfunction stateContext(el) {\n\t  var stateData = el.parent().inheritedData('$uiView');\n\t\n\t  if (stateData && stateData.state && stateData.state.name) {\n\t    return stateData.state;\n\t  }\n\t}\n\t\n\tfunction getTypeInfo(el) {\n\t  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n\t  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n\t  var isForm = el[0].nodeName === \"FORM\";\n\t\n\t  return {\n\t    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n\t    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n\t    clickable: !isForm\n\t  };\n\t}\n\t\n\tfunction clickHook(el, $state, $timeout, type, current) {\n\t  return function(e) {\n\t    var button = e.which || e.button, target = current();\n\t\n\t    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n\t      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n\t      var transition = $timeout(function() {\n\t        $state.go(target.state, target.params, target.options);\n\t      });\n\t      e.preventDefault();\n\t\n\t      // if the state has no URL, ignore one preventDefault from the <a> directive.\n\t      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\t\n\t      e.preventDefault = function() {\n\t        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n\t      };\n\t    }\n\t  };\n\t}\n\t\n\tfunction defaultOpts(el, $state) {\n\t  return { relative: stateContext(el) || $state.$current, inherit: true };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires $timeout\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n\t * URL, the directive will automatically generate & update the `href` attribute via\n\t * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n\t * the link will trigger a state transition with optional parameters.\n\t *\n\t * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n\t * handled natively by the browser.\n\t *\n\t * You can also use relative state paths within ui-sref, just like the relative\n\t * paths passed to `$state.go()`. You just need to be aware that the path is relative\n\t * to the state that the link lives in, in other words the state that loaded the\n\t * template containing the link.\n\t *\n\t * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n\t * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n\t * and `reload`.\n\t *\n\t * @example\n\t * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n\t * following template:\n\t * <pre>\n\t * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n\t *     </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n\t * <pre>\n\t * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n\t *\n\t * <ul>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n\t *     </li>\n\t *     <li ng-repeat=\"contact in contacts\">\n\t *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n\t *     </li>\n\t * </ul>\n\t *\n\t * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n\t * </pre>\n\t *\n\t * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n\t */\n\t$StateRefDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n\t      var def    = { state: ref.state, href: null, params: null };\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t\n\t      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\t\n\t      var update = function(val) {\n\t        if (val) def.params = angular.copy(val);\n\t        def.href = $state.href(ref.state, def.params, def.options);\n\t\n\t        if (active) active.$$addStateInfo(ref.state, def.params);\n\t        if (def.href !== null) attrs.$set(type.attr, def.href);\n\t      };\n\t\n\t      if (ref.paramExpr) {\n\t        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n\t        def.params = angular.copy(scope.$eval(ref.paramExpr));\n\t      }\n\t      update();\n\t\n\t      if (!type.clickable) return;\n\t      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n\t    }\n\t  };\n\t}\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-state\n\t *\n\t * @requires ui.router.state.uiSref\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n\t * params and override options.\n\t *\n\t * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n\t * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n\t * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n\t */\n\t$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\n\tfunction $StateRefDynamicDirective($state, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n\t    link: function(scope, element, attrs, uiSrefActive) {\n\t      var type   = getTypeInfo(element);\n\t      var active = uiSrefActive[1] || uiSrefActive[0];\n\t      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n\t      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n\t      var def    = { state: null, params: null, options: null, href: null };\n\t\n\t      function runStateRefLink (group) {\n\t        def.state = group[0]; def.params = group[1]; def.options = group[2];\n\t        def.href = $state.href(def.state, def.params, def.options);\n\t\n\t        if (active) active.$$addStateInfo(def.state, def.params);\n\t        if (def.href) attrs.$set(type.attr, def.href);\n\t      }\n\t\n\t      scope.$watch(watch, runStateRefLink, true);\n\t      runStateRefLink(scope.$eval(watch));\n\t\n\t      if (!type.clickable) return;\n\t      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n\t    }\n\t  };\n\t}\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * A directive working alongside ui-sref to add classes to an element when the\n\t * related ui-sref directive's state is active, and removing them when it is inactive.\n\t * The primary use-case is to simplify the special appearance of navigation menus\n\t * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n\t * distinguishing it from the inactive menu items.\n\t *\n\t * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n\t * ui-sref-active found at the same level or above the ui-sref will be used.\n\t *\n\t * Will activate when the ui-sref's target state or any child state is active. If you\n\t * need to activate only when the ui-sref target state is active and *not* any of\n\t * it's children, then you will use\n\t * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n\t *\n\t * @example\n\t * Given the following template:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item\">\n\t *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t *\n\t * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n\t * the resulting HTML will appear as (note the 'active' class):\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active=\"active\" class=\"item active\">\n\t *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * The class name is interpolated **once** during the directives link time (any further changes to the\n\t * interpolated value are ignored).\n\t *\n\t * Multiple classes may be specified in a space-separated format:\n\t * <pre>\n\t * <ul>\n\t *   <li ui-sref-active='class1 class2 class3'>\n\t *     <a ui-sref=\"app.user\">link</a>\n\t *   </li>\n\t * </ul>\n\t * </pre>\n\t *\n\t * It is also possible to pass ui-sref-active an expression that evaluates\n\t * to an object hash, whose keys represent active class names and whose\n\t * values represent the respective state names/globs.\n\t * ui-sref-active will match if the current active state **includes** any of\n\t * the specified state names/globs, even the abstract ones.\n\t *\n\t * @Example\n\t * Given the following template, with \"admin\" being an abstract state:\n\t * <pre>\n\t * <div ui-sref-active=\"{'active': 'admin.*'}\">\n\t *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n\t * </div>\n\t * </pre>\n\t *\n\t * When the current state is \"admin.roles\" the \"active\" class will be applied\n\t * to both the <div> and <a> elements. It is important to note that the state\n\t * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ui.router.state.directive:ui-sref-active-eq\n\t *\n\t * @requires ui.router.state.$state\n\t * @requires ui.router.state.$stateParams\n\t * @requires $interpolate\n\t *\n\t * @restrict A\n\t *\n\t * @description\n\t * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n\t * when the exact target state used in the `ui-sref` is active; no child states.\n\t *\n\t */\n\t$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\n\tfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n\t  return  {\n\t    restrict: \"A\",\n\t    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n\t      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\t\n\t      // There probably isn't much point in $observing this\n\t      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n\t      // slight difference in logic routing\n\t      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\t\n\t      try {\n\t        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n\t      } catch (e) {\n\t        // Do nothing. uiSrefActive is not a valid expression.\n\t        // Fall back to using $interpolate below\n\t      }\n\t      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n\t      if (isObject(uiSrefActive)) {\n\t        forEach(uiSrefActive, function(stateOrName, activeClass) {\n\t          if (isString(stateOrName)) {\n\t            var ref = parseStateRef(stateOrName, $state.current.name);\n\t            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n\t          }\n\t        });\n\t      }\n\t\n\t      // Allow uiSref to communicate with uiSrefActive[Equals]\n\t      this.$$addStateInfo = function (newState, newParams) {\n\t        // we already got an explicit state provided by ui-sref-active, so we\n\t        // shadow the one that comes from ui-sref\n\t        if (isObject(uiSrefActive) && states.length > 0) {\n\t          return;\n\t        }\n\t        addState(newState, newParams, uiSrefActive);\n\t        update();\n\t      };\n\t\n\t      $scope.$on('$stateChangeSuccess', update);\n\t\n\t      function addState(stateName, stateParams, activeClass) {\n\t        var state = $state.get(stateName, stateContext($element));\n\t        var stateHash = createStateHash(stateName, stateParams);\n\t\n\t        states.push({\n\t          state: state || { name: stateName },\n\t          params: stateParams,\n\t          hash: stateHash\n\t        });\n\t\n\t        activeClasses[stateHash] = activeClass;\n\t      }\n\t\n\t      /**\n\t       * @param {string} state\n\t       * @param {Object|string} [params]\n\t       * @return {string}\n\t       */\n\t      function createStateHash(state, params) {\n\t        if (!isString(state)) {\n\t          throw new Error('state should be a string');\n\t        }\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        params = $scope.$eval(params);\n\t        if (isObject(params)) {\n\t          return state + toJson(params);\n\t        }\n\t        return state;\n\t      }\n\t\n\t      // Update route state\n\t      function update() {\n\t        for (var i = 0; i < states.length; i++) {\n\t          if (anyMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeClasses[states[i].hash]);\n\t          } else {\n\t            removeClass($element, activeClasses[states[i].hash]);\n\t          }\n\t\n\t          if (exactMatch(states[i].state, states[i].params)) {\n\t            addClass($element, activeEqClass);\n\t          } else {\n\t            removeClass($element, activeEqClass);\n\t          }\n\t        }\n\t      }\n\t\n\t      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n\t      function removeClass(el, className) { el.removeClass(className); }\n\t      function anyMatch(state, params) { return $state.includes(state.name, params); }\n\t      function exactMatch(state, params) { return $state.is(state.name, params); }\n\t\n\t      update();\n\t    }]\n\t  };\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .directive('uiSref', $StateRefDirective)\n\t  .directive('uiSrefActive', $StateRefActiveDirective)\n\t  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n\t  .directive('uiState', $StateRefDynamicDirective);\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:isState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n\t */\n\t$IsStateFilter.$inject = ['$state'];\n\tfunction $IsStateFilter($state) {\n\t  var isFilter = function (state, params) {\n\t    return $state.is(state, params);\n\t  };\n\t  isFilter.$stateful = true;\n\t  return isFilter;\n\t}\n\t\n\t/**\n\t * @ngdoc filter\n\t * @name ui.router.state.filter:includedByState\n\t *\n\t * @requires ui.router.state.$state\n\t *\n\t * @description\n\t * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n\t */\n\t$IncludedByStateFilter.$inject = ['$state'];\n\tfunction $IncludedByStateFilter($state) {\n\t  var includesFilter = function (state, params, options) {\n\t    return $state.includes(state, params, options);\n\t  };\n\t  includesFilter.$stateful = true;\n\t  return  includesFilter;\n\t}\n\t\n\tangular.module('ui.router.state')\n\t  .filter('isState', $IsStateFilter)\n\t  .filter('includedByState', $IncludedByStateFilter);\n\t})(window, window.angular);\n\n/***/ },\n\n/***/ 12:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t  'use strict';\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (root.hasOwnProperty('angular')) {\n\t    // Browser globals (root is window), we don't register it.\n\t    factory(root.angular);\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = factory(require('angular'));\n\t  }\n\t}(this , function (angular) {\n\t    'use strict';\n\t\n\t    // In cases where Angular does not get passed or angular is a truthy value\n\t    // but misses .module we can fall back to using window.\n\t    angular = (angular && angular.module ) ? angular : window.angular;\n\t\n\t    /**\n\t     * @ngdoc overview\n\t     * @name ngStorage\n\t     */\n\t\n\t    return angular.module('ngStorage', [])\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$localStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$localStorage', _storageProvider('localStorage'))\n\t\n\t    /**\n\t     * @ngdoc object\n\t     * @name ngStorage.$sessionStorage\n\t     * @requires $rootScope\n\t     * @requires $window\n\t     */\n\t\n\t    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\t\n\t    function _storageProvider(storageType) {\n\t        return function () {\n\t          var storageKeyPrefix = 'ngStorage-';\n\t\n\t          this.setKeyPrefix = function (prefix) {\n\t            if (typeof prefix !== 'string') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n\t            }\n\t            storageKeyPrefix = prefix;\n\t          };\n\t\n\t          var serializer = angular.toJson;\n\t          var deserializer = angular.fromJson;\n\t\n\t          this.setSerializer = function (s) {\n\t            if (typeof s !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n\t            }\n\t\n\t            serializer = s;\n\t          };\n\t\n\t          this.setDeserializer = function (d) {\n\t            if (typeof d !== 'function') {\n\t              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n\t            }\n\t\n\t            deserializer = d;\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.get = function (key) {\n\t            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n\t          };\n\t\n\t          // Note: This is not very elegant at all.\n\t          this.set = function (key, value) {\n\t            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n\t          };\n\t\n\t          this.$get = [\n\t              '$rootScope',\n\t              '$window',\n\t              '$log',\n\t              '$timeout',\n\t              '$document',\n\t\n\t              function(\n\t                  $rootScope,\n\t                  $window,\n\t                  $log,\n\t                  $timeout,\n\t                  $document\n\t              ){\n\t                function isStorageSupported(storageType) {\n\t\n\t                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n\t                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n\t                    // that error and allow execution to continue.\n\t\n\t                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n\t                    // when \"Block cookies\": \"Always block\" is turned on\n\t                    var supported;\n\t                    try {\n\t                        supported = $window[storageType];\n\t                    }\n\t                    catch (err) {\n\t                        supported = false;\n\t                    }\n\t\n\t                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n\t                    // is available, but trying to call .setItem throws an exception below:\n\t                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n\t                    if (supported && storageType === 'localStorage') {\n\t                        var key = '__' + Math.round(Math.random() * 1e7);\n\t\n\t                        try {\n\t                            localStorage.setItem(key, key);\n\t                            localStorage.removeItem(key);\n\t                        }\n\t                        catch (err) {\n\t                            supported = false;\n\t                        }\n\t                    }\n\t\n\t                    return supported;\n\t                }\n\t\n\t                // The magic number 10 is used which only works for some keyPrefixes...\n\t                // See https://github.com/gsklee/ngStorage/issues/137\n\t                var prefixLength = storageKeyPrefix.length;\n\t\n\t                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n\t                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n\t                    $storage = {\n\t                        $default: function(items) {\n\t                            for (var k in items) {\n\t                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n\t                            }\n\t\n\t                            $storage.$sync();\n\t                            return $storage;\n\t                        },\n\t                        $reset: function(items) {\n\t                            for (var k in $storage) {\n\t                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n\t                            }\n\t\n\t                            return $storage.$default(items);\n\t                        },\n\t                        $sync: function () {\n\t                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n\t                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n\t                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n\t                            }\n\t                        },\n\t                        $apply: function() {\n\t                            var temp$storage;\n\t\n\t                            _debounce = null;\n\t\n\t                            if (!angular.equals($storage, _last$storage)) {\n\t                                temp$storage = angular.copy(_last$storage);\n\t                                angular.forEach($storage, function(v, k) {\n\t                                    if (angular.isDefined(v) && '$' !== k[0]) {\n\t                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n\t                                        delete temp$storage[k];\n\t                                    }\n\t                                });\n\t\n\t                                for (var k in temp$storage) {\n\t                                    webStorage.removeItem(storageKeyPrefix + k);\n\t                                }\n\t\n\t                                _last$storage = angular.copy($storage);\n\t                            }\n\t                        }\n\t                    },\n\t                    _last$storage,\n\t                    _debounce;\n\t\n\t                $storage.$sync();\n\t\n\t                _last$storage = angular.copy($storage);\n\t\n\t                $rootScope.$watch(function() {\n\t                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n\t                });\n\t\n\t                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n\t                $window.addEventListener && $window.addEventListener('storage', function(event) {\n\t                    if (!event.key) {\n\t                      return;\n\t                    }\n\t\n\t                    // Reference doc.\n\t                    var doc = $document[0];\n\t\n\t                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n\t                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\t\n\t                        _last$storage = angular.copy($storage);\n\t\n\t                        $rootScope.$apply();\n\t                    }\n\t                });\n\t\n\t                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n\t                    $storage.$apply();\n\t                });\n\t\n\t                return $storage;\n\t              }\n\t          ];\n\t      };\n\t    }\n\t\n\t}));\n\n\n/***/ },\n\n/***/ 13:\n/***/ function(module, exports) {\n\n\t/**\n\t * oclazyload - Load modules on demand (lazy load) with angularJS\n\t * @version v1.0.9\n\t * @link https://github.com/ocombe/ocLazyLoad\n\t * @license MIT\n\t * @author Olivier Combe <olivier.combe@gmail.com>\n\t */\n\t(function (angular, window) {\n\t    'use strict';\n\t\n\t    var regModules = ['ng', 'oc.lazyLoad'],\n\t        regInvokes = {},\n\t        regConfigs = [],\n\t        modulesToLoad = [],\n\t        // modules to load from angular.module or other sources\n\t    realModules = [],\n\t        // real modules called from angular.module\n\t    recordDeclarations = [],\n\t        broadcast = angular.noop,\n\t        runBlocks = {},\n\t        justLoaded = [];\n\t\n\t    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\t\n\t    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n\t        var modules = {},\n\t            providers = {\n\t            $controllerProvider: $controllerProvider,\n\t            $compileProvider: $compileProvider,\n\t            $filterProvider: $filterProvider,\n\t            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n\t            $injector: $injector,\n\t            $animateProvider: $animateProvider\n\t        },\n\t            debug = false,\n\t            events = false,\n\t            moduleCache = [],\n\t            modulePromises = {};\n\t\n\t        moduleCache.push = function (value) {\n\t            if (this.indexOf(value) === -1) {\n\t                Array.prototype.push.apply(this, arguments);\n\t            }\n\t        };\n\t\n\t        this.config = function (config) {\n\t            // If we want to define modules configs\n\t            if (angular.isDefined(config.modules)) {\n\t                if (angular.isArray(config.modules)) {\n\t                    angular.forEach(config.modules, function (moduleConfig) {\n\t                        modules[moduleConfig.name] = moduleConfig;\n\t                    });\n\t                } else {\n\t                    modules[config.modules.name] = config.modules;\n\t                }\n\t            }\n\t\n\t            if (angular.isDefined(config.debug)) {\n\t                debug = config.debug;\n\t            }\n\t\n\t            if (angular.isDefined(config.events)) {\n\t                events = config.events;\n\t            }\n\t        };\n\t\n\t        /**\n\t         * Get the list of existing registered modules\n\t         * @param element\n\t         */\n\t        this._init = function _init(element) {\n\t            // this is probably useless now because we override angular.bootstrap\n\t            if (modulesToLoad.length === 0) {\n\t                var elements = [element],\n\t                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n\t                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n\t                    append = function append(elm) {\n\t                    return elm && elements.push(elm);\n\t                };\n\t\n\t                angular.forEach(names, function (name) {\n\t                    names[name] = true;\n\t                    append(document.getElementById(name));\n\t                    name = name.replace(':', '\\\\:');\n\t                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n\t                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n\t                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n\t                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n\t                    }\n\t                });\n\t\n\t                angular.forEach(elements, function (elm) {\n\t                    if (modulesToLoad.length === 0) {\n\t                        var className = ' ' + element.className + ' ';\n\t                        var match = NG_APP_CLASS_REGEXP.exec(className);\n\t                        if (match) {\n\t                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n\t                        } else {\n\t                            angular.forEach(elm.attributes, function (attr) {\n\t                                if (modulesToLoad.length === 0 && names[attr.name]) {\n\t                                    modulesToLoad.push(attr.value);\n\t                                }\n\t                            });\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t\n\t            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n\t                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n\t            }\n\t\n\t            var addReg = function addReg(moduleName) {\n\t                if (regModules.indexOf(moduleName) === -1) {\n\t                    // register existing modules\n\t                    regModules.push(moduleName);\n\t                    var mainModule = angular.module(moduleName);\n\t\n\t                    // register existing components (directives, services, ...)\n\t                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n\t                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\t\n\t                    angular.forEach(mainModule.requires, addReg);\n\t                }\n\t            };\n\t\n\t            angular.forEach(modulesToLoad, function (moduleName) {\n\t                addReg(moduleName);\n\t            });\n\t\n\t            modulesToLoad = []; // reset for next bootstrap\n\t            recordDeclarations.pop(); // wait for the next lazy load\n\t        };\n\t\n\t        /**\n\t         * Like JSON.stringify but that doesn't throw on circular references\n\t         * @param obj\n\t         */\n\t        var stringify = function stringify(obj) {\n\t            try {\n\t                return JSON.stringify(obj);\n\t            } catch (e) {\n\t                var cache = [];\n\t                return JSON.stringify(obj, function (key, value) {\n\t                    if (angular.isObject(value) && value !== null) {\n\t                        if (cache.indexOf(value) !== -1) {\n\t                            // Circular reference found, discard key\n\t                            return;\n\t                        }\n\t                        // Store value in our collection\n\t                        cache.push(value);\n\t                    }\n\t                    return value;\n\t                });\n\t            }\n\t        };\n\t\n\t        var hashCode = function hashCode(str) {\n\t            var hash = 0,\n\t                i,\n\t                chr,\n\t                len;\n\t            if (str.length == 0) {\n\t                return hash;\n\t            }\n\t            for (i = 0, len = str.length; i < len; i++) {\n\t                chr = str.charCodeAt(i);\n\t                hash = (hash << 5) - hash + chr;\n\t                hash |= 0; // Convert to 32bit integer\n\t            }\n\t            return hash;\n\t        };\n\t\n\t        function _register(providers, registerModules, params) {\n\t            if (registerModules) {\n\t                var k,\n\t                    moduleName,\n\t                    moduleFn,\n\t                    tempRunBlocks = [];\n\t                for (k = registerModules.length - 1; k >= 0; k--) {\n\t                    moduleName = registerModules[k];\n\t                    if (!angular.isString(moduleName)) {\n\t                        moduleName = getModuleName(moduleName);\n\t                    }\n\t                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n\t                        continue;\n\t                    }\n\t                    // new if not registered\n\t                    var newModule = regModules.indexOf(moduleName) === -1;\n\t                    moduleFn = ngModuleFct(moduleName);\n\t                    if (newModule) {\n\t                        regModules.push(moduleName);\n\t                        _register(providers, moduleFn.requires, params);\n\t                    }\n\t                    if (moduleFn._runBlocks.length > 0) {\n\t                        // new run blocks detected! Replace the old ones (if existing)\n\t                        runBlocks[moduleName] = [];\n\t                        while (moduleFn._runBlocks.length > 0) {\n\t                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n\t                        }\n\t                    }\n\t                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n\t                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n\t                    }\n\t                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n\t                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n\t                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n\t                    registerModules.pop();\n\t                    justLoaded.push(moduleName);\n\t                }\n\t                // execute the run blocks at the end\n\t                var instanceInjector = providers.getInstanceInjector();\n\t                angular.forEach(tempRunBlocks, function (fn) {\n\t                    instanceInjector.invoke(fn);\n\t                });\n\t            }\n\t        }\n\t\n\t        function _registerInvokeList(args, moduleName) {\n\t            var invokeList = args[2][0],\n\t                type = args[1],\n\t                newInvoke = false;\n\t            if (angular.isUndefined(regInvokes[moduleName])) {\n\t                regInvokes[moduleName] = {};\n\t            }\n\t            if (angular.isUndefined(regInvokes[moduleName][type])) {\n\t                regInvokes[moduleName][type] = {};\n\t            }\n\t            var onInvoke = function onInvoke(invokeName, invoke) {\n\t                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n\t                    regInvokes[moduleName][type][invokeName] = [];\n\t                }\n\t                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n\t                    newInvoke = true;\n\t                    regInvokes[moduleName][type][invokeName].push(invoke);\n\t                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n\t                }\n\t            };\n\t\n\t            function checkHashes(potentialNew, invokes) {\n\t                var isNew = true,\n\t                    newHash;\n\t                if (invokes.length) {\n\t                    newHash = signature(potentialNew);\n\t                    angular.forEach(invokes, function (invoke) {\n\t                        isNew = isNew && signature(invoke) !== newHash;\n\t                    });\n\t                }\n\t                return isNew;\n\t            }\n\t\n\t            function signature(data) {\n\t                if (angular.isArray(data)) {\n\t                    // arrays are objects, we need to test for it first\n\t                    return hashCode(data.toString());\n\t                } else if (angular.isObject(data)) {\n\t                    // constants & values for example\n\t                    return hashCode(stringify(data));\n\t                } else {\n\t                    if (angular.isDefined(data) && data !== null) {\n\t                        return hashCode(data.toString());\n\t                    } else {\n\t                        // null & undefined constants\n\t                        return data;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (angular.isString(invokeList)) {\n\t                onInvoke(invokeList, args[2][1]);\n\t            } else if (angular.isObject(invokeList)) {\n\t                angular.forEach(invokeList, function (invoke, key) {\n\t                    if (angular.isString(invoke)) {\n\t                        // decorators for example\n\t                        onInvoke(invoke, invokeList[1]);\n\t                    } else {\n\t                        // components registered as object lists {\"componentName\": function() {}}\n\t                        onInvoke(key, invoke);\n\t                    }\n\t                });\n\t            } else {\n\t                return false;\n\t            }\n\t            return newInvoke;\n\t        }\n\t\n\t        function _invokeQueue(providers, queue, moduleName, reconfig) {\n\t            if (!queue) {\n\t                return;\n\t            }\n\t\n\t            var i, len, args, provider;\n\t            for (i = 0, len = queue.length; i < len; i++) {\n\t                args = queue[i];\n\t                if (angular.isArray(args)) {\n\t                    if (providers !== null) {\n\t                        if (providers.hasOwnProperty(args[0])) {\n\t                            provider = providers[args[0]];\n\t                        } else {\n\t                            throw new Error('unsupported provider ' + args[0]);\n\t                        }\n\t                    }\n\t                    var isNew = _registerInvokeList(args, moduleName);\n\t                    if (args[1] !== 'invoke') {\n\t                        if (isNew && angular.isDefined(provider)) {\n\t                            provider[args[1]].apply(provider, args[2]);\n\t                        }\n\t                    } else {\n\t                        // config block\n\t                        var callInvoke = function callInvoke(fct) {\n\t                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n\t                            if (invoked === -1 || reconfig) {\n\t                                if (invoked === -1) {\n\t                                    regConfigs.push(moduleName + '-' + fct);\n\t                                }\n\t                                if (angular.isDefined(provider)) {\n\t                                    provider[args[1]].apply(provider, args[2]);\n\t                                }\n\t                            }\n\t                        };\n\t                        if (angular.isFunction(args[2][0])) {\n\t                            callInvoke(args[2][0]);\n\t                        } else if (angular.isArray(args[2][0])) {\n\t                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n\t                                if (angular.isFunction(args[2][0][j])) {\n\t                                    callInvoke(args[2][0][j]);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function getModuleName(module) {\n\t            var moduleName = null;\n\t            if (angular.isString(module)) {\n\t                moduleName = module;\n\t            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n\t                moduleName = module.name;\n\t            }\n\t            return moduleName;\n\t        }\n\t\n\t        function moduleExists(moduleName) {\n\t            if (!angular.isString(moduleName)) {\n\t                return false;\n\t            }\n\t            try {\n\t                return ngModuleFct(moduleName);\n\t            } catch (e) {\n\t                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t\n\t        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n\t            var instanceInjector,\n\t                filesCache = $cacheFactory('ocLazyLoad');\n\t\n\t            if (!debug) {\n\t                $log = {};\n\t                $log['error'] = angular.noop;\n\t                $log['warn'] = angular.noop;\n\t                $log['info'] = angular.noop;\n\t            }\n\t\n\t            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n\t            providers.getInstanceInjector = function () {\n\t                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n\t            };\n\t\n\t            broadcast = function broadcast(eventName, params) {\n\t                if (events) {\n\t                    $rootScope.$broadcast(eventName, params);\n\t                }\n\t                if (debug) {\n\t                    $log.info(eventName, params);\n\t                }\n\t            };\n\t\n\t            function reject(e) {\n\t                var deferred = $q.defer();\n\t                $log.error(e.message);\n\t                deferred.reject(e);\n\t                return deferred.promise;\n\t            }\n\t\n\t            return {\n\t                _broadcast: broadcast,\n\t\n\t                _$log: $log,\n\t\n\t                /**\n\t                 * Returns the files cache used by the loaders to store the files currently loading\n\t                 * @returns {*}\n\t                 */\n\t                _getFilesCache: function getFilesCache() {\n\t                    return filesCache;\n\t                },\n\t\n\t                /**\n\t                 * Let the service know that it should monitor angular.module because files are loading\n\t                 * @param watch boolean\n\t                 */\n\t                toggleWatch: function toggleWatch(watch) {\n\t                    if (watch) {\n\t                        recordDeclarations.push(true);\n\t                    } else {\n\t                        recordDeclarations.pop();\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Let you get a module config object\n\t                 * @param moduleName String the name of the module\n\t                 * @returns {*}\n\t                 */\n\t                getModuleConfig: function getModuleConfig(moduleName) {\n\t                    if (!angular.isString(moduleName)) {\n\t                        throw new Error('You need to give the name of the module to get');\n\t                    }\n\t                    if (!modules[moduleName]) {\n\t                        return null;\n\t                    }\n\t                    return angular.copy(modules[moduleName]);\n\t                },\n\t\n\t                /**\n\t                 * Let you define a module config object\n\t                 * @param moduleConfig Object the module config object\n\t                 * @returns {*}\n\t                 */\n\t                setModuleConfig: function setModuleConfig(moduleConfig) {\n\t                    if (!angular.isObject(moduleConfig)) {\n\t                        throw new Error('You need to give the module config object to set');\n\t                    }\n\t                    modules[moduleConfig.name] = moduleConfig;\n\t                    return moduleConfig;\n\t                },\n\t\n\t                /**\n\t                 * Returns the list of loaded modules\n\t                 * @returns {string[]}\n\t                 */\n\t                getModules: function getModules() {\n\t                    return regModules;\n\t                },\n\t\n\t                /**\n\t                 * Let you check if a module has been loaded into Angular or not\n\t                 * @param modulesNames String/Object a module name, or a list of module names\n\t                 * @returns {boolean}\n\t                 */\n\t                isLoaded: function isLoaded(modulesNames) {\n\t                    var moduleLoaded = function moduleLoaded(module) {\n\t                        var isLoaded = regModules.indexOf(module) > -1;\n\t                        if (!isLoaded) {\n\t                            isLoaded = !!moduleExists(module);\n\t                        }\n\t                        return isLoaded;\n\t                    };\n\t                    if (angular.isString(modulesNames)) {\n\t                        modulesNames = [modulesNames];\n\t                    }\n\t                    if (angular.isArray(modulesNames)) {\n\t                        var i, len;\n\t                        for (i = 0, len = modulesNames.length; i < len; i++) {\n\t                            if (!moduleLoaded(modulesNames[i])) {\n\t                                return false;\n\t                            }\n\t                        }\n\t                        return true;\n\t                    } else {\n\t                        throw new Error('You need to define the module(s) name(s)');\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Given a module, return its name\n\t                 * @param module\n\t                 * @returns {String}\n\t                 */\n\t                _getModuleName: getModuleName,\n\t\n\t                /**\n\t                 * Returns a module if it exists\n\t                 * @param moduleName\n\t                 * @returns {module}\n\t                 */\n\t                _getModule: function getModule(moduleName) {\n\t                    try {\n\t                        return ngModuleFct(moduleName);\n\t                    } catch (e) {\n\t                        // this error message really suxx\n\t                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n\t                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n\t                        }\n\t                        throw e;\n\t                    }\n\t                },\n\t\n\t                /**\n\t                 * Check if a module exists and returns it if it does\n\t                 * @param moduleName\n\t                 * @returns {boolean}\n\t                 */\n\t                moduleExists: moduleExists,\n\t\n\t                /**\n\t                 * Load the dependencies, and might try to load new files depending on the config\n\t                 * @param moduleName (String or Array of Strings)\n\t                 * @param localParams\n\t                 * @returns {*}\n\t                 * @private\n\t                 */\n\t                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n\t                    var loadedModule,\n\t                        requires,\n\t                        diff,\n\t                        promisesList = [],\n\t                        self = this;\n\t\n\t                    moduleName = self._getModuleName(moduleName);\n\t\n\t                    if (moduleName === null) {\n\t                        return $q.when();\n\t                    } else {\n\t                        try {\n\t                            loadedModule = self._getModule(moduleName);\n\t                        } catch (e) {\n\t                            return reject(e);\n\t                        }\n\t                        // get unloaded requires\n\t                        requires = self.getRequires(loadedModule);\n\t                    }\n\t\n\t                    angular.forEach(requires, function (requireEntry) {\n\t                        // If no configuration is provided, try and find one from a previous load.\n\t                        // If there isn't one, bail and let the normal flow run\n\t                        if (angular.isString(requireEntry)) {\n\t                            var config = self.getModuleConfig(requireEntry);\n\t                            if (config === null) {\n\t                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n\t                                return;\n\t                            }\n\t                            requireEntry = config;\n\t                            // ignore the name because it's probably not a real module name\n\t                            config.name = undefined;\n\t                        }\n\t\n\t                        // Check if this dependency has been loaded previously\n\t                        if (self.moduleExists(requireEntry.name)) {\n\t                            // compare against the already loaded module to see if the new definition adds any new files\n\t                            diff = requireEntry.files.filter(function (n) {\n\t                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n\t                            });\n\t\n\t                            // If the module was redefined, advise via the console\n\t                            if (diff.length !== 0) {\n\t                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n\t                            }\n\t\n\t                            // Push everything to the file loader, it will weed out the duplicates.\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                            return;\n\t                        } else if (angular.isArray(requireEntry)) {\n\t                            var files = [];\n\t                            angular.forEach(requireEntry, function (entry) {\n\t                                // let's check if the entry is a file name or a config name\n\t                                var config = self.getModuleConfig(entry);\n\t                                if (config === null) {\n\t                                    files.push(entry);\n\t                                } else if (config.files) {\n\t                                    files = files.concat(config.files);\n\t                                }\n\t                            });\n\t                            if (files.length > 0) {\n\t                                requireEntry = {\n\t                                    files: files\n\t                                };\n\t                            }\n\t                        } else if (angular.isObject(requireEntry)) {\n\t                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n\t                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n\t                                self.setModuleConfig(requireEntry);\n\t                                moduleCache.push(requireEntry['name']);\n\t                            }\n\t                        }\n\t\n\t                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n\t                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n\t                            if (angular.isDefined(self.filesLoader)) {\n\t                                // if a files loader is defined\n\t                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n\t                                    return self._loadDependencies(requireEntry);\n\t                                }));\n\t                            } else {\n\t                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n\t                            }\n\t                        }\n\t                    });\n\t\n\t                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n\t                    return $q.all(promisesList);\n\t                },\n\t\n\t                /**\n\t                 * Inject new modules into Angular\n\t                 * @param moduleName\n\t                 * @param localParams\n\t                 * @param real\n\t                 */\n\t                inject: function inject(moduleName) {\n\t                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\t\n\t                    var self = this,\n\t                        deferred = $q.defer();\n\t                    if (angular.isDefined(moduleName) && moduleName !== null) {\n\t                        if (angular.isArray(moduleName)) {\n\t                            var promisesList = [];\n\t                            angular.forEach(moduleName, function (module) {\n\t                                promisesList.push(self.inject(module, localParams, real));\n\t                            });\n\t                            return $q.all(promisesList);\n\t                        } else {\n\t                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n\t                        }\n\t                    }\n\t                    if (modulesToLoad.length > 0) {\n\t                        var res = modulesToLoad.slice(); // clean copy\n\t                        var loadNext = function loadNext(moduleName) {\n\t                            moduleCache.push(moduleName);\n\t                            modulePromises[moduleName] = deferred.promise;\n\t                            self._loadDependencies(moduleName, localParams).then(function success() {\n\t                                try {\n\t                                    justLoaded = [];\n\t                                    _register(providers, moduleCache, localParams);\n\t                                } catch (e) {\n\t                                    self._$log.error(e.message);\n\t                                    deferred.reject(e);\n\t                                    return;\n\t                                }\n\t\n\t                                if (modulesToLoad.length > 0) {\n\t                                    loadNext(modulesToLoad.shift()); // load the next in list\n\t                                } else {\n\t                                        deferred.resolve(res); // everything has been loaded, resolve\n\t                                    }\n\t                            }, function error(err) {\n\t                                deferred.reject(err);\n\t                            });\n\t                        };\n\t\n\t                        // load the first in list\n\t                        loadNext(modulesToLoad.shift());\n\t                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n\t                        return modulePromises[localParams.name];\n\t                    } else {\n\t                        deferred.resolve();\n\t                    }\n\t                    return deferred.promise;\n\t                },\n\t\n\t                /**\n\t                 * Get the list of required modules/services/... for this module\n\t                 * @param module\n\t                 * @returns {Array}\n\t                 */\n\t                getRequires: function getRequires(module) {\n\t                    var requires = [];\n\t                    angular.forEach(module.requires, function (requireModule) {\n\t                        if (regModules.indexOf(requireModule) === -1) {\n\t                            requires.push(requireModule);\n\t                        }\n\t                    });\n\t                    return requires;\n\t                },\n\t\n\t                /**\n\t                 * Invoke the new modules & component by their providers\n\t                 * @param providers\n\t                 * @param queue\n\t                 * @param moduleName\n\t                 * @param reconfig\n\t                 * @private\n\t                 */\n\t                _invokeQueue: _invokeQueue,\n\t\n\t                /**\n\t                 * Check if a module has been invoked and registers it if not\n\t                 * @param args\n\t                 * @param moduleName\n\t                 * @returns {boolean} is new\n\t                 */\n\t                _registerInvokeList: _registerInvokeList,\n\t\n\t                /**\n\t                 * Register a new module and loads it, executing the run/config blocks if needed\n\t                 * @param providers\n\t                 * @param registerModules\n\t                 * @param params\n\t                 * @private\n\t                 */\n\t                _register: _register,\n\t\n\t                /**\n\t                 * Add a module name to the list of modules that will be loaded in the next inject\n\t                 * @param name\n\t                 * @param force\n\t                 * @private\n\t                 */\n\t                _addToLoadList: _addToLoadList,\n\t\n\t                /**\n\t                 * Unregister modules (you shouldn't have to use this)\n\t                 * @param modules\n\t                 */\n\t                _unregister: function _unregister(modules) {\n\t                    if (angular.isDefined(modules)) {\n\t                        if (angular.isArray(modules)) {\n\t                            angular.forEach(modules, function (module) {\n\t                                regInvokes[module] = undefined;\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            };\n\t        }];\n\t\n\t        // Let's get the list of loaded modules & components\n\t        this._init(angular.element(window.document));\n\t    }]);\n\t\n\t    var bootstrapFct = angular.bootstrap;\n\t    angular.bootstrap = function (element, modules, config) {\n\t        // we use slice to make a clean copy\n\t        angular.forEach(modules.slice(), function (module) {\n\t            _addToLoadList(module, true, true);\n\t        });\n\t        return bootstrapFct(element, modules, config);\n\t    };\n\t\n\t    var _addToLoadList = function _addToLoadList(name, force, real) {\n\t        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n\t            modulesToLoad.push(name);\n\t            if (real) {\n\t                realModules.push(name);\n\t            }\n\t        }\n\t    };\n\t\n\t    var ngModuleFct = angular.module;\n\t    angular.module = function (name, requires, configFn) {\n\t        _addToLoadList(name, false, true);\n\t        return ngModuleFct(name, requires, configFn);\n\t    };\n\t\n\t    // CommonJS package manager support:\n\t    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n\t        module.exports = 'oc.lazyLoad';\n\t    }\n\t})(angular, window);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\n\t        return {\n\t            restrict: 'A',\n\t            terminal: true,\n\t            priority: 1000,\n\t            compile: function compile(element, attrs) {\n\t                // we store the content and remove it before compilation\n\t                var content = element[0].innerHTML;\n\t                element.html('');\n\t\n\t                return function ($scope, $element, $attr) {\n\t                    var model = $parse($attr.ocLazyLoad);\n\t                    $scope.$watch(function () {\n\t                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n\t                    }, function (moduleName) {\n\t                        if (angular.isDefined(moduleName)) {\n\t                            $ocLazyLoad.load(moduleName).then(function () {\n\t                                // Attach element contents to DOM and then compile them.\n\t                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\n\t                                // of the compiled contents when attaching to the parent DOM.\n\t                                $animate.enter(content, $element);\n\t                                // get the new content & compile it\n\t                                $compile($element.contents())($scope);\n\t                            });\n\t                        }\n\t                    }, true);\n\t                };\n\t            }\n\t        };\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n\t            var uaCssChecked = false,\n\t                useCssLoadPatch = false,\n\t                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\t\n\t            /**\r\n\t             * Load a js/css file\r\n\t             * @param type\r\n\t             * @param path\r\n\t             * @param params\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.buildElement = function buildElement(type, path, params) {\n\t                var deferred = $q.defer(),\n\t                    el,\n\t                    loaded,\n\t                    filesCache = $delegate._getFilesCache(),\n\t                    cacheBuster = function cacheBuster(url) {\n\t                    var dc = new Date().getTime();\n\t                    if (url.indexOf('?') >= 0) {\n\t                        if (url.substring(0, url.length - 1) === '&') {\n\t                            return url + '_dc=' + dc;\n\t                        }\n\t                        return url + '&_dc=' + dc;\n\t                    } else {\n\t                        return url + '?_dc=' + dc;\n\t                    }\n\t                };\n\t\n\t                // Store the promise early so the file load can be detected by other parallel lazy loads\n\t                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n\t                // as it causes false positive load results.\n\t                if (angular.isUndefined(filesCache.get(path))) {\n\t                    filesCache.put(path, deferred.promise);\n\t                }\n\t\n\t                // Switch in case more content types are added later\n\t                switch (type) {\n\t                    case 'css':\n\t                        el = $window.document.createElement('link');\n\t                        el.type = 'text/css';\n\t                        el.rel = 'stylesheet';\n\t                        el.href = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    case 'js':\n\t                        el = $window.document.createElement('script');\n\t                        el.src = params.cache === false ? cacheBuster(path) : path;\n\t                        break;\n\t                    default:\n\t                        filesCache.remove(path);\n\t                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n\t                        break;\n\t                }\n\t                el.onload = el['onreadystatechange'] = function (e) {\n\t                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n\t                    el.onload = el['onreadystatechange'] = null;\n\t                    loaded = 1;\n\t                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n\t                    deferred.resolve();\n\t                };\n\t                el.onerror = function () {\n\t                    filesCache.remove(path);\n\t                    deferred.reject(new Error('Unable to load ' + path));\n\t                };\n\t                el.async = params.serie ? 0 : 1;\n\t\n\t                var insertBeforeElem = anchor.lastChild;\n\t                if (params.insertBefore) {\n\t                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n\t                    if (element && element.length > 0) {\n\t                        insertBeforeElem = element[0];\n\t                    }\n\t                }\n\t                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\t\n\t                /*\r\n\t                 The event load or readystatechange doesn't fire in:\r\n\t                 - iOS < 6       (default mobile browser)\r\n\t                 - Android < 4.4 (default mobile browser)\r\n\t                 - Safari < 6    (desktop browser)\r\n\t                 */\n\t                if (type == 'css') {\n\t                    if (!uaCssChecked) {\n\t                        var ua = $window.navigator.userAgent.toLowerCase();\n\t\n\t                        // iOS < 6\n\t                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n\t                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n\t                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n\t                            useCssLoadPatch = iOSVersion < 6;\n\t                        } else if (ua.indexOf(\"android\") > -1) {\n\t                            // Android < 4.4\n\t                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n\t                            useCssLoadPatch = androidVersion < 4.4;\n\t                        } else if (ua.indexOf('safari') > -1) {\n\t                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n\t                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n\t                        }\n\t                    }\n\t\n\t                    if (useCssLoadPatch) {\n\t                        var tries = 1000; // * 20 = 20000 miliseconds\n\t                        var interval = $interval(function () {\n\t                            try {\n\t                                el.sheet.cssRules;\n\t                                $interval.cancel(interval);\n\t                                el.onload();\n\t                            } catch (e) {\n\t                                if (--tries <= 0) {\n\t                                    el.onerror();\n\t                                }\n\t                            }\n\t                        }, 20);\n\t                    }\n\t                }\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\r\n\t             * The function that loads new files\r\n\t             * @param config\r\n\t             * @param params\r\n\t             * @returns {*}\r\n\t             */\n\t            $delegate.filesLoader = function filesLoader(config) {\n\t                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var cssFiles = [],\n\t                    templatesFiles = [],\n\t                    jsFiles = [],\n\t                    promises = [],\n\t                    cachePromise = null,\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                $delegate.toggleWatch(true); // start watching angular.module calls\n\t\n\t                angular.extend(params, config);\n\t\n\t                var pushFile = function pushFile(path) {\n\t                    var file_type = null,\n\t                        m;\n\t                    if (angular.isObject(path)) {\n\t                        file_type = path.type;\n\t                        path = path.path;\n\t                    }\n\t                    cachePromise = filesCache.get(path);\n\t                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\t\n\t                        // always check for requirejs syntax just in case\n\t                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n\t                            // Detect file type using preceding type declaration (ala requireJS)\n\t                            file_type = m[1];\n\t                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n\t                        }\n\t\n\t                        if (!file_type) {\n\t                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n\t                                // Detect file type via file extension\n\t                                file_type = m[1];\n\t                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\n\t                                // requirejs\n\t                                file_type = 'js';\n\t                            } else {\n\t                                $delegate._$log.error('File type could not be determined. ' + path);\n\t                                return;\n\t                            }\n\t                        }\n\t\n\t                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n\t                            cssFiles.push(path);\n\t                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n\t                            templatesFiles.push(path);\n\t                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n\t                            jsFiles.push(path);\n\t                        } else {\n\t                            $delegate._$log.error('File type is not valid. ' + path);\n\t                        }\n\t                    } else if (cachePromise) {\n\t                        promises.push(cachePromise);\n\t                    }\n\t                };\n\t\n\t                if (params.serie) {\n\t                    pushFile(params.files.shift());\n\t                } else {\n\t                    angular.forEach(params.files, function (path) {\n\t                        pushFile(path);\n\t                    });\n\t                }\n\t\n\t                if (cssFiles.length > 0) {\n\t                    var cssDeferred = $q.defer();\n\t                    $delegate.cssLoader(cssFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            cssDeferred.reject(err);\n\t                        } else {\n\t                            cssDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(cssDeferred.promise);\n\t                }\n\t\n\t                if (templatesFiles.length > 0) {\n\t                    var templatesDeferred = $q.defer();\n\t                    $delegate.templatesLoader(templatesFiles, function (err) {\n\t                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n\t                            $delegate._$log.error(err);\n\t                            templatesDeferred.reject(err);\n\t                        } else {\n\t                            templatesDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(templatesDeferred.promise);\n\t                }\n\t\n\t                if (jsFiles.length > 0) {\n\t                    var jsDeferred = $q.defer();\n\t                    $delegate.jsLoader(jsFiles, function (err) {\n\t                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\n\t                            $delegate._$log.error(err);\n\t                            jsDeferred.reject(err);\n\t                        } else {\n\t                            jsDeferred.resolve();\n\t                        }\n\t                    }, params);\n\t                    promises.push(jsDeferred.promise);\n\t                }\n\t\n\t                if (promises.length === 0) {\n\t                    var deferred = $q.defer(),\n\t                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n\t                    $delegate._$log.error(err);\n\t                    deferred.reject(err);\n\t                    return deferred.promise;\n\t                } else if (params.serie && params.files.length > 0) {\n\t                    return $q.all(promises).then(function () {\n\t                        return $delegate.filesLoader(config, params);\n\t                    });\n\t                } else {\n\t                    return $q.all(promises)['finally'](function (res) {\n\t                        $delegate.toggleWatch(false); // stop watching angular.module calls\n\t                        return res;\n\t                    });\n\t                }\n\t            };\n\t\n\t            /**\r\n\t             * Load a module or a list of modules into Angular\r\n\t             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n\t             * @param params Object optional parameters\r\n\t             * @returns promise\r\n\t             */\n\t            $delegate.load = function (originalModule) {\n\t                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t                var self = this,\n\t                    config = null,\n\t                    deferredList = [],\n\t                    deferred = $q.defer(),\n\t                    errText;\n\t\n\t                // clean copy\n\t                var module = angular.copy(originalModule);\n\t                var params = angular.copy(originalParams);\n\t\n\t                // If module is an array, break it down\n\t                if (angular.isArray(module)) {\n\t                    // Resubmit each entry as a single module\n\t                    angular.forEach(module, function (m) {\n\t                        deferredList.push(self.load(m, params));\n\t                    });\n\t\n\t                    // Resolve the promise once everything has loaded\n\t                    $q.all(deferredList).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t\n\t                    return deferred.promise;\n\t                }\n\t\n\t                // Get or Set a configuration depending on what was passed in\n\t                if (angular.isString(module)) {\n\t                    config = self.getModuleConfig(module);\n\t                    if (!config) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    }\n\t                } else if (angular.isObject(module)) {\n\t                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n\t                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n\t                        config = {\n\t                            files: [module]\n\t                        };\n\t                    } else {\n\t                        config = self.setModuleConfig(module);\n\t                    }\n\t                }\n\t\n\t                if (config === null) {\n\t                    var moduleName = self._getModuleName(module);\n\t                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n\t                    $delegate._$log.error(errText);\n\t                    deferred.reject(new Error(errText));\n\t                    return deferred.promise;\n\t                } else {\n\t                    // deprecated\n\t                    if (angular.isDefined(config.template)) {\n\t                        if (angular.isUndefined(config.files)) {\n\t                            config.files = [];\n\t                        }\n\t                        if (angular.isString(config.template)) {\n\t                            config.files.push(config.template);\n\t                        } else if (angular.isArray(config.template)) {\n\t                            config.files.concat(config.template);\n\t                        }\n\t                    }\n\t                }\n\t\n\t                var localParams = angular.extend({}, params, config);\n\t\n\t                // if someone used an external loader and called the load function with just the module name\n\t                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n\t                    return $delegate.inject(config.name, localParams, true);\n\t                }\n\t\n\t                $delegate.filesLoader(config, localParams).then(function () {\n\t                    $delegate.inject(null, localParams).then(function (res) {\n\t                        deferred.resolve(res);\n\t                    }, function (err) {\n\t                        deferred.reject(err);\n\t                    });\n\t                }, function (err) {\n\t                    deferred.reject(err);\n\t                });\n\t\n\t                return deferred.promise;\n\t            };\n\t\n\t            // return the patched service\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * cssLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite cssLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.cssLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('css', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.cssLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n\t            /**\n\t             * jsLoader function\n\t             * @type Function\n\t             * @param paths array list of js files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters\n\t             * because the user can overwrite jsLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.jsLoader = function (paths, callback, params) {\n\t                var promises = [];\n\t                angular.forEach(paths, function (path) {\n\t                    promises.push($delegate.buildElement('js', path, params));\n\t                });\n\t                $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.jsLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t(function (angular) {\n\t    'use strict';\n\t\n\t    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n\t        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n\t            /**\n\t             * templatesLoader function\n\t             * @type Function\n\t             * @param paths array list of css files to load\n\t             * @param callback to call when everything is loaded. We use a callback and not a promise\n\t             * @param params object config parameters for $http\n\t             * because the user can overwrite templatesLoader and it will probably not use promises :(\n\t             */\n\t            $delegate.templatesLoader = function (paths, callback, params) {\n\t                var promises = [],\n\t                    filesCache = $delegate._getFilesCache();\n\t\n\t                angular.forEach(paths, function (url) {\n\t                    var deferred = $q.defer();\n\t                    promises.push(deferred.promise);\n\t                    $http.get(url, params).success(function (data) {\n\t                        if (angular.isString(data) && data.length > 0) {\n\t                            angular.forEach(angular.element(data), function (node) {\n\t                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n\t                                    $templateCache.put(node.id, node.innerHTML);\n\t                                }\n\t                            });\n\t                        }\n\t                        if (angular.isUndefined(filesCache.get(url))) {\n\t                            filesCache.put(url, true);\n\t                        }\n\t                        deferred.resolve();\n\t                    }).error(function (err) {\n\t                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n\t                    });\n\t                });\n\t                return $q.all(promises).then(function () {\n\t                    callback();\n\t                }, function (err) {\n\t                    callback(err);\n\t                });\n\t            };\n\t            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\t\n\t            return $delegate;\n\t        }]);\n\t    }]);\n\t})(angular);\n\t// Array.indexOf polyfill for IE8\n\tif (!Array.prototype.indexOf) {\n\t    Array.prototype.indexOf = function (searchElement, fromIndex) {\n\t        var k;\n\t\n\t        // 1. Let O be the result of calling ToObject passing\n\t        //    the this value as the argument.\n\t        if (this == null) {\n\t            throw new TypeError('\"this\" is null or not defined');\n\t        }\n\t\n\t        var O = Object(this);\n\t\n\t        // 2. Let lenValue be the result of calling the Get\n\t        //    internal method of O with the argument \"length\".\n\t        // 3. Let len be ToUint32(lenValue).\n\t        var len = O.length >>> 0;\n\t\n\t        // 4. If len is 0, return -1.\n\t        if (len === 0) {\n\t            return -1;\n\t        }\n\t\n\t        // 5. If argument fromIndex was passed let n be\n\t        //    ToInteger(fromIndex); else let n be 0.\n\t        var n = +fromIndex || 0;\n\t\n\t        if (Math.abs(n) === Infinity) {\n\t            n = 0;\n\t        }\n\t\n\t        // 6. If n >= len, return -1.\n\t        if (n >= len) {\n\t            return -1;\n\t        }\n\t\n\t        // 7. If n >= 0, then Let k be n.\n\t        // 8. Else, n<0, Let k be len - abs(n).\n\t        //    If k is less than 0, then let k be 0.\n\t        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\t\n\t        // 9. Repeat, while k < len\n\t        while (k < len) {\n\t            // a. Let Pk be ToString(k).\n\t            //   This is implicit for LHS operands of the in operator\n\t            // b. Let kPresent be the result of calling the\n\t            //    HasProperty internal method of O with argument Pk.\n\t            //   This step can be combined with c\n\t            // c. If kPresent is true, then\n\t            //    i.  Let elementK be the result of calling the Get\n\t            //        internal method of O with the argument ToString(k).\n\t            //   ii.  Let same be the result of applying the\n\t            //        Strict Equality Comparison Algorithm to\n\t            //        searchElement and elementK.\n\t            //  iii.  If same is true, return k.\n\t            if (k in O && O[k] === searchElement) {\n\t                return k;\n\t            }\n\t            k++;\n\t        }\n\t        return -1;\n\t    };\n\t}\n\n/***/ },\n\n/***/ 14:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.0.0 by @mathias */\n\t;(function(root) {\n\t\n\t\t// Detect free variables `exports`\n\t\tvar freeExports = typeof exports == 'object' && exports;\n\t\n\t\t// Detect free variable `module`\n\t\tvar freeModule = typeof module == 'object' && module &&\n\t\t\tmodule.exports == freeExports && module;\n\t\n\t\t// Detect free variable `global`, from Node.js or Browserified code,\n\t\t// and use it as `root`\n\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\t\troot = freeGlobal;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\n\t\t// Taken from https://mths.be/punycode\n\t\tfunction ucs2decode(string) {\n\t\t\tvar output = [];\n\t\t\tvar counter = 0;\n\t\t\tvar length = string.length;\n\t\t\tvar value;\n\t\t\tvar extra;\n\t\t\twhile (counter < length) {\n\t\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\t\toutput.push(value);\n\t\t\t\t\t\tcounter--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\t// Taken from https://mths.be/punycode\n\t\tfunction ucs2encode(array) {\n\t\t\tvar length = array.length;\n\t\t\tvar index = -1;\n\t\t\tvar value;\n\t\t\tvar output = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvalue = array[index];\n\t\t\t\tif (value > 0xFFFF) {\n\t\t\t\t\tvalue -= 0x10000;\n\t\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t\t}\n\t\t\t\toutput += stringFromCharCode(value);\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\tfunction checkScalarValue(codePoint) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t\t' is not a scalar value'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tfunction createByte(codePoint, shift) {\n\t\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t\t}\n\t\n\t\tfunction encodeCodePoint(codePoint) {\n\t\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\t\treturn stringFromCharCode(codePoint);\n\t\t\t}\n\t\t\tvar symbol = '';\n\t\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t\t}\n\t\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\t\tsymbol += createByte(codePoint, 6);\n\t\t\t}\n\t\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\t\tsymbol += createByte(codePoint, 6);\n\t\t\t}\n\t\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\t\treturn symbol;\n\t\t}\n\t\n\t\tfunction utf8encode(string) {\n\t\t\tvar codePoints = ucs2decode(string);\n\t\t\tvar length = codePoints.length;\n\t\t\tvar index = -1;\n\t\t\tvar codePoint;\n\t\t\tvar byteString = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tcodePoint = codePoints[index];\n\t\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t\t}\n\t\t\treturn byteString;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tfunction readContinuationByte() {\n\t\t\tif (byteIndex >= byteCount) {\n\t\t\t\tthrow Error('Invalid byte index');\n\t\t\t}\n\t\n\t\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\t\tbyteIndex++;\n\t\n\t\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\t\treturn continuationByte & 0x3F;\n\t\t\t}\n\t\n\t\t\t// If we end up here, it’s not a continuation byte\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t\n\t\tfunction decodeSymbol() {\n\t\t\tvar byte1;\n\t\t\tvar byte2;\n\t\t\tvar byte3;\n\t\t\tvar byte4;\n\t\t\tvar codePoint;\n\t\n\t\t\tif (byteIndex > byteCount) {\n\t\t\t\tthrow Error('Invalid byte index');\n\t\t\t}\n\t\n\t\t\tif (byteIndex == byteCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\t// Read first byte\n\t\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\t\tbyteIndex++;\n\t\n\t\t\t// 1-byte sequence (no continuation bytes)\n\t\t\tif ((byte1 & 0x80) == 0) {\n\t\t\t\treturn byte1;\n\t\t\t}\n\t\n\t\t\t// 2-byte sequence\n\t\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\t\tvar byte2 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\t\tif (codePoint >= 0x80) {\n\t\t\t\t\treturn codePoint;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\t\tbyte2 = readContinuationByte();\n\t\t\t\tbyte3 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\t\treturn codePoint;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// 4-byte sequence\n\t\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\t\tbyte2 = readContinuationByte();\n\t\t\t\tbyte3 = readContinuationByte();\n\t\t\t\tbyte4 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\t\treturn codePoint;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthrow Error('Invalid UTF-8 detected');\n\t\t}\n\t\n\t\tvar byteArray;\n\t\tvar byteCount;\n\t\tvar byteIndex;\n\t\tfunction utf8decode(byteString) {\n\t\t\tbyteArray = ucs2decode(byteString);\n\t\t\tbyteCount = byteArray.length;\n\t\t\tbyteIndex = 0;\n\t\t\tvar codePoints = [];\n\t\t\tvar tmp;\n\t\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\t\tcodePoints.push(tmp);\n\t\t\t}\n\t\t\treturn ucs2encode(codePoints);\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tvar utf8 = {\n\t\t\t'version': '2.0.0',\n\t\t\t'encode': utf8encode,\n\t\t\t'decode': utf8decode\n\t\t};\n\t\n\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t// like the following:\n\t\tif (\n\t\t\ttrue\n\t\t) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn utf8;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\t\tfreeModule.exports = utf8;\n\t\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\t\tvar object = {};\n\t\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\t\tfor (var key in utf8) {\n\t\t\t\t\thasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // in Rhino or a web browser\n\t\t\troot.utf8 = utf8;\n\t\t}\n\t\n\t}(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(134)(module), (function() { return this; }())))\n\n/***/ },\n\n/***/ 15:\n/***/ function(module, exports) {\n\n\t'use strict';\n\tangular.module(\"ngLocale\", [], [\"$provide\", function($provide) {\n\tvar PLURAL_CATEGORY = {ZERO: \"zero\", ONE: \"one\", TWO: \"two\", FEW: \"few\", MANY: \"many\", OTHER: \"other\"};\n\tfunction getDecimals(n) {\n\t  n = n + '';\n\t  var i = n.indexOf('.');\n\t  return (i == -1) ? 0 : n.length - i - 1;\n\t}\n\t\n\tfunction getVF(n, opt_precision) {\n\t  var v = opt_precision;\n\t\n\t  if (undefined === v) {\n\t    v = Math.min(getDecimals(n), 3);\n\t  }\n\t\n\t  var base = Math.pow(10, v);\n\t  var f = ((n * base) | 0) % base;\n\t  return {v: v, f: f};\n\t}\n\t\n\t$provide.value(\"$locale\", {\n\t  \"DATETIME_FORMATS\": {\n\t    \"AMPMS\": [\n\t      \"vorm.\",\n\t      \"nachm.\"\n\t    ],\n\t    \"DAY\": [\n\t      \"Sonntag\",\n\t      \"Montag\",\n\t      \"Dienstag\",\n\t      \"Mittwoch\",\n\t      \"Donnerstag\",\n\t      \"Freitag\",\n\t      \"Samstag\"\n\t    ],\n\t    \"ERANAMES\": [\n\t      \"v. Chr.\",\n\t      \"n. Chr.\"\n\t    ],\n\t    \"ERAS\": [\n\t      \"v. Chr.\",\n\t      \"n. Chr.\"\n\t    ],\n\t    \"FIRSTDAYOFWEEK\": 0,\n\t    \"MONTH\": [\n\t      \"Januar\",\n\t      \"Februar\",\n\t      \"M\\u00e4rz\",\n\t      \"April\",\n\t      \"Mai\",\n\t      \"Juni\",\n\t      \"Juli\",\n\t      \"August\",\n\t      \"September\",\n\t      \"Oktober\",\n\t      \"November\",\n\t      \"Dezember\"\n\t    ],\n\t    \"SHORTDAY\": [\n\t      \"So.\",\n\t      \"Mo.\",\n\t      \"Di.\",\n\t      \"Mi.\",\n\t      \"Do.\",\n\t      \"Fr.\",\n\t      \"Sa.\"\n\t    ],\n\t    \"SHORTMONTH\": [\n\t      \"Jan.\",\n\t      \"Feb.\",\n\t      \"M\\u00e4rz\",\n\t      \"Apr.\",\n\t      \"Mai\",\n\t      \"Juni\",\n\t      \"Juli\",\n\t      \"Aug.\",\n\t      \"Sep.\",\n\t      \"Okt.\",\n\t      \"Nov.\",\n\t      \"Dez.\"\n\t    ],\n\t    \"STANDALONEMONTH\": [\n\t      \"Januar\",\n\t      \"Februar\",\n\t      \"M\\u00e4rz\",\n\t      \"April\",\n\t      \"Mai\",\n\t      \"Juni\",\n\t      \"Juli\",\n\t      \"August\",\n\t      \"September\",\n\t      \"Oktober\",\n\t      \"November\",\n\t      \"Dezember\"\n\t    ],\n\t    \"WEEKENDRANGE\": [\n\t      5,\n\t      6\n\t    ],\n\t    \"fullDate\": \"EEEE, d. MMMM y\",\n\t    \"longDate\": \"d. MMMM y\",\n\t    \"medium\": \"dd.MM.y HH:mm:ss\",\n\t    \"mediumDate\": \"dd.MM.y\",\n\t    \"mediumTime\": \"HH:mm:ss\",\n\t    \"short\": \"dd.MM.yy HH:mm\",\n\t    \"shortDate\": \"dd.MM.yy\",\n\t    \"shortTime\": \"HH:mm\"\n\t  },\n\t  \"NUMBER_FORMATS\": {\n\t    \"CURRENCY_SYM\": \"\\u20ac\",\n\t    \"DECIMAL_SEP\": \",\",\n\t    \"GROUP_SEP\": \".\",\n\t    \"PATTERNS\": [\n\t      {\n\t        \"gSize\": 3,\n\t        \"lgSize\": 3,\n\t        \"maxFrac\": 3,\n\t        \"minFrac\": 0,\n\t        \"minInt\": 1,\n\t        \"negPre\": \"-\",\n\t        \"negSuf\": \"\",\n\t        \"posPre\": \"\",\n\t        \"posSuf\": \"\"\n\t      },\n\t      {\n\t        \"gSize\": 3,\n\t        \"lgSize\": 3,\n\t        \"maxFrac\": 2,\n\t        \"minFrac\": 2,\n\t        \"minInt\": 1,\n\t        \"negPre\": \"-\",\n\t        \"negSuf\": \"\\u00a0\\u00a4\",\n\t        \"posPre\": \"\",\n\t        \"posSuf\": \"\\u00a0\\u00a4\"\n\t      }\n\t    ]\n\t  },\n\t  \"id\": \"de-de\",\n\t  \"pluralCat\": function(n, opt_precision) {  var i = n | 0;  var vf = getVF(n, opt_precision);  if (i == 1 && vf.v == 0) {    return PLURAL_CATEGORY.ONE;  }  return PLURAL_CATEGORY.OTHER;}\n\t});\n\t}]);\n\n\n/***/ },\n\n/***/ 16:\n/***/ function(module, exports) {\n\n\t/*\n\t * angular-ui-bootstrap\n\t * http://angular-ui.github.io/bootstrap/\n\t\n\t * Version: 1.2.1 - 2016-02-27\n\t * License: MIT\n\t */angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.debounce\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\n\tangular.module(\"ui.bootstrap.tpls\", [\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/popup.html\",\"uib/template/datepicker/year.html\",\"uib/template/modal/backdrop.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]);\n\tangular.module('ui.bootstrap.collapse', [])\n\t\n\t  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {\n\t    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n\t    return {\n\t      link: function(scope, element, attrs) {\n\t        var expandingExpr = $parse(attrs.expanding),\n\t            expandedExpr = $parse(attrs.expanded),\n\t            collapsingExpr = $parse(attrs.collapsing),\n\t            collapsedExpr = $parse(attrs.collapsed);\n\t\n\t        if (!scope.$eval(attrs.uibCollapse)) {\n\t          element.addClass('in')\n\t            .addClass('collapse')\n\t            .attr('aria-expanded', true)\n\t            .attr('aria-hidden', false)\n\t            .css({height: 'auto'});\n\t        }\n\t\n\t        function expand() {\n\t          if (element.hasClass('collapse') && element.hasClass('in')) {\n\t            return;\n\t          }\n\t\n\t          $q.resolve(expandingExpr(scope))\n\t            .then(function() {\n\t              element.removeClass('collapse')\n\t                .addClass('collapsing')\n\t                .attr('aria-expanded', true)\n\t                .attr('aria-hidden', false);\n\t\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  addClass: 'in',\n\t                  easing: 'ease',\n\t                  to: { height: element[0].scrollHeight + 'px' }\n\t                }).start()['finally'](expandDone);\n\t              } else {\n\t                $animate.addClass(element, 'in', {\n\t                  to: { height: element[0].scrollHeight + 'px' }\n\t                }).then(expandDone);\n\t              }\n\t            });\n\t        }\n\t\n\t        function expandDone() {\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse')\n\t            .css({height: 'auto'});\n\t          expandedExpr(scope);\n\t        }\n\t\n\t        function collapse() {\n\t          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n\t            return collapseDone();\n\t          }\n\t\n\t          $q.resolve(collapsingExpr(scope))\n\t            .then(function() {\n\t              element\n\t                // IMPORTANT: The height must be set before adding \"collapsing\" class.\n\t                // Otherwise, the browser attempts to animate from height 0 (in\n\t                // collapsing class) to the given height here.\n\t                .css({height: element[0].scrollHeight + 'px'})\n\t                // initially all panel collapse have the collapse class, this removal\n\t                // prevents the animation from jumping to collapsed state\n\t                .removeClass('collapse')\n\t                .addClass('collapsing')\n\t                .attr('aria-expanded', false)\n\t                .attr('aria-hidden', true);\n\t\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  removeClass: 'in',\n\t                  to: {height: '0'}\n\t                }).start()['finally'](collapseDone);\n\t              } else {\n\t                $animate.removeClass(element, 'in', {\n\t                  to: {height: '0'}\n\t                }).then(collapseDone);\n\t              }\n\t            });\n\t        }\n\t\n\t        function collapseDone() {\n\t          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n\t          element.removeClass('collapsing')\n\t            .addClass('collapse');\n\t          collapsedExpr(scope);\n\t        }\n\t\n\t        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n\t          if (shouldCollapse) {\n\t            collapse();\n\t          } else {\n\t            expand();\n\t          }\n\t        });\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\t\n\t.constant('uibAccordionConfig', {\n\t  closeOthers: true\n\t})\n\t\n\t.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n\t  // This array keeps track of the accordion groups\n\t  this.groups = [];\n\t\n\t  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n\t  this.closeOthers = function(openGroup) {\n\t    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n\t      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n\t    if (closeOthers) {\n\t      angular.forEach(this.groups, function(group) {\n\t        if (group !== openGroup) {\n\t          group.isOpen = false;\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  // This is called from the accordion-group directive to add itself to the accordion\n\t  this.addGroup = function(groupScope) {\n\t    var that = this;\n\t    this.groups.push(groupScope);\n\t\n\t    groupScope.$on('$destroy', function(event) {\n\t      that.removeGroup(groupScope);\n\t    });\n\t  };\n\t\n\t  // This is called from the accordion-group directive when to remove itself\n\t  this.removeGroup = function(group) {\n\t    var index = this.groups.indexOf(group);\n\t    if (index !== -1) {\n\t      this.groups.splice(index, 1);\n\t    }\n\t  };\n\t}])\n\t\n\t// The accordion directive simply sets up the directive controller\n\t// and adds an accordion CSS class to itself element.\n\t.directive('uibAccordion', function() {\n\t  return {\n\t    controller: 'UibAccordionController',\n\t    controllerAs: 'accordion',\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/accordion/accordion.html';\n\t    }\n\t  };\n\t})\n\t\n\t// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n\t.directive('uibAccordionGroup', function() {\n\t  return {\n\t    require: '^uibAccordion',         // We need this directive to be inside an accordion\n\t    transclude: true,              // It transcludes the contents of the directive into the template\n\t    replace: true,                // The element containing the directive will be replaced with the template\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';\n\t    },\n\t    scope: {\n\t      heading: '@',               // Interpolate the heading attribute onto this scope\n\t      isOpen: '=?',\n\t      isDisabled: '=?'\n\t    },\n\t    controller: function() {\n\t      this.setHeading = function(element) {\n\t        this.heading = element;\n\t      };\n\t    },\n\t    link: function(scope, element, attrs, accordionCtrl) {\n\t      accordionCtrl.addGroup(scope);\n\t\n\t      scope.openClass = attrs.openClass || 'panel-open';\n\t      scope.panelClass = attrs.panelClass || 'panel-default';\n\t      scope.$watch('isOpen', function(value) {\n\t        element.toggleClass(scope.openClass, !!value);\n\t        if (value) {\n\t          accordionCtrl.closeOthers(scope);\n\t        }\n\t      });\n\t\n\t      scope.toggleOpen = function($event) {\n\t        if (!scope.isDisabled) {\n\t          if (!$event || $event.which === 32) {\n\t            scope.isOpen = !scope.isOpen;\n\t          }\n\t        }\n\t      };\n\t\n\t      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t      scope.headingId = id + '-tab';\n\t      scope.panelId = id + '-panel';\n\t    }\n\t  };\n\t})\n\t\n\t// Use accordion-heading below an accordion-group to provide a heading containing HTML\n\t.directive('uibAccordionHeading', function() {\n\t  return {\n\t    transclude: true,   // Grab the contents to be used as the heading\n\t    template: '',       // In effect remove this element!\n\t    replace: true,\n\t    require: '^uibAccordionGroup',\n\t    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n\t      // Pass the heading to the accordion-group controller\n\t      // so that it can be transcluded into the right place in the template\n\t      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n\t      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n\t    }\n\t  };\n\t})\n\t\n\t// Use in the accordion-group template to indicate where you want the heading to be transcluded\n\t// You must provide the property on the accordion-group controller that will hold the transcluded element\n\t.directive('uibAccordionTransclude', function() {\n\t  return {\n\t    require: '^uibAccordionGroup',\n\t    link: function(scope, element, attrs, controller) {\n\t      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n\t        if (heading) {\n\t          var elem = angular.element(element[0].querySelector('[uib-accordion-header]'));\n\t          elem.html('');\n\t          elem.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.alert', [])\n\t\n\t.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n\t  $scope.closeable = !!$attrs.close;\n\t\n\t  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n\t    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\t\n\t  if (dismissOnTimeout) {\n\t    $timeout(function() {\n\t      $scope.close();\n\t    }, parseInt(dismissOnTimeout, 10));\n\t  }\n\t}])\n\t\n\t.directive('uibAlert', function() {\n\t  return {\n\t    controller: 'UibAlertController',\n\t    controllerAs: 'alert',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/alert/alert.html';\n\t    },\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {\n\t      type: '@',\n\t      close: '&'\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.buttons', [])\n\t\n\t.constant('uibButtonConfig', {\n\t  activeClass: 'active',\n\t  toggleEvent: 'click'\n\t})\n\t\n\t.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n\t  this.activeClass = buttonConfig.activeClass || 'active';\n\t  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n\t}])\n\t\n\t.directive('uibBtnRadio', ['$parse', function($parse) {\n\t  return {\n\t    require: ['uibBtnRadio', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'buttons',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      var uncheckableExpr = $parse(attrs.uibUncheckable);\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\t\n\t        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n\t          scope.$apply(function() {\n\t            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n\t            ngModelCtrl.$render();\n\t          });\n\t        }\n\t      });\n\t\n\t      if (attrs.uibUncheckable) {\n\t        scope.$watch(uncheckableExpr, function(uncheckable) {\n\t          attrs.$set('uncheckable', uncheckable ? '' : undefined);\n\t        });\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibBtnCheckbox', function() {\n\t  return {\n\t    require: ['uibBtnCheckbox', 'ngModel'],\n\t    controller: 'UibButtonsController',\n\t    controllerAs: 'button',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      element.find('input').css({display: 'none'});\n\t\n\t      function getTrueValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n\t      }\n\t\n\t      function getFalseValue() {\n\t        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n\t      }\n\t\n\t      function getCheckboxValue(attribute, defaultValue) {\n\t        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n\t      }\n\t\n\t      //model -> UI\n\t      ngModelCtrl.$render = function() {\n\t        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n\t      };\n\t\n\t      //ui->model\n\t      element.on(buttonsCtrl.toggleEvent, function() {\n\t        if (attrs.disabled) {\n\t          return;\n\t        }\n\t\n\t        scope.$apply(function() {\n\t          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n\t          ngModelCtrl.$render();\n\t        });\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.carousel', [])\n\t\n\t.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {\n\t  var self = this,\n\t    slides = self.slides = $scope.slides = [],\n\t    SLIDE_DIRECTION = 'uib-slideDirection',\n\t    currentIndex = $scope.active,\n\t    currentInterval, isPlaying, bufferedTransitions = [];\n\t\n\t  var destroyed = false;\n\t\n\t  self.addSlide = function(slide, element) {\n\t    slides.push({\n\t      slide: slide,\n\t      element: element\n\t    });\n\t    slides.sort(function(a, b) {\n\t      return +a.slide.index > +b.slide.index;\n\t    });\n\t    //if this is the first slide or the slide is set to active, select it\n\t    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {\n\t      if ($scope.$currentTransition) {\n\t        $scope.$currentTransition = null;\n\t      }\n\t\n\t      currentIndex = slide.index;\n\t      $scope.active = slide.index;\n\t      setActive(currentIndex);\n\t      self.select(slides[findSlideIndex(slide)]);\n\t      if (slides.length === 1) {\n\t        $scope.play();\n\t      }\n\t    }\n\t  };\n\t\n\t  self.getCurrentIndex = function() {\n\t    for (var i = 0; i < slides.length; i++) {\n\t      if (slides[i].slide.index === currentIndex) {\n\t        return i;\n\t      }\n\t    }\n\t  };\n\t\n\t  self.next = $scope.next = function() {\n\t    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\t\n\t    if (newIndex === 0 && $scope.noWrap()) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(slides[newIndex], 'next');\n\t  };\n\t\n\t  self.prev = $scope.prev = function() {\n\t    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\t\n\t    if ($scope.noWrap() && newIndex === slides.length - 1) {\n\t      $scope.pause();\n\t      return;\n\t    }\n\t\n\t    return self.select(slides[newIndex], 'prev');\n\t  };\n\t\n\t  self.removeSlide = function(slide) {\n\t    var index = findSlideIndex(slide);\n\t\n\t    var bufferedIndex = bufferedTransitions.indexOf(slides[index]);\n\t    if (bufferedIndex !== -1) {\n\t      bufferedTransitions.splice(bufferedIndex, 1);\n\t    }\n\t\n\t    //get the index of the slide inside the carousel\n\t    slides.splice(index, 1);\n\t    if (slides.length > 0 && currentIndex === index) {\n\t      if (index >= slides.length) {\n\t        currentIndex = slides.length - 1;\n\t        $scope.active = currentIndex;\n\t        setActive(currentIndex);\n\t        self.select(slides[slides.length - 1]);\n\t      } else {\n\t        currentIndex = index;\n\t        $scope.active = currentIndex;\n\t        setActive(currentIndex);\n\t        self.select(slides[index]);\n\t      }\n\t    } else if (currentIndex > index) {\n\t      currentIndex--;\n\t      $scope.active = currentIndex;\n\t    }\n\t\n\t    //clean the active value when no more slide\n\t    if (slides.length === 0) {\n\t      currentIndex = null;\n\t      $scope.active = null;\n\t      clearBufferedTransitions();\n\t    }\n\t  };\n\t\n\t  /* direction: \"prev\" or \"next\" */\n\t  self.select = $scope.select = function(nextSlide, direction) {\n\t    var nextIndex = findSlideIndex(nextSlide.slide);\n\t    //Decide direction if it's not given\n\t    if (direction === undefined) {\n\t      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n\t    }\n\t    //Prevent this user-triggered transition from occurring if there is already one in progress\n\t    if (nextSlide.slide.index !== currentIndex &&\n\t      !$scope.$currentTransition) {\n\t      goNext(nextSlide.slide, nextIndex, direction);\n\t    } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {\n\t      bufferedTransitions.push(slides[nextIndex]);\n\t    }\n\t  };\n\t\n\t  /* Allow outside people to call indexOf on slides array */\n\t  $scope.indexOfSlide = function(slide) {\n\t    return +slide.slide.index;\n\t  };\n\t\n\t  $scope.isActive = function(slide) {\n\t    return $scope.active === slide.slide.index;\n\t  };\n\t\n\t  $scope.pause = function() {\n\t    if (!$scope.noPause) {\n\t      isPlaying = false;\n\t      resetTimer();\n\t    }\n\t  };\n\t\n\t  $scope.play = function() {\n\t    if (!isPlaying) {\n\t      isPlaying = true;\n\t      restartTimer();\n\t    }\n\t  };\n\t\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t    resetTimer();\n\t  });\n\t\n\t  $scope.$watch('noTransition', function(noTransition) {\n\t    $animate.enabled($element, !noTransition);\n\t  });\n\t\n\t  $scope.$watch('interval', restartTimer);\n\t\n\t  $scope.$watchCollection('slides', resetTransition);\n\t\n\t  $scope.$watch('active', function(index) {\n\t    if (angular.isNumber(index) && currentIndex !== index) {\n\t      for (var i = 0; i < slides.length; i++) {\n\t        if (slides[i].slide.index === index) {\n\t          index = i;\n\t          break;\n\t        }\n\t      }\n\t\n\t      var slide = slides[index];\n\t      if (slide) {\n\t        currentIndex = index;\n\t        setActive(index);\n\t        self.select(slides[index]);\n\t      }\n\t    }\n\t  });\n\t\n\t  function clearBufferedTransitions() {\n\t    while (bufferedTransitions.length) {\n\t      bufferedTransitions.shift();\n\t    }\n\t  }\n\t\n\t  function getSlideByIndex(index) {\n\t    for (var i = 0, l = slides.length; i < l; ++i) {\n\t      if (slides[i].index === index) {\n\t        return slides[i];\n\t      }\n\t    }\n\t  }\n\t\n\t  function setActive(index) {\n\t    for (var i = 0; i < slides.length; i++) {\n\t      slides[i].slide.active = i === index;\n\t    }\n\t  }\n\t\n\t  function goNext(slide, index, direction) {\n\t    if (destroyed) {\n\t      return;\n\t    }\n\t\n\t    angular.extend(slide, {direction: direction});\n\t    angular.extend(slides[currentIndex].slide || {}, {direction: direction});\n\t    if ($animate.enabled($element) && !$scope.$currentTransition &&\n\t      slides[index].element && self.slides.length > 1) {\n\t      slides[index].element.data(SLIDE_DIRECTION, slide.direction);\n\t      var currentIdx = self.getCurrentIndex();\n\t\n\t      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {\n\t        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);\n\t      }\n\t\n\t      $scope.$currentTransition = true;\n\t      $animate.on('addClass', slides[index].element, function(element, phase) {\n\t        if (phase === 'close') {\n\t          $scope.$currentTransition = null;\n\t          $animate.off('addClass', element);\n\t          if (bufferedTransitions.length) {\n\t            var nextSlide = bufferedTransitions.pop().slide;\n\t            var nextIndex = nextSlide.index;\n\t            var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n\t            clearBufferedTransitions();\n\t\n\t            goNext(nextSlide, nextIndex, nextDirection);\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    $scope.active = slide.index;\n\t    currentIndex = slide.index;\n\t    setActive(index);\n\t\n\t    //every time you change slides, reset the timer\n\t    restartTimer();\n\t  }\n\t\n\t  function findSlideIndex(slide) {\n\t    for (var i = 0; i < slides.length; i++) {\n\t      if (slides[i].slide === slide) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t\n\t  function resetTimer() {\n\t    if (currentInterval) {\n\t      $interval.cancel(currentInterval);\n\t      currentInterval = null;\n\t    }\n\t  }\n\t\n\t  function resetTransition(slides) {\n\t    if (!slides.length) {\n\t      $scope.$currentTransition = null;\n\t      clearBufferedTransitions();\n\t    }\n\t  }\n\t\n\t  function restartTimer() {\n\t    resetTimer();\n\t    var interval = +$scope.interval;\n\t    if (!isNaN(interval) && interval > 0) {\n\t      currentInterval = $interval(timerFn, interval);\n\t    }\n\t  }\n\t\n\t  function timerFn() {\n\t    var interval = +$scope.interval;\n\t    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n\t      $scope.next();\n\t    } else {\n\t      $scope.pause();\n\t    }\n\t  }\n\t}])\n\t\n\t.directive('uibCarousel', function() {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    controller: 'UibCarouselController',\n\t    controllerAs: 'carousel',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/carousel/carousel.html';\n\t    },\n\t    scope: {\n\t      active: '=',\n\t      interval: '=',\n\t      noTransition: '=',\n\t      noPause: '=',\n\t      noWrap: '&'\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibSlide', function() {\n\t  return {\n\t    require: '^uibCarousel',\n\t    transclude: true,\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/carousel/slide.html';\n\t    },\n\t    scope: {\n\t      actual: '=?',\n\t      index: '=?'\n\t    },\n\t    link: function (scope, element, attrs, carouselCtrl) {\n\t      carouselCtrl.addSlide(scope, element);\n\t      //when the scope is destroyed then remove the slide from the current slides array\n\t      scope.$on('$destroy', function() {\n\t        carouselCtrl.removeSlide(scope);\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.animation('.item', ['$animateCss',\n\tfunction($animateCss) {\n\t  var SLIDE_DIRECTION = 'uib-slideDirection';\n\t\n\t  function removeClass(element, className, callback) {\n\t    element.removeClass(className);\n\t    if (callback) {\n\t      callback();\n\t    }\n\t  }\n\t\n\t  return {\n\t    beforeAddClass: function(element, className, done) {\n\t      if (className === 'active') {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction === 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element,\n\t          directionClass + ' ' + direction, done);\n\t        element.addClass(direction);\n\t\n\t        $animateCss(element, {addClass: directionClass})\n\t          .start()\n\t          .done(removeClassFn);\n\t\n\t        return function() {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    },\n\t    beforeRemoveClass: function (element, className, done) {\n\t      if (className === 'active') {\n\t        var stopped = false;\n\t        var direction = element.data(SLIDE_DIRECTION);\n\t        var directionClass = direction === 'next' ? 'left' : 'right';\n\t        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\t\n\t        $animateCss(element, {addClass: directionClass})\n\t          .start()\n\t          .done(removeClassFn);\n\t\n\t        return function() {\n\t          stopped = true;\n\t        };\n\t      }\n\t      done();\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.dateparser', [])\n\t\n\t.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {\n\t  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n\t  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\t\n\t  var localeId;\n\t  var formatCodeToRegex;\n\t\n\t  this.init = function() {\n\t    localeId = $locale.id;\n\t\n\t    this.parsers = {};\n\t    this.formatters = {};\n\t\n\t    formatCodeToRegex = [\n\t      {\n\t        key: 'yyyy',\n\t        regex: '\\\\d{4}',\n\t        apply: function(value) { this.year = +value; },\n\t        formatter: function(date) {\n\t          var _date = new Date();\n\t          _date.setFullYear(Math.abs(date.getFullYear()));\n\t          return dateFilter(_date, 'yyyy');\n\t        }\n\t      },\n\t      {\n\t        key: 'yy',\n\t        regex: '\\\\d{2}',\n\t        apply: function(value) { this.year = +value + 2000; },\n\t        formatter: function(date) {\n\t          var _date = new Date();\n\t          _date.setFullYear(Math.abs(date.getFullYear()));\n\t          return dateFilter(_date, 'yy');\n\t        }\n\t      },\n\t      {\n\t        key: 'y',\n\t        regex: '\\\\d{1,4}',\n\t        apply: function(value) { this.year = +value; },\n\t        formatter: function(date) {\n\t          var _date = new Date();\n\t          _date.setFullYear(Math.abs(date.getFullYear()));\n\t          return dateFilter(_date, 'y');\n\t        }\n\t      },\n\t      {\n\t        key: 'M!',\n\t        regex: '0?[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; },\n\t        formatter: function(date) {\n\t          var value = date.getMonth();\n\t          if (/^[0-9]$/.test(value)) {\n\t            return dateFilter(date, 'MM');\n\t          }\n\t\n\t          return dateFilter(date, 'M');\n\t        }\n\t      },\n\t      {\n\t        key: 'MMMM',\n\t        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },\n\t        formatter: function(date) { return dateFilter(date, 'MMMM'); }\n\t      },\n\t      {\n\t        key: 'MMM',\n\t        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n\t        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },\n\t        formatter: function(date) { return dateFilter(date, 'MMM'); }\n\t      },\n\t      {\n\t        key: 'MM',\n\t        regex: '0[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; },\n\t        formatter: function(date) { return dateFilter(date, 'MM'); }\n\t      },\n\t      {\n\t        key: 'M',\n\t        regex: '[1-9]|1[0-2]',\n\t        apply: function(value) { this.month = value - 1; },\n\t        formatter: function(date) { return dateFilter(date, 'M'); }\n\t      },\n\t      {\n\t        key: 'd!',\n\t        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; },\n\t        formatter: function(date) {\n\t          var value = date.getDate();\n\t          if (/^[1-9]$/.test(value)) {\n\t            return dateFilter(date, 'dd');\n\t          }\n\t\n\t          return dateFilter(date, 'd');\n\t        }\n\t      },\n\t      {\n\t        key: 'dd',\n\t        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'dd'); }\n\t      },\n\t      {\n\t        key: 'd',\n\t        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n\t        apply: function(value) { this.date = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'd'); }\n\t      },\n\t      {\n\t        key: 'EEEE',\n\t        regex: $locale.DATETIME_FORMATS.DAY.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'EEEE'); }\n\t      },\n\t      {\n\t        key: 'EEE',\n\t        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'EEE'); }\n\t      },\n\t      {\n\t        key: 'HH',\n\t        regex: '(?:0|1)[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'HH'); }\n\t      },\n\t      {\n\t        key: 'hh',\n\t        regex: '0[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'hh'); }\n\t      },\n\t      {\n\t        key: 'H',\n\t        regex: '1?[0-9]|2[0-3]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'H'); }\n\t      },\n\t      {\n\t        key: 'h',\n\t        regex: '[0-9]|1[0-2]',\n\t        apply: function(value) { this.hours = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'h'); }\n\t      },\n\t      {\n\t        key: 'mm',\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'mm'); }\n\t      },\n\t      {\n\t        key: 'm',\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.minutes = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'm'); }\n\t      },\n\t      {\n\t        key: 'sss',\n\t        regex: '[0-9][0-9][0-9]',\n\t        apply: function(value) { this.milliseconds = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'sss'); }\n\t      },\n\t      {\n\t        key: 'ss',\n\t        regex: '[0-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; },\n\t        formatter: function(date) { return dateFilter(date, 'ss'); }\n\t      },\n\t      {\n\t        key: 's',\n\t        regex: '[0-9]|[1-5][0-9]',\n\t        apply: function(value) { this.seconds = +value; },\n\t        formatter: function(date) { return dateFilter(date, 's'); }\n\t      },\n\t      {\n\t        key: 'a',\n\t        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n\t        apply: function(value) {\n\t          if (this.hours === 12) {\n\t            this.hours = 0;\n\t          }\n\t\n\t          if (value === 'PM') {\n\t            this.hours += 12;\n\t          }\n\t        },\n\t        formatter: function(date) { return dateFilter(date, 'a'); }\n\t      },\n\t      {\n\t        key: 'Z',\n\t        regex: '[+-]\\\\d{4}',\n\t        apply: function(value) {\n\t          var matches = value.match(/([+-])(\\d{2})(\\d{2})/),\n\t            sign = matches[1],\n\t            hours = matches[2],\n\t            minutes = matches[3];\n\t          this.hours += toInt(sign + hours);\n\t          this.minutes += toInt(sign + minutes);\n\t        },\n\t        formatter: function(date) {\n\t          return dateFilter(date, 'Z');\n\t        }\n\t      },\n\t      {\n\t        key: 'ww',\n\t        regex: '[0-4][0-9]|5[0-3]',\n\t        formatter: function(date) { return dateFilter(date, 'ww'); }\n\t      },\n\t      {\n\t        key: 'w',\n\t        regex: '[0-9]|[1-4][0-9]|5[0-3]',\n\t        formatter: function(date) { return dateFilter(date, 'w'); }\n\t      },\n\t      {\n\t        key: 'GGGG',\n\t        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\\s/g, '\\\\s'),\n\t        formatter: function(date) { return dateFilter(date, 'GGGG'); }\n\t      },\n\t      {\n\t        key: 'GGG',\n\t        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'GGG'); }\n\t      },\n\t      {\n\t        key: 'GG',\n\t        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'GG'); }\n\t      },\n\t      {\n\t        key: 'G',\n\t        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n\t        formatter: function(date) { return dateFilter(date, 'G'); }\n\t      }\n\t    ];\n\t  };\n\t\n\t  this.init();\n\t\n\t  function createParser(format, func) {\n\t    var map = [], regex = format.split('');\n\t\n\t    // check for literal values\n\t    var quoteIndex = format.indexOf('\\'');\n\t    if (quoteIndex > -1) {\n\t      var inLiteral = false;\n\t      format = format.split('');\n\t      for (var i = quoteIndex; i < format.length; i++) {\n\t        if (inLiteral) {\n\t          if (format[i] === '\\'') {\n\t            if (i + 1 < format.length && format[i+1] === '\\'') { // escaped single quote\n\t              format[i+1] = '$';\n\t              regex[i+1] = '';\n\t            } else { // end of literal\n\t              regex[i] = '';\n\t              inLiteral = false;\n\t            }\n\t          }\n\t          format[i] = '$';\n\t        } else {\n\t          if (format[i] === '\\'') { // start of literal\n\t            format[i] = '$';\n\t            regex[i] = '';\n\t            inLiteral = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      format = format.join('');\n\t    }\n\t\n\t    angular.forEach(formatCodeToRegex, function(data) {\n\t      var index = format.indexOf(data.key);\n\t\n\t      if (index > -1) {\n\t        format = format.split('');\n\t\n\t        regex[index] = '(' + data.regex + ')';\n\t        format[index] = '$'; // Custom symbol to define consumed part of format\n\t        for (var i = index + 1, n = index + data.key.length; i < n; i++) {\n\t          regex[i] = '';\n\t          format[i] = '$';\n\t        }\n\t        format = format.join('');\n\t\n\t        map.push({\n\t          index: index,\n\t          key: data.key,\n\t          apply: data[func],\n\t          matcher: data.regex\n\t        });\n\t      }\n\t    });\n\t\n\t    return {\n\t      regex: new RegExp('^' + regex.join('') + '$'),\n\t      map: orderByFilter(map, 'index')\n\t    };\n\t  }\n\t\n\t  this.filter = function(date, format) {\n\t    if (!angular.isDate(date) || isNaN(date) || !format) {\n\t      return '';\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t\n\t    if ($locale.id !== localeId) {\n\t      this.init();\n\t    }\n\t\n\t    if (!this.formatters[format]) {\n\t      this.formatters[format] = createParser(format, 'formatter');\n\t    }\n\t\n\t    var parser = this.formatters[format],\n\t      map = parser.map;\n\t\n\t    var _format = format;\n\t\n\t    return map.reduce(function(str, mapper, i) {\n\t      var match = _format.match(new RegExp('(.*)' + mapper.key));\n\t      if (match && angular.isString(match[1])) {\n\t        str += match[1];\n\t        _format = _format.replace(match[1] + mapper.key, '');\n\t      }\n\t\n\t      var endStr = i === map.length - 1 ? _format : '';\n\t\n\t      if (mapper.apply) {\n\t        return str + mapper.apply.call(null, date) + endStr;\n\t      }\n\t\n\t      return str + endStr;\n\t    }, '');\n\t  };\n\t\n\t  this.parse = function(input, format, baseDate) {\n\t    if (!angular.isString(input) || !format) {\n\t      return input;\n\t    }\n\t\n\t    format = $locale.DATETIME_FORMATS[format] || format;\n\t    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\t\n\t    if ($locale.id !== localeId) {\n\t      this.init();\n\t    }\n\t\n\t    if (!this.parsers[format]) {\n\t      this.parsers[format] = createParser(format, 'apply');\n\t    }\n\t\n\t    var parser = this.parsers[format],\n\t        regex = parser.regex,\n\t        map = parser.map,\n\t        results = input.match(regex),\n\t        tzOffset = false;\n\t    if (results && results.length) {\n\t      var fields, dt;\n\t      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n\t        fields = {\n\t          year: baseDate.getFullYear(),\n\t          month: baseDate.getMonth(),\n\t          date: baseDate.getDate(),\n\t          hours: baseDate.getHours(),\n\t          minutes: baseDate.getMinutes(),\n\t          seconds: baseDate.getSeconds(),\n\t          milliseconds: baseDate.getMilliseconds()\n\t        };\n\t      } else {\n\t        if (baseDate) {\n\t          $log.warn('dateparser:', 'baseDate is not a valid date');\n\t        }\n\t        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n\t      }\n\t\n\t      for (var i = 1, n = results.length; i < n; i++) {\n\t        var mapper = map[i - 1];\n\t        if (mapper.matcher === 'Z') {\n\t          tzOffset = true;\n\t        }\n\t\n\t        if (mapper.apply) {\n\t          mapper.apply.call(fields, results[i]);\n\t        }\n\t      }\n\t\n\t      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :\n\t        Date.prototype.setFullYear;\n\t      var timesetter = tzOffset ? Date.prototype.setUTCHours :\n\t        Date.prototype.setHours;\n\t\n\t      if (isValid(fields.year, fields.month, fields.date)) {\n\t        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {\n\t          dt = new Date(baseDate);\n\t          datesetter.call(dt, fields.year, fields.month, fields.date);\n\t          timesetter.call(dt, fields.hours, fields.minutes,\n\t            fields.seconds, fields.milliseconds);\n\t        } else {\n\t          dt = new Date(0);\n\t          datesetter.call(dt, fields.year, fields.month, fields.date);\n\t          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,\n\t            fields.seconds || 0, fields.milliseconds || 0);\n\t        }\n\t      }\n\t\n\t      return dt;\n\t    }\n\t  };\n\t\n\t  // Check if date is valid for specific month (and year for February).\n\t  // Month: 0 = Jan, 1 = Feb, etc\n\t  function isValid(year, month, date) {\n\t    if (date < 1) {\n\t      return false;\n\t    }\n\t\n\t    if (month === 1 && date > 28) {\n\t      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);\n\t    }\n\t\n\t    if (month === 3 || month === 5 || month === 8 || month === 10) {\n\t      return date < 31;\n\t    }\n\t\n\t    return true;\n\t  }\n\t\n\t  function toInt(str) {\n\t    return parseInt(str, 10);\n\t  }\n\t\n\t  this.toTimezone = toTimezone;\n\t  this.fromTimezone = fromTimezone;\n\t  this.timezoneToOffset = timezoneToOffset;\n\t  this.addDateMinutes = addDateMinutes;\n\t  this.convertTimezoneToLocal = convertTimezoneToLocal;\n\t\n\t  function toTimezone(date, timezone) {\n\t    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;\n\t  }\n\t\n\t  function fromTimezone(date, timezone) {\n\t    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;\n\t  }\n\t\n\t  //https://github.com/angular/angular.js/blob/4daafd3dbe6a80d578f5a31df1bb99c77559543e/src/Angular.js#L1207\n\t  function timezoneToOffset(timezone, fallback) {\n\t    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\n\t    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n\t  }\n\t\n\t  function addDateMinutes(date, minutes) {\n\t    date = new Date(date.getTime());\n\t    date.setMinutes(date.getMinutes() + minutes);\n\t    return date;\n\t  }\n\t\n\t  function convertTimezoneToLocal(date, timezone, reverse) {\n\t    reverse = reverse ? -1 : 1;\n\t    var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());\n\t    return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));\n\t  }\n\t}]);\n\t\n\t// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to\n\t// at most one element.\n\tangular.module('ui.bootstrap.isClass', [])\n\t.directive('uibIsClass', [\n\t         '$animate',\n\tfunction ($animate) {\n\t  //                    11111111          22222222\n\t  var ON_REGEXP = /^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/;\n\t  //                    11111111           22222222\n\t  var IS_REGEXP = /^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;\n\t\n\t  var dataPerTracked = {};\n\t\n\t  return {\n\t    restrict: 'A',\n\t    compile: function (tElement, tAttrs) {\n\t      var linkedScopes = [];\n\t      var instances = [];\n\t      var expToData = {};\n\t      var lastActivated = null;\n\t      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);\n\t      var onExp = onExpMatches[2];\n\t      var expsStr = onExpMatches[1];\n\t      var exps = expsStr.split(',');\n\t\n\t      return linkFn;\n\t\n\t      function linkFn(scope, element, attrs) {\n\t        linkedScopes.push(scope);\n\t        instances.push({\n\t          scope: scope,\n\t          element: element\n\t        });\n\t\n\t        exps.forEach(function (exp, k) {\n\t          addForExp(exp, scope);\n\t        });\n\t\n\t        scope.$on('$destroy', removeScope);\n\t      }\n\t\n\t      function addForExp(exp, scope) {\n\t        var matches = exp.match(IS_REGEXP);\n\t        var clazz = scope.$eval(matches[1]);\n\t        var compareWithExp = matches[2];\n\t        var data = expToData[exp];\n\t        if (!data) {\n\t          var watchFn = function (compareWithVal) {\n\t            var newActivated = null;\n\t            instances.some(function (instance) {\n\t              var thisVal = instance.scope.$eval(onExp);\n\t              if (thisVal === compareWithVal) {\n\t                newActivated = instance;\n\t                return true;\n\t              }\n\t            });\n\t            if (data.lastActivated !== newActivated) {\n\t              if (data.lastActivated) {\n\t                $animate.removeClass(data.lastActivated.element, clazz);\n\t              }\n\t              if (newActivated) {\n\t                $animate.addClass(newActivated.element, clazz);\n\t              }\n\t              data.lastActivated = newActivated;\n\t            }\n\t          };\n\t          expToData[exp] = data = {\n\t            lastActivated: null,\n\t            scope: scope,\n\t            watchFn: watchFn,\n\t            compareWithExp: compareWithExp,\n\t            watcher: scope.$watch(compareWithExp, watchFn)\n\t          };\n\t        }\n\t        data.watchFn(scope.$eval(compareWithExp));\n\t      }\n\t\n\t      function removeScope(e) {\n\t        var removedScope = e.targetScope;\n\t        var index = linkedScopes.indexOf(removedScope);\n\t        linkedScopes.splice(index, 1);\n\t        instances.splice(index, 1);\n\t        if (linkedScopes.length) {\n\t          var newWatchScope = linkedScopes[0];\n\t          angular.forEach(expToData, function (data) {\n\t            if (data.scope === removedScope) {\n\t              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);\n\t              data.scope = newWatchScope;\n\t            }\n\t          });\n\t        }\n\t        else {\n\t          expToData = {};\n\t        }\n\t      }\n\t    }\n\t  };\n\t}]);\n\tangular.module('ui.bootstrap.position', [])\n\t\n\t/**\n\t * A set of utility methods for working with the DOM.\n\t * It is meant to be used where we need to absolute-position elements in\n\t * relation to another element (this is the case for tooltips, popovers,\n\t * typeahead suggestions etc.).\n\t */\n\t  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n\t    /**\n\t     * Used by scrollbarWidth() function to cache scrollbar's width.\n\t     * Do not access this variable directly, use scrollbarWidth() instead.\n\t     */\n\t    var SCROLLBAR_WIDTH;\n\t    var OVERFLOW_REGEX = {\n\t      normal: /(auto|scroll)/,\n\t      hidden: /(auto|scroll|hidden)/\n\t    };\n\t    var PLACEMENT_REGEX = {\n\t      auto: /\\s?auto?\\s?/i,\n\t      primary: /^(top|bottom|left|right)$/,\n\t      secondary: /^(top|bottom|left|right|center)$/,\n\t      vertical: /^(top|bottom)$/\n\t    };\n\t\n\t    return {\n\t\n\t      /**\n\t       * Provides a raw DOM element from a jQuery/jQLite element.\n\t       *\n\t       * @param {element} elem - The element to convert.\n\t       *\n\t       * @returns {element} A HTML element.\n\t       */\n\t      getRawNode: function(elem) {\n\t        return elem.nodeName ? elem : elem[0] || elem;\n\t      },\n\t\n\t      /**\n\t       * Provides a parsed number for a style property.  Strips\n\t       * units and casts invalid numbers to 0.\n\t       *\n\t       * @param {string} value - The style value to parse.\n\t       *\n\t       * @returns {number} A valid number.\n\t       */\n\t      parseStyle: function(value) {\n\t        value = parseFloat(value);\n\t        return isFinite(value) ? value : 0;\n\t      },\n\t\n\t      /**\n\t       * Provides the closest positioned ancestor.\n\t       *\n\t       * @param {element} element - The element to get the offest parent for.\n\t       *\n\t       * @returns {element} The closest positioned ancestor.\n\t       */\n\t      offsetParent: function(elem) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var offsetParent = elem.offsetParent || $document[0].documentElement;\n\t\n\t        function isStaticPositioned(el) {\n\t          return ($window.getComputedStyle(el).position || 'static') === 'static';\n\t        }\n\t\n\t        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {\n\t          offsetParent = offsetParent.offsetParent;\n\t        }\n\t\n\t        return offsetParent || $document[0].documentElement;\n\t      },\n\t\n\t      /**\n\t       * Provides the scrollbar width, concept from TWBS measureScrollbar()\n\t       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js\n\t       *\n\t       * @returns {number} The width of the browser scollbar.\n\t       */\n\t      scrollbarWidth: function() {\n\t        if (angular.isUndefined(SCROLLBAR_WIDTH)) {\n\t          var scrollElem = angular.element('<div class=\"uib-position-scrollbar-measure\"></div>');\n\t          $document.find('body').append(scrollElem);\n\t          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;\n\t          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;\n\t          scrollElem.remove();\n\t        }\n\t\n\t        return SCROLLBAR_WIDTH;\n\t      },\n\t\n\t      /**\n\t       * Checks to see if the element is scrollable.\n\t       *\n\t       * @param {element} elem - The element to check.\n\t       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n\t       *   default is false.\n\t       *\n\t       * @returns {boolean} Whether the element is scrollable.\n\t       */\n\t      isScrollable: function(elem, includeHidden) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n\t        var elemStyle = $window.getComputedStyle(elem);\n\t        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);\n\t      },\n\t\n\t      /**\n\t       * Provides the closest scrollable ancestor.\n\t       * A port of the jQuery UI scrollParent method:\n\t       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js\n\t       *\n\t       * @param {element} elem - The element to find the scroll parent of.\n\t       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n\t       *   default is false.\n\t       *\n\t       * @returns {element} A HTML element.\n\t       */\n\t      scrollParent: function(elem, includeHidden) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n\t        var documentEl = $document[0].documentElement;\n\t        var elemStyle = $window.getComputedStyle(elem);\n\t        var excludeStatic = elemStyle.position === 'absolute';\n\t        var scrollParent = elem.parentElement || documentEl;\n\t\n\t        if (scrollParent === documentEl || elemStyle.position === 'fixed') {\n\t          return documentEl;\n\t        }\n\t\n\t        while (scrollParent.parentElement && scrollParent !== documentEl) {\n\t          var spStyle = $window.getComputedStyle(scrollParent);\n\t          if (excludeStatic && spStyle.position !== 'static') {\n\t            excludeStatic = false;\n\t          }\n\t\n\t          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {\n\t            break;\n\t          }\n\t          scrollParent = scrollParent.parentElement;\n\t        }\n\t\n\t        return scrollParent;\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's position function:\n\t       * http://api.jquery.com/position/ - distance to closest positioned\n\t       * ancestor.  Does not account for margins by default like jQuery position.\n\t       *\n\t       * @param {element} elem - The element to caclulate the position on.\n\t       * @param {boolean=} [includeMargins=false] - Should margins be accounted\n\t       * for, default is false.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**width**: the width of the element</li>\n\t       *     <li>**height**: the height of the element</li>\n\t       *     <li>**top**: distance to top edge of offset parent</li>\n\t       *     <li>**left**: distance to left edge of offset parent</li>\n\t       *   </ul>\n\t       */\n\t      position: function(elem, includeMagins) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var elemOffset = this.offset(elem);\n\t        if (includeMagins) {\n\t          var elemStyle = $window.getComputedStyle(elem);\n\t          elemOffset.top -= this.parseStyle(elemStyle.marginTop);\n\t          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);\n\t        }\n\t        var parent = this.offsetParent(elem);\n\t        var parentOffset = {top: 0, left: 0};\n\t\n\t        if (parent !== $document[0].documentElement) {\n\t          parentOffset = this.offset(parent);\n\t          parentOffset.top += parent.clientTop - parent.scrollTop;\n\t          parentOffset.left += parent.clientLeft - parent.scrollLeft;\n\t        }\n\t\n\t        return {\n\t          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),\n\t          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),\n\t          top: Math.round(elemOffset.top - parentOffset.top),\n\t          left: Math.round(elemOffset.left - parentOffset.left)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides read-only equivalent of jQuery's offset function:\n\t       * http://api.jquery.com/offset/ - distance to viewport.  Does\n\t       * not account for borders, margins, or padding on the body\n\t       * element.\n\t       *\n\t       * @param {element} elem - The element to calculate the offset on.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**width**: the width of the element</li>\n\t       *     <li>**height**: the height of the element</li>\n\t       *     <li>**top**: distance to top edge of viewport</li>\n\t       *     <li>**right**: distance to bottom edge of viewport</li>\n\t       *   </ul>\n\t       */\n\t      offset: function(elem) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var elemBCR = elem.getBoundingClientRect();\n\t        return {\n\t          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),\n\t          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),\n\t          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),\n\t          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides offset distance to the closest scrollable ancestor\n\t       * or viewport.  Accounts for border and scrollbar width.\n\t       *\n\t       * Right and bottom dimensions represent the distance to the\n\t       * respective edge of the viewport element.  If the element\n\t       * edge extends beyond the viewport, a negative value will be\n\t       * reported.\n\t       *\n\t       * @param {element} elem - The element to get the viewport offset for.\n\t       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead\n\t       * of the first scrollable element, default is false.\n\t       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element\n\t       * be accounted for, default is true.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**top**: distance to the top content edge of viewport element</li>\n\t       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>\n\t       *     <li>**left**: distance to the left content edge of viewport element</li>\n\t       *     <li>**right**: distance to the right content edge of viewport element</li>\n\t       *   </ul>\n\t       */\n\t      viewportOffset: function(elem, useDocument, includePadding) {\n\t        elem = this.getRawNode(elem);\n\t        includePadding = includePadding !== false ? true : false;\n\t\n\t        var elemBCR = elem.getBoundingClientRect();\n\t        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};\n\t\n\t        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);\n\t        var offsetParentBCR = offsetParent.getBoundingClientRect();\n\t\n\t        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;\n\t        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;\n\t        if (offsetParent === $document[0].documentElement) {\n\t          offsetBCR.top += $window.pageYOffset;\n\t          offsetBCR.left += $window.pageXOffset;\n\t        }\n\t        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;\n\t        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;\n\t\n\t        if (includePadding) {\n\t          var offsetParentStyle = $window.getComputedStyle(offsetParent);\n\t          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);\n\t          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);\n\t          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);\n\t          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);\n\t        }\n\t\n\t        return {\n\t          top: Math.round(elemBCR.top - offsetBCR.top),\n\t          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),\n\t          left: Math.round(elemBCR.left - offsetBCR.left),\n\t          right: Math.round(offsetBCR.right - elemBCR.right)\n\t        };\n\t      },\n\t\n\t      /**\n\t       * Provides an array of placement values parsed from a placement string.\n\t       * Along with the 'auto' indicator, supported placement strings are:\n\t       *   <ul>\n\t       *     <li>top: element on top, horizontally centered on host element.</li>\n\t       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>\n\t       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>\n\t       *     <li>bottom: element on bottom, horizontally centered on host element.</li>\n\t       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>\n\t       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>\n\t       *     <li>left: element on left, vertically centered on host element.</li>\n\t       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>\n\t       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>\n\t       *     <li>right: element on right, vertically centered on host element.</li>\n\t       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>\n\t       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>\n\t       *   </ul>\n\t       * A placement string with an 'auto' indicator is expected to be\n\t       * space separated from the placement, i.e: 'auto bottom-left'  If\n\t       * the primary and secondary placement values do not match 'top,\n\t       * bottom, left, right' then 'top' will be the primary placement and\n\t       * 'center' will be the secondary placement.  If 'auto' is passed, true\n\t       * will be returned as the 3rd value of the array.\n\t       *\n\t       * @param {string} placement - The placement string to parse.\n\t       *\n\t       * @returns {array} An array with the following values\n\t       * <ul>\n\t       *   <li>**[0]**: The primary placement.</li>\n\t       *   <li>**[1]**: The secondary placement.</li>\n\t       *   <li>**[2]**: If auto is passed: true, else undefined.</li>\n\t       * </ul>\n\t       */\n\t      parsePlacement: function(placement) {\n\t        var autoPlace = PLACEMENT_REGEX.auto.test(placement);\n\t        if (autoPlace) {\n\t          placement = placement.replace(PLACEMENT_REGEX.auto, '');\n\t        }\n\t\n\t        placement = placement.split('-');\n\t\n\t        placement[0] = placement[0] || 'top';\n\t        if (!PLACEMENT_REGEX.primary.test(placement[0])) {\n\t          placement[0] = 'top';\n\t        }\n\t\n\t        placement[1] = placement[1] || 'center';\n\t        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {\n\t          placement[1] = 'center';\n\t        }\n\t\n\t        if (autoPlace) {\n\t          placement[2] = true;\n\t        } else {\n\t          placement[2] = false;\n\t        }\n\t\n\t        return placement;\n\t      },\n\t\n\t      /**\n\t       * Provides coordinates for an element to be positioned relative to\n\t       * another element.  Passing 'auto' as part of the placement parameter\n\t       * will enable smart placement - where the element fits. i.e:\n\t       * 'auto left-top' will check to see if there is enough space to the left\n\t       * of the hostElem to fit the targetElem, if not place right (same for secondary\n\t       * top placement).  Available space is calculated using the viewportOffset\n\t       * function.\n\t       *\n\t       * @param {element} hostElem - The element to position against.\n\t       * @param {element} targetElem - The element to position.\n\t       * @param {string=} [placement=top] - The placement for the targetElem,\n\t       *   default is 'top'. 'center' is assumed as secondary placement for\n\t       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:\n\t       *   <ul>\n\t       *     <li>top</li>\n\t       *     <li>top-right</li>\n\t       *     <li>top-left</li>\n\t       *     <li>bottom</li>\n\t       *     <li>bottom-left</li>\n\t       *     <li>bottom-right</li>\n\t       *     <li>left</li>\n\t       *     <li>left-top</li>\n\t       *     <li>left-bottom</li>\n\t       *     <li>right</li>\n\t       *     <li>right-top</li>\n\t       *     <li>right-bottom</li>\n\t       *   </ul>\n\t       * @param {boolean=} [appendToBody=false] - Should the top and left values returned\n\t       *   be calculated from the body element, default is false.\n\t       *\n\t       * @returns {object} An object with the following properties:\n\t       *   <ul>\n\t       *     <li>**top**: Value for targetElem top.</li>\n\t       *     <li>**left**: Value for targetElem left.</li>\n\t       *     <li>**placement**: The resolved placement.</li>\n\t       *   </ul>\n\t       */\n\t      positionElements: function(hostElem, targetElem, placement, appendToBody) {\n\t        hostElem = this.getRawNode(hostElem);\n\t        targetElem = this.getRawNode(targetElem);\n\t\n\t        // need to read from prop to support tests.\n\t        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');\n\t        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');\n\t\n\t        placement = this.parsePlacement(placement);\n\t\n\t        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);\n\t        var targetElemPos = {top: 0, left: 0, placement: ''};\n\t\n\t        if (placement[2]) {\n\t          var viewportOffset = this.viewportOffset(hostElem);\n\t\n\t          var targetElemStyle = $window.getComputedStyle(targetElem);\n\t          var adjustedSize = {\n\t            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),\n\t            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))\n\t          };\n\t\n\t          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :\n\t                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :\n\t                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :\n\t                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :\n\t                         placement[0];\n\t\n\t          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :\n\t                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :\n\t                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :\n\t                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :\n\t                         placement[1];\n\t\n\t          if (placement[1] === 'center') {\n\t            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n\t              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;\n\t              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {\n\t                placement[1] = 'left';\n\t              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {\n\t                placement[1] = 'right';\n\t              }\n\t            } else {\n\t              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;\n\t              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {\n\t                placement[1] = 'top';\n\t              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {\n\t                placement[1] = 'bottom';\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        switch (placement[0]) {\n\t          case 'top':\n\t            targetElemPos.top = hostElemPos.top - targetHeight;\n\t            break;\n\t          case 'bottom':\n\t            targetElemPos.top = hostElemPos.top + hostElemPos.height;\n\t            break;\n\t          case 'left':\n\t            targetElemPos.left = hostElemPos.left - targetWidth;\n\t            break;\n\t          case 'right':\n\t            targetElemPos.left = hostElemPos.left + hostElemPos.width;\n\t            break;\n\t        }\n\t\n\t        switch (placement[1]) {\n\t          case 'top':\n\t            targetElemPos.top = hostElemPos.top;\n\t            break;\n\t          case 'bottom':\n\t            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;\n\t            break;\n\t          case 'left':\n\t            targetElemPos.left = hostElemPos.left;\n\t            break;\n\t          case 'right':\n\t            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;\n\t            break;\n\t          case 'center':\n\t            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n\t              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;\n\t            } else {\n\t              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;\n\t            }\n\t            break;\n\t        }\n\t\n\t        targetElemPos.top = Math.round(targetElemPos.top);\n\t        targetElemPos.left = Math.round(targetElemPos.left);\n\t        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];\n\t\n\t        return targetElemPos;\n\t      },\n\t\n\t      /**\n\t      * Provides a way for positioning tooltip & dropdown\n\t      * arrows when using placement options beyond the standard\n\t      * left, right, top, or bottom.\n\t      *\n\t      * @param {element} elem - The tooltip/dropdown element.\n\t      * @param {string} placement - The placement for the elem.\n\t      */\n\t      positionArrow: function(elem, placement) {\n\t        elem = this.getRawNode(elem);\n\t\n\t        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');\n\t        if (!innerElem) {\n\t          return;\n\t        }\n\t\n\t        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');\n\t\n\t        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');\n\t        if (!arrowElem) {\n\t          return;\n\t        }\n\t\n\t        var arrowCss = {\n\t          top: '',\n\t          bottom: '',\n\t          left: '',\n\t          right: ''\n\t        };\n\t\n\t        placement = this.parsePlacement(placement);\n\t        if (placement[1] === 'center') {\n\t          // no adjustment necessary - just reset styles\n\t          angular.element(arrowElem).css(arrowCss);\n\t          return;\n\t        }\n\t\n\t        var borderProp = 'border-' + placement[0] + '-width';\n\t        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];\n\t\n\t        var borderRadiusProp = 'border-';\n\t        if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n\t          borderRadiusProp += placement[0] + '-' + placement[1];\n\t        } else {\n\t          borderRadiusProp += placement[1] + '-' + placement[0];\n\t        }\n\t        borderRadiusProp += '-radius';\n\t        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];\n\t\n\t        switch (placement[0]) {\n\t          case 'top':\n\t            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t          case 'bottom':\n\t            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t          case 'left':\n\t            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t          case 'right':\n\t            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;\n\t            break;\n\t        }\n\t\n\t        arrowCss[placement[1]] = borderRadius;\n\t\n\t        angular.element(arrowElem).css(arrowCss);\n\t      }\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position'])\n\t\n\t.value('$datepickerSuppressError', false)\n\t.value('uibDatepickerAttributeWarning', true)\n\t\n\t.constant('uibDatepickerConfig', {\n\t  datepickerMode: 'day',\n\t  formatDay: 'dd',\n\t  formatMonth: 'MMMM',\n\t  formatYear: 'yyyy',\n\t  formatDayHeader: 'EEE',\n\t  formatDayTitle: 'MMMM yyyy',\n\t  formatMonthTitle: 'yyyy',\n\t  maxDate: null,\n\t  maxMode: 'year',\n\t  minDate: null,\n\t  minMode: 'day',\n\t  ngModelOptions: {},\n\t  shortcutPropagation: false,\n\t  showWeeks: true,\n\t  yearColumns: 5,\n\t  yearRows: 4\n\t})\n\t\n\t.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', 'uibDatepickerAttributeWarning', 'uibDateParser',\n\t  function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerSuppressError, datepickerAttributeWarning, dateParser) {\n\t  var self = this,\n\t      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;\n\t      ngModelOptions = {},\n\t      watchListeners = [],\n\t      optionsUsed = !!$attrs.datepickerOptions;\n\t\n\t  // Modes chain\n\t  this.modes = ['day', 'month', 'year'];\n\t\n\t  if (optionsUsed) {\n\t    [\n\t      'customClass',\n\t      'dateDisabled',\n\t      'datepickerMode',\n\t      'formatDay',\n\t      'formatDayHeader',\n\t      'formatDayTitle',\n\t      'formatMonth',\n\t      'formatMonthTitle',\n\t      'formatYear',\n\t      'initDate',\n\t      'maxDate',\n\t      'maxMode',\n\t      'minDate',\n\t      'minMode',\n\t      'showWeeks',\n\t      'shortcutPropagation',\n\t      'startingDay',\n\t      'yearColumns',\n\t      'yearRows'\n\t    ].forEach(function(key) {\n\t      switch (key) {\n\t        case 'customClass':\n\t        case 'dateDisabled':\n\t          $scope[key] = $scope.datepickerOptions[key] || angular.noop;\n\t          break;\n\t        case 'datepickerMode':\n\t          $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?\n\t            $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;\n\t          break;\n\t        case 'formatDay':\n\t        case 'formatDayHeader':\n\t        case 'formatDayTitle':\n\t        case 'formatMonth':\n\t        case 'formatMonthTitle':\n\t        case 'formatYear':\n\t          self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n\t            $interpolate($scope.datepickerOptions[key])($scope.$parent) :\n\t            datepickerConfig[key];\n\t          break;\n\t        case 'showWeeks':\n\t        case 'shortcutPropagation':\n\t        case 'yearColumns':\n\t        case 'yearRows':\n\t          self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n\t            $scope.datepickerOptions[key] : datepickerConfig[key];\n\t          break;\n\t        case 'startingDay':\n\t          if (angular.isDefined($scope.datepickerOptions.startingDay)) {\n\t            self.startingDay = $scope.datepickerOptions.startingDay;\n\t          } else if (angular.isNumber(datepickerConfig.startingDay)) {\n\t            self.startingDay = datepickerConfig.startingDay;\n\t          } else {\n\t            self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n\t          }\n\t\n\t          break;\n\t        case 'maxDate':\n\t        case 'minDate':\n\t          if ($scope.datepickerOptions[key]) {\n\t            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n\t              if (value) {\n\t                if (angular.isDate(value)) {\n\t                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n\t                } else {\n\t                  self[key] = new Date(dateFilter(value, 'medium'));\n\t                }\n\t              } else {\n\t                self[key] = null;\n\t              }\n\t\n\t              self.refreshView();\n\t            });\n\t          } else {\n\t            self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;\n\t          }\n\t\n\t          break;\n\t        case 'maxMode':\n\t        case 'minMode':\n\t          if ($scope.datepickerOptions[key]) {\n\t            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n\t              self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];\n\t              if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||\n\t                key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {\n\t                $scope.datepickerMode = self[key];\n\t                $scope.datepickerOptions.datepickerMode = self[key];\n\t              }\n\t            });\n\t          } else {\n\t            self[key] = $scope[key] = datepickerConfig[key] || null;\n\t          }\n\t\n\t          break;\n\t        case 'initDate':\n\t          if ($scope.datepickerOptions.initDate) {\n\t            self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();\n\t            $scope.$watch(function() { return $scope.datepickerOptions.initDate; }, function(initDate) {\n\t              if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t                self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n\t                self.refreshView();\n\t              }\n\t            });\n\t          } else {\n\t            self.activeDate = new Date();\n\t          }\n\t      }\n\t    });\n\t  } else {\n\t    // Interpolated configuration attributes\n\t    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle'], function(key) {\n\t      self[key] = angular.isDefined($attrs[key]) ? $interpolate($attrs[key])($scope.$parent) : datepickerConfig[key];\n\t\n\t      if (angular.isDefined($attrs[key]) && datepickerAttributeWarning) {\n\t        $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n\t      }\n\t    });\n\t\n\t    // Evaled configuration attributes\n\t    angular.forEach(['showWeeks', 'yearRows', 'yearColumns', 'shortcutPropagation'], function(key) {\n\t      self[key] = angular.isDefined($attrs[key]) ?\n\t        $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];\n\t\n\t      if (angular.isDefined($attrs[key]) && datepickerAttributeWarning) {\n\t        $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n\t      }\n\t    });\n\t\n\t    angular.forEach(['dateDisabled', 'customClass'], function(key) {\n\t      if (angular.isDefined($attrs[key]) && datepickerAttributeWarning) {\n\t        $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n\t      }\n\t    });\n\t\n\t    if (angular.isDefined($attrs.startingDay)) {\n\t      if (datepickerAttributeWarning) {\n\t        $log.warn('uib-datepicker startingDay attribute usage is deprecated, use datepicker-options attribute instead');\n\t      }\n\t\n\t      self.startingDay = $scope.$parent.$eval($attrs.startingDay);\n\t    } else if (angular.isNumber(datepickerConfig.startingDay)) {\n\t      self.startingDay = datepickerConfig.startingDay;\n\t    } else {\n\t      self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n\t    }\n\t\n\t    // Watchable date attributes\n\t    angular.forEach(['minDate', 'maxDate'], function(key) {\n\t      if ($attrs[key]) {\n\t        if (datepickerAttributeWarning) {\n\t          $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n\t        }\n\t\n\t        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {\n\t          if (value) {\n\t            if (angular.isDate(value)) {\n\t              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n\t            } else {\n\t              self[key] = new Date(dateFilter(value, 'medium'));\n\t            }\n\t          } else {\n\t            self[key] = null;\n\t          }\n\t\n\t          self.refreshView();\n\t        }));\n\t      } else {\n\t        self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;\n\t      }\n\t    });\n\t\n\t    angular.forEach(['minMode', 'maxMode'], function(key) {\n\t      if ($attrs[key]) {\n\t        if (datepickerAttributeWarning) {\n\t          $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n\t        }\n\t\n\t        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {\n\t          self[key] = $scope[key] = angular.isDefined(value) ? value : $attrs[key];\n\t          if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||\n\t            key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {\n\t            $scope.datepickerMode = self[key];\n\t          }\n\t        }));\n\t      } else {\n\t        self[key] = $scope[key] = datepickerConfig[key] || null;\n\t      }\n\t    });\n\t\n\t    if (angular.isDefined($attrs.initDate)) {\n\t      if (datepickerAttributeWarning) {\n\t        $log.warn('uib-datepicker initDate attribute usage is deprecated, use datepicker-options attribute instead');\n\t      }\n\t\n\t      var initDate = dateParser.fromTimezone($scope.$parent.$eval($attrs.initDate), ngModelOptions.timezone);\n\t      this.activeDate = !isNaN(initDate) ? initDate : new Date();\n\t      watchListeners.push($scope.$parent.$watch($attrs.initDate, function(initDate) {\n\t        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n\t          initDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n\t          self.activeDate = !isNaN(initDate) ? initDate : new Date();\n\t          self.refreshView();\n\t        }\n\t      }));\n\t    } else {\n\t      this.activeDate = new Date();\n\t    }\n\t\n\t    if ($attrs.datepickerMode && datepickerAttributeWarning) {\n\t      $log.warn('uib-datepicker datepickerMode attribute usage is deprecated, use datepicker-options attribute instead');\n\t    }\n\t\n\t    $scope.datepickerMode = $scope.datepickerMode ||\n\t      datepickerConfig.datepickerMode;\n\t  }\n\t\n\t  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t\n\t  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n\t  if (angular.isDefined($attrs.ngDisabled)) {\n\t    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {\n\t      $scope.disabled = disabled;\n\t      self.refreshView();\n\t    }));\n\t  }\n\t\n\t  $scope.isActive = function(dateObject) {\n\t    if (self.compare(dateObject.date, self.activeDate) === 0) {\n\t      $scope.activeDateId = dateObject.uid;\n\t      return true;\n\t    }\n\t    return false;\n\t  };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;\n\t\n\t    this.activeDate = ngModelCtrl.$modelValue || new Date();\n\t\n\t    ngModelCtrl.$render = function() {\n\t      self.render();\n\t    };\n\t  };\n\t\n\t  this.render = function() {\n\t    if (ngModelCtrl.$viewValue) {\n\t      var date = new Date(ngModelCtrl.$viewValue),\n\t          isValid = !isNaN(date);\n\t\n\t      if (isValid) {\n\t        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);\n\t      } else if (!$datepickerSuppressError) {\n\t        $log.error('Datepicker directive: \"ng-model\" value must be a Date object');\n\t      }\n\t    }\n\t    this.refreshView();\n\t  };\n\t\n\t  this.refreshView = function() {\n\t    if (this.element) {\n\t      $scope.selectedDt = null;\n\t      this._refreshView();\n\t      if ($scope.activeDt) {\n\t        $scope.activeDateId = $scope.activeDt.uid;\n\t      }\n\t\n\t      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t      date = dateParser.fromTimezone(date, ngModelOptions.timezone);\n\t      ngModelCtrl.$setValidity('dateDisabled', !date ||\n\t        this.element && !this.isDisabled(date));\n\t    }\n\t  };\n\t\n\t  this.createDateObject = function(date, format) {\n\t    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n\t    model = dateParser.fromTimezone(model, ngModelOptions.timezone);\n\t    var dt = {\n\t      date: date,\n\t      label: dateParser.filter(date, format),\n\t      selected: model && this.compare(date, model) === 0,\n\t      disabled: this.isDisabled(date),\n\t      current: this.compare(date, new Date()) === 0,\n\t      customClass: this.customClass(date) || null\n\t    };\n\t\n\t    if (model && this.compare(date, model) === 0) {\n\t      $scope.selectedDt = dt;\n\t    }\n\t\n\t    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {\n\t      $scope.activeDt = dt;\n\t    }\n\t\n\t    return dt;\n\t  };\n\t\n\t  this.isDisabled = function(date) {\n\t    return $scope.disabled ||\n\t      this.minDate && this.compare(date, this.minDate) < 0 ||\n\t      this.maxDate && this.compare(date, this.maxDate) > 0 ||\n\t      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  this.customClass = function(date) {\n\t    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n\t  };\n\t\n\t  // Split array into smaller arrays\n\t  this.split = function(arr, size) {\n\t    var arrays = [];\n\t    while (arr.length > 0) {\n\t      arrays.push(arr.splice(0, size));\n\t    }\n\t    return arrays;\n\t  };\n\t\n\t  $scope.select = function(date) {\n\t    if ($scope.datepickerMode === self.minMode) {\n\t      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);\n\t      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n\t      dt = dateParser.toTimezone(dt, ngModelOptions.timezone);\n\t      ngModelCtrl.$setViewValue(dt);\n\t      ngModelCtrl.$render();\n\t    } else {\n\t      self.activeDate = date;\n\t      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);\n\t\n\t      $scope.$emit('uib:datepicker.mode');\n\t    }\n\t  };\n\t\n\t  $scope.move = function(direction) {\n\t    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n\t        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n\t    self.activeDate.setFullYear(year, month, 1);\n\t    self.refreshView();\n\t  };\n\t\n\t  $scope.toggleMode = function(direction) {\n\t    direction = direction || 1;\n\t\n\t    if ($scope.datepickerMode === self.maxMode && direction === 1 ||\n\t      $scope.datepickerMode === self.minMode && direction === -1) {\n\t      return;\n\t    }\n\t\n\t    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);\n\t\n\t    $scope.$emit('uib:datepicker.mode');\n\t  };\n\t\n\t  // Key event mapper\n\t  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\t\n\t  var focusElement = function() {\n\t    self.element[0].focus();\n\t  };\n\t\n\t  // Listen for focus requests from popup directive\n\t  $scope.$on('uib:datepicker.focus', focusElement);\n\t\n\t  $scope.keydown = function(evt) {\n\t    var key = $scope.keys[evt.which];\n\t\n\t    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {\n\t      return;\n\t    }\n\t\n\t    evt.preventDefault();\n\t    if (!self.shortcutPropagation) {\n\t      evt.stopPropagation();\n\t    }\n\t\n\t    if (key === 'enter' || key === 'space') {\n\t      if (self.isDisabled(self.activeDate)) {\n\t        return; // do nothing\n\t      }\n\t      $scope.select(self.activeDate);\n\t    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n\t      $scope.toggleMode(key === 'up' ? 1 : -1);\n\t    } else {\n\t      self.handleKeyDown(key, evt);\n\t      self.refreshView();\n\t    }\n\t  };\n\t\n\t  $scope.$on(\"$destroy\", function() {\n\t    //Clear all watch listeners on destroy\n\t    while (watchListeners.length) {\n\t      watchListeners.shift()();\n\t    }\n\t  });\n\t\n\t  function setMode(mode) {\n\t    $scope.datepickerMode = mode;\n\t    if (optionsUsed) {\n\t      $scope.datepickerOptions.datepickerMode = mode;\n\t    }\n\t  }\n\t}])\n\t\n\t.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\t\n\t  this.step = { months: 1 };\n\t  this.element = $element;\n\t  function getDaysInMonth(year, month) {\n\t    return month === 1 && year % 4 === 0 &&\n\t      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];\n\t  }\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    scope.showWeeks = ctrl.showWeeks;\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this.getDates = function(startDate, n) {\n\t    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n\t    while (i < n) {\n\t      date = new Date(current);\n\t      dates[i++] = date;\n\t      current.setDate(current.getDate() + 1);\n\t    }\n\t    return dates;\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var year = this.activeDate.getFullYear(),\n\t      month = this.activeDate.getMonth(),\n\t      firstDayOfMonth = new Date(this.activeDate);\n\t\n\t    firstDayOfMonth.setFullYear(year, month, 1);\n\t\n\t    var difference = this.startingDay - firstDayOfMonth.getDay(),\n\t      numDisplayedFromPreviousMonth = difference > 0 ?\n\t        7 - difference : - difference,\n\t      firstDate = new Date(firstDayOfMonth);\n\t\n\t    if (numDisplayedFromPreviousMonth > 0) {\n\t      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n\t    }\n\t\n\t    // 42 is the number of days on a six-week calendar\n\t    var days = this.getDates(firstDate, 42);\n\t    for (var i = 0; i < 42; i ++) {\n\t      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n\t        secondary: days[i].getMonth() !== month,\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.labels = new Array(7);\n\t    for (var j = 0; j < 7; j++) {\n\t      scope.labels[j] = {\n\t        abbr: dateFilter(days[j].date, this.formatDayHeader),\n\t        full: dateFilter(days[j].date, 'EEEE')\n\t      };\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n\t    scope.rows = this.split(days, 7);\n\t\n\t    if (scope.showWeeks) {\n\t      scope.weekNumbers = [];\n\t      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n\t          numWeeks = scope.rows.length;\n\t      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n\t        scope.weekNumbers.push(\n\t          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n\t      }\n\t    }\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\n\t    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n\t    _date1.setFullYear(date1.getFullYear());\n\t    _date2.setFullYear(date2.getFullYear());\n\t    return _date1 - _date2;\n\t  };\n\t\n\t  function getISO8601WeekNumber(date) {\n\t    var checkDate = new Date(date);\n\t    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n\t    var time = checkDate.getTime();\n\t    checkDate.setMonth(0); // Compare with Jan 1\n\t    checkDate.setDate(1);\n\t    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t  }\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getDate();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;\n\t    } else if (key === 'up') {\n\t      date = date - 7;\n\t    } else if (key === 'right') {\n\t      date = date + 1;\n\t    } else if (key === 'down') {\n\t      date = date + 7;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setMonth(month, 1);\n\t      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n\t    } else if (key === 'home') {\n\t      date = 1;\n\t    } else if (key === 'end') {\n\t      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n\t    }\n\t    this.activeDate.setDate(date);\n\t  };\n\t}])\n\t\n\t.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  this.step = { years: 1 };\n\t  this.element = $element;\n\t\n\t  this.init = function(ctrl) {\n\t    angular.extend(ctrl, this);\n\t    ctrl.refreshView();\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var months = new Array(12),\n\t        year = this.activeDate.getFullYear(),\n\t        date;\n\t\n\t    for (var i = 0; i < 12; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(year, i, 1);\n\t      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n\t    scope.rows = this.split(months, 3);\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    var _date1 = new Date(date1.getFullYear(), date1.getMonth());\n\t    var _date2 = new Date(date2.getFullYear(), date2.getMonth());\n\t    _date1.setFullYear(date1.getFullYear());\n\t    _date2.setFullYear(date2.getFullYear());\n\t    return _date1 - _date2;\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getMonth();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;\n\t    } else if (key === 'up') {\n\t      date = date - 3;\n\t    } else if (key === 'right') {\n\t      date = date + 1;\n\t    } else if (key === 'down') {\n\t      date = date + 3;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n\t      this.activeDate.setFullYear(year);\n\t    } else if (key === 'home') {\n\t      date = 0;\n\t    } else if (key === 'end') {\n\t      date = 11;\n\t    }\n\t    this.activeDate.setMonth(date);\n\t  };\n\t}])\n\t\n\t.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n\t  var columns, range;\n\t  this.element = $element;\n\t\n\t  function getStartingYear(year) {\n\t    return parseInt((year - 1) / range, 10) * range + 1;\n\t  }\n\t\n\t  this.yearpickerInit = function() {\n\t    columns = this.yearColumns;\n\t    range = this.yearRows * columns;\n\t    this.step = { years: range };\n\t  };\n\t\n\t  this._refreshView = function() {\n\t    var years = new Array(range), date;\n\t\n\t    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n\t      date = new Date(this.activeDate);\n\t      date.setFullYear(start + i, 0, 1);\n\t      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n\t        uid: scope.uniqueId + '-' + i\n\t      });\n\t    }\n\t\n\t    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n\t    scope.rows = this.split(years, columns);\n\t    scope.columns = columns;\n\t  };\n\t\n\t  this.compare = function(date1, date2) {\n\t    return date1.getFullYear() - date2.getFullYear();\n\t  };\n\t\n\t  this.handleKeyDown = function(key, evt) {\n\t    var date = this.activeDate.getFullYear();\n\t\n\t    if (key === 'left') {\n\t      date = date - 1;\n\t    } else if (key === 'up') {\n\t      date = date - columns;\n\t    } else if (key === 'right') {\n\t      date = date + 1;\n\t    } else if (key === 'down') {\n\t      date = date + columns;\n\t    } else if (key === 'pageup' || key === 'pagedown') {\n\t      date += (key === 'pageup' ? - 1 : 1) * range;\n\t    } else if (key === 'home') {\n\t      date = getStartingYear(this.activeDate.getFullYear());\n\t    } else if (key === 'end') {\n\t      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n\t    }\n\t    this.activeDate.setFullYear(date);\n\t  };\n\t}])\n\t\n\t.directive('uibDatepicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';\n\t    },\n\t    scope: {\n\t      datepickerMode: '=?',\n\t      datepickerOptions: '=?',\n\t      dateDisabled: '&',\n\t      customClass: '&',\n\t      shortcutPropagation: '&?'\n\t    },\n\t    require: ['uibDatepicker', '^ngModel'],\n\t    controller: 'UibDatepickerController',\n\t    controllerAs: 'datepicker',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      datepickerCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDaypicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/day.html';\n\t    },\n\t    require: ['^uibDatepicker', 'uibDaypicker'],\n\t    controller: 'UibDaypickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0],\n\t        daypickerCtrl = ctrls[1];\n\t\n\t      daypickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibMonthpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/month.html';\n\t    },\n\t    require: ['^uibDatepicker', 'uibMonthpicker'],\n\t    controller: 'UibMonthpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var datepickerCtrl = ctrls[0],\n\t        monthpickerCtrl = ctrls[1];\n\t\n\t      monthpickerCtrl.init(datepickerCtrl);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibYearpicker', function() {\n\t  return {\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/year.html';\n\t    },\n\t    require: ['^uibDatepicker', 'uibYearpicker'],\n\t    controller: 'UibYearpickerController',\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ctrl = ctrls[0];\n\t      angular.extend(ctrl, ctrls[1]);\n\t      ctrl.yearpickerInit();\n\t\n\t      ctrl.refreshView();\n\t    }\n\t  };\n\t})\n\t\n\t.value('uibDatepickerPopupAttributeWarning', true)\n\t\n\t.constant('uibDatepickerPopupConfig', {\n\t  altInputFormats: [],\n\t  appendToBody: false,\n\t  clearText: 'Clear',\n\t  closeOnDateSelection: true,\n\t  closeText: 'Done',\n\t  currentText: 'Today',\n\t  datepickerPopup: 'yyyy-MM-dd',\n\t  datepickerPopupTemplateUrl: 'uib/template/datepicker/popup.html',\n\t  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',\n\t  html5Types: {\n\t    date: 'yyyy-MM-dd',\n\t    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n\t    'month': 'yyyy-MM'\n\t  },\n\t  onOpenFocus: true,\n\t  showButtonBar: true,\n\t  placement: 'auto bottom-left'\n\t})\n\t\n\t.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', 'uibDatepickerPopupAttributeWarning',\n\tfunction($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, datepickerPopupAttributeWarning) {\n\t  var cache = {},\n\t    isHtml5DateInput = false;\n\t  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n\t    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,\n\t    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];\n\t\n\t  $scope.watchData = {};\n\t\n\t  this.init = function(_ngModel_) {\n\t    ngModel = _ngModel_;\n\t    ngModelOptions = _ngModel_.$options || datepickerConfig.ngModelOptions;\n\t    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?\n\t      $scope.$parent.$eval($attrs.closeOnDateSelection) :\n\t      datepickerPopupConfig.closeOnDateSelection;\n\t    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?\n\t      $scope.$parent.$eval($attrs.datepickerAppendToBody) :\n\t      datepickerPopupConfig.appendToBody;\n\t    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?\n\t      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n\t    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?\n\t      $attrs.datepickerPopupTemplateUrl :\n\t      datepickerPopupConfig.datepickerPopupTemplateUrl;\n\t    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?\n\t      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n\t    altInputFormats = angular.isDefined($attrs.altInputFormats) ?\n\t      $scope.$parent.$eval($attrs.altInputFormats) :\n\t      datepickerPopupConfig.altInputFormats;\n\t\n\t    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?\n\t      $scope.$parent.$eval($attrs.showButtonBar) :\n\t      datepickerPopupConfig.showButtonBar;\n\t\n\t    if (datepickerPopupConfig.html5Types[$attrs.type]) {\n\t      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];\n\t      isHtml5DateInput = true;\n\t    } else {\n\t      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n\t      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n\t        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n\t        // Invalidate the $modelValue to ensure that formatters re-run\n\t        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n\t        if (newDateFormat !== dateFormat) {\n\t          dateFormat = newDateFormat;\n\t          ngModel.$modelValue = null;\n\t\n\t          if (!dateFormat) {\n\t            throw new Error('uibDatepickerPopup must have a date format specified.');\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    if (!dateFormat) {\n\t      throw new Error('uibDatepickerPopup must have a date format specified.');\n\t    }\n\t\n\t    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {\n\t      throw new Error('HTML5 date input types do not support custom formats.');\n\t    }\n\t\n\t    // popup element used to display calendar\n\t    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n\t    $scope.ngModelOptions = angular.copy(ngModelOptions);\n\t    $scope.ngModelOptions.timezone = null;\n\t    if ($scope.ngModelOptions.updateOnDefault === true) {\n\t      $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ?\n\t        $scope.ngModelOptions.updateOn + ' default' : 'default';\n\t    }\n\t\n\t    popupEl.attr({\n\t      'ng-model': 'date',\n\t      'ng-model-options': 'ngModelOptions',\n\t      'ng-change': 'dateSelection(date)',\n\t      'template-url': datepickerPopupTemplateUrl\n\t    });\n\t\n\t    // datepicker element\n\t    datepickerEl = angular.element(popupEl.children()[0]);\n\t    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\t\n\t    if (isHtml5DateInput) {\n\t      if ($attrs.type === 'month') {\n\t        datepickerEl.attr('datepicker-mode', '\"month\"');\n\t        datepickerEl.attr('min-mode', 'month');\n\t      }\n\t    }\n\t\n\t    if ($scope.datepickerOptions) {\n\t      datepickerEl.attr('datepicker-options', 'datepickerOptions');\n\t    }\n\t\n\t    angular.forEach(['minMode', 'maxMode', 'datepickerMode', 'shortcutPropagation'], function(key) {\n\t      if ($attrs[key]) {\n\t        if (datepickerPopupAttributeWarning) {\n\t          $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n\t        }\n\t\n\t        var getAttribute = $parse($attrs[key]);\n\t        var propConfig = {\n\t          get: function() {\n\t            return getAttribute($scope.$parent);\n\t          }\n\t        };\n\t\n\t        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\t\n\t        // Propagate changes from datepicker to outside\n\t        if (key === 'datepickerMode') {\n\t          var setAttribute = getAttribute.assign;\n\t          propConfig.set = function(v) {\n\t            setAttribute($scope.$parent, v);\n\t          };\n\t        }\n\t\n\t        Object.defineProperty($scope.watchData, key, propConfig);\n\t      }\n\t    });\n\t\n\t    angular.forEach(['minDate', 'maxDate', 'initDate'], function(key) {\n\t      if ($attrs[key]) {\n\t        if (datepickerPopupAttributeWarning) {\n\t          $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n\t        }\n\t\n\t        var getAttribute = $parse($attrs[key]);\n\t\n\t        watchListeners.push($scope.$parent.$watch(getAttribute, function(value) {\n\t          if (key === 'minDate' || key === 'maxDate') {\n\t            if (value === null) {\n\t              cache[key] = null;\n\t            } else if (angular.isDate(value)) {\n\t              cache[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n\t            } else {\n\t              cache[key] = new Date(dateFilter(value, 'medium'));\n\t            }\n\t\n\t            $scope.watchData[key] = value === null ? null : cache[key];\n\t          } else {\n\t            var date = value ? new Date(value) : new Date();\n\t            $scope.watchData[key] = dateParser.fromTimezone(date, ngModelOptions.timezone);\n\t          }\n\t        }));\n\t\n\t        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\t      }\n\t    });\n\t\n\t    if ($attrs.dateDisabled) {\n\t      if (datepickerPopupAttributeWarning) {\n\t        $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n\t      }\n\t\n\t      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n\t    }\n\t\n\t    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRows', 'yearColumns'], function(key) {\n\t      if (angular.isDefined($attrs[key])) {\n\t        if (datepickerPopupAttributeWarning) {\n\t          $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n\t        }\n\t\n\t        datepickerEl.attr(cameltoDash(key), $attrs[key]);\n\t      }\n\t    });\n\t\n\t    if ($attrs.customClass) {\n\t      if (datepickerPopupAttributeWarning) {\n\t        $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n\t      }\n\t\n\t      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n\t    }\n\t\n\t    if (!isHtml5DateInput) {\n\t      // Internal API to maintain the correct ng-invalid-[key] class\n\t      ngModel.$$parserName = 'date';\n\t      ngModel.$validators.date = validator;\n\t      ngModel.$parsers.unshift(parseDate);\n\t      ngModel.$formatters.push(function(value) {\n\t        if (ngModel.$isEmpty(value)) {\n\t          $scope.date = value;\n\t          return value;\n\t        }\n\t\n\t        $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);\n\t\n\t        if (angular.isNumber($scope.date)) {\n\t          $scope.date = new Date($scope.date);\n\t        }\n\t\n\t        return dateParser.filter($scope.date, dateFormat);\n\t      });\n\t    } else {\n\t      ngModel.$formatters.push(function(value) {\n\t        $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);\n\t        return value;\n\t      });\n\t    }\n\t\n\t    // Detect changes in the view from the text box\n\t    ngModel.$viewChangeListeners.push(function() {\n\t      $scope.date = parseDateString(ngModel.$viewValue);\n\t    });\n\t\n\t    $element.on('keydown', inputKeydownBind);\n\t\n\t    $popup = $compile(popupEl)($scope);\n\t    // Prevent jQuery cache memory leak (template is now redundant after linking)\n\t    popupEl.remove();\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else {\n\t      $element.after($popup);\n\t    }\n\t\n\t    $scope.$on('$destroy', function() {\n\t      if ($scope.isOpen === true) {\n\t        if (!$rootScope.$$phase) {\n\t          $scope.$apply(function() {\n\t            $scope.isOpen = false;\n\t          });\n\t        }\n\t      }\n\t\n\t      $popup.remove();\n\t      $element.off('keydown', inputKeydownBind);\n\t      $document.off('click', documentClickBind);\n\t      if (scrollParentEl) {\n\t        scrollParentEl.off('scroll', positionPopup);\n\t      }\n\t      angular.element($window).off('resize', positionPopup);\n\t\n\t      //Clear all watch listeners on destroy\n\t      while (watchListeners.length) {\n\t        watchListeners.shift()();\n\t      }\n\t    });\n\t  };\n\t\n\t  $scope.getText = function(key) {\n\t    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n\t  };\n\t\n\t  $scope.isDisabled = function(date) {\n\t    if (date === 'today') {\n\t      date = new Date();\n\t    }\n\t\n\t    return $scope.watchData.minDate && $scope.compare(date, cache.minDate) < 0 ||\n\t        $scope.watchData.maxDate && $scope.compare(date, cache.maxDate) > 0;\n\t  };\n\t\n\t  $scope.compare = function(date1, date2) {\n\t    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n\t  };\n\t\n\t  // Inner change\n\t  $scope.dateSelection = function(dt) {\n\t    if (angular.isDefined(dt)) {\n\t      $scope.date = dt;\n\t    }\n\t    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n\t    $element.val(date);\n\t    ngModel.$setViewValue(date);\n\t\n\t    if (closeOnDateSelection) {\n\t      $scope.isOpen = false;\n\t      $element[0].focus();\n\t    }\n\t  };\n\t\n\t  $scope.keydown = function(evt) {\n\t    if (evt.which === 27) {\n\t      evt.stopPropagation();\n\t      $scope.isOpen = false;\n\t      $element[0].focus();\n\t    }\n\t  };\n\t\n\t  $scope.select = function(date, evt) {\n\t    evt.stopPropagation();\n\t\n\t    if (date === 'today') {\n\t      var today = new Date();\n\t      if (angular.isDate($scope.date)) {\n\t        date = new Date($scope.date);\n\t        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n\t      } else {\n\t        date = new Date(today.setHours(0, 0, 0, 0));\n\t      }\n\t    }\n\t    $scope.dateSelection(date);\n\t  };\n\t\n\t  $scope.close = function(evt) {\n\t    evt.stopPropagation();\n\t\n\t    $scope.isOpen = false;\n\t    $element[0].focus();\n\t  };\n\t\n\t  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n\t  if ($attrs.ngDisabled) {\n\t    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {\n\t      $scope.disabled = disabled;\n\t    }));\n\t  }\n\t\n\t  $scope.$watch('isOpen', function(value) {\n\t    if (value) {\n\t      if (!$scope.disabled) {\n\t        $timeout(function() {\n\t          positionPopup();\n\t\n\t          if (onOpenFocus) {\n\t            $scope.$broadcast('uib:datepicker.focus');\n\t          }\n\t          $document.on('click', documentClickBind);\n\t\n\t          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n\t          if (appendToBody || $position.parsePlacement(placement)[2]) {\n\t            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));\n\t            if (scrollParentEl) {\n\t              scrollParentEl.on('scroll', positionPopup);\n\t            }\n\t          } else {\n\t            scrollParentEl = null;\n\t          }\n\t\n\t          angular.element($window).on('resize', positionPopup);\n\t        }, 0, false);\n\t      } else {\n\t        $scope.isOpen = false;\n\t      }\n\t    } else {\n\t      $document.off('click', documentClickBind);\n\t      if (scrollParentEl) {\n\t        scrollParentEl.off('scroll', positionPopup);\n\t      }\n\t      angular.element($window).off('resize', positionPopup);\n\t    }\n\t  });\n\t\n\t  function cameltoDash(string) {\n\t    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n\t  }\n\t\n\t  function parseDateString(viewValue) {\n\t    var date = dateParser.parse(viewValue, dateFormat, $scope.date);\n\t    if (isNaN(date)) {\n\t      for (var i = 0; i < altInputFormats.length; i++) {\n\t        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);\n\t        if (!isNaN(date)) {\n\t          return date;\n\t        }\n\t      }\n\t    }\n\t    return date;\n\t  }\n\t\n\t  function parseDate(viewValue) {\n\t    if (angular.isNumber(viewValue)) {\n\t      // presumably timestamp to date object\n\t      viewValue = new Date(viewValue);\n\t    }\n\t\n\t    if (!viewValue) {\n\t      return null;\n\t    }\n\t\n\t    if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n\t      return viewValue;\n\t    }\n\t\n\t    if (angular.isString(viewValue)) {\n\t      var date = parseDateString(viewValue);\n\t      if (!isNaN(date)) {\n\t        return dateParser.toTimezone(date, ngModelOptions.timezone);\n\t      }\n\t    }\n\t\n\t    return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;\n\t  }\n\t\n\t  function validator(modelValue, viewValue) {\n\t    var value = modelValue || viewValue;\n\t\n\t    if (!$attrs.ngRequired && !value) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isNumber(value)) {\n\t      value = new Date(value);\n\t    }\n\t\n\t    if (!value) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isDate(value) && !isNaN(value)) {\n\t      return true;\n\t    }\n\t\n\t    if (angular.isString(value)) {\n\t      return !isNaN(parseDateString(viewValue));\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function documentClickBind(event) {\n\t    if (!$scope.isOpen && $scope.disabled) {\n\t      return;\n\t    }\n\t\n\t    var popup = $popup[0];\n\t    var dpContainsTarget = $element[0].contains(event.target);\n\t    // The popup node may not be an element node\n\t    // In some browsers (IE) only element nodes have the 'contains' function\n\t    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n\t    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n\t      $scope.$apply(function() {\n\t        $scope.isOpen = false;\n\t      });\n\t    }\n\t  }\n\t\n\t  function inputKeydownBind(evt) {\n\t    if (evt.which === 27 && $scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.$apply(function() {\n\t        $scope.isOpen = false;\n\t      });\n\t      $element[0].focus();\n\t    } else if (evt.which === 40 && !$scope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.$apply(function() {\n\t        $scope.isOpen = true;\n\t      });\n\t    }\n\t  }\n\t\n\t  function positionPopup() {\n\t    if ($scope.isOpen) {\n\t      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));\n\t      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n\t      var position = $position.positionElements($element, dpElement, placement, appendToBody);\n\t      dpElement.css({top: position.top + 'px', left: position.left + 'px'});\n\t      if (dpElement.hasClass('uib-position-measure')) {\n\t        dpElement.removeClass('uib-position-measure');\n\t      }\n\t    }\n\t  }\n\t\n\t  $scope.$on('uib:datepicker.mode', function() {\n\t    $timeout(positionPopup, 0, false);\n\t  });\n\t}])\n\t\n\t.directive('uibDatepickerPopup', function() {\n\t  return {\n\t    require: ['ngModel', 'uibDatepickerPopup'],\n\t    controller: 'UibDatepickerPopupController',\n\t    scope: {\n\t      datepickerOptions: '=?',\n\t      isOpen: '=?',\n\t      currentText: '@',\n\t      clearText: '@',\n\t      closeText: '@',\n\t      dateDisabled: '&',\n\t      customClass: '&'\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ngModel = ctrls[0],\n\t        ctrl = ctrls[1];\n\t\n\t      ctrl.init(ngModel);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDatepickerPopupWrap', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/datepicker/popup.html';\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.debounce', [])\n\t/**\n\t * A helper, internal service that debounces a function\n\t */\n\t  .factory('$$debounce', ['$timeout', function($timeout) {\n\t    return function(callback, debounceTime) {\n\t      var timeoutPromise;\n\t\n\t      return function() {\n\t        var self = this;\n\t        var args = Array.prototype.slice.call(arguments);\n\t        if (timeoutPromise) {\n\t          $timeout.cancel(timeoutPromise);\n\t        }\n\t\n\t        timeoutPromise = $timeout(function() {\n\t          callback.apply(self, args);\n\t        }, debounceTime);\n\t      };\n\t    };\n\t  }]);\n\t\n\tangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\t\n\t.constant('uibDropdownConfig', {\n\t  appendToOpenClass: 'uib-dropdown-open',\n\t  openClass: 'open'\n\t})\n\t\n\t.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n\t  var openScope = null;\n\t\n\t  this.open = function(dropdownScope) {\n\t    if (!openScope) {\n\t      $document.on('click', closeDropdown);\n\t      $document.on('keydown', keybindFilter);\n\t    }\n\t\n\t    if (openScope && openScope !== dropdownScope) {\n\t      openScope.isOpen = false;\n\t    }\n\t\n\t    openScope = dropdownScope;\n\t  };\n\t\n\t  this.close = function(dropdownScope) {\n\t    if (openScope === dropdownScope) {\n\t      openScope = null;\n\t      $document.off('click', closeDropdown);\n\t      $document.off('keydown', keybindFilter);\n\t    }\n\t  };\n\t\n\t  var closeDropdown = function(evt) {\n\t    // This method may still be called during the same mouse event that\n\t    // unbound this event handler. So check openScope before proceeding.\n\t    if (!openScope) { return; }\n\t\n\t    if (evt && openScope.getAutoClose() === 'disabled') { return; }\n\t\n\t    if (evt && evt.which === 3) { return; }\n\t\n\t    var toggleElement = openScope.getToggleElement();\n\t    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    var dropdownElement = openScope.getDropdownElement();\n\t    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n\t      dropdownElement && dropdownElement[0].contains(evt.target)) {\n\t      return;\n\t    }\n\t\n\t    openScope.isOpen = false;\n\t\n\t    if (!$rootScope.$$phase) {\n\t      openScope.$apply();\n\t    }\n\t  };\n\t\n\t  var keybindFilter = function(evt) {\n\t    if (evt.which === 27) {\n\t      openScope.focusToggleElement();\n\t      closeDropdown();\n\t    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      openScope.focusDropdownEntry(evt.which);\n\t    }\n\t  };\n\t}])\n\t\n\t.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n\t  var self = this,\n\t    scope = $scope.$new(), // create a child scope so we are not polluting original one\n\t    templateScope,\n\t    appendToOpenClass = dropdownConfig.appendToOpenClass,\n\t    openClass = dropdownConfig.openClass,\n\t    getIsOpen,\n\t    setIsOpen = angular.noop,\n\t    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n\t    appendToBody = false,\n\t    appendTo = null,\n\t    keynavEnabled = false,\n\t    selectedOption = null,\n\t    body = $document.find('body');\n\t\n\t  $element.addClass('dropdown');\n\t\n\t  this.init = function() {\n\t    if ($attrs.isOpen) {\n\t      getIsOpen = $parse($attrs.isOpen);\n\t      setIsOpen = getIsOpen.assign;\n\t\n\t      $scope.$watch(getIsOpen, function(value) {\n\t        scope.isOpen = !!value;\n\t      });\n\t    }\n\t\n\t    if (angular.isDefined($attrs.dropdownAppendTo)) {\n\t      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);\n\t      if (appendToEl) {\n\t        appendTo = angular.element(appendToEl);\n\t      }\n\t    }\n\t\n\t    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n\t    keynavEnabled = angular.isDefined($attrs.keyboardNav);\n\t\n\t    if (appendToBody && !appendTo) {\n\t      appendTo = body;\n\t    }\n\t\n\t    if (appendTo && self.dropdownMenu) {\n\t      appendTo.append(self.dropdownMenu);\n\t      $element.on('$destroy', function handleDestroyEvent() {\n\t        self.dropdownMenu.remove();\n\t      });\n\t    }\n\t  };\n\t\n\t  this.toggle = function(open) {\n\t    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n\t  };\n\t\n\t  // Allow other directives to watch status\n\t  this.isOpen = function() {\n\t    return scope.isOpen;\n\t  };\n\t\n\t  scope.getToggleElement = function() {\n\t    return self.toggleElement;\n\t  };\n\t\n\t  scope.getAutoClose = function() {\n\t    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n\t  };\n\t\n\t  scope.getElement = function() {\n\t    return $element;\n\t  };\n\t\n\t  scope.isKeynavEnabled = function() {\n\t    return keynavEnabled;\n\t  };\n\t\n\t  scope.focusDropdownEntry = function(keyCode) {\n\t    var elems = self.dropdownMenu ? //If append to body is used.\n\t      angular.element(self.dropdownMenu).find('a') :\n\t      $element.find('ul').eq(0).find('a');\n\t\n\t    switch (keyCode) {\n\t      case 40: {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = 0;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === elems.length - 1 ?\n\t            self.selectedOption :\n\t            self.selectedOption + 1;\n\t        }\n\t        break;\n\t      }\n\t      case 38: {\n\t        if (!angular.isNumber(self.selectedOption)) {\n\t          self.selectedOption = elems.length - 1;\n\t        } else {\n\t          self.selectedOption = self.selectedOption === 0 ?\n\t            0 : self.selectedOption - 1;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    elems[self.selectedOption].focus();\n\t  };\n\t\n\t  scope.getDropdownElement = function() {\n\t    return self.dropdownMenu;\n\t  };\n\t\n\t  scope.focusToggleElement = function() {\n\t    if (self.toggleElement) {\n\t      self.toggleElement[0].focus();\n\t    }\n\t  };\n\t\n\t  scope.$watch('isOpen', function(isOpen, wasOpen) {\n\t    if (appendTo && self.dropdownMenu) {\n\t      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),\n\t        css,\n\t        rightalign;\n\t\n\t      css = {\n\t        top: pos.top + 'px',\n\t        display: isOpen ? 'block' : 'none'\n\t      };\n\t\n\t      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n\t      if (!rightalign) {\n\t        css.left = pos.left + 'px';\n\t        css.right = 'auto';\n\t      } else {\n\t        css.left = 'auto';\n\t        css.right = window.innerWidth -\n\t          (pos.left + $element.prop('offsetWidth')) + 'px';\n\t      }\n\t\n\t      // Need to adjust our positioning to be relative to the appendTo container\n\t      // if it's not the body element\n\t      if (!appendToBody) {\n\t        var appendOffset = $position.offset(appendTo);\n\t\n\t        css.top = pos.top - appendOffset.top + 'px';\n\t\n\t        if (!rightalign) {\n\t          css.left = pos.left - appendOffset.left + 'px';\n\t        } else {\n\t          css.right = window.innerWidth -\n\t            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';\n\t        }\n\t      }\n\t\n\t      self.dropdownMenu.css(css);\n\t    }\n\t\n\t    var openContainer = appendTo ? appendTo : $element;\n\t    var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);\n\t\n\t    if (hasOpenClass === !isOpen) {\n\t      $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {\n\t        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n\t          toggleInvoker($scope, { open: !!isOpen });\n\t        }\n\t      });\n\t    }\n\t\n\t    if (isOpen) {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n\t          templateScope = scope.$new();\n\t          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n\t            var newEl = dropdownElement;\n\t            self.dropdownMenu.replaceWith(newEl);\n\t            self.dropdownMenu = newEl;\n\t          });\n\t        });\n\t      }\n\t\n\t      scope.focusToggleElement();\n\t      uibDropdownService.open(scope);\n\t    } else {\n\t      if (self.dropdownMenuTemplateUrl) {\n\t        if (templateScope) {\n\t          templateScope.$destroy();\n\t        }\n\t        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n\t        self.dropdownMenu.replaceWith(newEl);\n\t        self.dropdownMenu = newEl;\n\t      }\n\t\n\t      uibDropdownService.close(scope);\n\t      self.selectedOption = null;\n\t    }\n\t\n\t    if (angular.isFunction(setIsOpen)) {\n\t      setIsOpen($scope, isOpen);\n\t    }\n\t  });\n\t\n\t  $scope.$on('$locationChangeSuccess', function() {\n\t    if (scope.getAutoClose() !== 'disabled') {\n\t      scope.isOpen = false;\n\t    }\n\t  });\n\t}])\n\t\n\t.directive('uibDropdown', function() {\n\t  return {\n\t    controller: 'UibDropdownController',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      dropdownCtrl.init();\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownMenu', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-menu');\n\t\n\t      var tplUrl = attrs.templateUrl;\n\t      if (tplUrl) {\n\t        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n\t      }\n\t\n\t      if (!dropdownCtrl.dropdownMenu) {\n\t        dropdownCtrl.dropdownMenu = element;\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibDropdownToggle', function() {\n\t  return {\n\t    require: '?^uibDropdown',\n\t    link: function(scope, element, attrs, dropdownCtrl) {\n\t      if (!dropdownCtrl) {\n\t        return;\n\t      }\n\t\n\t      element.addClass('dropdown-toggle');\n\t\n\t      dropdownCtrl.toggleElement = element;\n\t\n\t      var toggleDropdown = function(event) {\n\t        event.preventDefault();\n\t\n\t        if (!element.hasClass('disabled') && !attrs.disabled) {\n\t          scope.$apply(function() {\n\t            dropdownCtrl.toggle();\n\t          });\n\t        }\n\t      };\n\t\n\t      element.bind('click', toggleDropdown);\n\t\n\t      // WAI-ARIA\n\t      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n\t      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n\t        element.attr('aria-expanded', !!isOpen);\n\t      });\n\t\n\t      scope.$on('$destroy', function() {\n\t        element.unbind('click', toggleDropdown);\n\t      });\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.stackedMap', [])\n\t/**\n\t * A helper, internal data structure that acts as a map but also allows getting / removing\n\t * elements in the LIFO order\n\t */\n\t  .factory('$$stackedMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var stack = [];\n\t\n\t        return {\n\t          add: function(key, value) {\n\t            stack.push({\n\t              key: key,\n\t              value: value\n\t            });\n\t          },\n\t          get: function(key) {\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key === stack[i].key) {\n\t                return stack[i];\n\t              }\n\t            }\n\t          },\n\t          keys: function() {\n\t            var keys = [];\n\t            for (var i = 0; i < stack.length; i++) {\n\t              keys.push(stack[i].key);\n\t            }\n\t            return keys;\n\t          },\n\t          top: function() {\n\t            return stack[stack.length - 1];\n\t          },\n\t          remove: function(key) {\n\t            var idx = -1;\n\t            for (var i = 0; i < stack.length; i++) {\n\t              if (key === stack[i].key) {\n\t                idx = i;\n\t                break;\n\t              }\n\t            }\n\t            return stack.splice(idx, 1)[0];\n\t          },\n\t          removeTop: function() {\n\t            return stack.splice(stack.length - 1, 1)[0];\n\t          },\n\t          length: function() {\n\t            return stack.length;\n\t          }\n\t        };\n\t      }\n\t    };\n\t  });\n\tangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n\t/**\n\t * A helper, internal data structure that stores all references attached to key\n\t */\n\t  .factory('$$multiMap', function() {\n\t    return {\n\t      createNew: function() {\n\t        var map = {};\n\t\n\t        return {\n\t          entries: function() {\n\t            return Object.keys(map).map(function(key) {\n\t              return {\n\t                key: key,\n\t                value: map[key]\n\t              };\n\t            });\n\t          },\n\t          get: function(key) {\n\t            return map[key];\n\t          },\n\t          hasKey: function(key) {\n\t            return !!map[key];\n\t          },\n\t          keys: function() {\n\t            return Object.keys(map);\n\t          },\n\t          put: function(key, value) {\n\t            if (!map[key]) {\n\t              map[key] = [];\n\t            }\n\t\n\t            map[key].push(value);\n\t          },\n\t          remove: function(key, value) {\n\t            var values = map[key];\n\t\n\t            if (!values) {\n\t              return;\n\t            }\n\t\n\t            var idx = values.indexOf(value);\n\t\n\t            if (idx !== -1) {\n\t              values.splice(idx, 1);\n\t            }\n\t\n\t            if (!values.length) {\n\t              delete map[key];\n\t            }\n\t          }\n\t        };\n\t      }\n\t    };\n\t  })\n\t\n\t/**\n\t * Pluggable resolve mechanism for the modal resolve resolution\n\t * Supports UI Router's $resolve service\n\t */\n\t  .provider('$uibResolve', function() {\n\t    var resolve = this;\n\t    this.resolver = null;\n\t\n\t    this.setResolver = function(resolver) {\n\t      this.resolver = resolver;\n\t    };\n\t\n\t    this.$get = ['$injector', '$q', function($injector, $q) {\n\t      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;\n\t      return {\n\t        resolve: function(invocables, locals, parent, self) {\n\t          if (resolver) {\n\t            return resolver.resolve(invocables, locals, parent, self);\n\t          }\n\t\n\t          var promises = [];\n\t\n\t          angular.forEach(invocables, function(value) {\n\t            if (angular.isFunction(value) || angular.isArray(value)) {\n\t              promises.push($q.resolve($injector.invoke(value)));\n\t            } else if (angular.isString(value)) {\n\t              promises.push($q.resolve($injector.get(value)));\n\t            } else {\n\t              promises.push($q.resolve(value));\n\t            }\n\t          });\n\t\n\t          return $q.all(promises).then(function(resolves) {\n\t            var resolveObj = {};\n\t            var resolveIter = 0;\n\t            angular.forEach(invocables, function(value, key) {\n\t              resolveObj[key] = resolves[resolveIter++];\n\t            });\n\t\n\t            return resolveObj;\n\t          });\n\t        }\n\t      };\n\t    }];\n\t  })\n\t\n\t/**\n\t * A helper directive for the $modal service. It creates a backdrop element.\n\t */\n\t  .directive('uibModalBackdrop', ['$animateCss', '$injector', '$uibModalStack',\n\t  function($animateCss, $injector, $modalStack) {\n\t    return {\n\t      replace: true,\n\t      templateUrl: 'uib/template/modal/backdrop.html',\n\t      compile: function(tElement, tAttrs) {\n\t        tElement.addClass(tAttrs.backdropClass);\n\t        return linkFn;\n\t      }\n\t    };\n\t\n\t    function linkFn(scope, element, attrs) {\n\t      if (attrs.modalInClass) {\n\t        $animateCss(element, {\n\t          addClass: attrs.modalInClass\n\t        }).start();\n\t\n\t        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t          var done = setIsAsync();\n\t          if (scope.modalOptions.animation) {\n\t            $animateCss(element, {\n\t              removeClass: attrs.modalInClass\n\t            }).start().then(done);\n\t          } else {\n\t            done();\n\t          }\n\t        });\n\t      }\n\t    }\n\t  }])\n\t\n\t  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animate', '$animateCss', '$document',\n\t  function($modalStack, $q, $animate, $animateCss, $document) {\n\t    return {\n\t      scope: {\n\t        index: '@'\n\t      },\n\t      replace: true,\n\t      transclude: true,\n\t      templateUrl: function(tElement, tAttrs) {\n\t        return tAttrs.templateUrl || 'uib/template/modal/window.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        element.addClass(attrs.windowClass || '');\n\t        element.addClass(attrs.windowTopClass || '');\n\t        scope.size = attrs.size;\n\t\n\t        scope.close = function(evt) {\n\t          var modal = $modalStack.getTop();\n\t          if (modal && modal.value.backdrop &&\n\t            modal.value.backdrop !== 'static' &&\n\t            evt.target === evt.currentTarget) {\n\t            evt.preventDefault();\n\t            evt.stopPropagation();\n\t            $modalStack.dismiss(modal.key, 'backdrop click');\n\t          }\n\t        };\n\t\n\t        // moved from template to fix issue #2280\n\t        element.on('click', scope.close);\n\t\n\t        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n\t        // We can detect that by using this property in the template associated with this directive and then use\n\t        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n\t        scope.$isRendered = true;\n\t\n\t        // Deferred object that will be resolved when this modal is render.\n\t        var modalRenderDeferObj = $q.defer();\n\t        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n\t        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n\t        attrs.$observe('modalRender', function(value) {\n\t          if (value === 'true') {\n\t            modalRenderDeferObj.resolve();\n\t          }\n\t        });\n\t\n\t        modalRenderDeferObj.promise.then(function() {\n\t          var animationPromise = null;\n\t\n\t          if (attrs.modalInClass) {\n\t            animationPromise = $animateCss(element, {\n\t              addClass: attrs.modalInClass\n\t            }).start();\n\t\n\t            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n\t              var done = setIsAsync();\n\t              if ($animateCss) {\n\t                $animateCss(element, {\n\t                  removeClass: attrs.modalInClass\n\t                }).start().then(done);\n\t              } else {\n\t                $animate.removeClass(element, attrs.modalInClass).then(done);\n\t              }\n\t            });\n\t          }\n\t\n\t\n\t          $q.when(animationPromise).then(function() {\n\t            // Notify {@link $modalStack} that modal is rendered.\n\t            var modal = $modalStack.getTop();\n\t            if (modal) {\n\t              $modalStack.modalRendered(modal.key);\n\t            }\n\t\n\t            /**\n\t             * If something within the freshly-opened modal already has focus (perhaps via a\n\t             * directive that causes focus). then no need to try and focus anything.\n\t             */\n\t            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {\n\t              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n\t              /**\n\t               * Auto-focusing of a freshly-opened modal element causes any child elements\n\t               * with the autofocus attribute to lose focus. This is an issue on touch\n\t               * based devices which will show and then hide the onscreen keyboard.\n\t               * Attempts to refocus the autofocus element via JavaScript will not reopen\n\t               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n\t               * the modal element if the modal does not contain an autofocus element.\n\t               */\n\t              if (inputWithAutofocus) {\n\t                inputWithAutofocus.focus();\n\t              } else {\n\t                element[0].focus();\n\t              }\n\t            }\n\t          });\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('uibModalAnimationClass', function() {\n\t    return {\n\t      compile: function(tElement, tAttrs) {\n\t        if (tAttrs.modalAnimation) {\n\t          tElement.addClass(tAttrs.uibModalAnimationClass);\n\t        }\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibModalTransclude', function() {\n\t    return {\n\t      link: function(scope, element, attrs, controller, transclude) {\n\t        transclude(scope.$parent, function(clone) {\n\t          element.empty();\n\t          element.append(clone);\n\t        });\n\t      }\n\t    };\n\t  })\n\t\n\t  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',\n\t    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap',\n\t    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap) {\n\t      var OPENED_MODAL_CLASS = 'modal-open';\n\t\n\t      var backdropDomEl, backdropScope;\n\t      var openedWindows = $$stackedMap.createNew();\n\t      var openedClasses = $$multiMap.createNew();\n\t      var $modalStack = {\n\t        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n\t      };\n\t\n\t      //Modal focus behavior\n\t      var focusableElementList;\n\t      var focusIndex = 0;\n\t      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n\t        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n\t        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\t\n\t      function backdropIndex() {\n\t        var topBackdropIndex = -1;\n\t        var opened = openedWindows.keys();\n\t        for (var i = 0; i < opened.length; i++) {\n\t          if (openedWindows.get(opened[i]).value.backdrop) {\n\t            topBackdropIndex = i;\n\t          }\n\t        }\n\t        return topBackdropIndex;\n\t      }\n\t\n\t      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n\t        if (backdropScope) {\n\t          backdropScope.index = newBackdropIndex;\n\t        }\n\t      });\n\t\n\t      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n\t        var modalWindow = openedWindows.get(modalInstance).value;\n\t        var appendToElement = modalWindow.appendTo;\n\t\n\t        //clean up the stack\n\t        openedWindows.remove(modalInstance);\n\t\n\t        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n\t          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n\t          openedClasses.remove(modalBodyClass, modalInstance);\n\t          appendToElement.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n\t          toggleTopWindowClass(true);\n\t        }, modalWindow.closedDeferred);\n\t        checkRemoveBackdrop();\n\t\n\t        //move focus to specified element if available, or else to body\n\t        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n\t          elementToReceiveFocus.focus();\n\t        } else if (appendToElement.focus) {\n\t          appendToElement.focus();\n\t        }\n\t      }\n\t\n\t      // Add or remove \"windowTopClass\" from the top window in the stack\n\t      function toggleTopWindowClass(toggleSwitch) {\n\t        var modalWindow;\n\t\n\t        if (openedWindows.length() > 0) {\n\t          modalWindow = openedWindows.top().value;\n\t          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n\t        }\n\t      }\n\t\n\t      function checkRemoveBackdrop() {\n\t        //remove backdrop if no longer needed\n\t        if (backdropDomEl && backdropIndex() === -1) {\n\t          var backdropScopeRef = backdropScope;\n\t          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n\t            backdropScopeRef = null;\n\t          });\n\t          backdropDomEl = undefined;\n\t          backdropScope = undefined;\n\t        }\n\t      }\n\t\n\t      function removeAfterAnimate(domEl, scope, done, closedDeferred) {\n\t        var asyncDeferred;\n\t        var asyncPromise = null;\n\t        var setIsAsync = function() {\n\t          if (!asyncDeferred) {\n\t            asyncDeferred = $q.defer();\n\t            asyncPromise = asyncDeferred.promise;\n\t          }\n\t\n\t          return function asyncDone() {\n\t            asyncDeferred.resolve();\n\t          };\n\t        };\n\t        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\t\n\t        // Note that it's intentional that asyncPromise might be null.\n\t        // That's when setIsAsync has not been called during the\n\t        // NOW_CLOSING_EVENT broadcast.\n\t        return $q.when(asyncPromise).then(afterAnimating);\n\t\n\t        function afterAnimating() {\n\t          if (afterAnimating.done) {\n\t            return;\n\t          }\n\t          afterAnimating.done = true;\n\t\n\t          $animateCss(domEl, {\n\t            event: 'leave'\n\t          }).start().then(function() {\n\t            domEl.remove();\n\t            if (closedDeferred) {\n\t              closedDeferred.resolve();\n\t            }\n\t          });\n\t\n\t          scope.$destroy();\n\t          if (done) {\n\t            done();\n\t          }\n\t        }\n\t      }\n\t\n\t      $document.on('keydown', keydownListener);\n\t\n\t      $rootScope.$on('$destroy', function() {\n\t        $document.off('keydown', keydownListener);\n\t      });\n\t\n\t      function keydownListener(evt) {\n\t        if (evt.isDefaultPrevented()) {\n\t          return evt;\n\t        }\n\t\n\t        var modal = openedWindows.top();\n\t        if (modal) {\n\t          switch (evt.which) {\n\t            case 27: {\n\t              if (modal.value.keyboard) {\n\t                evt.preventDefault();\n\t                $rootScope.$apply(function() {\n\t                  $modalStack.dismiss(modal.key, 'escape key press');\n\t                });\n\t              }\n\t              break;\n\t            }\n\t            case 9: {\n\t              $modalStack.loadFocusElementList(modal);\n\t              var focusChanged = false;\n\t              if (evt.shiftKey) {\n\t                if ($modalStack.isFocusInFirstItem(evt) || $modalStack.isModalFocused(evt, modal)) {\n\t                  focusChanged = $modalStack.focusLastFocusableElement();\n\t                }\n\t              } else {\n\t                if ($modalStack.isFocusInLastItem(evt)) {\n\t                  focusChanged = $modalStack.focusFirstFocusableElement();\n\t                }\n\t              }\n\t\n\t              if (focusChanged) {\n\t                evt.preventDefault();\n\t                evt.stopPropagation();\n\t              }\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      $modalStack.open = function(modalInstance, modal) {\n\t        var modalOpener = $document[0].activeElement,\n\t          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\t\n\t        toggleTopWindowClass(false);\n\t\n\t        openedWindows.add(modalInstance, {\n\t          deferred: modal.deferred,\n\t          renderDeferred: modal.renderDeferred,\n\t          closedDeferred: modal.closedDeferred,\n\t          modalScope: modal.scope,\n\t          backdrop: modal.backdrop,\n\t          keyboard: modal.keyboard,\n\t          openedClass: modal.openedClass,\n\t          windowTopClass: modal.windowTopClass,\n\t          animation: modal.animation,\n\t          appendTo: modal.appendTo\n\t        });\n\t\n\t        openedClasses.put(modalBodyClass, modalInstance);\n\t\n\t        var appendToElement = modal.appendTo,\n\t            currBackdropIndex = backdropIndex();\n\t\n\t        if (!appendToElement.length) {\n\t          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');\n\t        }\n\t\n\t        if (currBackdropIndex >= 0 && !backdropDomEl) {\n\t          backdropScope = $rootScope.$new(true);\n\t          backdropScope.modalOptions = modal;\n\t          backdropScope.index = currBackdropIndex;\n\t          backdropDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n\t          backdropDomEl.attr('backdrop-class', modal.backdropClass);\n\t          if (modal.animation) {\n\t            backdropDomEl.attr('modal-animation', 'true');\n\t          }\n\t          $compile(backdropDomEl)(backdropScope);\n\t          $animate.enter(backdropDomEl, appendToElement);\n\t        }\n\t\n\t        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n\t        angularDomEl.attr({\n\t          'template-url': modal.windowTemplateUrl,\n\t          'window-class': modal.windowClass,\n\t          'window-top-class': modal.windowTopClass,\n\t          'size': modal.size,\n\t          'index': openedWindows.length() - 1,\n\t          'animate': 'animate'\n\t        }).html(modal.content);\n\t        if (modal.animation) {\n\t          angularDomEl.attr('modal-animation', 'true');\n\t        }\n\t\n\t        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement)\n\t          .then(function() {\n\t            if (!modal.scope.$$uibDestructionScheduled) {\n\t              $animate.addClass(appendToElement, modalBodyClass);\n\t            }\n\t          });\n\t\n\t        openedWindows.top().value.modalDomEl = angularDomEl;\n\t        openedWindows.top().value.modalOpener = modalOpener;\n\t\n\t        $modalStack.clearFocusListCache();\n\t      };\n\t\n\t      function broadcastClosing(modalWindow, resultOrReason, closing) {\n\t        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n\t      }\n\t\n\t      $modalStack.close = function(modalInstance, result) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.resolve(result);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismiss = function(modalInstance, reason) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n\t          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n\t          modalWindow.value.deferred.reject(reason);\n\t          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n\t          return true;\n\t        }\n\t        return !modalWindow;\n\t      };\n\t\n\t      $modalStack.dismissAll = function(reason) {\n\t        var topModal = this.getTop();\n\t        while (topModal && this.dismiss(topModal.key, reason)) {\n\t          topModal = this.getTop();\n\t        }\n\t      };\n\t\n\t      $modalStack.getTop = function() {\n\t        return openedWindows.top();\n\t      };\n\t\n\t      $modalStack.modalRendered = function(modalInstance) {\n\t        var modalWindow = openedWindows.get(modalInstance);\n\t        if (modalWindow) {\n\t          modalWindow.value.renderDeferred.resolve();\n\t        }\n\t      };\n\t\n\t      $modalStack.focusFirstFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[0].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t      $modalStack.focusLastFocusableElement = function() {\n\t        if (focusableElementList.length > 0) {\n\t          focusableElementList[focusableElementList.length - 1].focus();\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isModalFocused = function(evt, modalWindow) {\n\t        if (evt && modalWindow) {\n\t          var modalDomEl = modalWindow.value.modalDomEl;\n\t          if (modalDomEl && modalDomEl.length) {\n\t            return (evt.target || evt.srcElement) === modalDomEl[0];\n\t          }\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInFirstItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) === focusableElementList[0];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.isFocusInLastItem = function(evt) {\n\t        if (focusableElementList.length > 0) {\n\t          return (evt.target || evt.srcElement) === focusableElementList[focusableElementList.length - 1];\n\t        }\n\t        return false;\n\t      };\n\t\n\t      $modalStack.clearFocusListCache = function() {\n\t        focusableElementList = [];\n\t        focusIndex = 0;\n\t      };\n\t\n\t      $modalStack.loadFocusElementList = function(modalWindow) {\n\t        if (focusableElementList === undefined || !focusableElementList.length) {\n\t          if (modalWindow) {\n\t            var modalDomE1 = modalWindow.value.modalDomEl;\n\t            if (modalDomE1 && modalDomE1.length) {\n\t              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      return $modalStack;\n\t    }])\n\t\n\t  .provider('$uibModal', function() {\n\t    var $modalProvider = {\n\t      options: {\n\t        animation: true,\n\t        backdrop: true, //can also be false or 'static'\n\t        keyboard: true\n\t      },\n\t      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',\n\t        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {\n\t          var $modal = {};\n\t\n\t          function getTemplatePromise(options) {\n\t            return options.template ? $q.when(options.template) :\n\t              $templateRequest(angular.isFunction(options.templateUrl) ?\n\t                options.templateUrl() : options.templateUrl);\n\t          }\n\t\n\t          var promiseChain = null;\n\t          $modal.getPromiseChain = function() {\n\t            return promiseChain;\n\t          };\n\t\n\t          $modal.open = function(modalOptions) {\n\t            var modalResultDeferred = $q.defer();\n\t            var modalOpenedDeferred = $q.defer();\n\t            var modalClosedDeferred = $q.defer();\n\t            var modalRenderDeferred = $q.defer();\n\t\n\t            //prepare an instance of a modal to be injected into controllers and returned to a caller\n\t            var modalInstance = {\n\t              result: modalResultDeferred.promise,\n\t              opened: modalOpenedDeferred.promise,\n\t              closed: modalClosedDeferred.promise,\n\t              rendered: modalRenderDeferred.promise,\n\t              close: function (result) {\n\t                return $modalStack.close(modalInstance, result);\n\t              },\n\t              dismiss: function (reason) {\n\t                return $modalStack.dismiss(modalInstance, reason);\n\t              }\n\t            };\n\t\n\t            //merge and clean up options\n\t            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n\t            modalOptions.resolve = modalOptions.resolve || {};\n\t            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);\n\t\n\t            //verify options\n\t            if (!modalOptions.template && !modalOptions.templateUrl) {\n\t              throw new Error('One of template or templateUrl options is required.');\n\t            }\n\t\n\t            var templateAndResolvePromise =\n\t              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);\n\t\n\t            function resolveWithTemplate() {\n\t              return templateAndResolvePromise;\n\t            }\n\t\n\t            // Wait for the resolution of the existing promise chain.\n\t            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n\t            // Then add to $modalStack and resolve opened.\n\t            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n\t            var samePromise;\n\t            samePromise = promiseChain = $q.all([promiseChain])\n\t              .then(resolveWithTemplate, resolveWithTemplate)\n\t              .then(function resolveSuccess(tplAndVars) {\n\t                var providedScope = modalOptions.scope || $rootScope;\n\t\n\t                var modalScope = providedScope.$new();\n\t                modalScope.$close = modalInstance.close;\n\t                modalScope.$dismiss = modalInstance.dismiss;\n\t\n\t                modalScope.$on('$destroy', function() {\n\t                  if (!modalScope.$$uibDestructionScheduled) {\n\t                    modalScope.$dismiss('$uibUnscheduledDestruction');\n\t                  }\n\t                });\n\t\n\t                var ctrlInstance, ctrlLocals = {};\n\t\n\t                //controllers\n\t                if (modalOptions.controller) {\n\t                  ctrlLocals.$scope = modalScope;\n\t                  ctrlLocals.$uibModalInstance = modalInstance;\n\t                  angular.forEach(tplAndVars[1], function(value, key) {\n\t                    ctrlLocals[key] = value;\n\t                  });\n\t\n\t                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n\t                  if (modalOptions.controllerAs) {\n\t                    if (modalOptions.bindToController) {\n\t                      ctrlInstance.$close = modalScope.$close;\n\t                      ctrlInstance.$dismiss = modalScope.$dismiss;\n\t                      angular.extend(ctrlInstance, providedScope);\n\t                      if (angular.isFunction(ctrlInstance.$onInit)) {\n\t                        ctrlInstance.$onInit();\n\t                      }\n\t                    }\n\t\n\t                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n\t                  }\n\t                }\n\t\n\t                $modalStack.open(modalInstance, {\n\t                  scope: modalScope,\n\t                  deferred: modalResultDeferred,\n\t                  renderDeferred: modalRenderDeferred,\n\t                  closedDeferred: modalClosedDeferred,\n\t                  content: tplAndVars[0],\n\t                  animation: modalOptions.animation,\n\t                  backdrop: modalOptions.backdrop,\n\t                  keyboard: modalOptions.keyboard,\n\t                  backdropClass: modalOptions.backdropClass,\n\t                  windowTopClass: modalOptions.windowTopClass,\n\t                  windowClass: modalOptions.windowClass,\n\t                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n\t                  size: modalOptions.size,\n\t                  openedClass: modalOptions.openedClass,\n\t                  appendTo: modalOptions.appendTo\n\t                });\n\t                modalOpenedDeferred.resolve(true);\n\t\n\t            }, function resolveError(reason) {\n\t              modalOpenedDeferred.reject(reason);\n\t              modalResultDeferred.reject(reason);\n\t            })['finally'](function() {\n\t              if (promiseChain === samePromise) {\n\t                promiseChain = null;\n\t              }\n\t            });\n\t\n\t            return modalInstance;\n\t          };\n\t\n\t          return $modal;\n\t        }\n\t      ]\n\t    };\n\t\n\t    return $modalProvider;\n\t  });\n\t\n\tangular.module('ui.bootstrap.paging', [])\n\t/**\n\t * Helper internal service for generating common controller code between the\n\t * pager and pagination components\n\t */\n\t.factory('uibPaging', ['$parse', function($parse) {\n\t  return {\n\t    create: function(ctrl, $scope, $attrs) {\n\t      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\t      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl\n\t      ctrl._watchers = [];\n\t\n\t      ctrl.init = function(ngModelCtrl, config) {\n\t        ctrl.ngModelCtrl = ngModelCtrl;\n\t        ctrl.config = config;\n\t\n\t        ngModelCtrl.$render = function() {\n\t          ctrl.render();\n\t        };\n\t\n\t        if ($attrs.itemsPerPage) {\n\t          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {\n\t            ctrl.itemsPerPage = parseInt(value, 10);\n\t            $scope.totalPages = ctrl.calculateTotalPages();\n\t            ctrl.updatePage();\n\t          }));\n\t        } else {\n\t          ctrl.itemsPerPage = config.itemsPerPage;\n\t        }\n\t\n\t        $scope.$watch('totalItems', function(newTotal, oldTotal) {\n\t          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {\n\t            $scope.totalPages = ctrl.calculateTotalPages();\n\t            ctrl.updatePage();\n\t          }\n\t        });\n\t      };\n\t\n\t      ctrl.calculateTotalPages = function() {\n\t        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);\n\t        return Math.max(totalPages || 0, 1);\n\t      };\n\t\n\t      ctrl.render = function() {\n\t        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;\n\t      };\n\t\n\t      $scope.selectPage = function(page, evt) {\n\t        if (evt) {\n\t          evt.preventDefault();\n\t        }\n\t\n\t        var clickAllowed = !$scope.ngDisabled || !evt;\n\t        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n\t          if (evt && evt.target) {\n\t            evt.target.blur();\n\t          }\n\t          ctrl.ngModelCtrl.$setViewValue(page);\n\t          ctrl.ngModelCtrl.$render();\n\t        }\n\t      };\n\t\n\t      $scope.getText = function(key) {\n\t        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];\n\t      };\n\t\n\t      $scope.noPrevious = function() {\n\t        return $scope.page === 1;\n\t      };\n\t\n\t      $scope.noNext = function() {\n\t        return $scope.page === $scope.totalPages;\n\t      };\n\t\n\t      ctrl.updatePage = function() {\n\t        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable\n\t\n\t        if ($scope.page > $scope.totalPages) {\n\t          $scope.selectPage($scope.totalPages);\n\t        } else {\n\t          ctrl.ngModelCtrl.$render();\n\t        }\n\t      };\n\t\n\t      $scope.$on('$destroy', function() {\n\t        while (ctrl._watchers.length) {\n\t          ctrl._watchers.shift()();\n\t        }\n\t      });\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])\n\t\n\t.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {\n\t  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;\n\t\n\t  uibPaging.create(this, $scope, $attrs);\n\t}])\n\t\n\t.constant('uibPagerConfig', {\n\t  itemsPerPage: 10,\n\t  previousText: '« Previous',\n\t  nextText: 'Next »',\n\t  align: true\n\t})\n\t\n\t.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {\n\t  return {\n\t    scope: {\n\t      totalItems: '=',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      ngDisabled: '='\n\t    },\n\t    require: ['uibPager', '?ngModel'],\n\t    controller: 'UibPagerController',\n\t    controllerAs: 'pager',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/pager/pager.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t        return; // do nothing if no ng-model\n\t      }\n\t\n\t      paginationCtrl.init(ngModelCtrl, uibPagerConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])\n\t.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {\n\t  var ctrl = this;\n\t  // Setup configuration parameters\n\t  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,\n\t    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,\n\t    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,\n\t    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,\n\t    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;\n\t  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;\n\t  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;\n\t\n\t  uibPaging.create(this, $scope, $attrs);\n\t\n\t  if ($attrs.maxSize) {\n\t    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {\n\t      maxSize = parseInt(value, 10);\n\t      ctrl.render();\n\t    }));\n\t  }\n\t\n\t  // Create page object used in template\n\t  function makePage(number, text, isActive) {\n\t    return {\n\t      number: number,\n\t      text: text,\n\t      active: isActive\n\t    };\n\t  }\n\t\n\t  function getPages(currentPage, totalPages) {\n\t    var pages = [];\n\t\n\t    // Default page limits\n\t    var startPage = 1, endPage = totalPages;\n\t    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\t\n\t    // recompute if maxSize\n\t    if (isMaxSized) {\n\t      if (rotate) {\n\t        // Current page is displayed in the middle of the visible ones\n\t        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\n\t        endPage = startPage + maxSize - 1;\n\t\n\t        // Adjust if limit is exceeded\n\t        if (endPage > totalPages) {\n\t          endPage = totalPages;\n\t          startPage = endPage - maxSize + 1;\n\t        }\n\t      } else {\n\t        // Visible pages are paginated with maxSize\n\t        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;\n\t\n\t        // Adjust last page if limit is exceeded\n\t        endPage = Math.min(startPage + maxSize - 1, totalPages);\n\t      }\n\t    }\n\t\n\t    // Add page number links\n\t    for (var number = startPage; number <= endPage; number++) {\n\t      var page = makePage(number, pageLabel(number), number === currentPage);\n\t      pages.push(page);\n\t    }\n\t\n\t    // Add links to move between page sets\n\t    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {\n\t      if (startPage > 1) {\n\t        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning\n\t        var previousPageSet = makePage(startPage - 1, '...', false);\n\t        pages.unshift(previousPageSet);\n\t      }\n\t        if (boundaryLinkNumbers) {\n\t          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential\n\t            var secondPageLink = makePage(2, '2', false);\n\t            pages.unshift(secondPageLink);\n\t          }\n\t          //add the first page\n\t          var firstPageLink = makePage(1, '1', false);\n\t          pages.unshift(firstPageLink);\n\t        }\n\t      }\n\t\n\t      if (endPage < totalPages) {\n\t        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end\n\t        var nextPageSet = makePage(endPage + 1, '...', false);\n\t        pages.push(nextPageSet);\n\t      }\n\t        if (boundaryLinkNumbers) {\n\t          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential\n\t            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);\n\t            pages.push(secondToLastPageLink);\n\t          }\n\t          //add the last page\n\t          var lastPageLink = makePage(totalPages, totalPages, false);\n\t          pages.push(lastPageLink);\n\t        }\n\t      }\n\t    }\n\t    return pages;\n\t  }\n\t\n\t  var originalRender = this.render;\n\t  this.render = function() {\n\t    originalRender();\n\t    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {\n\t      $scope.pages = getPages($scope.page, $scope.totalPages);\n\t    }\n\t  };\n\t}])\n\t\n\t.constant('uibPaginationConfig', {\n\t  itemsPerPage: 10,\n\t  boundaryLinks: false,\n\t  boundaryLinkNumbers: false,\n\t  directionLinks: true,\n\t  firstText: 'First',\n\t  previousText: 'Previous',\n\t  nextText: 'Next',\n\t  lastText: 'Last',\n\t  rotate: true,\n\t  forceEllipses: false\n\t})\n\t\n\t.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {\n\t  return {\n\t    scope: {\n\t      totalItems: '=',\n\t      firstText: '@',\n\t      previousText: '@',\n\t      nextText: '@',\n\t      lastText: '@',\n\t      ngDisabled:'='\n\t    },\n\t    require: ['uibPagination', '?ngModel'],\n\t    controller: 'UibPaginationController',\n\t    controllerAs: 'pagination',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/pagination/pagination.html';\n\t    },\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (!ngModelCtrl) {\n\t         return; // do nothing if no ng-model\n\t      }\n\t\n\t      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);\n\t    }\n\t  };\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, html tooltips, and selector delegation.\n\t */\n\tangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\t\n\t/**\n\t * The $tooltip service creates tooltip- and popover-like directives as well as\n\t * houses global options for them.\n\t */\n\t.provider('$uibTooltip', function() {\n\t  // The default options tooltip and popover.\n\t  var defaultOptions = {\n\t    placement: 'top',\n\t    placementClassPrefix: '',\n\t    animation: true,\n\t    popupDelay: 0,\n\t    popupCloseDelay: 0,\n\t    useContentExp: false\n\t  };\n\t\n\t  // Default hide triggers for each show trigger\n\t  var triggerMap = {\n\t    'mouseenter': 'mouseleave',\n\t    'click': 'click',\n\t    'outsideClick': 'outsideClick',\n\t    'focus': 'blur',\n\t    'none': ''\n\t  };\n\t\n\t  // The options specified to the provider globally.\n\t  var globalOptions = {};\n\t\n\t  /**\n\t   * `options({})` allows global configuration of all tooltips in the\n\t   * application.\n\t   *\n\t   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n\t   *     // place tooltips left instead of top by default\n\t   *     $tooltipProvider.options( { placement: 'left' } );\n\t   *   });\n\t   */\n\t\tthis.options = function(value) {\n\t\t\tangular.extend(globalOptions, value);\n\t\t};\n\t\n\t  /**\n\t   * This allows you to extend the set of trigger mappings available. E.g.:\n\t   *\n\t   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n\t   */\n\t  this.setTriggers = function setTriggers(triggers) {\n\t    angular.extend(triggerMap, triggers);\n\t  };\n\t\n\t  /**\n\t   * This is a helper function for translating camel-case to snake_case.\n\t   */\n\t  function snake_case(name) {\n\t    var regexp = /[A-Z]/g;\n\t    var separator = '-';\n\t    return name.replace(regexp, function(letter, pos) {\n\t      return (pos ? separator : '') + letter.toLowerCase();\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Returns the actual instance of the $tooltip service.\n\t   * TODO support multiple triggers\n\t   */\n\t  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n\t    var openedTooltips = $$stackedMap.createNew();\n\t    $document.on('keypress', keypressListener);\n\t\n\t    $rootScope.$on('$destroy', function() {\n\t      $document.off('keypress', keypressListener);\n\t    });\n\t\n\t    function keypressListener(e) {\n\t      if (e.which === 27) {\n\t        var last = openedTooltips.top();\n\t        if (last) {\n\t          last.value.close();\n\t          openedTooltips.removeTop();\n\t          last = null;\n\t        }\n\t      }\n\t    }\n\t\n\t    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n\t      options = angular.extend({}, defaultOptions, globalOptions, options);\n\t\n\t      /**\n\t       * Returns an object of show and hide triggers.\n\t       *\n\t       * If a trigger is supplied,\n\t       * it is used to show the tooltip; otherwise, it will use the `trigger`\n\t       * option passed to the `$tooltipProvider.options` method; else it will\n\t       * default to the trigger supplied to this directive factory.\n\t       *\n\t       * The hide trigger is based on the show trigger. If the `trigger` option\n\t       * was passed to the `$tooltipProvider.options` method, it will use the\n\t       * mapped trigger from `triggerMap` or the passed trigger if the map is\n\t       * undefined; otherwise, it uses the `triggerMap` value of the show\n\t       * trigger; else it will just use the show trigger.\n\t       */\n\t      function getTriggers(trigger) {\n\t        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n\t        var hide = show.map(function(trigger) {\n\t          return triggerMap[trigger] || trigger;\n\t        });\n\t        return {\n\t          show: show,\n\t          hide: hide\n\t        };\n\t      }\n\t\n\t      var directiveName = snake_case(ttType);\n\t\n\t      var startSym = $interpolate.startSymbol();\n\t      var endSym = $interpolate.endSymbol();\n\t      var template =\n\t        '<div '+ directiveName + '-popup '+\n\t          'title=\"' + startSym + 'title' + endSym + '\" '+\n\t          (options.useContentExp ?\n\t            'content-exp=\"contentExp()\" ' :\n\t            'content=\"' + startSym + 'content' + endSym + '\" ') +\n\t          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n\t          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n\t          'animation=\"animation\" ' +\n\t          'is-open=\"isOpen\"' +\n\t          'origin-scope=\"origScope\" ' +\n\t          'class=\"uib-position-measure\"' +\n\t          '>' +\n\t        '</div>';\n\t\n\t      return {\n\t        compile: function(tElem, tAttrs) {\n\t          var tooltipLinker = $compile(template);\n\t\n\t          return function link(scope, element, attrs, tooltipCtrl) {\n\t            var tooltip;\n\t            var tooltipLinkedScope;\n\t            var transitionTimeout;\n\t            var showTimeout;\n\t            var hideTimeout;\n\t            var positionTimeout;\n\t            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n\t            var triggers = getTriggers(undefined);\n\t            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n\t            var ttScope = scope.$new(true);\n\t            var repositionScheduled = false;\n\t            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n\t            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n\t            var observers = [];\n\t            var lastPlacement;\n\t\n\t            var positionTooltip = function() {\n\t              // check if tooltip exists and is not empty\n\t              if (!tooltip || !tooltip.html()) { return; }\n\t\n\t              if (!positionTimeout) {\n\t                positionTimeout = $timeout(function() {\n\t                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n\t                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });\n\t\n\t                  if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {\n\t                    tooltip.removeClass(lastPlacement.split('-')[0]);\n\t                    tooltip.addClass(ttPosition.placement.split('-')[0]);\n\t                  }\n\t\n\t                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {\n\t                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);\n\t                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);\n\t                  }\n\t\n\t                  // first time through tt element will have the\n\t                  // uib-position-measure class or if the placement\n\t                  // has changed we need to position the arrow.\n\t                  if (tooltip.hasClass('uib-position-measure')) {\n\t                    $position.positionArrow(tooltip, ttPosition.placement);\n\t                    tooltip.removeClass('uib-position-measure');\n\t                  } else if (lastPlacement !== ttPosition.placement) {\n\t                    $position.positionArrow(tooltip, ttPosition.placement);\n\t                  }\n\t                  lastPlacement = ttPosition.placement;\n\t\n\t                  positionTimeout = null;\n\t                }, 0, false);\n\t              }\n\t            };\n\t\n\t            // Set up the correct scope to allow transclusion later\n\t            ttScope.origScope = scope;\n\t\n\t            // By default, the tooltip is not open.\n\t            // TODO add ability to start tooltip opened\n\t            ttScope.isOpen = false;\n\t            openedTooltips.add(ttScope, {\n\t              close: hide\n\t            });\n\t\n\t            function toggleTooltipBind() {\n\t              if (!ttScope.isOpen) {\n\t                showTooltipBind();\n\t              } else {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip with delay if specified, otherwise show it immediately\n\t            function showTooltipBind() {\n\t              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n\t                return;\n\t              }\n\t\n\t              cancelHide();\n\t              prepareTooltip();\n\t\n\t              if (ttScope.popupDelay) {\n\t                // Do nothing if the tooltip was already scheduled to pop-up.\n\t                // This happens if show is triggered multiple times before any hide is triggered.\n\t                if (!showTimeout) {\n\t                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n\t                }\n\t              } else {\n\t                show();\n\t              }\n\t            }\n\t\n\t            function hideTooltipBind() {\n\t              cancelShow();\n\t\n\t              if (ttScope.popupCloseDelay) {\n\t                if (!hideTimeout) {\n\t                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n\t                }\n\t              } else {\n\t                hide();\n\t              }\n\t            }\n\t\n\t            // Show the tooltip popup element.\n\t            function show() {\n\t              cancelShow();\n\t              cancelHide();\n\t\n\t              // Don't show empty tooltips.\n\t              if (!ttScope.content) {\n\t                return angular.noop;\n\t              }\n\t\n\t              createTooltip();\n\t\n\t              // And show the tooltip.\n\t              ttScope.$evalAsync(function() {\n\t                ttScope.isOpen = true;\n\t                assignIsOpen(true);\n\t                positionTooltip();\n\t              });\n\t            }\n\t\n\t            function cancelShow() {\n\t              if (showTimeout) {\n\t                $timeout.cancel(showTimeout);\n\t                showTimeout = null;\n\t              }\n\t\n\t              if (positionTimeout) {\n\t                $timeout.cancel(positionTimeout);\n\t                positionTimeout = null;\n\t              }\n\t            }\n\t\n\t            // Hide the tooltip popup element.\n\t            function hide() {\n\t              if (!ttScope) {\n\t                return;\n\t              }\n\t\n\t              // First things first: we don't show it anymore.\n\t              ttScope.$evalAsync(function() {\n\t                if (ttScope) {\n\t                  ttScope.isOpen = false;\n\t                  assignIsOpen(false);\n\t                  // And now we remove it from the DOM. However, if we have animation, we\n\t                  // need to wait for it to expire beforehand.\n\t                  // FIXME: this is a placeholder for a port of the transitions library.\n\t                  // The fade transition in TWBS is 150ms.\n\t                  if (ttScope.animation) {\n\t                    if (!transitionTimeout) {\n\t                      transitionTimeout = $timeout(removeTooltip, 150, false);\n\t                    }\n\t                  } else {\n\t                    removeTooltip();\n\t                  }\n\t                }\n\t              });\n\t            }\n\t\n\t            function cancelHide() {\n\t              if (hideTimeout) {\n\t                $timeout.cancel(hideTimeout);\n\t                hideTimeout = null;\n\t              }\n\t\n\t              if (transitionTimeout) {\n\t                $timeout.cancel(transitionTimeout);\n\t                transitionTimeout = null;\n\t              }\n\t            }\n\t\n\t            function createTooltip() {\n\t              // There can only be one tooltip element per directive shown at once.\n\t              if (tooltip) {\n\t                return;\n\t              }\n\t\n\t              tooltipLinkedScope = ttScope.$new();\n\t              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n\t                if (appendToBody) {\n\t                  $document.find('body').append(tooltip);\n\t                } else {\n\t                  element.after(tooltip);\n\t                }\n\t              });\n\t\n\t              prepObservers();\n\t            }\n\t\n\t            function removeTooltip() {\n\t              cancelShow();\n\t              cancelHide();\n\t              unregisterObservers();\n\t\n\t              if (tooltip) {\n\t                tooltip.remove();\n\t                tooltip = null;\n\t              }\n\t              if (tooltipLinkedScope) {\n\t                tooltipLinkedScope.$destroy();\n\t                tooltipLinkedScope = null;\n\t              }\n\t            }\n\t\n\t            /**\n\t             * Set the initial scope values. Once\n\t             * the tooltip is created, the observers\n\t             * will be added to keep things in sync.\n\t             */\n\t            function prepareTooltip() {\n\t              ttScope.title = attrs[prefix + 'Title'];\n\t              if (contentParse) {\n\t                ttScope.content = contentParse(scope);\n\t              } else {\n\t                ttScope.content = attrs[ttType];\n\t              }\n\t\n\t              ttScope.popupClass = attrs[prefix + 'Class'];\n\t              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n\t              var placement = $position.parsePlacement(ttScope.placement);\n\t              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];\n\t\n\t              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n\t              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n\t              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n\t              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n\t            }\n\t\n\t            function assignIsOpen(isOpen) {\n\t              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n\t                isOpenParse.assign(scope, isOpen);\n\t              }\n\t            }\n\t\n\t            ttScope.contentExp = function() {\n\t              return ttScope.content;\n\t            };\n\t\n\t            /**\n\t             * Observe the relevant attributes.\n\t             */\n\t            attrs.$observe('disabled', function(val) {\n\t              if (val) {\n\t                cancelShow();\n\t              }\n\t\n\t              if (val && ttScope.isOpen) {\n\t                hide();\n\t              }\n\t            });\n\t\n\t            if (isOpenParse) {\n\t              scope.$watch(isOpenParse, function(val) {\n\t                if (ttScope && !val === ttScope.isOpen) {\n\t                  toggleTooltipBind();\n\t                }\n\t              });\n\t            }\n\t\n\t            function prepObservers() {\n\t              observers.length = 0;\n\t\n\t              if (contentParse) {\n\t                observers.push(\n\t                  scope.$watch(contentParse, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    }\n\t                  })\n\t                );\n\t\n\t                observers.push(\n\t                  tooltipLinkedScope.$watch(function() {\n\t                    if (!repositionScheduled) {\n\t                      repositionScheduled = true;\n\t                      tooltipLinkedScope.$$postDigest(function() {\n\t                        repositionScheduled = false;\n\t                        if (ttScope && ttScope.isOpen) {\n\t                          positionTooltip();\n\t                        }\n\t                      });\n\t                    }\n\t                  })\n\t                );\n\t              } else {\n\t                observers.push(\n\t                  attrs.$observe(ttType, function(val) {\n\t                    ttScope.content = val;\n\t                    if (!val && ttScope.isOpen) {\n\t                      hide();\n\t                    } else {\n\t                      positionTooltip();\n\t                    }\n\t                  })\n\t                );\n\t              }\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Title', function(val) {\n\t                  ttScope.title = val;\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t\n\t              observers.push(\n\t                attrs.$observe(prefix + 'Placement', function(val) {\n\t                  ttScope.placement = val ? val : options.placement;\n\t                  var placement = $position.parsePlacement(ttScope.placement);\n\t                  lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];\n\t                  if (ttScope.isOpen) {\n\t                    positionTooltip();\n\t                  }\n\t                })\n\t              );\n\t            }\n\t\n\t            function unregisterObservers() {\n\t              if (observers.length) {\n\t                angular.forEach(observers, function(observer) {\n\t                  observer();\n\t                });\n\t                observers.length = 0;\n\t              }\n\t            }\n\t\n\t            // hide tooltips/popovers for outsideClick trigger\n\t            function bodyHideTooltipBind(e) {\n\t              if (!ttScope || !ttScope.isOpen || !tooltip) {\n\t                return;\n\t              }\n\t              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked\n\t              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {\n\t                hideTooltipBind();\n\t              }\n\t            }\n\t\n\t            var unregisterTriggers = function() {\n\t              triggers.show.forEach(function(trigger) {\n\t                if (trigger === 'outsideClick') {\n\t                  element.off('click', toggleTooltipBind);\n\t                } else {\n\t                  element.off(trigger, showTooltipBind);\n\t                  element.off(trigger, toggleTooltipBind);\n\t                }\n\t              });\n\t              triggers.hide.forEach(function(trigger) {\n\t                if (trigger === 'outsideClick') {\n\t                  $document.off('click', bodyHideTooltipBind);\n\t                } else {\n\t                  element.off(trigger, hideTooltipBind);\n\t                }\n\t              });\n\t            };\n\t\n\t            function prepTriggers() {\n\t              var val = attrs[prefix + 'Trigger'];\n\t              unregisterTriggers();\n\t\n\t              triggers = getTriggers(val);\n\t\n\t              if (triggers.show !== 'none') {\n\t                triggers.show.forEach(function(trigger, idx) {\n\t                  if (trigger === 'outsideClick') {\n\t                    element.on('click', toggleTooltipBind);\n\t                    $document.on('click', bodyHideTooltipBind);\n\t                  } else if (trigger === triggers.hide[idx]) {\n\t                    element.on(trigger, toggleTooltipBind);\n\t                  } else if (trigger) {\n\t                    element.on(trigger, showTooltipBind);\n\t                    element.on(triggers.hide[idx], hideTooltipBind);\n\t                  }\n\t\n\t                  element.on('keypress', function(e) {\n\t                    if (e.which === 27) {\n\t                      hideTooltipBind();\n\t                    }\n\t                  });\n\t                });\n\t              }\n\t            }\n\t\n\t            prepTriggers();\n\t\n\t            var animation = scope.$eval(attrs[prefix + 'Animation']);\n\t            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\t\n\t            var appendToBodyVal;\n\t            var appendKey = prefix + 'AppendToBody';\n\t            if (appendKey in attrs && attrs[appendKey] === undefined) {\n\t              appendToBodyVal = true;\n\t            } else {\n\t              appendToBodyVal = scope.$eval(attrs[appendKey]);\n\t            }\n\t\n\t            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\t\n\t            // Make sure tooltip is destroyed and removed.\n\t            scope.$on('$destroy', function onDestroyTooltip() {\n\t              unregisterTriggers();\n\t              removeTooltip();\n\t              openedTooltips.remove(ttScope);\n\t              ttScope = null;\n\t            });\n\t          };\n\t        }\n\t      };\n\t    };\n\t  }];\n\t})\n\t\n\t// This is mostly ngInclude code but with a custom scope\n\t.directive('uibTooltipTemplateTransclude', [\n\t         '$animate', '$sce', '$compile', '$templateRequest',\n\tfunction ($animate, $sce, $compile, $templateRequest) {\n\t  return {\n\t    link: function(scope, elem, attrs) {\n\t      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\t\n\t      var changeCounter = 0,\n\t        currentScope,\n\t        previousElement,\n\t        currentElement;\n\t\n\t      var cleanupLastIncludeContent = function() {\n\t        if (previousElement) {\n\t          previousElement.remove();\n\t          previousElement = null;\n\t        }\n\t\n\t        if (currentScope) {\n\t          currentScope.$destroy();\n\t          currentScope = null;\n\t        }\n\t\n\t        if (currentElement) {\n\t          $animate.leave(currentElement).then(function() {\n\t            previousElement = null;\n\t          });\n\t          previousElement = currentElement;\n\t          currentElement = null;\n\t        }\n\t      };\n\t\n\t      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n\t        var thisChangeId = ++changeCounter;\n\t\n\t        if (src) {\n\t          //set the 2nd param to true to ignore the template request error so that the inner\n\t          //contents and scope can be cleaned up.\n\t          $templateRequest(src, true).then(function(response) {\n\t            if (thisChangeId !== changeCounter) { return; }\n\t            var newScope = origScope.$new();\n\t            var template = response;\n\t\n\t            var clone = $compile(template)(newScope, function(clone) {\n\t              cleanupLastIncludeContent();\n\t              $animate.enter(clone, elem);\n\t            });\n\t\n\t            currentScope = newScope;\n\t            currentElement = clone;\n\t\n\t            currentScope.$emit('$includeContentLoaded', src);\n\t          }, function() {\n\t            if (thisChangeId === changeCounter) {\n\t              cleanupLastIncludeContent();\n\t              scope.$emit('$includeContentError', src);\n\t            }\n\t          });\n\t          scope.$emit('$includeContentRequested', src);\n\t        } else {\n\t          cleanupLastIncludeContent();\n\t        }\n\t      });\n\t\n\t      scope.$on('$destroy', cleanupLastIncludeContent);\n\t    }\n\t  };\n\t}])\n\t\n\t/**\n\t * Note that it's intentional that these classes are *not* applied through $animate.\n\t * They must not be animated as they're expected to be present on the tooltip on\n\t * initialization.\n\t */\n\t.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attrs) {\n\t      // need to set the primary position so the\n\t      // arrow has space during position measure.\n\t      // tooltip.positionTooltip()\n\t      if (scope.placement) {\n\t        // // There are no top-left etc... classes\n\t        // // in TWBS, so we need the primary position.\n\t        var position = $uibPosition.parsePlacement(scope.placement);\n\t        element.addClass(position[0]);\n\t      }\n\t\n\t      if (scope.popupClass) {\n\t        element.addClass(scope.popupClass);\n\t      }\n\t\n\t      if (scope.animation()) {\n\t        element.addClass(attrs.tooltipAnimationClass);\n\t      }\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTooltipPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/tooltip/tooltip-popup.html'\n\t  };\n\t})\n\t\n\t.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n\t}])\n\t\n\t.directive('uibTooltipTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'\n\t  };\n\t})\n\t\n\t.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibTooltipHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'\n\t  };\n\t})\n\t\n\t.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n\t    useContentExp: true\n\t  });\n\t}]);\n\t\n\t/**\n\t * The following features are still outstanding: popup delay, animation as a\n\t * function, placement as a function, inside, support for more triggers than\n\t * just mouse enter/leave, and selector delegatation.\n\t */\n\tangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\t\n\t.directive('uibPopoverTemplatePopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n\t      originScope: '&' },\n\t    templateUrl: 'uib/template/popover/popover-template.html'\n\t  };\n\t})\n\t\n\t.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverHtmlPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/popover/popover-html.html'\n\t  };\n\t})\n\t\n\t.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n\t    useContentExp: true\n\t  });\n\t}])\n\t\n\t.directive('uibPopoverPopup', function() {\n\t  return {\n\t    replace: true,\n\t    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n\t    templateUrl: 'uib/template/popover/popover.html'\n\t  };\n\t})\n\t\n\t.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n\t  return $uibTooltip('uibPopover', 'popover', 'click');\n\t}]);\n\t\n\tangular.module('ui.bootstrap.progressbar', [])\n\t\n\t.constant('uibProgressConfig', {\n\t  animate: true,\n\t  max: 100\n\t})\n\t\n\t.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n\t  var self = this,\n\t      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\t\n\t  this.bars = [];\n\t  $scope.max = getMaxOrDefault();\n\t\n\t  this.addBar = function(bar, element, attrs) {\n\t    if (!animate) {\n\t      element.css({'transition': 'none'});\n\t    }\n\t\n\t    this.bars.push(bar);\n\t\n\t    bar.max = getMaxOrDefault();\n\t    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\t\n\t    bar.$watch('value', function(value) {\n\t      bar.recalculatePercentage();\n\t    });\n\t\n\t    bar.recalculatePercentage = function() {\n\t      var totalPercentage = self.bars.reduce(function(total, bar) {\n\t        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n\t        return total + bar.percent;\n\t      }, 0);\n\t\n\t      if (totalPercentage > 100) {\n\t        bar.percent -= totalPercentage - 100;\n\t      }\n\t    };\n\t\n\t    bar.$on('$destroy', function() {\n\t      element = null;\n\t      self.removeBar(bar);\n\t    });\n\t  };\n\t\n\t  this.removeBar = function(bar) {\n\t    this.bars.splice(this.bars.indexOf(bar), 1);\n\t    this.bars.forEach(function (bar) {\n\t      bar.recalculatePercentage();\n\t    });\n\t  };\n\t\n\t  //$attrs.$observe('maxParam', function(maxParam) {\n\t  $scope.$watch('maxParam', function(maxParam) {\n\t    self.bars.forEach(function(bar) {\n\t      bar.max = getMaxOrDefault();\n\t      bar.recalculatePercentage();\n\t    });\n\t  });\n\t\n\t  function getMaxOrDefault () {\n\t    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;\n\t  }\n\t}])\n\t\n\t.directive('uibProgress', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    require: 'uibProgress',\n\t    scope: {\n\t      maxParam: '=?max'\n\t    },\n\t    templateUrl: 'uib/template/progressbar/progress.html'\n\t  };\n\t})\n\t\n\t.directive('uibBar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    require: '^uibProgress',\n\t    scope: {\n\t      value: '=',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'uib/template/progressbar/bar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, element, attrs);\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibProgressbar', function() {\n\t  return {\n\t    replace: true,\n\t    transclude: true,\n\t    controller: 'UibProgressController',\n\t    scope: {\n\t      value: '=',\n\t      maxParam: '=?max',\n\t      type: '@'\n\t    },\n\t    templateUrl: 'uib/template/progressbar/progressbar.html',\n\t    link: function(scope, element, attrs, progressCtrl) {\n\t      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.rating', [])\n\t\n\t.constant('uibRatingConfig', {\n\t  max: 5,\n\t  stateOn: null,\n\t  stateOff: null,\n\t  titles : ['one', 'two', 'three', 'four', 'five']\n\t})\n\t\n\t.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n\t  var ngModelCtrl = { $setViewValue: angular.noop };\n\t\n\t  this.init = function(ngModelCtrl_) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.push(function(value) {\n\t      if (angular.isNumber(value) && value << 0 !== value) {\n\t        value = Math.round(value);\n\t      }\n\t\n\t      return value;\n\t    });\n\t\n\t    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n\t    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n\t    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n\t    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n\t      tmpTitles : ratingConfig.titles;\n\t\n\t    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n\t      $scope.$parent.$eval($attrs.ratingStates) :\n\t      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n\t    $scope.range = this.buildTemplateObjects(ratingStates);\n\t  };\n\t\n\t  this.buildTemplateObjects = function(states) {\n\t    for (var i = 0, n = states.length; i < n; i++) {\n\t      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n\t    }\n\t    return states;\n\t  };\n\t\n\t  this.getTitle = function(index) {\n\t    if (index >= this.titles.length) {\n\t      return index + 1;\n\t    }\n\t\n\t    return this.titles[index];\n\t  };\n\t\n\t  $scope.rate = function(value) {\n\t    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n\t      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n\t      ngModelCtrl.$render();\n\t    }\n\t  };\n\t\n\t  $scope.enter = function(value) {\n\t    if (!$scope.readonly) {\n\t      $scope.value = value;\n\t    }\n\t    $scope.onHover({value: value});\n\t  };\n\t\n\t  $scope.reset = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t    $scope.onLeave();\n\t  };\n\t\n\t  $scope.onKeydown = function(evt) {\n\t    if (/(37|38|39|40)/.test(evt.which)) {\n\t      evt.preventDefault();\n\t      evt.stopPropagation();\n\t      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n\t    }\n\t  };\n\t\n\t  this.render = function() {\n\t    $scope.value = ngModelCtrl.$viewValue;\n\t  };\n\t}])\n\t\n\t.directive('uibRating', function() {\n\t  return {\n\t    require: ['uibRating', 'ngModel'],\n\t    scope: {\n\t      readonly: '=?readOnly',\n\t      onHover: '&',\n\t      onLeave: '&'\n\t    },\n\t    controller: 'UibRatingController',\n\t    templateUrl: 'uib/template/rating/rating.html',\n\t    replace: true,\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t      ratingCtrl.init(ngModelCtrl);\n\t    }\n\t  };\n\t});\n\t\n\tangular.module('ui.bootstrap.tabs', [])\n\t\n\t.controller('UibTabsetController', ['$scope', function ($scope) {\n\t  var ctrl = this,\n\t    oldIndex;\n\t  ctrl.tabs = [];\n\t\n\t  ctrl.select = function(index) {\n\t    if (!destroyed) {\n\t      var previousIndex = findTabIndex(oldIndex);\n\t      var previousSelected = ctrl.tabs[previousIndex];\n\t      if (previousSelected) {\n\t        previousSelected.tab.onDeselect();\n\t        previousSelected.tab.active = false;\n\t      }\n\t\n\t      var selected = ctrl.tabs[index];\n\t      if (selected) {\n\t        selected.tab.onSelect();\n\t        selected.tab.active = true;\n\t        ctrl.active = selected.index;\n\t        oldIndex = selected.index;\n\t      } else if (!selected && angular.isNumber(oldIndex)) {\n\t        ctrl.active = null;\n\t        oldIndex = null;\n\t      }\n\t    }\n\t  };\n\t\n\t  ctrl.addTab = function addTab(tab) {\n\t    ctrl.tabs.push({\n\t      tab: tab,\n\t      index: tab.index\n\t    });\n\t    ctrl.tabs.sort(function(t1, t2) {\n\t      if (t1.index > t2.index) {\n\t        return 1;\n\t      }\n\t\n\t      if (t1.index < t2.index) {\n\t        return -1;\n\t      }\n\t\n\t      return 0;\n\t    });\n\t\n\t    if (tab.index === ctrl.active || !angular.isNumber(ctrl.active) && ctrl.tabs.length === 1) {\n\t      var newActiveIndex = findTabIndex(tab.index);\n\t      ctrl.select(newActiveIndex);\n\t    }\n\t  };\n\t\n\t  ctrl.removeTab = function removeTab(tab) {\n\t    var index = findTabIndex(tab.index);\n\t\n\t    if (tab.index === ctrl.active) {\n\t      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?\n\t        index - 1 : index + 1 % ctrl.tabs.length;\n\t      ctrl.select(newActiveTabIndex);\n\t    }\n\t\n\t    ctrl.tabs.splice(index, 1);\n\t  };\n\t\n\t  $scope.$watch('tabset.active', function(val) {\n\t    if (angular.isNumber(val) && val !== oldIndex) {\n\t      ctrl.select(findTabIndex(val));\n\t    }\n\t  });\n\t\n\t  var destroyed;\n\t  $scope.$on('$destroy', function() {\n\t    destroyed = true;\n\t  });\n\t\n\t  function findTabIndex(index) {\n\t    for (var i = 0; i < ctrl.tabs.length; i++) {\n\t      if (ctrl.tabs[i].index === index) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t}])\n\t\n\t.directive('uibTabset', function() {\n\t  return {\n\t    transclude: true,\n\t    replace: true,\n\t    scope: {},\n\t    bindToController: {\n\t      active: '=?',\n\t      type: '@'\n\t    },\n\t    controller: 'UibTabsetController',\n\t    controllerAs: 'tabset',\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/tabs/tabset.html';\n\t    },\n\t    link: function(scope, element, attrs) {\n\t      scope.vertical = angular.isDefined(attrs.vertical) ?\n\t        scope.$parent.$eval(attrs.vertical) : false;\n\t      scope.justified = angular.isDefined(attrs.justified) ?\n\t        scope.$parent.$eval(attrs.justified) : false;\n\t      if (angular.isUndefined(attrs.active)) {\n\t        scope.active = 0;\n\t      }\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTab', ['$parse', function($parse) {\n\t  return {\n\t    require: '^uibTabset',\n\t    replace: true,\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || 'uib/template/tabs/tab.html';\n\t    },\n\t    transclude: true,\n\t    scope: {\n\t      heading: '@',\n\t      index: '=?',\n\t      classes: '@?',\n\t      onSelect: '&select', //This callback is called in contentHeadingTransclude\n\t                          //once it inserts the tab's content into the dom\n\t      onDeselect: '&deselect'\n\t    },\n\t    controller: function() {\n\t      //Empty controller so other directives can require being 'under' a tab\n\t    },\n\t    controllerAs: 'tab',\n\t    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n\t      scope.disabled = false;\n\t      if (attrs.disable) {\n\t        scope.$parent.$watch($parse(attrs.disable), function(value) {\n\t          scope.disabled = !! value;\n\t        });\n\t      }\n\t\n\t      if (angular.isUndefined(attrs.index)) {\n\t        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {\n\t          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;\n\t        } else {\n\t          scope.index = 0;\n\t        }\n\t      }\n\t\n\t      if (angular.isUndefined(attrs.classes)) {\n\t        scope.classes = '';\n\t      }\n\t\n\t      scope.select = function() {\n\t        if (!scope.disabled) {\n\t          var index;\n\t          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {\n\t            if (tabsetCtrl.tabs[i].tab === scope) {\n\t              index = i;\n\t              break;\n\t            }\n\t          }\n\t\n\t          tabsetCtrl.select(index);\n\t        }\n\t      };\n\t\n\t      tabsetCtrl.addTab(scope);\n\t      scope.$on('$destroy', function() {\n\t        tabsetCtrl.removeTab(scope);\n\t      });\n\t\n\t      //We need to transclude later, once the content container is ready.\n\t      //when this link happens, we're inside a tab heading.\n\t      scope.$transcludeFn = transclude;\n\t    }\n\t  };\n\t}])\n\t\n\t.directive('uibTabHeadingTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^uibTab',\n\t    link: function(scope, elm) {\n\t      scope.$watch('headingElement', function updateHeadingElement(heading) {\n\t        if (heading) {\n\t          elm.html('');\n\t          elm.append(heading);\n\t        }\n\t      });\n\t    }\n\t  };\n\t})\n\t\n\t.directive('uibTabContentTransclude', function() {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^uibTabset',\n\t    link: function(scope, elm, attrs) {\n\t      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;\n\t\n\t      //Now our tab is ready to be transcluded: both the tab heading area\n\t      //and the tab content area are loaded.  Transclude 'em both.\n\t      tab.$transcludeFn(tab.$parent, function(contents) {\n\t        angular.forEach(contents, function(node) {\n\t          if (isTabHeading(node)) {\n\t            //Let tabHeadingTransclude know.\n\t            tab.headingElement = node;\n\t          } else {\n\t            elm.append(node);\n\t          }\n\t        });\n\t      });\n\t    }\n\t  };\n\t\n\t  function isTabHeading(node) {\n\t    return node.tagName && (\n\t      node.hasAttribute('uib-tab-heading') ||\n\t      node.hasAttribute('data-uib-tab-heading') ||\n\t      node.hasAttribute('x-uib-tab-heading') ||\n\t      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n\t      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n\t    );\n\t  }\n\t});\n\t\n\tangular.module('ui.bootstrap.timepicker', [])\n\t\n\t.constant('uibTimepickerConfig', {\n\t  hourStep: 1,\n\t  minuteStep: 1,\n\t  secondStep: 1,\n\t  showMeridian: true,\n\t  showSeconds: false,\n\t  meridians: null,\n\t  readonlyInput: false,\n\t  mousewheel: true,\n\t  arrowkeys: true,\n\t  showSpinners: true,\n\t  templateUrl: 'uib/template/timepicker/timepicker.html'\n\t})\n\t\n\t.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n\t  var selected = new Date(),\n\t    watchers = [],\n\t    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n\t    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\t\n\t  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n\t  $element.removeAttr('tabindex');\n\t\n\t  this.init = function(ngModelCtrl_, inputs) {\n\t    ngModelCtrl = ngModelCtrl_;\n\t    ngModelCtrl.$render = this.render;\n\t\n\t    ngModelCtrl.$formatters.unshift(function(modelValue) {\n\t      return modelValue ? new Date(modelValue) : null;\n\t    });\n\t\n\t    var hoursInputEl = inputs.eq(0),\n\t        minutesInputEl = inputs.eq(1),\n\t        secondsInputEl = inputs.eq(2);\n\t\n\t    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\t\n\t    if (mousewheel) {\n\t      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n\t    }\n\t\n\t    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n\t    if (arrowkeys) {\n\t      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n\t    }\n\t\n\t    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n\t    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n\t  };\n\t\n\t  var hourStep = timepickerConfig.hourStep;\n\t  if ($attrs.hourStep) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n\t      hourStep = +value;\n\t    }));\n\t  }\n\t\n\t  var minuteStep = timepickerConfig.minuteStep;\n\t  if ($attrs.minuteStep) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n\t      minuteStep = +value;\n\t    }));\n\t  }\n\t\n\t  var min;\n\t  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {\n\t    var dt = new Date(value);\n\t    min = isNaN(dt) ? undefined : dt;\n\t  }));\n\t\n\t  var max;\n\t  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {\n\t    var dt = new Date(value);\n\t    max = isNaN(dt) ? undefined : dt;\n\t  }));\n\t\n\t  var disabled = false;\n\t  if ($attrs.ngDisabled) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {\n\t      disabled = value;\n\t    }));\n\t  }\n\t\n\t  $scope.noIncrementHours = function() {\n\t    var incrementedSelected = addMinutes(selected, hourStep * 60);\n\t    return disabled || incrementedSelected > max ||\n\t      incrementedSelected < selected && incrementedSelected < min;\n\t  };\n\t\n\t  $scope.noDecrementHours = function() {\n\t    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n\t    return disabled || decrementedSelected < min ||\n\t      decrementedSelected > selected && decrementedSelected > max;\n\t  };\n\t\n\t  $scope.noIncrementMinutes = function() {\n\t    var incrementedSelected = addMinutes(selected, minuteStep);\n\t    return disabled || incrementedSelected > max ||\n\t      incrementedSelected < selected && incrementedSelected < min;\n\t  };\n\t\n\t  $scope.noDecrementMinutes = function() {\n\t    var decrementedSelected = addMinutes(selected, -minuteStep);\n\t    return disabled || decrementedSelected < min ||\n\t      decrementedSelected > selected && decrementedSelected > max;\n\t  };\n\t\n\t  $scope.noIncrementSeconds = function() {\n\t    var incrementedSelected = addSeconds(selected, secondStep);\n\t    return disabled || incrementedSelected > max ||\n\t      incrementedSelected < selected && incrementedSelected < min;\n\t  };\n\t\n\t  $scope.noDecrementSeconds = function() {\n\t    var decrementedSelected = addSeconds(selected, -secondStep);\n\t    return disabled || decrementedSelected < min ||\n\t      decrementedSelected > selected && decrementedSelected > max;\n\t  };\n\t\n\t  $scope.noToggleMeridian = function() {\n\t    if (selected.getHours() < 12) {\n\t      return disabled || addMinutes(selected, 12 * 60) > max;\n\t    }\n\t\n\t    return disabled || addMinutes(selected, -12 * 60) < min;\n\t  };\n\t\n\t  var secondStep = timepickerConfig.secondStep;\n\t  if ($attrs.secondStep) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {\n\t      secondStep = +value;\n\t    }));\n\t  }\n\t\n\t  $scope.showSeconds = timepickerConfig.showSeconds;\n\t  if ($attrs.showSeconds) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {\n\t      $scope.showSeconds = !!value;\n\t    }));\n\t  }\n\t\n\t  // 12H / 24H mode\n\t  $scope.showMeridian = timepickerConfig.showMeridian;\n\t  if ($attrs.showMeridian) {\n\t    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n\t      $scope.showMeridian = !!value;\n\t\n\t      if (ngModelCtrl.$error.time) {\n\t        // Evaluate from template\n\t        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n\t        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t          selected.setHours(hours);\n\t          refresh();\n\t        }\n\t      } else {\n\t        updateTemplate();\n\t      }\n\t    }));\n\t  }\n\t\n\t  // Get $scope.hours in 24H mode if valid\n\t  function getHoursFromTemplate() {\n\t    var hours = +$scope.hours;\n\t    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :\n\t      hours >= 0 && hours < 24;\n\t    if (!valid) {\n\t      return undefined;\n\t    }\n\t\n\t    if ($scope.showMeridian) {\n\t      if (hours === 12) {\n\t        hours = 0;\n\t      }\n\t      if ($scope.meridian === meridians[1]) {\n\t        hours = hours + 12;\n\t      }\n\t    }\n\t    return hours;\n\t  }\n\t\n\t  function getMinutesFromTemplate() {\n\t    var minutes = +$scope.minutes;\n\t    return minutes >= 0 && minutes < 60 ? minutes : undefined;\n\t  }\n\t\n\t  function getSecondsFromTemplate() {\n\t    var seconds = +$scope.seconds;\n\t    return seconds >= 0 && seconds < 60 ? seconds : undefined;\n\t  }\n\t\n\t  function pad(value) {\n\t    if (value === null) {\n\t      return '';\n\t    }\n\t\n\t    return angular.isDefined(value) && value.toString().length < 2 ?\n\t      '0' + value : value.toString();\n\t  }\n\t\n\t  // Respond on mousewheel spin\n\t  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n\t    var isScrollingUp = function(e) {\n\t      if (e.originalEvent) {\n\t        e = e.originalEvent;\n\t      }\n\t      //pick correct delta variable depending on event\n\t      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;\n\t      return e.detail || delta > 0;\n\t    };\n\t\n\t    hoursInputEl.bind('mousewheel wheel', function(e) {\n\t      if (!disabled) {\n\t        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n\t      }\n\t      e.preventDefault();\n\t    });\n\t\n\t    minutesInputEl.bind('mousewheel wheel', function(e) {\n\t      if (!disabled) {\n\t        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n\t      }\n\t      e.preventDefault();\n\t    });\n\t\n\t     secondsInputEl.bind('mousewheel wheel', function(e) {\n\t      if (!disabled) {\n\t        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());\n\t      }\n\t      e.preventDefault();\n\t    });\n\t  };\n\t\n\t  // Respond on up/down arrowkeys\n\t  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n\t    hoursInputEl.bind('keydown', function(e) {\n\t      if (!disabled) {\n\t        if (e.which === 38) { // up\n\t          e.preventDefault();\n\t          $scope.incrementHours();\n\t          $scope.$apply();\n\t        } else if (e.which === 40) { // down\n\t          e.preventDefault();\n\t          $scope.decrementHours();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    });\n\t\n\t    minutesInputEl.bind('keydown', function(e) {\n\t      if (!disabled) {\n\t        if (e.which === 38) { // up\n\t          e.preventDefault();\n\t          $scope.incrementMinutes();\n\t          $scope.$apply();\n\t        } else if (e.which === 40) { // down\n\t          e.preventDefault();\n\t          $scope.decrementMinutes();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    });\n\t\n\t    secondsInputEl.bind('keydown', function(e) {\n\t      if (!disabled) {\n\t        if (e.which === 38) { // up\n\t          e.preventDefault();\n\t          $scope.incrementSeconds();\n\t          $scope.$apply();\n\t        } else if (e.which === 40) { // down\n\t          e.preventDefault();\n\t          $scope.decrementSeconds();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    });\n\t  };\n\t\n\t  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n\t    if ($scope.readonlyInput) {\n\t      $scope.updateHours = angular.noop;\n\t      $scope.updateMinutes = angular.noop;\n\t      $scope.updateSeconds = angular.noop;\n\t      return;\n\t    }\n\t\n\t    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {\n\t      ngModelCtrl.$setViewValue(null);\n\t      ngModelCtrl.$setValidity('time', false);\n\t      if (angular.isDefined(invalidHours)) {\n\t        $scope.invalidHours = invalidHours;\n\t      }\n\t\n\t      if (angular.isDefined(invalidMinutes)) {\n\t        $scope.invalidMinutes = invalidMinutes;\n\t      }\n\t\n\t      if (angular.isDefined(invalidSeconds)) {\n\t        $scope.invalidSeconds = invalidSeconds;\n\t      }\n\t    };\n\t\n\t    $scope.updateHours = function() {\n\t      var hours = getHoursFromTemplate(),\n\t        minutes = getMinutesFromTemplate();\n\t\n\t      ngModelCtrl.$setDirty();\n\t\n\t      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n\t        selected.setHours(hours);\n\t        selected.setMinutes(minutes);\n\t        if (selected < min || selected > max) {\n\t          invalidate(true);\n\t        } else {\n\t          refresh('h');\n\t        }\n\t      } else {\n\t        invalidate(true);\n\t      }\n\t    };\n\t\n\t    hoursInputEl.bind('blur', function(e) {\n\t      ngModelCtrl.$setTouched();\n\t      if ($scope.hours === null || $scope.hours === '') {\n\t        invalidate(true);\n\t      } else if (!$scope.invalidHours && $scope.hours < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.hours = pad($scope.hours);\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateMinutes = function() {\n\t      var minutes = getMinutesFromTemplate(),\n\t        hours = getHoursFromTemplate();\n\t\n\t      ngModelCtrl.$setDirty();\n\t\n\t      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n\t        selected.setHours(hours);\n\t        selected.setMinutes(minutes);\n\t        if (selected < min || selected > max) {\n\t          invalidate(undefined, true);\n\t        } else {\n\t          refresh('m');\n\t        }\n\t      } else {\n\t        invalidate(undefined, true);\n\t      }\n\t    };\n\t\n\t    minutesInputEl.bind('blur', function(e) {\n\t      ngModelCtrl.$setTouched();\n\t      if ($scope.minutes === null) {\n\t        invalidate(undefined, true);\n\t      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {\n\t        $scope.$apply(function() {\n\t          $scope.minutes = pad($scope.minutes);\n\t        });\n\t      }\n\t    });\n\t\n\t    $scope.updateSeconds = function() {\n\t      var seconds = getSecondsFromTemplate();\n\t\n\t      ngModelCtrl.$setDirty();\n\t\n\t      if (angular.isDefined(seconds)) {\n\t        selected.setSeconds(seconds);\n\t        refresh('s');\n\t      } else {\n\t        invalidate(undefined, undefined, true);\n\t      }\n\t    };\n\t\n\t    secondsInputEl.bind('blur', function(e) {\n\t      if (!$scope.invalidSeconds && $scope.seconds < 10) {\n\t        $scope.$apply( function() {\n\t          $scope.seconds = pad($scope.seconds);\n\t        });\n\t      }\n\t    });\n\t\n\t  };\n\t\n\t  this.render = function() {\n\t    var date = ngModelCtrl.$viewValue;\n\t\n\t    if (isNaN(date)) {\n\t      ngModelCtrl.$setValidity('time', false);\n\t      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n\t    } else {\n\t      if (date) {\n\t        selected = date;\n\t      }\n\t\n\t      if (selected < min || selected > max) {\n\t        ngModelCtrl.$setValidity('time', false);\n\t        $scope.invalidHours = true;\n\t        $scope.invalidMinutes = true;\n\t      } else {\n\t        makeValid();\n\t      }\n\t      updateTemplate();\n\t    }\n\t  };\n\t\n\t  // Call internally when we know that model is valid.\n\t  function refresh(keyboardChange) {\n\t    makeValid();\n\t    ngModelCtrl.$setViewValue(new Date(selected));\n\t    updateTemplate(keyboardChange);\n\t  }\n\t\n\t  function makeValid() {\n\t    ngModelCtrl.$setValidity('time', true);\n\t    $scope.invalidHours = false;\n\t    $scope.invalidMinutes = false;\n\t    $scope.invalidSeconds = false;\n\t  }\n\t\n\t  function updateTemplate(keyboardChange) {\n\t    if (!ngModelCtrl.$modelValue) {\n\t      $scope.hours = null;\n\t      $scope.minutes = null;\n\t      $scope.seconds = null;\n\t      $scope.meridian = meridians[0];\n\t    } else {\n\t      var hours = selected.getHours(),\n\t        minutes = selected.getMinutes(),\n\t        seconds = selected.getSeconds();\n\t\n\t      if ($scope.showMeridian) {\n\t        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system\n\t      }\n\t\n\t      $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n\t      if (keyboardChange !== 'm') {\n\t        $scope.minutes = pad(minutes);\n\t      }\n\t      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t\n\t      if (keyboardChange !== 's') {\n\t        $scope.seconds = pad(seconds);\n\t      }\n\t      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\t    }\n\t  }\n\t\n\t  function addSecondsToSelected(seconds) {\n\t    selected = addSeconds(selected, seconds);\n\t    refresh();\n\t  }\n\t\n\t  function addMinutes(selected, minutes) {\n\t    return addSeconds(selected, minutes*60);\n\t  }\n\t\n\t  function addSeconds(date, seconds) {\n\t    var dt = new Date(date.getTime() + seconds * 1000);\n\t    var newDate = new Date(date);\n\t    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());\n\t    return newDate;\n\t  }\n\t\n\t  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n\t    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\t\n\t  $scope.incrementHours = function() {\n\t    if (!$scope.noIncrementHours()) {\n\t      addSecondsToSelected(hourStep * 60 * 60);\n\t    }\n\t  };\n\t\n\t  $scope.decrementHours = function() {\n\t    if (!$scope.noDecrementHours()) {\n\t      addSecondsToSelected(-hourStep * 60 * 60);\n\t    }\n\t  };\n\t\n\t  $scope.incrementMinutes = function() {\n\t    if (!$scope.noIncrementMinutes()) {\n\t      addSecondsToSelected(minuteStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.decrementMinutes = function() {\n\t    if (!$scope.noDecrementMinutes()) {\n\t      addSecondsToSelected(-minuteStep * 60);\n\t    }\n\t  };\n\t\n\t  $scope.incrementSeconds = function() {\n\t    if (!$scope.noIncrementSeconds()) {\n\t      addSecondsToSelected(secondStep);\n\t    }\n\t  };\n\t\n\t  $scope.decrementSeconds = function() {\n\t    if (!$scope.noDecrementSeconds()) {\n\t      addSecondsToSelected(-secondStep);\n\t    }\n\t  };\n\t\n\t  $scope.toggleMeridian = function() {\n\t    var minutes = getMinutesFromTemplate(),\n\t        hours = getHoursFromTemplate();\n\t\n\t    if (!$scope.noToggleMeridian()) {\n\t      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n\t        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));\n\t      } else {\n\t        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];\n\t      }\n\t    }\n\t  };\n\t\n\t  $scope.blur = function() {\n\t    ngModelCtrl.$setTouched();\n\t  };\n\t\n\t  $scope.$on('$destroy', function() {\n\t    while (watchers.length) {\n\t      watchers.shift()();\n\t    }\n\t  });\n\t}])\n\t\n\t.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {\n\t  return {\n\t    require: ['uibTimepicker', '?^ngModel'],\n\t    controller: 'UibTimepickerController',\n\t    controllerAs: 'timepicker',\n\t    replace: true,\n\t    scope: {},\n\t    templateUrl: function(element, attrs) {\n\t      return attrs.templateUrl || uibTimepickerConfig.templateUrl;\n\t    },\n\t    link: function(scope, element, attrs, ctrls) {\n\t      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\t\n\t      if (ngModelCtrl) {\n\t        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n\t      }\n\t    }\n\t  };\n\t}]);\n\t\n\tangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])\n\t\n\t/**\n\t * A helper service that can parse typeahead's syntax (string provided by users)\n\t * Extracted to a separate service for ease of unit testing\n\t */\n\t  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n\t    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n\t    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n\t    return {\n\t      parse: function(input) {\n\t        var match = input.match(TYPEAHEAD_REGEXP);\n\t        if (!match) {\n\t          throw new Error(\n\t            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n\t              ' but got \"' + input + '\".');\n\t        }\n\t\n\t        return {\n\t          itemName: match[3],\n\t          source: $parse(match[4]),\n\t          viewMapper: $parse(match[2] || match[1]),\n\t          modelMapper: $parse(match[1])\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',\n\t    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {\n\t    var HOT_KEYS = [9, 13, 27, 38, 40];\n\t    var eventDebounceTime = 200;\n\t    var modelCtrl, ngModelOptions;\n\t    //SUPPORTED ATTRIBUTES (OPTIONS)\n\t\n\t    //minimal no of characters that needs to be entered before typeahead kicks-in\n\t    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n\t    if (!minLength && minLength !== 0) {\n\t      minLength = 1;\n\t    }\n\t\n\t    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {\n\t        minLength = !newVal && newVal !== 0 ? 1 : newVal;\n\t    });\n\t    \n\t    //minimal wait time after last character typed before typeahead kicks-in\n\t    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\t\n\t    //should it restrict model values to the ones selected from the popup only?\n\t    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n\t    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {\n\t      isEditable = newVal !== false;\n\t    });\n\t\n\t    //binding to a variable that indicates if matches are being retrieved asynchronously\n\t    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\t\n\t    //a callback executed when a match is selected\n\t    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\t\n\t    //should it select highlighted popup value when losing focus?\n\t    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\t\n\t    //binding to a variable that indicates if there were no results after the query is completed\n\t    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\t\n\t    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\t\n\t    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\t\n\t    var appendTo = attrs.typeaheadAppendTo ?\n\t      originalScope.$eval(attrs.typeaheadAppendTo) : null;\n\t\n\t    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\t\n\t    //If input matches an item of the list exactly, select it automatically\n\t    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\t\n\t    //binding to a variable that indicates if dropdown is open\n\t    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;\n\t\n\t    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;\n\t\n\t    //INTERNAL VARIABLES\n\t\n\t    //model setter executed upon match selection\n\t    var parsedModel = $parse(attrs.ngModel);\n\t    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n\t    var $setModelValue = function(scope, newValue) {\n\t      if (angular.isFunction(parsedModel(originalScope)) &&\n\t        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n\t        return invokeModelSetter(scope, {$$$p: newValue});\n\t      }\n\t\n\t      return parsedModel.assign(scope, newValue);\n\t    };\n\t\n\t    //expressions used by typeahead\n\t    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\t\n\t    var hasFocus;\n\t\n\t    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n\t    //mousedown & mouseup events\n\t    //Issue #3699\n\t    var selected;\n\t\n\t    //create a child scope for the typeahead directive so we are not polluting original scope\n\t    //with typeahead-specific data (matches, query etc.)\n\t    var scope = originalScope.$new();\n\t    var offDestroy = originalScope.$on('$destroy', function() {\n\t      scope.$destroy();\n\t    });\n\t    scope.$on('$destroy', offDestroy);\n\t\n\t    // WAI-ARIA\n\t    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n\t    element.attr({\n\t      'aria-autocomplete': 'list',\n\t      'aria-expanded': false,\n\t      'aria-owns': popupId\n\t    });\n\t\n\t    var inputsContainer, hintInputElem;\n\t    //add read-only input to show hint\n\t    if (showHint) {\n\t      inputsContainer = angular.element('<div></div>');\n\t      inputsContainer.css('position', 'relative');\n\t      element.after(inputsContainer);\n\t      hintInputElem = element.clone();\n\t      hintInputElem.attr('placeholder', '');\n\t      hintInputElem.attr('tabindex', '-1');\n\t      hintInputElem.val('');\n\t      hintInputElem.css({\n\t        'position': 'absolute',\n\t        'top': '0px',\n\t        'left': '0px',\n\t        'border-color': 'transparent',\n\t        'box-shadow': 'none',\n\t        'opacity': 1,\n\t        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',\n\t        'color': '#999'\n\t      });\n\t      element.css({\n\t        'position': 'relative',\n\t        'vertical-align': 'top',\n\t        'background-color': 'transparent'\n\t      });\n\t      inputsContainer.append(hintInputElem);\n\t      hintInputElem.after(element);\n\t    }\n\t\n\t    //pop-up element used to display matches\n\t    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n\t    popUpEl.attr({\n\t      id: popupId,\n\t      matches: 'matches',\n\t      active: 'activeIdx',\n\t      select: 'select(activeIdx, evt)',\n\t      'move-in-progress': 'moveInProgress',\n\t      query: 'query',\n\t      position: 'position',\n\t      'assign-is-open': 'assignIsOpen(isOpen)',\n\t      debounce: 'debounceUpdate'\n\t    });\n\t    //custom item template\n\t    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n\t      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n\t    }\n\t\n\t    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n\t      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n\t    }\n\t\n\t    var resetHint = function() {\n\t      if (showHint) {\n\t        hintInputElem.val('');\n\t      }\n\t    };\n\t\n\t    var resetMatches = function() {\n\t      scope.matches = [];\n\t      scope.activeIdx = -1;\n\t      element.attr('aria-expanded', false);\n\t      resetHint();\n\t    };\n\t\n\t    var getMatchId = function(index) {\n\t      return popupId + '-option-' + index;\n\t    };\n\t\n\t    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n\t    // This attribute is added or removed automatically when the `activeIdx` changes.\n\t    scope.$watch('activeIdx', function(index) {\n\t      if (index < 0) {\n\t        element.removeAttr('aria-activedescendant');\n\t      } else {\n\t        element.attr('aria-activedescendant', getMatchId(index));\n\t      }\n\t    });\n\t\n\t    var inputIsExactMatch = function(inputValue, index) {\n\t      if (scope.matches.length > index && inputValue) {\n\t        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    var getMatchesAsync = function(inputValue, evt) {\n\t      var locals = {$viewValue: inputValue};\n\t      isLoadingSetter(originalScope, true);\n\t      isNoResultsSetter(originalScope, false);\n\t      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n\t        //it might happen that several async queries were in progress if a user were typing fast\n\t        //but we are interested only in responses that correspond to the current view value\n\t        var onCurrentRequest = inputValue === modelCtrl.$viewValue;\n\t        if (onCurrentRequest && hasFocus) {\n\t          if (matches && matches.length > 0) {\n\t            scope.activeIdx = focusFirst ? 0 : -1;\n\t            isNoResultsSetter(originalScope, false);\n\t            scope.matches.length = 0;\n\t\n\t            //transform labels\n\t            for (var i = 0; i < matches.length; i++) {\n\t              locals[parserResult.itemName] = matches[i];\n\t              scope.matches.push({\n\t                id: getMatchId(i),\n\t                label: parserResult.viewMapper(scope, locals),\n\t                model: matches[i]\n\t              });\n\t            }\n\t\n\t            scope.query = inputValue;\n\t            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n\t            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n\t            //due to other elements being rendered\n\t            recalculatePosition();\n\t\n\t            element.attr('aria-expanded', true);\n\t\n\t            //Select the single remaining option if user input matches\n\t            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n\t              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n\t                $$debounce(function() {\n\t                  scope.select(0, evt);\n\t                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n\t              } else {\n\t                scope.select(0, evt);\n\t              }\n\t            }\n\t\n\t            if (showHint) {\n\t              var firstLabel = scope.matches[0].label;\n\t              if (angular.isString(inputValue) &&\n\t                inputValue.length > 0 &&\n\t                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {\n\t                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));\n\t              } else {\n\t                hintInputElem.val('');\n\t              }\n\t            }\n\t          } else {\n\t            resetMatches();\n\t            isNoResultsSetter(originalScope, true);\n\t          }\n\t        }\n\t        if (onCurrentRequest) {\n\t          isLoadingSetter(originalScope, false);\n\t        }\n\t      }, function() {\n\t        resetMatches();\n\t        isLoadingSetter(originalScope, false);\n\t        isNoResultsSetter(originalScope, true);\n\t      });\n\t    };\n\t\n\t    // bind events only if appendToBody params exist - performance feature\n\t    if (appendToBody) {\n\t      angular.element($window).on('resize', fireRecalculating);\n\t      $document.find('body').on('scroll', fireRecalculating);\n\t    }\n\t\n\t    // Declare the debounced function outside recalculating for\n\t    // proper debouncing\n\t    var debouncedRecalculate = $$debounce(function() {\n\t      // if popup is visible\n\t      if (scope.matches.length) {\n\t        recalculatePosition();\n\t      }\n\t\n\t      scope.moveInProgress = false;\n\t    }, eventDebounceTime);\n\t\n\t    // Default progress type\n\t    scope.moveInProgress = false;\n\t\n\t    function fireRecalculating() {\n\t      if (!scope.moveInProgress) {\n\t        scope.moveInProgress = true;\n\t        scope.$digest();\n\t      }\n\t\n\t      debouncedRecalculate();\n\t    }\n\t\n\t    // recalculate actual position and set new values to scope\n\t    // after digest loop is popup in right position\n\t    function recalculatePosition() {\n\t      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n\t      scope.position.top += element.prop('offsetHeight');\n\t    }\n\t\n\t    //we need to propagate user's query so we can higlight matches\n\t    scope.query = undefined;\n\t\n\t    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n\t    var timeoutPromise;\n\t\n\t    var scheduleSearchWithTimeout = function(inputValue) {\n\t      timeoutPromise = $timeout(function() {\n\t        getMatchesAsync(inputValue);\n\t      }, waitTime);\n\t    };\n\t\n\t    var cancelPreviousTimeout = function() {\n\t      if (timeoutPromise) {\n\t        $timeout.cancel(timeoutPromise);\n\t      }\n\t    };\n\t\n\t    resetMatches();\n\t\n\t    scope.assignIsOpen = function (isOpen) {\n\t      isOpenSetter(originalScope, isOpen);\n\t    };\n\t\n\t    scope.select = function(activeIdx, evt) {\n\t      //called from within the $digest() cycle\n\t      var locals = {};\n\t      var model, item;\n\t\n\t      selected = true;\n\t      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n\t      model = parserResult.modelMapper(originalScope, locals);\n\t      $setModelValue(originalScope, model);\n\t      modelCtrl.$setValidity('editable', true);\n\t      modelCtrl.$setValidity('parse', true);\n\t\n\t      onSelectCallback(originalScope, {\n\t        $item: item,\n\t        $model: model,\n\t        $label: parserResult.viewMapper(originalScope, locals),\n\t        $event: evt\n\t      });\n\t\n\t      resetMatches();\n\t\n\t      //return focus to the input element if a match was selected via a mouse click event\n\t      // use timeout to avoid $rootScope:inprog error\n\t      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n\t        $timeout(function() { element[0].focus(); }, 0, false);\n\t      }\n\t    };\n\t\n\t    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n\t    element.on('keydown', function(evt) {\n\t      //typeahead is open and an \"interesting\" key was pressed\n\t      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n\t        return;\n\t      }\n\t\n\t      /**\n\t       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit\n\t       * or\n\t       * shift + tab is pressed to bring focus to the previous element\n\t       * then clear the results\n\t       */\n\t      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13) || evt.which === 9 && !!evt.shiftKey) {\n\t        resetMatches();\n\t        scope.$digest();\n\t        return;\n\t      }\n\t\n\t      evt.preventDefault();\n\t      var target;\n\t      switch (evt.which) {\n\t        case 9:\n\t        case 13:\n\t          scope.$apply(function () {\n\t            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n\t              $$debounce(function() {\n\t                scope.select(scope.activeIdx, evt);\n\t              }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n\t            } else {\n\t              scope.select(scope.activeIdx, evt);\n\t            }\n\t          });\n\t          break;\n\t        case 27:\n\t          evt.stopPropagation();\n\t\n\t          resetMatches();\n\t          scope.$digest();\n\t          break;\n\t        case 38:\n\t          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n\t          scope.$digest();\n\t          target = popUpEl.find('li')[scope.activeIdx];\n\t          target.parentNode.scrollTop = target.offsetTop;\n\t          break;\n\t        case 40:\n\t          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n\t          scope.$digest();\n\t          target = popUpEl.find('li')[scope.activeIdx];\n\t          target.parentNode.scrollTop = target.offsetTop;\n\t          break;\n\t      }\n\t    });\n\t\n\t    element.bind('focus', function (evt) {\n\t      hasFocus = true;\n\t      if (minLength === 0 && !modelCtrl.$viewValue) {\n\t        $timeout(function() {\n\t          getMatchesAsync(modelCtrl.$viewValue, evt);\n\t        }, 0);\n\t      }\n\t    });\n\t\n\t    element.bind('blur', function(evt) {\n\t      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n\t        selected = true;\n\t        scope.$apply(function() {\n\t          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {\n\t            $$debounce(function() {\n\t              scope.select(scope.activeIdx, evt);\n\t            }, scope.debounceUpdate.blur);\n\t          } else {\n\t            scope.select(scope.activeIdx, evt);\n\t          }\n\t        });\n\t      }\n\t      if (!isEditable && modelCtrl.$error.editable) {\n\t        modelCtrl.$viewValue = '';\n\t        element.val('');\n\t      }\n\t      hasFocus = false;\n\t      selected = false;\n\t    });\n\t\n\t    // Keep reference to click handler to unbind it.\n\t    var dismissClickHandler = function(evt) {\n\t      // Issue #3973\n\t      // Firefox treats right click as a click on document\n\t      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n\t        resetMatches();\n\t        if (!$rootScope.$$phase) {\n\t          scope.$digest();\n\t        }\n\t      }\n\t    };\n\t\n\t    $document.on('click', dismissClickHandler);\n\t\n\t    originalScope.$on('$destroy', function() {\n\t      $document.off('click', dismissClickHandler);\n\t      if (appendToBody || appendTo) {\n\t        $popup.remove();\n\t      }\n\t\n\t      if (appendToBody) {\n\t        angular.element($window).off('resize', fireRecalculating);\n\t        $document.find('body').off('scroll', fireRecalculating);\n\t      }\n\t      // Prevent jQuery cache memory leak\n\t      popUpEl.remove();\n\t\n\t      if (showHint) {\n\t          inputsContainer.remove();\n\t      }\n\t    });\n\t\n\t    var $popup = $compile(popUpEl)(scope);\n\t\n\t    if (appendToBody) {\n\t      $document.find('body').append($popup);\n\t    } else if (appendTo) {\n\t      angular.element(appendTo).eq(0).append($popup);\n\t    } else {\n\t      element.after($popup);\n\t    }\n\t\n\t    this.init = function(_modelCtrl, _ngModelOptions) {\n\t      modelCtrl = _modelCtrl;\n\t      ngModelOptions = _ngModelOptions;\n\t\n\t      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);\n\t\n\t      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n\t      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n\t      modelCtrl.$parsers.unshift(function(inputValue) {\n\t        hasFocus = true;\n\t\n\t        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n\t          if (waitTime > 0) {\n\t            cancelPreviousTimeout();\n\t            scheduleSearchWithTimeout(inputValue);\n\t          } else {\n\t            getMatchesAsync(inputValue);\n\t          }\n\t        } else {\n\t          isLoadingSetter(originalScope, false);\n\t          cancelPreviousTimeout();\n\t          resetMatches();\n\t        }\n\t\n\t        if (isEditable) {\n\t          return inputValue;\n\t        }\n\t\n\t        if (!inputValue) {\n\t          // Reset in case user had typed something previously.\n\t          modelCtrl.$setValidity('editable', true);\n\t          return null;\n\t        }\n\t\n\t        modelCtrl.$setValidity('editable', false);\n\t        return undefined;\n\t      });\n\t\n\t      modelCtrl.$formatters.push(function(modelValue) {\n\t        var candidateViewValue, emptyViewValue;\n\t        var locals = {};\n\t\n\t        // The validity may be set to false via $parsers (see above) if\n\t        // the model is restricted to selected values. If the model\n\t        // is set manually it is considered to be valid.\n\t        if (!isEditable) {\n\t          modelCtrl.$setValidity('editable', true);\n\t        }\n\t\n\t        if (inputFormatter) {\n\t          locals.$model = modelValue;\n\t          return inputFormatter(originalScope, locals);\n\t        }\n\t\n\t        //it might happen that we don't have enough info to properly render input value\n\t        //we need to check for this situation and simply return model value if we can't apply custom formatting\n\t        locals[parserResult.itemName] = modelValue;\n\t        candidateViewValue = parserResult.viewMapper(originalScope, locals);\n\t        locals[parserResult.itemName] = undefined;\n\t        emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\t\n\t        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n\t      });\n\t    };\n\t  }])\n\t\n\t  .directive('uibTypeahead', function() {\n\t    return {\n\t      controller: 'UibTypeaheadController',\n\t      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n\t      link: function(originalScope, element, attrs, ctrls) {\n\t        ctrls[2].init(ctrls[0], ctrls[1]);\n\t      }\n\t    };\n\t  })\n\t\n\t  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {\n\t    return {\n\t      scope: {\n\t        matches: '=',\n\t        query: '=',\n\t        active: '=',\n\t        position: '&',\n\t        moveInProgress: '=',\n\t        select: '&',\n\t        assignIsOpen: '&',\n\t        debounce: '&'\n\t      },\n\t      replace: true,\n\t      templateUrl: function(element, attrs) {\n\t        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        scope.templateUrl = attrs.templateUrl;\n\t\n\t        scope.isOpen = function() {\n\t          var isDropdownOpen = scope.matches.length > 0;\n\t          scope.assignIsOpen({ isOpen: isDropdownOpen });\n\t          return isDropdownOpen;\n\t        };\n\t\n\t        scope.isActive = function(matchIdx) {\n\t          return scope.active === matchIdx;\n\t        };\n\t\n\t        scope.selectActive = function(matchIdx) {\n\t          scope.active = matchIdx;\n\t        };\n\t\n\t        scope.selectMatch = function(activeIdx, evt) {\n\t          var debounce = scope.debounce();\n\t          if (angular.isNumber(debounce) || angular.isObject(debounce)) {\n\t            $$debounce(function() {\n\t              scope.select({activeIdx: activeIdx, evt: evt});\n\t            }, angular.isNumber(debounce) ? debounce : debounce['default']);\n\t          } else {\n\t            scope.select({activeIdx: activeIdx, evt: evt});\n\t          }\n\t        };\n\t      }\n\t    };\n\t  }])\n\t\n\t  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n\t    return {\n\t      scope: {\n\t        index: '=',\n\t        match: '=',\n\t        query: '='\n\t      },\n\t      link: function(scope, element, attrs) {\n\t        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';\n\t        $templateRequest(tplUrl).then(function(tplContent) {\n\t          var tplEl = angular.element(tplContent.trim());\n\t          element.replaceWith(tplEl);\n\t          $compile(tplEl)(scope);\n\t        });\n\t      }\n\t    };\n\t  }])\n\t\n\t  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n\t    var isSanitizePresent;\n\t    isSanitizePresent = $injector.has('$sanitize');\n\t\n\t    function escapeRegexp(queryToEscape) {\n\t      // Regex: capture the whole query string and replace it with the string that will be used to match\n\t      // the results, for example if the capture is \"a\" the result will be \\a\n\t      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n\t    }\n\t\n\t    function containsHtml(matchItem) {\n\t      return /<.*>/g.test(matchItem);\n\t    }\n\t\n\t    return function(matchItem, query) {\n\t      if (!isSanitizePresent && containsHtml(matchItem)) {\n\t        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n\t      }\n\t      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n\t      if (!isSanitizePresent) {\n\t        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n\t      }\n\t      return matchItem;\n\t    };\n\t  }]);\n\t\n\tangular.module(\"uib/template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/accordion/accordion-group.html\",\n\t    \"<div class=\\\"panel\\\" ng-class=\\\"panelClass || 'panel-default'\\\">\\n\" +\n\t    \"  <div role=\\\"tab\\\" id=\\\"{{::headingId}}\\\" aria-selected=\\\"{{isOpen}}\\\" class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n\t    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n\t    \"      <a role=\\\"button\\\" data-toggle=\\\"collapse\\\" href aria-expanded=\\\"{{isOpen}}\\\" aria-controls=\\\"{{::panelId}}\\\" tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span uib-accordion-header ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n\t    \"    </h4>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"  <div id=\\\"{{::panelId}}\\\" aria-labelledby=\\\"{{::headingId}}\\\" aria-hidden=\\\"{{!isOpen}}\\\" role=\\\"tabpanel\\\" class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n\t    \"    <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/accordion/accordion.html\",\n\t    \"<div role=\\\"tablist\\\" class=\\\"panel-group\\\" ng-transclude></div>\");\n\t}]);\n\t\n\tangular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/alert/alert.html\",\n\t    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n\t    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n\t    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n\t    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n\t    \"    </button>\\n\" +\n\t    \"    <div ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/carousel/carousel.html\",\n\t    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n\t    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n\t    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n\t    \"  </a>\\n\" +\n\t    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n\t    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"  </ol>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/carousel/slide.html\",\n\t    \"<div ng-class=\\\"{\\n\" +\n\t    \"    'active': active\\n\" +\n\t    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/datepicker.html\",\n\t    \"<div class=\\\"uib-datepicker\\\" ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n\t    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n\t    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n\t    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/day.html\",\n\t    \"<table class=\\\"uib-daypicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n\t    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"uib-weeks\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-day text-center\\\" role=\\\"gridcell\\\"\\n\" +\n\t    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n\t    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\"\\n\" +\n\t    \"          uib-is-class=\\\"\\n\" +\n\t    \"            'btn-info' for selectedDt,\\n\" +\n\t    \"            'active' for activeDt\\n\" +\n\t    \"            on dt\\\"\\n\" +\n\t    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n\t    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n\t    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/month.html\",\n\t    \"<table class=\\\"uib-monthpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"uib-months\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-month text-center\\\" role=\\\"gridcell\\\"\\n\" +\n\t    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n\t    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n\t    \"          uib-is-class=\\\"\\n\" +\n\t    \"            'btn-info' for selectedDt,\\n\" +\n\t    \"            'active' for activeDt\\n\" +\n\t    \"            on dt\\\"\\n\" +\n\t    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n\t    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n\t    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/popup.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"uib-datepicker-popup dropdown-menu uib-position-measure\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n\t    \"    <li ng-transclude></li>\\n\" +\n\t    \"    <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n\t    \"      <span class=\\\"btn-group pull-left\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today', $event)\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null, $event)\\\">{{ getText('clear') }}</button>\\n\" +\n\t    \"      </span>\\n\" +\n\t    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close($event)\\\">{{ getText('close') }}</button>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"  </ul>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/datepicker/year.html\",\n\t    \"<table class=\\\"uib-yearpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n\t    \"  <thead>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n\t    \"      <th colspan=\\\"{{::columns - 2}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n\t    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </thead>\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"uib-years\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n\t    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-year text-center\\\" role=\\\"gridcell\\\"\\n\" +\n\t    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n\t    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n\t    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n\t    \"          uib-is-class=\\\"\\n\" +\n\t    \"            'btn-info' for selectedDt,\\n\" +\n\t    \"            'active' for activeDt\\n\" +\n\t    \"            on dt\\\"\\n\" +\n\t    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n\t    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n\t    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/modal/backdrop.html\",\n\t    \"<div class=\\\"modal-backdrop\\\"\\n\" +\n\t    \"     uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"     modal-in-class=\\\"in\\\"\\n\" +\n\t    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n\t    \"></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/modal/window.html\",\n\t    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n\t    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n\t    \"    modal-in-class=\\\"in\\\"\\n\" +\n\t    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n\t    \"    <div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/pager/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/pager/pager.html\",\n\t    \"<ul class=\\\"pager\\\">\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/pagination/pager.html\",\n\t    \"<ul class=\\\"pager\\\">\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/pagination/pagination.html\",\n\t    \"<ul class=\\\"pagination\\\">\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n\t    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n\t    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tooltip/tooltip-html-popup.html\",\n\t    \"<div class=\\\"tooltip\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tooltip/tooltip-popup.html\",\n\t    \"<div class=\\\"tooltip\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tooltip/tooltip-template-popup.html\",\n\t    \"<div class=\\\"tooltip\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n\t    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n\t    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/popover/popover-html.html\",\n\t    \"<div class=\\\"popover\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/popover/popover-template.html\",\n\t    \"<div class=\\\"popover\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\"\\n\" +\n\t    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n\t    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/popover/popover.html\",\n\t    \"<div class=\\\"popover\\\"\\n\" +\n\t    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n\t    \"  uib-tooltip-classes\\n\" +\n\t    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n\t    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n\t    \"\\n\" +\n\t    \"  <div class=\\\"popover-inner\\\">\\n\" +\n\t    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n\t    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/progressbar/bar.html\",\n\t    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/progressbar/progress.html\",\n\t    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n\t}]);\n\t\n\tangular.module(\"uib/template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/progressbar/progressbar.html\",\n\t    \"<div class=\\\"progress\\\">\\n\" +\n\t    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/rating/rating.html\",\n\t    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n\t    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n\t    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n\t    \"</span>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tabs/tab.html\",\n\t    \"<li ng-class=\\\"[{active: active, disabled: disabled}, classes]\\\" class=\\\"uib-tab nav-item\\\">\\n\" +\n\t    \"  <a href ng-click=\\\"select()\\\" class=\\\"nav-link\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n\t    \"</li>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/tabs/tabset.html\",\n\t    \"<div>\\n\" +\n\t    \"  <ul class=\\\"nav nav-{{tabset.type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n\t    \"  <div class=\\\"tab-content\\\">\\n\" +\n\t    \"    <div class=\\\"tab-pane\\\"\\n\" +\n\t    \"         ng-repeat=\\\"tab in tabset.tabs\\\"\\n\" +\n\t    \"         ng-class=\\\"{active: tabset.active === tab.index}\\\"\\n\" +\n\t    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n\t    \"    </div>\\n\" +\n\t    \"  </div>\\n\" +\n\t    \"</div>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/timepicker/timepicker.html\",\n\t    \"<table class=\\\"uib-timepicker\\\">\\n\" +\n\t    \"  <tbody>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td class=\\\"uib-increment hours\\\"><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td class=\\\"uib-increment minutes\\\"><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-increment seconds\\\"><a ng-click=\\\"incrementSeconds()\\\" ng-class=\\\"{disabled: noIncrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr>\\n\" +\n\t    \"      <td class=\\\"form-group uib-time hours\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"HH\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementHours()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td class=\\\"uib-separator\\\">:</td>\\n\" +\n\t    \"      <td class=\\\"form-group uib-time minutes\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"MM\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementMinutes()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-separator\\\">:</td>\\n\" +\n\t    \"      <td class=\\\"form-group uib-time seconds\\\" ng-class=\\\"{'has-error': invalidSeconds}\\\" ng-show=\\\"showSeconds\\\">\\n\" +\n\t    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"SS\\\" ng-model=\\\"seconds\\\" ng-change=\\\"updateSeconds()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementSeconds()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n\t    \"      </td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\" class=\\\"uib-time am-pm\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n\t    \"      <td class=\\\"uib-decrement hours\\\"><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td>&nbsp;</td>\\n\" +\n\t    \"      <td class=\\\"uib-decrement minutes\\\"><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n\t    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-decrement seconds\\\"><a ng-click=\\\"decrementSeconds()\\\" ng-class=\\\"{disabled: noDecrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n\t    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n\t    \"    </tr>\\n\" +\n\t    \"  </tbody>\\n\" +\n\t    \"</table>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/typeahead/typeahead-match.html\",\n\t    \"<a href\\n\" +\n\t    \"   tabindex=\\\"-1\\\"\\n\" +\n\t    \"   ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"\\n\" +\n\t    \"   ng-attr-title=\\\"{{match.label}}\\\"></a>\\n\" +\n\t    \"\");\n\t}]);\n\t\n\tangular.module(\"uib/template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n\t  $templateCache.put(\"uib/template/typeahead/typeahead-popup.html\",\n\t    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n\t    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index, $event)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n\t    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n\t    \"    </li>\\n\" +\n\t    \"</ul>\\n\" +\n\t    \"\");\n\t}]);\n\tangular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); });\n\tangular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll;}</style>'); });\n\tangular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}.uib-left,.uib-right{width:100%}</style>'); });\n\tangular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); });\n\tangular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'); });\n\tangular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); });\n\n/***/ },\n\n/***/ 134:\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }\n\n/******/ })));\n\n\n/** WEBPACK FOOTER **\n ** vendors.eca3ce42c5612bd159b7.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tvar _m = moreModules[moduleId];\n\n \t\t\t// Check if module is deduplicated\n \t\t\tswitch(typeof _m) {\n \t\t\tcase \"object\":\n \t\t\t\t// Module can be created from a template\n \t\t\t\tmodules[moduleId] = (function(_m) {\n \t\t\t\t\tvar args = _m.slice(1), templateId = _m[0];\n \t\t\t\t\treturn function (a,b,c) {\n \t\t\t\t\t\tmodules[templateId].apply(this, [a,b,c].concat(args));\n \t\t\t\t\t};\n \t\t\t\t}(_m));\n \t\t\t\tbreak;\n \t\t\tcase \"function\":\n \t\t\t\t// Normal module\n \t\t\t\tmodules[moduleId] = _m;\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\t// Module is a copy of another module\n \t\t\t\tmodules[moduleId] = modules[_m];\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t1:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"chunk.\" + {\"0\":\"bea689d366ba2240570d\",\"2\":\"e50da52995f0151ae5fb\",\"3\":\"1d63a2e9ba095d06927b\"}[chunkId] + \".js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap eca3ce42c5612bd159b7\n **/","module.exports = angular;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 2\n ** module chunks = 1\n **/","//! api-check version 7.5.5 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us) (ó ì_í)=óò=(ì_í ò)\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"apiCheck\"] = factory();\n\telse\n\t\troot[\"apiCheck\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _apiCheck = __webpack_require__(1);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = _apiCheck2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\tvar apiCheckUtil = __webpack_require__(3);\n\tvar each = apiCheckUtil.each;\n\tvar isError = apiCheckUtil.isError;\n\tvar t = apiCheckUtil.t;\n\tvar arrayify = apiCheckUtil.arrayify;\n\tvar getCheckerDisplay = apiCheckUtil.getCheckerDisplay;\n\tvar typeOf = apiCheckUtil.typeOf;\n\tvar getError = apiCheckUtil.getError;\n\n\tvar checkers = __webpack_require__(4);\n\tvar apiCheckApis = getApiCheckApis();\n\n\tmodule.exports = getApiCheckInstance;\n\tmodule.exports.VERSION = (\"7.5.5\");\n\tmodule.exports.utils = apiCheckUtil;\n\tmodule.exports.globalConfig = {\n\t  verbose: false,\n\t  disabled: false\n\t};\n\n\tvar apiCheckApiCheck = getApiCheckInstance({\n\t  output: { prefix: 'apiCheck' }\n\t});\n\tmodule.exports.internalChecker = apiCheckApiCheck;\n\n\teach(checkers, function (checker, name) {\n\t  return module.exports[name] = checker;\n\t});\n\n\tfunction getApiCheckInstance() {\n\t  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t  var extraCheckers = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t  /* eslint complexity:[2, 6] */\n\t  if (apiCheckApiCheck && arguments.length) {\n\t    apiCheckApiCheck['throw'](apiCheckApis.getApiCheckInstanceCheckers, arguments, {\n\t      prefix: 'creating an apiCheck instance'\n\t    });\n\t  }\n\n\t  var additionalProperties = {\n\t    'throw': getApiCheck(true),\n\t    warn: getApiCheck(false),\n\t    getErrorMessage: getErrorMessage,\n\t    handleErrorMessage: handleErrorMessage,\n\t    config: {\n\t      output: config.output || {\n\t        prefix: '',\n\t        suffix: '',\n\t        docsBaseUrl: ''\n\t      },\n\t      verbose: config.verbose || false,\n\t      disabled: config.disabled || false\n\t    },\n\t    utils: apiCheckUtil\n\t  };\n\n\t  each(additionalProperties, function (wrapper, name) {\n\t    return apiCheck[name] = wrapper;\n\t  });\n\n\t  var disabled = apiCheck.disabled || module.exports.globalConfig.disabled;\n\t  each(checkers.getCheckers(disabled), function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\t  each(extraCheckers, function (checker, name) {\n\t    return apiCheck[name] = checker;\n\t  });\n\n\t  return apiCheck;\n\n\t  /**\n\t   * This is the instance function. Other things are attached to this see additional properties above.\n\t   * @param {Array} api - the checkers to check with\n\t   * @param {Array} args - the args to check\n\t   * @param {Object} output - output options\n\t   * @returns {Object} - if this has a failed = true property, then it failed\n\t   */\n\t  function apiCheck(api, args, output) {\n\t    /* eslint complexity:[2, 8] */\n\t    if (apiCheck.config.disabled || module.exports.globalConfig.disabled) {\n\t      return {\n\t        apiTypes: {}, argTypes: {},\n\t        passed: true, message: '',\n\t        failed: false\n\t      }; // empty version of what is normally returned\n\t    }\n\t    checkApiCheckApi(arguments);\n\t    if (!Array.isArray(api)) {\n\t      api = [api];\n\t      args = [args];\n\t    } else {\n\t      // turn arguments into an array\n\t      args = Array.prototype.slice.call(args);\n\t    }\n\t    var messages = checkEnoughArgs(api, args);\n\t    if (!messages.length) {\n\t      // this is where we actually go perform the checks.\n\t      messages = checkApiWithArgs(api, args);\n\t    }\n\n\t    var returnObject = getTypes(api, args);\n\t    returnObject.args = args;\n\t    if (messages.length) {\n\t      returnObject.message = apiCheck.getErrorMessage(api, args, messages, output);\n\t      returnObject.failed = true;\n\t      returnObject.passed = false;\n\t    } else {\n\t      returnObject.message = '';\n\t      returnObject.failed = false;\n\t      returnObject.passed = true;\n\t    }\n\t    return returnObject;\n\t  }\n\n\t  /**\n\t   * checkApiCheckApi, should be read like: check apiCheck api. As in, check the api for apiCheck :-)\n\t   * @param {Array} checkApiArgs - args provided to apiCheck function\n\t   */\n\t  function checkApiCheckApi(checkApiArgs) {\n\t    var api = checkApiArgs[0];\n\t    var args = checkApiArgs[1];\n\t    var isArrayOrArgs = Array.isArray(args) || args && typeof args === 'object' && typeof args.length === 'number';\n\n\t    if (Array.isArray(api) && !isArrayOrArgs) {\n\t      throw new Error(getErrorMessage(api, [args], ['If an array is provided for the api, an array must be provided for the args as well.'], { prefix: 'apiCheck' }));\n\t    }\n\t    // dog fooding here\n\t    var errors = checkApiWithArgs(apiCheckApis.checkApiCheckApi, checkApiArgs);\n\t    if (errors.length) {\n\t      var message = apiCheck.getErrorMessage(apiCheckApis.checkApiCheckApi, checkApiArgs, errors, {\n\t        prefix: 'apiCheck'\n\t      });\n\t      apiCheck.handleErrorMessage(message, true);\n\t    }\n\t  }\n\n\t  function getApiCheck(shouldThrow) {\n\t    return function apiCheckWrapper(api, args, output) {\n\t      var result = apiCheck(api, args, output);\n\t      apiCheck.handleErrorMessage(result.message, shouldThrow);\n\t      return result; // wont get here if an error is thrown\n\t    };\n\t  }\n\n\t  function handleErrorMessage(message, shouldThrow) {\n\t    if (shouldThrow && message) {\n\t      throw new Error(message);\n\t    } else if (message) {\n\t      /* eslint no-console:0 */\n\t      console.warn(message);\n\t    }\n\t  }\n\n\t  function getErrorMessage(api, args) {\n\t    var messages = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\t    var output = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n\t    var gOut = apiCheck.config.output || {};\n\t    var prefix = getPrefix();\n\t    var suffix = getSuffix();\n\t    var url = getUrl();\n\t    var message = 'apiCheck failed! ' + messages.join(', ');\n\t    var passedAndShouldHavePassed = '\\n\\n' + buildMessageFromApiAndArgs(api, args);\n\t    return (prefix + ' ' + message + ' ' + suffix + ' ' + (url || '') + passedAndShouldHavePassed).trim();\n\n\t    function getPrefix() {\n\t      var p = output.onlyPrefix;\n\t      if (!p) {\n\t        p = ((gOut.prefix || '') + ' ' + (output.prefix || '')).trim();\n\t      }\n\t      return p;\n\t    }\n\n\t    function getSuffix() {\n\t      var s = output.onlySuffix;\n\t      if (!s) {\n\t        s = ((output.suffix || '') + ' ' + (gOut.suffix || '')).trim();\n\t      }\n\t      return s;\n\t    }\n\n\t    function getUrl() {\n\t      var u = output.url;\n\t      if (!u) {\n\t        u = gOut.docsBaseUrl && output.urlSuffix && ('' + gOut.docsBaseUrl + output.urlSuffix).trim();\n\t      }\n\t      return u;\n\t    }\n\t  }\n\n\t  function buildMessageFromApiAndArgs(api, args) {\n\t    var _getTypes = getTypes(api, args);\n\n\t    var apiTypes = _getTypes.apiTypes;\n\t    var argTypes = _getTypes.argTypes;\n\n\t    var copy = Array.prototype.slice.call(args || []);\n\t    var replacedItems = [];\n\t    replaceFunctionWithName(copy);\n\t    var passedArgs = getObjectString(copy);\n\t    argTypes = getObjectString(argTypes);\n\t    apiTypes = getObjectString(apiTypes);\n\n\t    return generateMessage();\n\n\t    // functions\n\n\t    function replaceFunctionWithName(obj) {\n\t      each(obj, function (val, name) {\n\t        /* eslint complexity:[2, 6] */\n\t        if (replacedItems.indexOf(val) === -1) {\n\t          // avoid recursive problems\n\t          replacedItems.push(val);\n\t          if (typeof val === 'object') {\n\t            replaceFunctionWithName(obj);\n\t          } else if (typeof val === 'function') {\n\t            obj[name] = val.displayName || val.name || 'anonymous function';\n\t          }\n\t        }\n\t      });\n\t    }\n\n\t    function getObjectString(types) {\n\t      if (!types || !types.length) {\n\t        return 'nothing';\n\t      } else if (types && types.length === 1) {\n\t        types = types[0];\n\t      }\n\t      return stringify(types, null, 2);\n\t    }\n\n\t    function generateMessage() {\n\t      var n = '\\n';\n\t      var useS = true;\n\t      if (args && args.length === 1) {\n\t        if (typeof args[0] === 'object' && args[0] !== null) {\n\t          useS = !!Object.keys(args[0]).length;\n\t        } else {\n\t          useS = false;\n\t        }\n\t      }\n\t      var types = 'type' + (useS ? 's' : '');\n\t      var newLine = n + n;\n\t      return 'You passed:' + n + passedArgs + newLine + ('With the ' + types + ':' + n + argTypes + newLine) + ('The API calls for:' + n + apiTypes);\n\t    }\n\t  }\n\n\t  function getTypes(api, args) {\n\t    api = arrayify(api);\n\t    args = arrayify(args);\n\t    var apiTypes = api.map(function (checker, index) {\n\t      var specified = module.exports.globalConfig.hasOwnProperty('verbose');\n\t      return getCheckerDisplay(checker, {\n\t        terse: specified ? !module.exports.globalConfig.verbose : !apiCheck.config.verbose,\n\t        obj: args[index],\n\t        addHelpers: true\n\t      });\n\t    });\n\t    var argTypes = args.map(function (arg) {\n\t      return getArgDisplay(arg, []);\n\t    });\n\t    return { argTypes: argTypes, apiTypes: apiTypes };\n\t  }\n\t}\n\n\t// STATELESS FUNCTIONS\n\n\t/**\n\t * This is where the magic happens for actually checking the arguments with the api.\n\t * @param {Array} api - checkers\n\t * @param  {Array} args - and arguments object\n\t * @returns {Array} - the error messages\n\t */\n\tfunction checkApiWithArgs(api, args) {\n\t  /* eslint complexity:[2, 7] */\n\t  var messages = [];\n\t  var failed = false;\n\t  var checkerIndex = 0;\n\t  var argIndex = 0;\n\t  var arg = undefined,\n\t      checker = undefined,\n\t      res = undefined,\n\t      lastChecker = undefined,\n\t      argName = undefined,\n\t      argFailed = undefined,\n\t      skipPreviousChecker = undefined;\n\t  /* jshint -W084 */\n\t  while ((checker = api[checkerIndex++]) && argIndex < args.length) {\n\t    arg = args[argIndex++];\n\t    argName = 'Argument ' + argIndex + (checker.isOptional ? ' (optional)' : '');\n\t    res = checker(arg, 'value', argName);\n\t    argFailed = isError(res);\n\t    lastChecker = checkerIndex >= api.length;\n\t    skipPreviousChecker = checkerIndex > 1 && api[checkerIndex - 1].isOptional;\n\t    if (argFailed && lastChecker || argFailed && !lastChecker && !checker.isOptional && !skipPreviousChecker) {\n\t      failed = true;\n\t      messages.push(getCheckerErrorMessage(res, checker, arg));\n\t    } else if (argFailed && checker.isOptional) {\n\t      argIndex--;\n\t    } else {\n\t      messages.push(t(argName) + ' passed');\n\t    }\n\t  }\n\t  return failed ? messages : [];\n\t}\n\n\tcheckerTypeType.type = 'function with __apiCheckData property and `${function.type}` property';\n\tfunction checkerTypeType(checkerType, name, location) {\n\t  var apiCheckDataChecker = checkers.shape({\n\t    type: checkers.string,\n\t    optional: checkers.bool\n\t  });\n\t  var asFunc = checkers.func.withProperties({ __apiCheckData: apiCheckDataChecker });\n\t  var asShape = checkers.shape({ __apiCheckData: apiCheckDataChecker });\n\t  var wrongShape = checkers.oneOfType([asFunc, asShape])(checkerType, name, location);\n\t  if (isError(wrongShape)) {\n\t    return wrongShape;\n\t  }\n\t  if (typeof checkerType !== 'function' && !checkerType.hasOwnProperty(checkerType.__apiCheckData.type)) {\n\t    return getError(name, location, checkerTypeType.type);\n\t  }\n\t}\n\n\tfunction getCheckerErrorMessage(res, checker, val) {\n\t  var checkerHelp = getCheckerHelp(checker, val);\n\t  checkerHelp = checkerHelp ? ' - ' + checkerHelp : '';\n\t  return res.message + checkerHelp;\n\t}\n\n\tfunction getCheckerHelp(_ref, val) {\n\t  var help = _ref.help;\n\n\t  if (!help) {\n\t    return '';\n\t  }\n\t  if (typeof help === 'function') {\n\t    help = help(val);\n\t  }\n\t  return help;\n\t}\n\n\tfunction checkEnoughArgs(api, args) {\n\t  var requiredArgs = api.filter(function (a) {\n\t    return !a.isOptional;\n\t  });\n\t  if (args.length < requiredArgs.length) {\n\t    return ['Not enough arguments specified. Requires `' + requiredArgs.length + '`, you passed `' + args.length + '`'];\n\t  } else {\n\t    return [];\n\t  }\n\t}\n\n\tfunction getArgDisplay(arg, gottenArgs) {\n\t  /* eslint complexity:[2, 7] */\n\t  var cName = arg && arg.constructor && arg.constructor.name;\n\t  var type = typeOf(arg);\n\t  if (type === 'function') {\n\t    if (hasKeys()) {\n\t      var properties = stringify(getDisplayIfNotGotten());\n\t      return cName + ' (with properties: ' + properties + ')';\n\t    }\n\t    return cName;\n\t  }\n\n\t  if (arg === null) {\n\t    return 'null';\n\t  }\n\n\t  if (type !== 'array' && type !== 'object') {\n\t    return type;\n\t  }\n\n\t  if (hasKeys()) {\n\t    return getDisplayIfNotGotten();\n\t  }\n\n\t  return cName;\n\n\t  // utility functions\n\t  function hasKeys() {\n\t    return arg && Object.keys(arg).length;\n\t  }\n\n\t  function getDisplayIfNotGotten() {\n\t    if (gottenArgs.indexOf(arg) !== -1) {\n\t      return '[Circular]';\n\t    }\n\t    gottenArgs.push(arg);\n\t    return getDisplay(arg, gottenArgs);\n\t  }\n\t}\n\n\tfunction getDisplay(obj, gottenArgs) {\n\t  var argDisplay = {};\n\t  each(obj, function (v, k) {\n\t    return argDisplay[k] = getArgDisplay(v, gottenArgs);\n\t  });\n\t  return argDisplay;\n\t}\n\n\tfunction getApiCheckApis() {\n\t  var os = checkers.string.optional;\n\n\t  var checkerFnChecker = checkers.func.withProperties({\n\t    type: checkers.oneOfType([checkers.string, checkerTypeType]).optional,\n\t    displayName: checkers.string.optional,\n\t    shortType: checkers.string.optional,\n\t    notOptional: checkers.bool.optional,\n\t    notRequired: checkers.bool.optional\n\t  });\n\n\t  var getApiCheckInstanceCheckers = [checkers.shape({\n\t    output: checkers.shape({\n\t      prefix: checkers.string.optional,\n\t      suffix: checkers.string.optional,\n\t      docsBaseUrl: checkers.string.optional\n\t    }).strict.optional,\n\t    verbose: checkers.bool.optional,\n\t    disabled: checkers.bool.optional\n\t  }).strict.optional, checkers.objectOf(checkerFnChecker).optional];\n\n\t  var checkApiCheckApi = [checkers.typeOrArrayOf(checkerFnChecker), checkers.any.optional, checkers.shape({\n\t    prefix: os, suffix: os, urlSuffix: os, // appended case\n\t    onlyPrefix: os, onlySuffix: os, url: os // override case\n\t  }).strict.optional];\n\n\t  return {\n\t    checkerFnChecker: checkerFnChecker,\n\t    getApiCheckInstanceCheckers: getApiCheckInstanceCheckers,\n\t    checkApiCheckApi: checkApiCheckApi\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = stringify;\n\n\tfunction getSerialize (fn, decycle) {\n\t  var seen = [], keys = [];\n\t  decycle = decycle || function(key, value) {\n\t    return '[Circular ' + getPath(value, seen, keys) + ']'\n\t  };\n\t  return function(key, value) {\n\t    var ret = value;\n\t    if (typeof value === 'object' && value) {\n\t      if (seen.indexOf(value) !== -1)\n\t        ret = decycle(key, value);\n\t      else {\n\t        seen.push(value);\n\t        keys.push(key);\n\t      }\n\t    }\n\t    if (fn) ret = fn(key, ret);\n\t    return ret;\n\t  }\n\t}\n\n\tfunction getPath (value, seen, keys) {\n\t  var index = seen.indexOf(value);\n\t  var path = [ keys[index] ];\n\t  for (index--; index >= 0; index--) {\n\t    if (seen[index][ path[0] ] === value) {\n\t      value = seen[index];\n\t      path.unshift(keys[index]);\n\t    }\n\t  }\n\t  return '~' + path.join('.');\n\t}\n\n\tfunction stringify(obj, fn, spaces, decycle) {\n\t  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);\n\t}\n\n\tstringify.getSerialize = getSerialize;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\tvar stringify = __webpack_require__(2);\n\tvar checkerHelpers = {\n\t  addOptional: addOptional, getRequiredVersion: getRequiredVersion, setupChecker: setupChecker, addNullable: addNullable\n\t};\n\n\tmodule.exports = {\n\t  each: each, copy: copy, typeOf: typeOf, arrayify: arrayify, getCheckerDisplay: getCheckerDisplay,\n\t  isError: isError, list: list, getError: getError, nAtL: nAtL, t: t, undef: undef, checkerHelpers: checkerHelpers,\n\t  noop: noop\n\t};\n\n\tfunction copy(obj) {\n\t  var type = typeOf(obj);\n\t  var daCopy = undefined;\n\t  if (type === 'array') {\n\t    daCopy = [];\n\t  } else if (type === 'object') {\n\t    daCopy = {};\n\t  } else {\n\t    return obj;\n\t  }\n\t  each(obj, function (val, key) {\n\t    daCopy[key] = val; // cannot single-line this because we don't want to abort the each\n\t  });\n\t  return daCopy;\n\t}\n\n\tfunction typeOf(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return 'array';\n\t  } else if (obj instanceof RegExp) {\n\t    return 'object';\n\t  } else {\n\t    return typeof obj;\n\t  }\n\t}\n\n\tfunction getCheckerDisplay(checker, options) {\n\t  /* eslint complexity:[2, 7] */\n\t  var display = undefined;\n\t  var short = options && options.short;\n\t  if (short && checker.shortType) {\n\t    display = checker.shortType;\n\t  } else if (!short && typeof checker.type === 'object' || checker.type === 'function') {\n\t    display = getCheckerType(checker, options);\n\t  } else {\n\t    display = getCheckerType(checker, options) || checker.displayName || checker.name;\n\t  }\n\t  return display;\n\t}\n\n\tfunction getCheckerType(_ref, options) {\n\t  var type = _ref.type;\n\n\t  if (typeof type === 'function') {\n\t    var __apiCheckData = type.__apiCheckData;\n\t    var typeTypes = type(options);\n\t    type = _defineProperty({\n\t      __apiCheckData: __apiCheckData\n\t    }, __apiCheckData.type, typeTypes);\n\t  }\n\t  return type;\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (!obj) {\n\t    return [];\n\t  } else if (Array.isArray(obj)) {\n\t    return obj;\n\t  } else {\n\t    return [obj];\n\t  }\n\t}\n\n\tfunction each(obj, iterator, context) {\n\t  if (Array.isArray(obj)) {\n\t    return eachArry(obj, iterator, context);\n\t  } else {\n\t    return eachObj(obj, iterator, context);\n\t  }\n\t}\n\n\tfunction eachObj(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t  /* eslint prefer-const:0 */ // some weird eslint bug?\n\t  for (var key in obj) {\n\t    if (hasOwn.call(obj, key)) {\n\t      ret = iterator.call(context, obj[key], key, obj);\n\t      if (ret === false) {\n\t        return ret;\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction eachArry(obj, iterator, context) {\n\t  var ret = undefined;\n\t  var length = obj.length;\n\t  for (var i = 0; i < length; i++) {\n\t    ret = iterator.call(context, obj[i], i, obj);\n\t    if (ret === false) {\n\t      return ret;\n\t    }\n\t  }\n\t  return true;\n\t}\n\n\tfunction isError(obj) {\n\t  return obj instanceof Error;\n\t}\n\n\tfunction list(arry, join, finalJoin) {\n\t  arry = arrayify(arry);\n\t  var copy = arry.slice();\n\t  var last = copy.pop();\n\t  if (copy.length === 1) {\n\t    join = ' ';\n\t  }\n\t  return copy.join(join) + ('' + (copy.length ? join + finalJoin : '') + last);\n\t}\n\n\tfunction getError(name, location, checkerType) {\n\t  if (typeof checkerType === 'function') {\n\t    checkerType = checkerType({ short: true });\n\t  }\n\t  var stringType = typeof checkerType !== 'object' ? checkerType : stringify(checkerType);\n\t  return new Error(nAtL(name, location) + ' must be ' + t(stringType));\n\t}\n\n\tfunction nAtL(name, location) {\n\t  var tName = t(name || 'value');\n\t  var tLocation = !location ? '' : ' at ' + t(location);\n\t  return '' + tName + tLocation;\n\t}\n\n\tfunction t(thing) {\n\t  return '`' + thing + '`';\n\t}\n\n\tfunction undef(thing) {\n\t  return typeof thing === 'undefined';\n\t}\n\n\t/**\n\t * This will set up the checker with all of the defaults that most checkers want like required by default and an\n\t * optional version\n\t *\n\t * @param {Function} checker - the checker to setup with properties\n\t * @param {Object} properties - properties to add to the checker\n\t * @param {boolean} disabled - when set to true, this will set the checker to a no-op function\n\t * @returns {Function} checker - the setup checker\n\t */\n\tfunction setupChecker(checker, properties, disabled) {\n\t  /* eslint complexity:[2, 9] */\n\t  if (disabled) {\n\t    // swap out the checker for its own copy of noop\n\t    checker = getNoop();\n\t    checker.isNoop = true;\n\t  }\n\n\t  if (typeof checker.type === 'string') {\n\t    checker.shortType = checker.type;\n\t  }\n\n\t  // assign all properties given\n\t  each(properties, function (prop, name) {\n\t    return checker[name] = prop;\n\t  });\n\n\t  if (!checker.displayName) {\n\t    checker.displayName = 'apiCheck ' + t(checker.shortType || checker.type || checker.name) + ' type checker';\n\t  }\n\n\t  if (!checker.notRequired) {\n\t    checker = getRequiredVersion(checker, disabled);\n\t  }\n\n\t  if (!checker.notNullable) {\n\t    addNullable(checker, disabled);\n\t  }\n\n\t  if (!checker.notOptional) {\n\t    addOptional(checker, disabled);\n\t  }\n\n\t  return checker;\n\t}\n\n\tfunction getRequiredVersion(checker, disabled) {\n\t  var requiredChecker = disabled ? getNoop() : function requiredChecker(val, name, location, obj) {\n\t    if (undef(val) && !checker.isOptional) {\n\t      var tLocation = location ? ' in ' + t(location) : '';\n\t      var type = getCheckerDisplay(checker, { short: true });\n\t      var stringType = typeof type !== 'object' ? type : stringify(type);\n\t      return new Error('Required ' + t(name) + ' not specified' + tLocation + '. Must be ' + t(stringType));\n\t    } else {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  copyProps(checker, requiredChecker);\n\t  requiredChecker.originalChecker = checker;\n\t  return requiredChecker;\n\t}\n\n\tfunction addOptional(checker, disabled) {\n\t  var optionalCheck = disabled ? getNoop() : function optionalCheck(val, name, location, obj) {\n\t    if (!undef(val)) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, optionalCheck);\n\n\t  optionalCheck.isOptional = true;\n\t  optionalCheck.displayName = checker.displayName + ' (optional)';\n\t  optionalCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .optional to the end of the checkers\n\t  checker.optional = optionalCheck;\n\n\t  fixType(checker, checker.optional);\n\t}\n\n\tfunction addNullable(checker, disabled) {\n\t  var nullableCheck = disabled ? getNoop() : function nullableCheck(val, name, location, obj) {\n\t    if (val !== null) {\n\t      return checker(val, name, location, obj);\n\t    }\n\t  };\n\t  // inherit all properties on the original checker\n\t  copyProps(checker, nullableCheck);\n\n\t  nullableCheck.isNullable = true;\n\t  nullableCheck.displayName = checker.displayName + ' (nullable)';\n\t  nullableCheck.originalChecker = checker;\n\n\t  // the magic line that allows you to add .nullable to the end of the checkers\n\t  checker.nullable = nullableCheck;\n\n\t  fixType(checker, checker.nullable);\n\t  if (!checker.notOptional) {\n\t    addOptional(checker.nullable, disabled);\n\t  }\n\t}\n\n\tfunction fixType(checker, checkerCopy) {\n\t  // fix type, because it's not a straight copy...\n\t  // the reason is we need to specify type.__apiCheckData.optional as true for the terse/verbose option.\n\t  // we also want to add \"(optional)\" to the types with a string\n\t  if (typeof checkerCopy.type === 'object') {\n\t    checkerCopy.type = copy(checkerCopy.type); // make our own copy of this\n\t  } else if (typeof checkerCopy.type === 'function') {\n\t      checkerCopy.type = function () {\n\t        return checker.type.apply(checker, arguments);\n\t      };\n\t    } else {\n\t      checkerCopy.type += ' (optional)';\n\t      return;\n\t    }\n\t  checkerCopy.type.__apiCheckData = copy(checker.type.__apiCheckData) || {}; // and this\n\t  checkerCopy.type.__apiCheckData.optional = true;\n\t}\n\n\t// UTILS\n\n\tfunction copyProps(src, dest) {\n\t  each(Object.keys(src), function (key) {\n\t    return dest[key] = src[key];\n\t  });\n\t}\n\n\tfunction noop() {}\n\n\tfunction getNoop() {\n\t  /* eslint no-shadow:0 */\n\t  /* istanbul ignore next */\n\t  return function noop() {};\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar stringify = __webpack_require__(2);\n\n\tvar _require = __webpack_require__(3);\n\n\tvar typeOf = _require.typeOf;\n\tvar each = _require.each;\n\tvar copy = _require.copy;\n\tvar getCheckerDisplay = _require.getCheckerDisplay;\n\tvar isError = _require.isError;\n\tvar arrayify = _require.arrayify;\n\tvar list = _require.list;\n\tvar getError = _require.getError;\n\tvar nAtL = _require.nAtL;\n\tvar t = _require.t;\n\tvar checkerHelpers = _require.checkerHelpers;\n\tvar undef = _require.undef;\n\tvar setupChecker = checkerHelpers.setupChecker;\n\n\tvar checkers = module.exports = getCheckers();\n\tmodule.exports.getCheckers = getCheckers;\n\n\tfunction getCheckers(disabled) {\n\t  return {\n\t    array: typeOfCheckGetter('Array'),\n\t    bool: typeOfCheckGetter('Boolean'),\n\t    number: typeOfCheckGetter('Number'),\n\t    string: typeOfCheckGetter('String'),\n\t    func: funcCheckGetter(),\n\t    object: objectCheckGetter(),\n\n\t    emptyObject: emptyObjectCheckGetter(),\n\n\t    instanceOf: instanceCheckGetter,\n\t    oneOf: oneOfCheckGetter,\n\t    oneOfType: oneOfTypeCheckGetter,\n\n\t    arrayOf: arrayOfCheckGetter,\n\t    objectOf: objectOfCheckGetter,\n\t    typeOrArrayOf: typeOrArrayOfCheckGetter,\n\n\t    range: rangeCheckGetter,\n\t    lessThan: lessThanCheckGetter,\n\t    greaterThan: greaterThanCheckGetter,\n\n\t    shape: getShapeCheckGetter(),\n\t    args: argumentsCheckerGetter(),\n\n\t    any: anyCheckGetter(),\n\t    'null': nullCheckGetter()\n\n\t  };\n\n\t  function typeOfCheckGetter(type) {\n\t    var lType = type.toLowerCase();\n\t    return setupChecker(function typeOfCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== lType) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function funcCheckGetter() {\n\t    var type = 'Function';\n\t    var functionChecker = setupChecker(function functionCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'function') {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\n\t    functionChecker.withProperties = function getWithPropertiesChecker(properties) {\n\t      var apiError = checkers.objectOf(checkers.func)(properties, 'properties', 'apiCheck.func.withProperties');\n\t      if (isError(apiError)) {\n\t        throw apiError;\n\t      }\n\t      var shapeChecker = checkers.shape(properties, true);\n\t      shapeChecker.type.__apiCheckData.type = 'func.withProperties';\n\n\t      return setupChecker(function functionWithPropertiesChecker(val, name, location) {\n\t        var notFunction = checkers.func(val, name, location);\n\t        if (isError(notFunction)) {\n\t          return notFunction;\n\t        }\n\t        return shapeChecker(val, name, location);\n\t      }, { type: shapeChecker.type, shortType: 'func.withProperties' }, disabled);\n\t    };\n\t    return functionChecker;\n\t  }\n\n\t  function objectCheckGetter() {\n\t    var type = 'Object';\n\t    var nullType = 'Object (null ok)';\n\t    var objectNullOkChecker = setupChecker(function objectNullOkCheckerDefinition(val, name, location) {\n\t      if (typeOf(val) !== 'object') {\n\t        return getError(name, location, nullType);\n\t      }\n\t    }, { type: nullType }, disabled);\n\n\t    var objectChecker = setupChecker(function objectCheckerDefinition(val, name, location) {\n\t      if (val === null || isError(objectNullOkChecker(val, name, location))) {\n\t        return getError(name, location, objectChecker.type);\n\t      }\n\t    }, { type: type, nullOk: objectNullOkChecker }, disabled);\n\n\t    return objectChecker;\n\t  }\n\n\t  function instanceCheckGetter(classToCheck) {\n\t    return setupChecker(function instanceCheckerDefinition(val, name, location) {\n\t      if (!(val instanceof classToCheck)) {\n\t        return getError(name, location, classToCheck.name);\n\t      }\n\t    }, { type: classToCheck.name }, disabled);\n\t  }\n\n\t  function oneOfCheckGetter(enums) {\n\t    var type = {\n\t      __apiCheckData: { optional: false, type: 'enum' },\n\t      'enum': enums\n\t    };\n\t    var shortType = 'oneOf[' + enums.map(function (enm) {\n\t      return stringify(enm);\n\t    }).join(', ') + ']';\n\t    return setupChecker(function oneOfCheckerDefinition(val, name, location) {\n\t      if (!enums.some(function (enm) {\n\t        return enm === val;\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function oneOfTypeCheckGetter(typeCheckers) {\n\t    var checkersDisplay = typeCheckers.map(function (checker) {\n\t      return getCheckerDisplay(checker, { short: true });\n\t    });\n\t    var shortType = 'oneOfType[' + checkersDisplay.join(', ') + ']';\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return typeCheckers.map(function (checker) {\n\t        return getCheckerDisplay(checker, options);\n\t      });\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'oneOfType' };\n\t    return setupChecker(function oneOfTypeCheckerDefinition(val, name, location) {\n\t      if (!typeCheckers.some(function (checker) {\n\t        return !isError(checker(val, name, location));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function arrayOfCheckGetter(checker) {\n\t    var shortCheckerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'arrayOf[' + shortCheckerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'arrayOf' };\n\n\t    return setupChecker(function arrayOfCheckerDefinition(val, name, location) {\n\t      if (isError(checkers.array(val)) || !val.every(function (item) {\n\t        return !isError(checker(item));\n\t      })) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function objectOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'objectOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\t    type.__apiCheckData = { optional: false, type: 'objectOf' };\n\n\t    return setupChecker(function objectOfCheckerDefinition(val, name, location) {\n\t      var notObject = checkers.object(val, name, location);\n\t      if (isError(notObject)) {\n\t        return notObject;\n\t      }\n\t      var allTypesSuccess = each(val, function (item, key) {\n\t        if (isError(checker(item, key, name))) {\n\t          return false;\n\t        }\n\t      });\n\t      if (!allTypesSuccess) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function typeOrArrayOfCheckGetter(checker) {\n\t    var checkerDisplay = getCheckerDisplay(checker, { short: true });\n\t    var shortType = 'typeOrArrayOf[' + checkerDisplay + ']';\n\n\t    function type(options) {\n\t      if (options && options.short) {\n\t        return shortType;\n\t      }\n\t      return getCheckerDisplay(checker, options);\n\t    }\n\n\t    type.__apiCheckData = { optional: false, type: 'typeOrArrayOf' };\n\t    return setupChecker(function typeOrArrayOfDefinition(val, name, location, obj) {\n\t      if (isError(checkers.oneOfType([checker, checkers.arrayOf(checker)])(val, name, location, obj))) {\n\t        return getError(name, location, shortType);\n\t      }\n\t    }, { type: type, shortType: shortType }, disabled);\n\t  }\n\n\t  function getShapeCheckGetter() {\n\t    function shapeCheckGetter(shape, nonObject) {\n\t      var shapeTypes = {};\n\t      each(shape, function (checker, prop) {\n\t        shapeTypes[prop] = getCheckerDisplay(checker);\n\t      });\n\t      function type() {\n\t        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t        var ret = {};\n\t        var terse = options.terse;\n\t        var obj = options.obj;\n\t        var addHelpers = options.addHelpers;\n\n\t        var parentRequired = options.required;\n\t        each(shape, function (checker, prop) {\n\t          /* eslint complexity:[2, 6] */\n\t          var specified = obj && obj.hasOwnProperty(prop);\n\t          var required = undef(parentRequired) ? !checker.isOptional : parentRequired;\n\t          if (!terse || (specified || !checker.isOptional)) {\n\t            ret[prop] = getCheckerDisplay(checker, { terse: terse, obj: obj && obj[prop], required: required, addHelpers: addHelpers });\n\t          }\n\t          if (addHelpers) {\n\t            modifyTypeDisplayToHelpOut(ret, prop, specified, checker, required);\n\t          }\n\t        });\n\t        return ret;\n\n\t        function modifyTypeDisplayToHelpOut(theRet, prop, specified, checker, required) {\n\t          if (!specified && required && !checker.isOptional) {\n\t            var item = 'ITEM';\n\t            if (checker.type && checker.type.__apiCheckData) {\n\t              item = checker.type.__apiCheckData.type.toUpperCase();\n\t            }\n\t            addHelper('missing', 'MISSING THIS ' + item, ' <-- YOU ARE MISSING THIS');\n\t          } else if (specified) {\n\t            var error = checker(obj[prop], prop, null, obj);\n\t            if (isError(error)) {\n\t              addHelper('error', 'THIS IS THE PROBLEM: ' + error.message, ' <-- THIS IS THE PROBLEM: ' + error.message);\n\t            }\n\t          }\n\n\t          function addHelper(property, objectMessage, stringMessage) {\n\t            if (typeof theRet[prop] === 'string') {\n\t              theRet[prop] += stringMessage;\n\t            } else {\n\t              theRet[prop].__apiCheckData[property] = objectMessage;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      type.__apiCheckData = { strict: false, optional: false, type: 'shape' };\n\t      var shapeChecker = setupChecker(function shapeCheckerDefinition(val, name, location) {\n\t        /* eslint complexity:[2, 6] */\n\t        var isObject = !nonObject && checkers.object(val, name, location);\n\t        if (isError(isObject)) {\n\t          return isObject;\n\t        }\n\t        var shapePropError = undefined;\n\t        location = location ? location + (name ? '/' : '') : '';\n\t        name = name || '';\n\t        each(shape, function (checker, prop) {\n\t          if (val.hasOwnProperty(prop) || !checker.isOptional) {\n\t            shapePropError = checker(val[prop], prop, '' + location + name, val);\n\t            return !isError(shapePropError);\n\t          }\n\t        });\n\t        if (isError(shapePropError)) {\n\t          return shapePropError;\n\t        }\n\t      }, { type: type, shortType: 'shape' }, disabled);\n\n\t      function strictType() {\n\t        return type.apply(undefined, arguments);\n\t      }\n\n\t      strictType.__apiCheckData = copy(shapeChecker.type.__apiCheckData);\n\t      strictType.__apiCheckData.strict = true;\n\t      shapeChecker.strict = setupChecker(function strictShapeCheckerDefinition(val, name, location) {\n\t        var shapeError = shapeChecker(val, name, location);\n\t        if (isError(shapeError)) {\n\t          return shapeError;\n\t        }\n\t        var allowedProperties = Object.keys(shape);\n\t        var extraProps = Object.keys(val).filter(function (prop) {\n\t          return allowedProperties.indexOf(prop) === -1;\n\t        });\n\t        if (extraProps.length) {\n\t          return new Error(nAtL(name, location) + ' cannot have extra properties: ' + t(extraProps.join('`, `')) + '.' + ('It is limited to ' + t(allowedProperties.join('`, `'))));\n\t        }\n\t      }, { type: strictType, shortType: 'strict shape' }, disabled);\n\n\t      return shapeChecker;\n\t    }\n\n\t    shapeCheckGetter.ifNot = function ifNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is not specified';\n\t      } else {\n\t        description = 'specified only if none of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'ifNot[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function ifNotChecker(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var otherPropsExist = otherProps.some(function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (propExists === otherPropsExist) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { notRequired: true, type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.onlyIf = function onlyIf(otherProps, propChecker) {\n\t      otherProps = arrayify(otherProps);\n\t      var description = undefined;\n\t      if (otherProps.length === 1) {\n\t        description = 'specified only if ' + otherProps[0] + ' is also specified';\n\t      } else {\n\t        description = 'specified only if all of the following are specified: [' + list(otherProps, ', ', 'and ') + ']';\n\t      }\n\t      var shortType = 'onlyIf[' + otherProps.join(', ') + ']';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function onlyIfCheckerDefinition(prop, propName, location, obj) {\n\t        var othersPresent = otherProps.every(function (property) {\n\t          return obj.hasOwnProperty(property);\n\t        });\n\t        if (!othersPresent) {\n\t          return getError(propName, location, type);\n\t        } else {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, shortType: shortType }, disabled);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot = function shapeRequiredIfNot(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        otherProps = [otherProps];\n\t      }\n\t      return getRequiredIfNotChecker(false, otherProps, propChecker);\n\t    };\n\n\t    shapeCheckGetter.requiredIfNot.all = function shapeRequiredIfNotAll(otherProps, propChecker) {\n\t      if (!Array.isArray(otherProps)) {\n\t        throw new Error('requiredIfNot.all must be passed an array');\n\t      }\n\t      return getRequiredIfNotChecker(true, otherProps, propChecker);\n\t    };\n\n\t    function getRequiredIfNotChecker(all, otherProps, propChecker) {\n\t      var props = t(otherProps.join(', '));\n\t      var ifProps = 'if ' + (all ? 'all of' : 'at least one of');\n\t      var description = 'specified ' + ifProps + ' these are not specified: ' + props + ' (otherwise it\\'s optional)';\n\t      var shortType = 'requiredIfNot' + (all ? '.all' : '') + '[' + otherProps.join(', ') + '}]';\n\t      var type = getTypeForShapeChild(propChecker, description, shortType);\n\t      return setupChecker(function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t        var propExists = obj && obj.hasOwnProperty(propName);\n\t        var iteration = all ? 'every' : 'some';\n\t        var otherPropsExist = otherProps[iteration](function (otherProp) {\n\t          return obj && obj.hasOwnProperty(otherProp);\n\t        });\n\t        if (!otherPropsExist && !propExists) {\n\t          return getError(propName, location, type);\n\t        } else if (propExists) {\n\t          return propChecker(prop, propName, location, obj);\n\t        }\n\t      }, { type: type, notRequired: true }, disabled);\n\t    }\n\n\t    return shapeCheckGetter;\n\n\t    function getTypeForShapeChild(propChecker, description, shortType) {\n\t      function type(options) {\n\t        if (options && options.short) {\n\t          return shortType;\n\t        }\n\t        return getCheckerDisplay(propChecker);\n\t      }\n\t      type.__apiCheckData = { optional: false, type: 'ifNot', description: description };\n\t      return type;\n\t    }\n\t  }\n\n\t  function argumentsCheckerGetter() {\n\t    var type = 'function arguments';\n\t    return setupChecker(function argsCheckerDefinition(val, name, location) {\n\t      if (Array.isArray(val) || isError(checkers.object(val)) || isError(checkers.number(val.length))) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function anyCheckGetter() {\n\t    return setupChecker(function anyCheckerDefinition() {\n\t      // don't do anything\n\t    }, { type: 'any' }, disabled);\n\t  }\n\n\t  function nullCheckGetter() {\n\t    var type = 'null';\n\t    return setupChecker(function nullChecker(val, name, location) {\n\t      if (val !== null) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function rangeCheckGetter(min, max) {\n\t    var type = 'Range (' + min + ' - ' + max + ')';\n\t    return setupChecker(function rangeChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < min || val > max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function lessThanCheckGetter(min) {\n\t    var type = 'lessThan[' + min + ']';\n\t    return setupChecker(function lessThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val > min) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function greaterThanCheckGetter(max) {\n\t    var type = 'greaterThan[' + max + ']';\n\t    return setupChecker(function greaterThanChecker(val, name, location) {\n\t      if (typeof val !== 'number' || val < max) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\n\t  function emptyObjectCheckGetter() {\n\t    var type = 'empty object';\n\t    return setupChecker(function emptyObjectChecker(val, name, location) {\n\t      if (typeOf(val) !== 'object' || val === null || Object.keys(val).length) {\n\t        return getError(name, location, type);\n\t      }\n\t    }, { type: type }, disabled);\n\t  }\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/api-check/dist/api-check.js\n ** module id = 3\n ** module chunks = 1\n **/","/*!\n* angular-formly JavaScript Library v7.5.1\n*\n* @license MIT (http://license.angular-formly.com)\n*\n* built with ♥ by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us>\n* (ó ì_í)=óò=(ì_í ò)\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormly\"] = factory(require(\"angular\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormly\"] = factory(root[\"angular\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _indexCommon = __webpack_require__(1);\n\n\tvar _indexCommon2 = _interopRequireDefault(_indexCommon);\n\n\texports['default'] = _indexCommon2['default'];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _providersFormlyApiCheck = __webpack_require__(4);\n\n\tvar _providersFormlyApiCheck2 = _interopRequireDefault(_providersFormlyApiCheck);\n\n\tvar _otherDocsBaseUrl = __webpack_require__(6);\n\n\tvar _otherDocsBaseUrl2 = _interopRequireDefault(_otherDocsBaseUrl);\n\n\tvar _providersFormlyUsability = __webpack_require__(7);\n\n\tvar _providersFormlyUsability2 = _interopRequireDefault(_providersFormlyUsability);\n\n\tvar _providersFormlyConfig = __webpack_require__(8);\n\n\tvar _providersFormlyConfig2 = _interopRequireDefault(_providersFormlyConfig);\n\n\tvar _providersFormlyValidationMessages = __webpack_require__(10);\n\n\tvar _providersFormlyValidationMessages2 = _interopRequireDefault(_providersFormlyValidationMessages);\n\n\tvar _servicesFormlyUtil = __webpack_require__(11);\n\n\tvar _servicesFormlyUtil2 = _interopRequireDefault(_servicesFormlyUtil);\n\n\tvar _servicesFormlyWarn = __webpack_require__(12);\n\n\tvar _servicesFormlyWarn2 = _interopRequireDefault(_servicesFormlyWarn);\n\n\tvar _directivesFormlyCustomValidation = __webpack_require__(13);\n\n\tvar _directivesFormlyCustomValidation2 = _interopRequireDefault(_directivesFormlyCustomValidation);\n\n\tvar _directivesFormlyField = __webpack_require__(14);\n\n\tvar _directivesFormlyField2 = _interopRequireDefault(_directivesFormlyField);\n\n\tvar _directivesFormlyFocus = __webpack_require__(15);\n\n\tvar _directivesFormlyFocus2 = _interopRequireDefault(_directivesFormlyFocus);\n\n\tvar _directivesFormlyForm = __webpack_require__(16);\n\n\tvar _directivesFormlyForm2 = _interopRequireDefault(_directivesFormlyForm);\n\n\tvar _runFormlyNgModelAttrsManipulator = __webpack_require__(17);\n\n\tvar _runFormlyNgModelAttrsManipulator2 = _interopRequireDefault(_runFormlyNgModelAttrsManipulator);\n\n\tvar _runFormlyCustomTags = __webpack_require__(18);\n\n\tvar _runFormlyCustomTags2 = _interopRequireDefault(_runFormlyCustomTags);\n\n\tvar ngModuleName = 'formly';\n\n\texports['default'] = ngModuleName;\n\n\tvar ngModule = _angularFix2['default'].module(ngModuleName, []);\n\n\tngModule.constant('formlyApiCheck', _providersFormlyApiCheck2['default']);\n\tngModule.constant('formlyErrorAndWarningsUrlPrefix', _otherDocsBaseUrl2['default']);\n\tngModule.constant('formlyVersion', (\"7.5.1\")); // <-- webpack variable\n\n\tngModule.provider('formlyUsability', _providersFormlyUsability2['default']);\n\tngModule.provider('formlyConfig', _providersFormlyConfig2['default']);\n\n\tngModule.factory('formlyValidationMessages', _providersFormlyValidationMessages2['default']);\n\tngModule.factory('formlyUtil', _servicesFormlyUtil2['default']);\n\tngModule.factory('formlyWarn', _servicesFormlyWarn2['default']);\n\n\tngModule.directive('formlyCustomValidation', _directivesFormlyCustomValidation2['default']);\n\tngModule.directive('formlyField', _directivesFormlyField2['default']);\n\tngModule.directive('formlyFocus', _directivesFormlyFocus2['default']);\n\tngModule.directive('formlyForm', _directivesFormlyForm2['default']);\n\n\tngModule.run(_runFormlyNgModelAttrsManipulator2['default']);\n\tngModule.run(_runFormlyCustomTags2['default']);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar angular = __webpack_require__(3);\n\n\t/* istanbul ignore next */\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\texports['default'] = angular;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\tvar apiCheck = (0, _apiCheck2['default'])({\n\t  output: {\n\t    prefix: 'angular-formly:',\n\t    docsBaseUrl: __webpack_require__(6)\n\t  }\n\t});\n\n\tfunction shapeRequiredIfNot(otherProps, propChecker) {\n\t  if (!_angularFix2['default'].isArray(otherProps)) {\n\t    otherProps = [otherProps];\n\t  }\n\t  var type = 'specified if these are not specified: `' + otherProps.join(', ') + '` (otherwise it\\'s optional)';\n\n\t  function shapeRequiredIfNotDefinition(prop, propName, location, obj) {\n\t    var propExists = obj && obj.hasOwnProperty(propName);\n\t    var otherPropsExist = otherProps.some(function (otherProp) {\n\t      return obj && obj.hasOwnProperty(otherProp);\n\t    });\n\t    if (!otherPropsExist && !propExists) {\n\t      return apiCheck.utils.getError(propName, location, type);\n\t    } else if (propExists) {\n\t      return propChecker(prop, propName, location, obj);\n\t    }\n\t  }\n\n\t  shapeRequiredIfNotDefinition.type = type;\n\t  return apiCheck.utils.checkerHelpers.setupChecker(shapeRequiredIfNotDefinition);\n\t}\n\n\tvar formlyExpression = apiCheck.oneOfType([apiCheck.string, apiCheck.func]);\n\tvar specifyWrapperType = apiCheck.typeOrArrayOf(apiCheck.string).nullable;\n\n\tvar apiCheckProperty = apiCheck.func;\n\n\tvar apiCheckInstanceProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.func.withProperties({\n\t  warn: apiCheck.func,\n\t  'throw': apiCheck.func,\n\t  shape: apiCheck.func\n\t}));\n\n\tvar apiCheckFunctionProperty = apiCheck.shape.onlyIf('apiCheck', apiCheck.oneOf(['throw', 'warn']));\n\n\tvar formlyWrapperType = apiCheck.shape({\n\t  name: shapeRequiredIfNot('types', apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.string).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.string).optional,\n\t  types: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  overwriteOk: apiCheck.bool.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional\n\t}).strict;\n\n\tvar expressionProperties = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar modelChecker = apiCheck.oneOfType([apiCheck.string, apiCheck.object]);\n\n\tvar templateManipulators = apiCheck.shape({\n\t  preWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional,\n\t  postWrapper: apiCheck.arrayOf(apiCheck.func).nullable.optional\n\t}).strict.nullable;\n\n\tvar validatorChecker = apiCheck.objectOf(apiCheck.oneOfType([formlyExpression, apiCheck.shape({\n\t  expression: formlyExpression,\n\t  message: formlyExpression.optional\n\t}).strict]));\n\n\tvar watcherChecker = apiCheck.typeOrArrayOf(apiCheck.shape({\n\t  expression: formlyExpression.optional,\n\t  listener: formlyExpression.optional,\n\t  runFieldExpressions: apiCheck.bool.optional\n\t}));\n\n\tvar fieldOptionsApiShape = {\n\t  $$hashKey: apiCheck.any.optional,\n\t  type: apiCheck.shape.ifNot(['template', 'templateUrl'], apiCheck.string).optional,\n\t  template: apiCheck.shape.ifNot(['type', 'templateUrl'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot(['type', 'template'], apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  model: modelChecker.optional,\n\t  originalModel: modelChecker.optional,\n\t  className: apiCheck.string.optional,\n\t  id: apiCheck.string.optional,\n\t  name: apiCheck.string.optional,\n\t  expressionProperties: expressionProperties.optional,\n\t  extras: apiCheck.shape({\n\t    validateOnModelChange: apiCheck.bool.optional,\n\t    skipNgModelAttrsManipulator: apiCheck.oneOfType([apiCheck.string, apiCheck.bool]).optional\n\t  }).strict.optional,\n\t  data: apiCheck.object.optional,\n\t  templateOptions: apiCheck.object.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  modelOptions: apiCheck.shape({\n\t    updateOn: apiCheck.string.optional,\n\t    debounce: apiCheck.oneOfType([apiCheck.objectOf(apiCheck.number), apiCheck.number]).optional,\n\t    allowInvalid: apiCheck.bool.optional,\n\t    getterSetter: apiCheck.bool.optional,\n\t    timezone: apiCheck.string.optional\n\t  }).optional,\n\t  watcher: watcherChecker.optional,\n\t  validators: validatorChecker.optional,\n\t  asyncValidators: validatorChecker.optional,\n\t  parsers: apiCheck.arrayOf(formlyExpression).optional,\n\t  formatters: apiCheck.arrayOf(formlyExpression).optional,\n\t  noFormControl: apiCheck.bool.optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  ngModelElAttrs: apiCheck.objectOf(apiCheck.string).optional,\n\t  ngModelAttrs: apiCheck.objectOf(apiCheck.shape({\n\t    statement: apiCheck.shape.ifNot(['value', 'attribute', 'bound', 'boolean'], apiCheck.any).optional,\n\t    value: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    attribute: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    bound: apiCheck.shape.ifNot('statement', apiCheck.any).optional,\n\t    boolean: apiCheck.shape.ifNot('statement', apiCheck.any).optional\n\t  }).strict).optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional,\n\t  optionsTypes: apiCheck.typeOrArrayOf(apiCheck.string).optional,\n\t  link: apiCheck.func.optional,\n\t  controller: apiCheck.oneOfType([apiCheck.string, apiCheck.func, apiCheck.array]).optional,\n\t  validation: apiCheck.shape({\n\t    show: apiCheck.bool.nullable.optional,\n\t    messages: apiCheck.objectOf(formlyExpression).optional,\n\t    errorExistsAndShouldBeVisible: apiCheck.bool.optional\n\t  }).optional,\n\t  formControl: apiCheck.typeOrArrayOf(apiCheck.object).optional,\n\t  value: apiCheck.func.optional,\n\t  runExpressions: apiCheck.func.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  initialValue: apiCheck.any.optional,\n\t  defaultValue: apiCheck.any.optional\n\t};\n\n\tvar formlyFieldOptions = apiCheck.shape(fieldOptionsApiShape).strict;\n\n\tvar formOptionsApi = apiCheck.shape({\n\t  formState: apiCheck.object.optional,\n\t  resetModel: apiCheck.func.optional,\n\t  updateInitialValue: apiCheck.func.optional,\n\t  removeChromeAutoComplete: apiCheck.bool.optional,\n\t  templateManipulators: templateManipulators.optional,\n\t  manualModelWatcher: apiCheck.oneOfType([apiCheck.bool, apiCheck.func]).optional,\n\t  watchAllExpressions: apiCheck.bool.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  fieldTransform: apiCheck.oneOfType([apiCheck.func, apiCheck.array]).optional,\n\t  data: apiCheck.object.optional\n\t}).strict;\n\n\tvar fieldGroup = apiCheck.shape({\n\t  $$hashKey: apiCheck.any.optional,\n\t  key: apiCheck.oneOfType([apiCheck.string, apiCheck.number]).optional,\n\t  // danger. Nested field groups wont get api-checked...\n\t  fieldGroup: apiCheck.arrayOf(apiCheck.oneOfType([formlyFieldOptions, apiCheck.object])),\n\t  className: apiCheck.string.optional,\n\t  options: formOptionsApi.optional,\n\t  templateOptions: apiCheck.object.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  watcher: watcherChecker.optional,\n\t  hide: apiCheck.bool.optional,\n\t  hideExpression: formlyExpression.optional,\n\t  data: apiCheck.object.optional,\n\t  model: modelChecker.optional,\n\t  form: apiCheck.object.optional,\n\t  elementAttributes: apiCheck.objectOf(apiCheck.string).optional\n\t}).strict;\n\n\tvar typeOptionsDefaultOptions = _angularFix2['default'].copy(fieldOptionsApiShape);\n\ttypeOptionsDefaultOptions.key = apiCheck.string.optional;\n\n\tvar formlyTypeOptions = apiCheck.shape({\n\t  name: apiCheck.string,\n\t  template: apiCheck.shape.ifNot('templateUrl', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  templateUrl: apiCheck.shape.ifNot('template', apiCheck.oneOfType([apiCheck.string, apiCheck.func])).optional,\n\t  controller: apiCheck.oneOfType([apiCheck.func, apiCheck.string, apiCheck.array]).optional,\n\t  link: apiCheck.func.optional,\n\t  defaultOptions: apiCheck.oneOfType([apiCheck.func, apiCheck.shape(typeOptionsDefaultOptions)]).optional,\n\t  'extends': apiCheck.string.optional,\n\t  wrapper: specifyWrapperType.optional,\n\t  data: apiCheck.object.optional,\n\t  apiCheck: apiCheckProperty.optional,\n\t  apiCheckInstance: apiCheckInstanceProperty.optional,\n\t  apiCheckFunction: apiCheckFunctionProperty.optional,\n\t  apiCheckOptions: apiCheck.object.optional,\n\t  overwriteOk: apiCheck.bool.optional\n\t}).strict;\n\n\t_angularFix2['default'].extend(apiCheck, {\n\t  formlyTypeOptions: formlyTypeOptions, formlyFieldOptions: formlyFieldOptions, formlyExpression: formlyExpression, formlyWrapperType: formlyWrapperType, fieldGroup: fieldGroup, formOptionsApi: formOptionsApi\n\t});\n\n\texports['default'] = apiCheck;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports[\"default\"] = \"https://github.com/formly-js/angular-formly/blob/\" + (\"7.5.1\") + \"/other/ERRORS_AND_WARNINGS.md#\";\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyUsability;\n\n\t// @ngInject\n\tfunction formlyUsability(formlyApiCheck, formlyErrorAndWarningsUrlPrefix) {\n\t  var _this = this;\n\n\t  _angularFix2['default'].extend(this, {\n\t    getFormlyError: getFormlyError,\n\t    getFieldError: getFieldError,\n\t    checkWrapper: checkWrapper,\n\t    checkWrapperTemplate: checkWrapperTemplate,\n\t    getErrorMessage: getErrorMessage,\n\t    $get: function $get() {\n\t      return _this;\n\t    }\n\t  });\n\n\t  function getFieldError(errorInfoSlug, message, field) {\n\t    if (arguments.length < 3) {\n\t      field = message;\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message) + (' Field definition: ' + _angularFix2['default'].toJson(field)));\n\t  }\n\n\t  function getFormlyError(errorInfoSlug, message) {\n\t    if (!message) {\n\t      message = errorInfoSlug;\n\t      errorInfoSlug = null;\n\t    }\n\t    return new Error(getErrorMessage(errorInfoSlug, message));\n\t  }\n\n\t  function getErrorMessage(errorInfoSlug, message) {\n\t    var url = '';\n\t    if (errorInfoSlug !== null) {\n\t      url = '' + formlyErrorAndWarningsUrlPrefix + errorInfoSlug;\n\t    }\n\t    return 'Formly Error: ' + message + '. ' + url;\n\t  }\n\n\t  function checkWrapper(wrapper) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyWrapperType, wrapper, {\n\t      prefix: 'formlyConfig.setWrapper',\n\t      urlSuffix: 'setwrapper-validation-failed'\n\t    });\n\t  }\n\n\t  function checkWrapperTemplate(template, additionalInfo) {\n\t    var formlyTransclude = '<formly-transclude></formly-transclude>';\n\t    if (template.indexOf(formlyTransclude) === -1) {\n\t      throw getFormlyError('Template wrapper templates must use \"' + formlyTransclude + '\" somewhere in them. ' + ('This one does not have \"<formly-transclude></formly-transclude>\" in it: ' + template) + '\\n' + ('Additional information: ' + JSON.stringify(additionalInfo)));\n\t    }\n\t  }\n\t}\n\tformlyUsability.$inject = [\"formlyApiCheck\", \"formlyErrorAndWarningsUrlPrefix\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyConfig;\n\n\t// @ngInject\n\tfunction formlyConfig(formlyUsabilityProvider, formlyErrorAndWarningsUrlPrefix, formlyApiCheck) {\n\t  var _this2 = this;\n\n\t  var typeMap = {};\n\t  var templateWrappersMap = {};\n\t  var defaultWrapperName = 'default';\n\t  var _this = this;\n\t  var getError = formlyUsabilityProvider.getFormlyError;\n\n\t  _angularFix2['default'].extend(this, {\n\t    setType: setType,\n\t    getType: getType,\n\t    getTypeHeritage: getTypeHeritage,\n\t    setWrapper: setWrapper,\n\t    getWrapper: getWrapper,\n\t    getWrapperByType: getWrapperByType,\n\t    removeWrapperByName: removeWrapperByName,\n\t    removeWrappersForType: removeWrappersForType,\n\t    disableWarnings: false,\n\t    extras: {\n\t      disableNgModelAttrsManipulator: false,\n\t      fieldTransform: [],\n\t      ngModelAttrsManipulatorPreferUnbound: false,\n\t      removeChromeAutoComplete: false,\n\t      defaultHideDirective: 'ng-if',\n\t      getFieldId: null\n\t    },\n\t    templateManipulators: {\n\t      preWrapper: [],\n\t      postWrapper: []\n\t    },\n\t    $get: function $get() {\n\t      return _this2;\n\t    }\n\t  });\n\n\t  function setType(options) {\n\t    if (_angularFix2['default'].isArray(options)) {\n\t      var _ret = (function () {\n\t        var allTypes = [];\n\t        _angularFix2['default'].forEach(options, function (item) {\n\t          allTypes.push(setType(item));\n\t        });\n\t        return {\n\t          v: allTypes\n\t        };\n\t      })();\n\n\t      if (typeof _ret === 'object') return _ret.v;\n\t    } else if (_angularFix2['default'].isObject(options)) {\n\t      checkType(options);\n\t      if (options['extends']) {\n\t        extendTypeOptions(options);\n\t      }\n\t      typeMap[options.name] = options;\n\t      return typeMap[options.name];\n\t    } else {\n\t      throw getError('You must provide an object or array for setType. You provided: ' + JSON.stringify(arguments));\n\t    }\n\t  }\n\n\t  function checkType(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyTypeOptions, options, {\n\t      prefix: 'formlyConfig.setType',\n\t      url: 'settype-validation-failed'\n\t    });\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, typeMap, options, 'types');\n\t    } else {\n\t      options.overwriteOk = undefined;\n\t    }\n\t  }\n\n\t  function extendTypeOptions(options) {\n\t    var extendsType = getType(options['extends'], true, options);\n\t    extendTypeControllerFunction(options, extendsType);\n\t    extendTypeLinkFunction(options, extendsType);\n\t    extendTypeDefaultOptions(options, extendsType);\n\t    _otherUtils2['default'].reverseDeepMerge(options, extendsType);\n\t    extendTemplate(options, extendsType);\n\t  }\n\n\t  function extendTemplate(options, extendsType) {\n\t    if (options.template && extendsType.templateUrl) {\n\t      delete options.templateUrl;\n\t    } else if (options.templateUrl && extendsType.template) {\n\t      delete options.template;\n\t    }\n\t  }\n\n\t  function extendTypeControllerFunction(options, extendsType) {\n\t    var extendsCtrl = extendsType.controller;\n\t    if (!_angularFix2['default'].isDefined(extendsCtrl)) {\n\t      return;\n\t    }\n\t    var optionsCtrl = options.controller;\n\t    if (_angularFix2['default'].isDefined(optionsCtrl)) {\n\t      options.controller = function ($scope, $controller) {\n\t        $controller(extendsCtrl, { $scope: $scope });\n\t        $controller(optionsCtrl, { $scope: $scope });\n\t      };\n\t      options.controller.$inject = ['$scope', '$controller'];\n\t    } else {\n\t      options.controller = extendsCtrl;\n\t    }\n\t  }\n\n\t  function extendTypeLinkFunction(options, extendsType) {\n\t    var extendsFn = extendsType.link;\n\t    if (!_angularFix2['default'].isDefined(extendsFn)) {\n\t      return;\n\t    }\n\t    var optionsFn = options.link;\n\t    if (_angularFix2['default'].isDefined(optionsFn)) {\n\t      options.link = function () {\n\t        extendsFn.apply(undefined, arguments);\n\t        optionsFn.apply(undefined, arguments);\n\t      };\n\t    } else {\n\t      options.link = extendsFn;\n\t    }\n\t  }\n\n\t  function extendTypeDefaultOptions(options, extendsType) {\n\t    var extendsDO = extendsType.defaultOptions;\n\t    if (!_angularFix2['default'].isDefined(extendsDO)) {\n\t      return;\n\t    }\n\t    var optionsDO = options.defaultOptions;\n\t    var optionsDOIsFn = _angularFix2['default'].isFunction(optionsDO);\n\t    var extendsDOIsFn = _angularFix2['default'].isFunction(extendsDO);\n\t    if (extendsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var extendsDefaultOptions = extendsDO(opts, scope);\n\t        var mergedDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(mergedDefaultOptions, opts, extendsDefaultOptions);\n\t        var extenderOptionsDefaultOptions = optionsDO;\n\t        if (optionsDOIsFn) {\n\t          extenderOptionsDefaultOptions = extenderOptionsDefaultOptions(mergedDefaultOptions, scope);\n\t        }\n\t        _otherUtils2['default'].reverseDeepMerge(extendsDefaultOptions, extenderOptionsDefaultOptions);\n\t        return extendsDefaultOptions;\n\t      };\n\t    } else if (optionsDOIsFn) {\n\t      options.defaultOptions = function defaultOptions(opts, scope) {\n\t        var newDefaultOptions = {};\n\t        _otherUtils2['default'].reverseDeepMerge(newDefaultOptions, opts, extendsDO);\n\t        return optionsDO(newDefaultOptions, scope);\n\t      };\n\t    }\n\t  }\n\n\t  function getType(name, throwError, errorContext) {\n\t    if (!name) {\n\t      return undefined;\n\t    }\n\t    var type = typeMap[name];\n\t    if (!type && throwError === true) {\n\t      throw getError('There is no type by the name of \"' + name + '\": ' + JSON.stringify(errorContext));\n\t    } else {\n\t      return type;\n\t    }\n\t  }\n\n\t  function getTypeHeritage(parent) {\n\t    var heritage = [];\n\t    var type = parent;\n\t    if (_angularFix2['default'].isString(type)) {\n\t      type = getType(parent);\n\t    }\n\t    parent = type['extends'];\n\t    while (parent) {\n\t      type = getType(parent);\n\t      heritage.push(type);\n\t      parent = type['extends'];\n\t    }\n\t    return heritage;\n\t  }\n\n\t  function setWrapper(_x, _x2) {\n\t    var _again = true;\n\n\t    _function: while (_again) {\n\t      var options = _x,\n\t          name = _x2;\n\t      _again = false;\n\n\t      if (_angularFix2['default'].isArray(options)) {\n\t        return options.map(function (wrapperOptions) {\n\t          return setWrapper(wrapperOptions);\n\t        });\n\t      } else if (_angularFix2['default'].isObject(options)) {\n\t        options.types = getOptionsTypes(options);\n\t        options.name = getOptionsName(options, name);\n\t        checkWrapperAPI(options);\n\t        templateWrappersMap[options.name] = options;\n\t        return options;\n\t      } else if (_angularFix2['default'].isString(options)) {\n\t        _x = {\n\t          template: options,\n\t          name: name\n\t        };\n\t        _x2 = undefined;\n\t        _again = true;\n\t        continue _function;\n\t      }\n\t    }\n\t  }\n\n\t  function getOptionsTypes(options) {\n\t    if (_angularFix2['default'].isString(options.types)) {\n\t      return [options.types];\n\t    }\n\t    if (!_angularFix2['default'].isDefined(options.types)) {\n\t      return [];\n\t    } else {\n\t      return options.types;\n\t    }\n\t  }\n\n\t  function getOptionsName(options, name) {\n\t    return options.name || name || options.types.join(' ') || defaultWrapperName;\n\t  }\n\n\t  function checkWrapperAPI(options) {\n\t    formlyUsabilityProvider.checkWrapper(options);\n\t    if (options.template) {\n\t      formlyUsabilityProvider.checkWrapperTemplate(options.template, options);\n\t    }\n\t    if (!options.overwriteOk) {\n\t      checkOverwrite(options.name, templateWrappersMap, options, 'templateWrappers');\n\t    } else {\n\t      delete options.overwriteOk;\n\t    }\n\t    checkWrapperTypes(options);\n\t  }\n\n\t  function checkWrapperTypes(options) {\n\t    var shouldThrow = !_angularFix2['default'].isArray(options.types) || !options.types.every(_angularFix2['default'].isString);\n\t    if (shouldThrow) {\n\t      throw getError('Attempted to create a template wrapper with types that is not a string or an array of strings');\n\t    }\n\t  }\n\n\t  function checkOverwrite(property, object, newValue, objectName) {\n\t    if (object.hasOwnProperty(property)) {\n\t      warn('overwriting-types-or-wrappers', ['Attempting to overwrite ' + property + ' on ' + objectName + ' which is currently', JSON.stringify(object[property]) + ' with ' + JSON.stringify(newValue), 'To supress this warning, specify the property \"overwriteOk: true\"'].join(' '));\n\t    }\n\t  }\n\n\t  function getWrapper(name) {\n\t    return templateWrappersMap[name || defaultWrapperName];\n\t  }\n\n\t  function getWrapperByType(type) {\n\t    /* eslint prefer-const:0 */\n\t    var wrappers = [];\n\t    for (var _name in templateWrappersMap) {\n\t      if (templateWrappersMap.hasOwnProperty(_name)) {\n\t        if (templateWrappersMap[_name].types && templateWrappersMap[_name].types.indexOf(type) !== -1) {\n\t          wrappers.push(templateWrappersMap[_name]);\n\t        }\n\t      }\n\t    }\n\t    return wrappers;\n\t  }\n\n\t  function removeWrapperByName(name) {\n\t    var wrapper = templateWrappersMap[name];\n\t    delete templateWrappersMap[name];\n\t    return wrapper;\n\t  }\n\n\t  function removeWrappersForType(type) {\n\t    var wrappers = getWrapperByType(type);\n\t    if (!wrappers) {\n\t      return undefined;\n\t    }\n\t    if (!_angularFix2['default'].isArray(wrappers)) {\n\t      return removeWrapperByName(wrappers.name);\n\t    } else {\n\t      wrappers.forEach(function (wrapper) {\n\t        return removeWrapperByName(wrapper.name);\n\t      });\n\t      return wrappers;\n\t    }\n\t  }\n\n\t  function warn() {\n\t    if (!_this.disableWarnings && console.warn) {\n\t      /* eslint no-console:0 */\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      console.warn.apply(console, _toConsumableArray(args));\n\t    }\n\t  }\n\t}\n\tformlyConfig.$inject = [\"formlyUsabilityProvider\", \"formlyErrorAndWarningsUrlPrefix\", \"formlyApiCheck\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = {\n\t  containsSelector: containsSelector, containsSpecialChar: containsSpecialChar, formlyEval: formlyEval, getFieldId: getFieldId, reverseDeepMerge: reverseDeepMerge, findByNodeName: findByNodeName,\n\t  arrayify: arrayify, extendFunction: extendFunction, extendArray: extendArray, startsWith: startsWith, contains: contains\n\t};\n\n\tfunction containsSelector(string) {\n\t  return containsSpecialChar(string, '.') || containsSpecialChar(string, '[') && containsSpecialChar(string, ']');\n\t}\n\n\tfunction containsSpecialChar(a, b) {\n\t  if (!a || !a.indexOf) {\n\t    return false;\n\t  }\n\t  return a.indexOf(b) !== -1;\n\t}\n\n\tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n\t  if (_angularFix2['default'].isFunction(expression)) {\n\t    return expression($viewValue, $modelValue, scope, extraLocals);\n\t  } else {\n\t    return scope.$eval(expression, _angularFix2['default'].extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n\t  }\n\t}\n\n\tfunction getFieldId(formId, options, index) {\n\t  if (options.id) {\n\t    return options.id;\n\t  }\n\t  var type = options.type;\n\t  if (!type && options.template) {\n\t    type = 'template';\n\t  } else if (!type && options.templateUrl) {\n\t    type = 'templateUrl';\n\t  }\n\n\t  return [formId, type, options.key, index].join('_');\n\t}\n\n\tfunction reverseDeepMerge(dest) {\n\t  _angularFix2['default'].forEach(arguments, function (src, index) {\n\t    if (!index) {\n\t      return;\n\t    }\n\t    _angularFix2['default'].forEach(src, function (val, prop) {\n\t      if (!_angularFix2['default'].isDefined(dest[prop])) {\n\t        dest[prop] = _angularFix2['default'].copy(val);\n\t      } else if (objAndSameType(dest[prop], val)) {\n\t        reverseDeepMerge(dest[prop], val);\n\t      }\n\t    });\n\t  });\n\t  return dest;\n\t}\n\n\tfunction objAndSameType(obj1, obj2) {\n\t  return _angularFix2['default'].isObject(obj1) && _angularFix2['default'].isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t}\n\n\t// recurse down a node tree to find a node with matching nodeName, for custom tags jQuery.find doesn't work in IE8\n\tfunction findByNodeName(el, nodeName) {\n\t  if (!el.prop) {\n\t    // not a jQuery or jqLite object -> wrap it\n\t    el = _angularFix2['default'].element(el);\n\t  }\n\n\t  if (el.prop('nodeName') === nodeName.toUpperCase()) {\n\t    return el;\n\t  }\n\n\t  var c = el.children();\n\t  for (var i = 0; c && i < c.length; i++) {\n\t    var node = findByNodeName(c[i], nodeName);\n\t    if (node) {\n\t      return node;\n\t    }\n\t  }\n\t}\n\n\tfunction arrayify(obj) {\n\t  if (obj && !_angularFix2['default'].isArray(obj)) {\n\t    obj = [obj];\n\t  } else if (!obj) {\n\t    obj = [];\n\t  }\n\t  return obj;\n\t}\n\n\tfunction extendFunction() {\n\t  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {\n\t    fns[_key] = arguments[_key];\n\t  }\n\n\t  return function extendedFunction() {\n\t    var args = arguments;\n\t    fns.forEach(function (fn) {\n\t      return fn.apply(null, args);\n\t    });\n\t  };\n\t}\n\n\tfunction extendArray(primary, secondary, property) {\n\t  if (property) {\n\t    primary = primary[property];\n\t    secondary = secondary[property];\n\t  }\n\t  if (secondary && primary) {\n\t    _angularFix2['default'].forEach(secondary, function (item) {\n\t      if (primary.indexOf(item) === -1) {\n\t        primary.push(item);\n\t      }\n\t    });\n\t    return primary;\n\t  } else if (secondary) {\n\t    return secondary;\n\t  } else {\n\t    return primary;\n\t  }\n\t}\n\n\tfunction startsWith(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.substring(0, search.length) === search;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n\tfunction contains(str, search) {\n\t  if (_angularFix2['default'].isString(str) && _angularFix2['default'].isString(search)) {\n\t    return str.length >= search.length && str.indexOf(search) !== -1;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = formlyValidationMessages;\n\n\t// @ngInject\n\tfunction formlyValidationMessages() {\n\n\t  var validationMessages = {\n\t    addTemplateOptionValueMessage: addTemplateOptionValueMessage,\n\t    addStringMessage: addStringMessage,\n\t    messages: {}\n\t  };\n\n\t  return validationMessages;\n\n\t  function addTemplateOptionValueMessage(name, prop, prefix, suffix, alternate) {\n\t    validationMessages.messages[name] = templateOptionValue(prop, prefix, suffix, alternate);\n\t  }\n\n\t  function addStringMessage(name, string) {\n\t    validationMessages.messages[name] = function () {\n\t      return string;\n\t    };\n\t  }\n\n\t  function templateOptionValue(prop, prefix, suffix, alternate) {\n\t    return function getValidationMessage(viewValue, modelValue, scope) {\n\t      if (typeof scope.options.templateOptions[prop] !== 'undefined') {\n\t        return prefix + ' ' + scope.options.templateOptions[prop] + ' ' + suffix;\n\t      } else {\n\t        return alternate;\n\t      }\n\t    };\n\t  }\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\tvar _otherUtils2 = _interopRequireDefault(_otherUtils);\n\n\texports['default'] = formlyUtil;\n\n\t// @ngInject\n\tfunction formlyUtil() {\n\t  return _otherUtils2['default'];\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\texports['default'] = formlyWarn;\n\n\t// @ngInject\n\tfunction formlyWarn(formlyConfig, formlyErrorAndWarningsUrlPrefix, $log) {\n\t  return function warn() {\n\t    if (!formlyConfig.disableWarnings) {\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var warnInfoSlug = args.shift();\n\t      args.unshift('Formly Warning:');\n\t      args.push('' + formlyErrorAndWarningsUrlPrefix + warnInfoSlug);\n\t      $log.warn.apply($log, _toConsumableArray(args));\n\t    }\n\t  };\n\t}\n\tformlyWarn.$inject = [\"formlyConfig\", \"formlyErrorAndWarningsUrlPrefix\", \"$log\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyCustomValidation;\n\n\t// @ngInject\n\tfunction formlyCustomValidation(formlyUtil) {\n\t  return {\n\t    restrict: 'A',\n\t    require: 'ngModel',\n\t    link: function formlyCustomValidationLink(scope, el, attrs, ctrl) {\n\t      var opts = scope.options;\n\t      opts.validation.messages = opts.validation.messages || {};\n\t      _angularFix2['default'].forEach(opts.validation.messages, function (message, key) {\n\t        opts.validation.messages[key] = function () {\n\t          return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t        };\n\t      });\n\n\t      var useNewValidatorsApi = ctrl.hasOwnProperty('$validators') && !attrs.hasOwnProperty('useParsers');\n\t      _angularFix2['default'].forEach(opts.validators, _angularFix2['default'].bind(null, addValidatorToPipeline, false));\n\t      _angularFix2['default'].forEach(opts.asyncValidators, _angularFix2['default'].bind(null, addValidatorToPipeline, true));\n\n\t      function addValidatorToPipeline(isAsync, validator, name) {\n\t        setupMessage(validator, name);\n\t        validator = _angularFix2['default'].isObject(validator) ? validator.expression : validator;\n\t        if (useNewValidatorsApi) {\n\t          setupWithValidators(validator, name, isAsync);\n\t        } else {\n\t          setupWithParsers(validator, name, isAsync);\n\t        }\n\t      }\n\n\t      function setupMessage(validator, name) {\n\t        var message = validator.message;\n\t        if (message) {\n\t          opts.validation.messages[name] = function () {\n\t            return formlyUtil.formlyEval(scope, message, ctrl.$modelValue, ctrl.$viewValue);\n\t          };\n\t        }\n\t      }\n\n\t      function setupWithValidators(validator, name, isAsync) {\n\t        var validatorCollection = isAsync ? '$asyncValidators' : '$validators';\n\n\t        ctrl[validatorCollection][name] = function evalValidity(modelValue, viewValue) {\n\t          return formlyUtil.formlyEval(scope, validator, modelValue, viewValue);\n\t        };\n\t      }\n\n\t      function setupWithParsers(validator, name, isAsync) {\n\t        var inFlightValidator = undefined;\n\t        ctrl.$parsers.unshift(function evalValidityOfParser(viewValue) {\n\t          var isValid = formlyUtil.formlyEval(scope, validator, ctrl.$modelValue, viewValue);\n\t          if (isAsync) {\n\t            ctrl.$pending = ctrl.$pending || {};\n\t            ctrl.$pending[name] = true;\n\t            inFlightValidator = isValid;\n\t            isValid.then(function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, true);\n\t              }\n\t            })['catch'](function () {\n\t              if (inFlightValidator === isValid) {\n\t                ctrl.$setValidity(name, false);\n\t              }\n\t            })['finally'](function () {\n\t              var $pending = ctrl.$pending || {};\n\t              if (Object.keys($pending).length === 1) {\n\t                delete ctrl.$pending;\n\t              } else {\n\t                delete ctrl.$pending[name];\n\t              }\n\t            });\n\t          } else {\n\t            ctrl.$setValidity(name, isValid);\n\t          }\n\t          return viewValue;\n\t        });\n\t      }\n\t    }\n\t  };\n\t}\n\tformlyCustomValidation.$inject = [\"formlyUtil\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _apiCheck = __webpack_require__(5);\n\n\tvar _apiCheck2 = _interopRequireDefault(_apiCheck);\n\n\texports['default'] = formlyField;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyField\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyField($http, $q, $compile, $templateCache, $interpolate, formlyConfig, formlyApiCheck, formlyUtil, formlyUsability, formlyWarn) {\n\t  var arrayify = formlyUtil.arrayify;\n\n\t  FormlyFieldController.$inject = [\"$scope\", \"$timeout\", \"$parse\", \"$controller\", \"formlyValidationMessages\"];\n\t  return {\n\t    restrict: 'AE',\n\t    transclude: true,\n\t    require: '?^formlyForm',\n\t    scope: {\n\t      options: '=',\n\t      model: '=',\n\t      originalModel: '=?',\n\t      formId: '@', // TODO remove formId in a breaking release\n\t      index: '=?',\n\t      fields: '=?',\n\t      formState: '=?',\n\t      formOptions: '=?',\n\t      form: '=?' },\n\t    // TODO require form in a breaking release\n\t    controller: FormlyFieldController,\n\t    link: fieldLink\n\t  };\n\n\t  // @ngInject\n\t  function FormlyFieldController($scope, $timeout, $parse, $controller, formlyValidationMessages) {\n\t    /* eslint max-statements:[2, 34] */\n\t    if ($scope.options.fieldGroup) {\n\t      setupFieldGroup();\n\t      return;\n\t    }\n\n\t    var fieldType = getFieldType($scope.options);\n\t    simplifyLife($scope.options);\n\t    mergeFieldOptionsWithTypeDefaults($scope.options, fieldType);\n\t    extendOptionsWithDefaults($scope.options, $scope.index);\n\t    checkApi($scope.options);\n\t    // set field id to link labels and fields\n\n\t    // initalization\n\t    setFieldIdAndName();\n\t    setDefaultValue();\n\t    setInitialValue();\n\t    runExpressions();\n\t    watchExpressions();\n\t    addValidationMessages($scope.options);\n\t    invokeControllers($scope, $scope.options, fieldType);\n\n\t    // function definitions\n\t    function runExpressions() {\n\t      // must run on next tick to make sure that the current value is correct.\n\t      return $timeout(function runExpressionsOnNextTick() {\n\t        var field = $scope.options;\n\t        var currentValue = valueGetterSetter();\n\t        _angularFix2['default'].forEach(field.expressionProperties, function runExpression(expression, prop) {\n\t          var setter = $parse(prop).assign;\n\t          var promise = $q.when(formlyUtil.formlyEval($scope, expression, currentValue, currentValue));\n\t          promise.then(function setFieldValue(value) {\n\t            setter(field, value);\n\t          });\n\t        });\n\t      }, 0, false);\n\t    }\n\n\t    function watchExpressions() {\n\t      if ($scope.formOptions.watchAllExpressions) {\n\t        (function () {\n\t          var field = $scope.options;\n\t          var currentValue = valueGetterSetter();\n\t          _angularFix2['default'].forEach(field.expressionProperties, function watchExpression(expression, prop) {\n\t            var setter = $parse(prop).assign;\n\t            $scope.$watch(function expressionPropertyWatcher() {\n\t              return formlyUtil.formlyEval($scope, expression, currentValue, currentValue);\n\t            }, function expressionPropertyListener(value) {\n\t              setter(field, value);\n\t            }, true);\n\t          });\n\t        })();\n\t      }\n\t    }\n\n\t    function valueGetterSetter(newVal) {\n\t      if (!$scope.model || !$scope.options.key) {\n\t        return undefined;\n\t      }\n\t      if (_angularFix2['default'].isDefined(newVal)) {\n\t        parseSet($scope.options.key, $scope.model, newVal);\n\t      }\n\t      return parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function shouldNotUseParseKey(key) {\n\t      return _angularFix2['default'].isNumber(key) || !formlyUtil.containsSelector(key);\n\t    }\n\n\t    function parseSet(key, model, newVal) {\n\t      // If either of these are null/undefined then just return undefined\n\t      if (!key || !model) {\n\t        return;\n\t      }\n\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t      if (shouldNotUseParseKey(key)) {\n\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t        model[key] = newVal;\n\t      } else {\n\t        var setter = $parse($scope.options.key).assign;\n\t        if (setter) {\n\t          setter($scope.model, newVal);\n\t        }\n\t      }\n\t    }\n\n\t    function parseGet(key, model) {\n\t      // If either of these are null/undefined then just return undefined\n\t      if (!key || !model) {\n\t        return undefined;\n\t      }\n\n\t      // If we are working with a number then $parse wont work, default back to the old way for now\n\t      if (shouldNotUseParseKey(key)) {\n\t        // TODO: Fix this so we can get several levels instead of just one with properties that are numeric\n\t        return model[key];\n\t      } else {\n\t        return $parse(key)(model);\n\t      }\n\t    }\n\n\t    function simplifyLife(options) {\n\t      // add a few empty objects (if they don't already exist) so you don't have to undefined check everywhere\n\t      formlyUtil.reverseDeepMerge(options, {\n\t        originalModel: options.model,\n\t        extras: {},\n\t        data: {},\n\t        templateOptions: {},\n\t        validation: {}\n\t      });\n\t      // create $scope.to so template authors can reference to instead of $scope.options.templateOptions\n\t      $scope.to = $scope.options.templateOptions;\n\t      $scope.formOptions = $scope.formOptions || {};\n\t    }\n\n\t    function setFieldIdAndName() {\n\t      if (_angularFix2['default'].isFunction(formlyConfig.extras.getFieldId)) {\n\t        $scope.id = formlyConfig.extras.getFieldId($scope.options, $scope.model, $scope);\n\t      } else {\n\t        var formName = $scope.form && $scope.form.$name || $scope.formId;\n\t        $scope.id = formlyUtil.getFieldId(formName, $scope.options, $scope.index);\n\t      }\n\t      $scope.options.id = $scope.id;\n\t      $scope.name = $scope.options.name || $scope.options.id;\n\t      $scope.options.name = $scope.name;\n\t    }\n\n\t    function setDefaultValue() {\n\t      if (_angularFix2['default'].isDefined($scope.options.defaultValue) && !_angularFix2['default'].isDefined(parseGet($scope.options.key, $scope.model))) {\n\t        parseSet($scope.options.key, $scope.model, $scope.options.defaultValue);\n\t      }\n\t    }\n\n\t    function setInitialValue() {\n\t      $scope.options.initialValue = $scope.model && parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function mergeFieldOptionsWithTypeDefaults(options, type) {\n\t      if (type) {\n\t        mergeOptions(options, type.defaultOptions);\n\t      }\n\t      var properOrder = arrayify(options.optionsTypes).reverse(); // so the right things are overridden\n\t      _angularFix2['default'].forEach(properOrder, function (typeName) {\n\t        mergeOptions(options, formlyConfig.getType(typeName, true, options).defaultOptions);\n\t      });\n\t    }\n\n\t    function mergeOptions(options, extraOptions) {\n\t      if (extraOptions) {\n\t        if (_angularFix2['default'].isFunction(extraOptions)) {\n\t          extraOptions = extraOptions(options, $scope);\n\t        }\n\t        formlyUtil.reverseDeepMerge(options, extraOptions);\n\t      }\n\t    }\n\n\t    function extendOptionsWithDefaults(options, index) {\n\t      var key = options.key || index || 0;\n\t      _angularFix2['default'].extend(options, {\n\t        // attach the key in case the formly-field directive is used directly\n\t        key: key,\n\t        value: options.value || valueGetterSetter,\n\t        runExpressions: runExpressions,\n\t        resetModel: resetModel,\n\t        updateInitialValue: updateInitialValue\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      parseSet($scope.options.key, $scope.model, $scope.options.initialValue);\n\t      if ($scope.options.formControl) {\n\t        if (_angularFix2['default'].isArray($scope.options.formControl)) {\n\t          _angularFix2['default'].forEach($scope.options.formControl, function (formControl) {\n\t            resetFormControl(formControl, true);\n\t          });\n\t        } else {\n\t          resetFormControl($scope.options.formControl);\n\t        }\n\t      }\n\t      if ($scope.form) {\n\t        $scope.form.$setUntouched && $scope.form.$setUntouched();\n\t        $scope.form.$setPristine();\n\t      }\n\t    }\n\n\t    function resetFormControl(formControl, isMultiNgModel) {\n\t      if (!isMultiNgModel) {\n\t        formControl.$setViewValue(parseGet($scope.options.key, $scope.model));\n\t      }\n\n\t      formControl.$render();\n\t      formControl.$setUntouched && formControl.$setUntouched();\n\t      formControl.$setPristine();\n\n\t      // To prevent breaking change requiring a digest to reset $viewModel\n\t      if (!$scope.$root.$$phase) {\n\t        $scope.$digest();\n\t      }\n\t    }\n\n\t    function updateInitialValue() {\n\t      $scope.options.initialValue = parseGet($scope.options.key, $scope.model);\n\t    }\n\n\t    function addValidationMessages(options) {\n\t      options.validation.messages = options.validation.messages || {};\n\t      _angularFix2['default'].forEach(formlyValidationMessages.messages, function createFunctionForMessage(expression, name) {\n\t        if (!options.validation.messages[name]) {\n\t          options.validation.messages[name] = function evaluateMessage(viewValue, modelValue, scope) {\n\t            return formlyUtil.formlyEval(scope, expression, modelValue, viewValue);\n\t          };\n\t        }\n\t      });\n\t    }\n\n\t    function invokeControllers(scope) {\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t      var type = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t      _angularFix2['default'].forEach([type.controller, options.controller], function (controller) {\n\t        if (controller) {\n\t          $controller(controller, { $scope: scope });\n\t        }\n\t      });\n\t    }\n\n\t    function setupFieldGroup() {\n\t      $scope.options.options = $scope.options.options || {};\n\t      $scope.options.options.formState = $scope.formState;\n\t      $scope.to = $scope.options.templateOptions;\n\t    }\n\t  }\n\n\t  // link function\n\t  function fieldLink(scope, el, attrs, formlyFormCtrl) {\n\t    if (scope.options.fieldGroup) {\n\t      setFieldGroupTemplate();\n\t      return;\n\t    }\n\n\t    // watch the field model (if exists) if there is no parent formly-form directive (that would watch it instead)\n\t    if (!formlyFormCtrl && scope.options.model) {\n\t      scope.$watch('options.model', function () {\n\t        return scope.options.runExpressions();\n\t      }, true);\n\t    }\n\n\t    addAttributes();\n\t    addClasses();\n\n\t    var type = getFieldType(scope.options);\n\t    var args = arguments;\n\t    var thusly = this;\n\t    var fieldCount = 0;\n\t    var fieldManipulators = getManipulators(scope.options, scope.formOptions);\n\t    getFieldTemplate(scope.options).then(runManipulators(fieldManipulators.preWrapper)).then(transcludeInWrappers(scope.options, scope.formOptions)).then(runManipulators(fieldManipulators.postWrapper)).then(setElementTemplate).then(watchFormControl).then(callLinkFunctions)['catch'](function (error) {\n\t      formlyWarn('there-was-a-problem-setting-the-template-for-this-field', 'There was a problem setting the template for this field ', scope.options, error);\n\t    });\n\n\t    function setFieldGroupTemplate() {\n\t      checkFieldGroupApi(scope.options);\n\t      el.addClass('formly-field-group');\n\t      var extraAttributes = '';\n\t      if (scope.options.elementAttributes) {\n\t        extraAttributes = Object.keys(scope.options.elementAttributes).map(function (key) {\n\t          return key + '=\"' + scope.options.elementAttributes[key] + '\"';\n\t        }).join(' ');\n\t      }\n\t      var modelValue = 'model';\n\t      scope.options.form = scope.form;\n\t      if (scope.options.key) {\n\t        modelValue = 'model[\\'' + scope.options.key + '\\']';\n\t      }\n\t      getTemplate('\\n          <formly-form model=\"' + modelValue + '\"\\n                       fields=\"options.fieldGroup\"\\n                       options=\"options.options\"\\n                       form=\"options.form\"\\n                       class=\"' + scope.options.className + '\"\\n                       ' + extraAttributes + '\\n                       is-field-group>\\n          </formly-form>\\n        ').then(transcludeInWrappers(scope.options, scope.formOptions)).then(setElementTemplate);\n\t    }\n\n\t    function addAttributes() {\n\t      if (scope.options.elementAttributes) {\n\t        el.attr(scope.options.elementAttributes);\n\t      }\n\t    }\n\n\t    function addClasses() {\n\t      if (scope.options.className) {\n\t        el.addClass(scope.options.className);\n\t      }\n\t      if (scope.options.type) {\n\t        el.addClass('formly-field-' + scope.options.type);\n\t      }\n\t    }\n\n\t    function setElementTemplate(templateString) {\n\t      el.html(asHtml(templateString));\n\t      $compile(el.contents())(scope);\n\t      return templateString;\n\t    }\n\n\t    function watchFormControl(templateString) {\n\t      var stopWatchingShowError = _angularFix2['default'].noop;\n\t      if (scope.options.noFormControl) {\n\t        return;\n\t      }\n\t      var templateEl = _angularFix2['default'].element('<div>' + templateString + '</div>');\n\t      var ngModelNodes = templateEl[0].querySelectorAll('[ng-model],[data-ng-model]');\n\n\t      if (ngModelNodes.length) {\n\t        _angularFix2['default'].forEach(ngModelNodes, function (ngModelNode) {\n\t          fieldCount++;\n\t          watchFieldNameOrExistence(ngModelNode.getAttribute('name'));\n\t        });\n\t      }\n\n\t      function watchFieldNameOrExistence(name) {\n\t        var nameExpressionRegex = /\\{\\{(.*?)}}/;\n\t        var nameExpression = nameExpressionRegex.exec(name);\n\t        if (nameExpression) {\n\t          name = $interpolate(name)(scope);\n\t        }\n\t        watchFieldExistence(name);\n\t      }\n\n\t      function watchFieldExistence(name) {\n\t        scope.$watch('form[\"' + name + '\"]', function formControlChange(formControl) {\n\t          if (formControl) {\n\t            if (fieldCount > 1) {\n\t              if (!scope.options.formControl) {\n\t                scope.options.formControl = [];\n\t              }\n\t              scope.options.formControl.push(formControl);\n\t            } else {\n\t              scope.options.formControl = formControl;\n\t            }\n\t            scope.fc = scope.options.formControl; // shortcut for template authors\n\t            stopWatchingShowError();\n\t            addShowMessagesWatcher();\n\t            addParsers();\n\t            addFormatters();\n\t          }\n\t        });\n\t      }\n\n\t      function addShowMessagesWatcher() {\n\t        stopWatchingShowError = scope.$watch(function watchShowValidationChange() {\n\t          var customExpression = formlyConfig.extras.errorExistsAndShouldBeVisibleExpression;\n\t          var options = scope.options;\n\t          var formControls = arrayify(scope.fc);\n\t          if (!formControls.some(function (fc) {\n\t            return fc.$invalid;\n\t          })) {\n\t            return false;\n\t          } else if (typeof options.validation.show === 'boolean') {\n\t            return options.validation.show;\n\t          } else if (customExpression) {\n\t            return formControls.some(function (fc) {\n\t              return formlyUtil.formlyEval(scope, customExpression, fc.$modelValue, fc.$viewValue);\n\t            });\n\t          } else {\n\t            return formControls.some(function (fc) {\n\t              var noTouchedButDirty = _angularFix2['default'].isUndefined(fc.$touched) && fc.$dirty;\n\t              return fc.$touched || noTouchedButDirty;\n\t            });\n\t          }\n\t        }, function onShowValidationChange(show) {\n\t          scope.options.validation.errorExistsAndShouldBeVisible = show;\n\t          scope.showError = show; // shortcut for template authors\n\t        });\n\t      }\n\n\t      function addParsers() {\n\t        setParsersOrFormatters('parsers');\n\t      }\n\n\t      function addFormatters() {\n\t        setParsersOrFormatters('formatters');\n\t        var ctrl = scope.fc;\n\t        var formWasPristine = scope.form.$pristine;\n\t        if (scope.options.formatters) {\n\t          (function () {\n\t            var value = ctrl.$modelValue;\n\t            ctrl.$formatters.forEach(function (formatter) {\n\t              value = formatter(value);\n\t            });\n\n\t            ctrl.$setViewValue(value);\n\t            ctrl.$render();\n\t            ctrl.$setPristine();\n\t            if (formWasPristine) {\n\t              scope.form.$setPristine();\n\t            }\n\t          })();\n\t        }\n\t      }\n\n\t      function setParsersOrFormatters(which) {\n\t        var originalThingProp = 'originalParser';\n\t        if (which === 'formatters') {\n\t          originalThingProp = 'originalFormatter';\n\t        }\n\n\t        // init with type's parsers\n\t        var things = getThingsFromType(type);\n\n\t        // get optionsTypes things\n\t        things = formlyUtil.extendArray(things, getThingsFromOptionsTypes(scope.options.optionsTypes));\n\n\t        // get field's things\n\t        things = formlyUtil.extendArray(things, scope.options[which]);\n\n\t        // convert things into formlyExpression things\n\t        _angularFix2['default'].forEach(things, function (thing, index) {\n\t          things[index] = getFormlyExpressionThing(thing);\n\t        });\n\n\t        var ngModelCtrls = scope.fc;\n\t        if (!_angularFix2['default'].isArray(ngModelCtrls)) {\n\t          ngModelCtrls = [ngModelCtrls];\n\t        }\n\n\t        _angularFix2['default'].forEach(ngModelCtrls, function (ngModelCtrl) {\n\t          var _ngModelCtrl;\n\n\t          ngModelCtrl['$' + which] = (_ngModelCtrl = ngModelCtrl['$' + which]).concat.apply(_ngModelCtrl, _toConsumableArray(things));\n\t        });\n\n\t        function getThingsFromType(theType) {\n\t          if (!theType) {\n\t            return [];\n\t          }\n\t          if (_angularFix2['default'].isString(theType)) {\n\t            theType = formlyConfig.getType(theType, true, scope.options);\n\t          }\n\t          var typeThings = [];\n\n\t          // get things from parent\n\t          if (theType['extends']) {\n\t            typeThings = formlyUtil.extendArray(typeThings, getThingsFromType(theType['extends']));\n\t          }\n\n\t          // get own type's things\n\t          typeThings = formlyUtil.extendArray(typeThings, getDefaultOptionsProperty(theType, which, []));\n\n\t          // get things from optionsTypes\n\t          typeThings = formlyUtil.extendArray(typeThings, getThingsFromOptionsTypes(getDefaultOptionsOptionsTypes(theType)));\n\n\t          return typeThings;\n\t        }\n\n\t        function getThingsFromOptionsTypes() {\n\t          var optionsTypes = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n\t          var optionsTypesThings = [];\n\t          _angularFix2['default'].forEach(_angularFix2['default'].copy(arrayify(optionsTypes)).reverse(), function (optionsTypeName) {\n\t            optionsTypesThings = formlyUtil.extendArray(optionsTypesThings, getThingsFromType(optionsTypeName));\n\t          });\n\t          return optionsTypesThings;\n\t        }\n\n\t        function getFormlyExpressionThing(thing) {\n\t          formlyExpressionParserOrFormatterFunction[originalThingProp] = thing;\n\t          return formlyExpressionParserOrFormatterFunction;\n\n\t          function formlyExpressionParserOrFormatterFunction($viewValue) {\n\t            var $modelValue = scope.options.value();\n\t            return formlyUtil.formlyEval(scope, thing, $modelValue, $viewValue);\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    function callLinkFunctions() {\n\t      if (type && type.link) {\n\t        type.link.apply(thusly, args);\n\t      }\n\t      if (scope.options.link) {\n\t        scope.options.link.apply(thusly, args);\n\t      }\n\t    }\n\n\t    function runManipulators(manipulators) {\n\t      return function runManipulatorsOnTemplate(templateToManipulate) {\n\t        var chain = $q.when(templateToManipulate);\n\t        _angularFix2['default'].forEach(manipulators, function (manipulator) {\n\t          chain = chain.then(function (template) {\n\t            return $q.when(manipulator(template, scope.options, scope)).then(function (newTemplate) {\n\t              return _angularFix2['default'].isString(newTemplate) ? newTemplate : asHtml(newTemplate);\n\t            });\n\t          });\n\t        });\n\t        return chain;\n\t      };\n\t    }\n\t  }\n\n\t  // sort-of stateless util functions\n\t  function asHtml(el) {\n\t    var wrapper = _angularFix2['default'].element('<a></a>');\n\t    return wrapper.append(el).html();\n\t  }\n\n\t  function getFieldType(options) {\n\t    return options.type && formlyConfig.getType(options.type);\n\t  }\n\n\t  function getManipulators(options, formOptions) {\n\t    var preWrapper = [];\n\t    var postWrapper = [];\n\t    addManipulators(options.templateManipulators);\n\t    addManipulators(formOptions.templateManipulators);\n\t    addManipulators(formlyConfig.templateManipulators);\n\t    return { preWrapper: preWrapper, postWrapper: postWrapper };\n\n\t    function addManipulators(manipulators) {\n\t      /* eslint-disable */ // it doesn't understand this :-(\n\n\t      var _ref = manipulators || {};\n\n\t      var _ref$preWrapper = _ref.preWrapper;\n\t      var pre = _ref$preWrapper === undefined ? [] : _ref$preWrapper;\n\t      var _ref$postWrapper = _ref.postWrapper;\n\t      var post = _ref$postWrapper === undefined ? [] : _ref$postWrapper;\n\n\t      preWrapper = preWrapper.concat(pre);\n\t      postWrapper = postWrapper.concat(post);\n\t      /* eslint-enable */\n\t    }\n\t  }\n\n\t  function getFieldTemplate(options) {\n\t    function fromOptionsOrType(key, fieldType) {\n\t      if (_angularFix2['default'].isDefined(options[key])) {\n\t        return options[key];\n\t      } else if (fieldType && _angularFix2['default'].isDefined(fieldType[key])) {\n\t        return fieldType[key];\n\t      }\n\t    }\n\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    var template = fromOptionsOrType('template', type);\n\t    var templateUrl = fromOptionsOrType('templateUrl', type);\n\t    if (_angularFix2['default'].isUndefined(template) && !templateUrl) {\n\t      throw formlyUsability.getFieldError('type-type-has-no-template', 'Type \\'' + options.type + '\\' has no template. On element:', options);\n\t    }\n\n\t    return getTemplate(templateUrl || template, _angularFix2['default'].isUndefined(template), options);\n\t  }\n\n\t  function getTemplate(template, isUrl, options) {\n\t    var templatePromise = undefined;\n\t    if (_angularFix2['default'].isFunction(template)) {\n\t      templatePromise = $q.when(template(options));\n\t    } else {\n\t      templatePromise = $q.when(template);\n\t    }\n\n\t    if (!isUrl) {\n\t      return templatePromise;\n\t    } else {\n\t      var _ret3 = (function () {\n\t        var httpOptions = { cache: $templateCache };\n\t        return {\n\t          v: templatePromise.then(function (url) {\n\t            return $http.get(url, httpOptions);\n\t          }).then(function (response) {\n\t            return response.data;\n\t          })['catch'](function handleErrorGettingATemplate(error) {\n\t            formlyWarn('problem-loading-template-for-templateurl', 'Problem loading template for ' + template, error);\n\t          })\n\t        };\n\t      })();\n\n\t      if (typeof _ret3 === 'object') return _ret3.v;\n\t    }\n\t  }\n\n\t  function transcludeInWrappers(options, formOptions) {\n\t    var wrapper = getWrapperOption(options, formOptions);\n\n\t    return function transcludeTemplate(template) {\n\t      if (!wrapper.length) {\n\t        return $q.when(template);\n\t      }\n\n\t      wrapper.forEach(function (aWrapper) {\n\t        formlyUsability.checkWrapper(aWrapper, options);\n\t        runApiCheck(aWrapper, options);\n\t      });\n\t      var promises = wrapper.map(function (w) {\n\t        return getTemplate(w.template || w.templateUrl, !w.template);\n\t      });\n\t      return $q.all(promises).then(function (wrappersTemplates) {\n\t        wrappersTemplates.forEach(function (wrapperTemplate, index) {\n\t          formlyUsability.checkWrapperTemplate(wrapperTemplate, wrapper[index]);\n\t        });\n\t        wrappersTemplates.reverse(); // wrapper 0 is wrapped in wrapper 1 and so on...\n\t        var totalWrapper = wrappersTemplates.shift();\n\t        wrappersTemplates.forEach(function (wrapperTemplate) {\n\t          totalWrapper = doTransclusion(totalWrapper, wrapperTemplate);\n\t        });\n\t        return doTransclusion(totalWrapper, template);\n\t      });\n\t    };\n\t  }\n\n\t  function doTransclusion(wrapper, template) {\n\t    var superWrapper = _angularFix2['default'].element('<a></a>'); // this allows people not have to have a single root in wrappers\n\t    superWrapper.append(wrapper);\n\t    var transcludeEl = superWrapper.find('formly-transclude');\n\t    if (!transcludeEl.length) {\n\t      // try it using our custom find function\n\t      transcludeEl = formlyUtil.findByNodeName(superWrapper, 'formly-transclude');\n\t    }\n\t    transcludeEl.replaceWith(template);\n\t    return superWrapper.html();\n\t  }\n\n\t  function getWrapperOption(options, formOptions) {\n\t    /* eslint complexity:[2, 6] */\n\t    var wrapper = options.wrapper;\n\t    // explicit null means no wrapper\n\t    if (wrapper === null) {\n\t      return [];\n\t    }\n\n\t    // nothing specified means use the default wrapper for the type\n\t    if (!wrapper) {\n\t      // get all wrappers that specify they apply to this type\n\t      wrapper = arrayify(formlyConfig.getWrapperByType(options.type));\n\t    } else {\n\t      wrapper = arrayify(wrapper).map(formlyConfig.getWrapper);\n\t    }\n\n\t    // get all wrappers for that the type specified that it uses.\n\t    var type = formlyConfig.getType(options.type, true, options);\n\t    if (type && type.wrapper) {\n\t      var typeWrappers = arrayify(type.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(typeWrappers);\n\t    }\n\n\t    // add form wrappers\n\t    if (formOptions.wrapper) {\n\t      var formWrappers = arrayify(formOptions.wrapper).map(formlyConfig.getWrapper);\n\t      wrapper = wrapper.concat(formWrappers);\n\t    }\n\n\t    // add the default wrapper last\n\t    var defaultWrapper = formlyConfig.getWrapper();\n\t    if (defaultWrapper) {\n\t      wrapper.push(defaultWrapper);\n\t    }\n\t    return wrapper;\n\t  }\n\n\t  function checkApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.formlyFieldOptions, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t    // validate with the type\n\t    var type = options.type && formlyConfig.getType(options.type);\n\t    if (type) {\n\t      runApiCheck(type, options, true);\n\t    }\n\t    if (options.expressionProperties && options.expressionProperties.hide) {\n\t      formlyWarn('dont-use-expressionproperties.hide-use-hideexpression-instead', 'You have specified `hide` in `expressionProperties`. Use `hideExpression` instead', options);\n\t    }\n\t  }\n\n\t  function checkFieldGroupApi(options) {\n\t    formlyApiCheck['throw'](formlyApiCheck.fieldGroup, options, {\n\t      prefix: 'formly-field directive',\n\t      url: 'formly-field-directive-validation-failed'\n\t    });\n\t  }\n\n\t  function runApiCheck(_ref2, options, forType) {\n\t    var apiCheck = _ref2.apiCheck;\n\t    var apiCheckInstance = _ref2.apiCheckInstance;\n\t    var apiCheckFunction = _ref2.apiCheckFunction;\n\t    var apiCheckOptions = _ref2.apiCheckOptions;\n\n\t    runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options);\n\t    if (forType && options.type) {\n\t      _angularFix2['default'].forEach(formlyConfig.getTypeHeritage(options.type), function (type) {\n\t        runApiCheckForType(type.apiCheck, type.apiCheckInstance, type.apiCheckFunction, type.apiCheckOptions, options);\n\t      });\n\t    }\n\t  }\n\n\t  function runApiCheckForType(apiCheck, apiCheckInstance, apiCheckFunction, apiCheckOptions, options) {\n\t    /* eslint complexity:[2, 9] */\n\t    if (!apiCheck) {\n\t      return;\n\t    }\n\t    var instance = apiCheckInstance || formlyConfig.extras.apiCheckInstance || formlyApiCheck;\n\t    if (instance.config.disabled || _apiCheck2['default'].globalConfig.disabled) {\n\t      return;\n\t    }\n\t    var fn = apiCheckFunction || 'warn';\n\t    // this is the new API\n\t    var checkerObjects = apiCheck(instance);\n\t    _angularFix2['default'].forEach(checkerObjects, function (shape, name) {\n\t      var checker = instance.shape(shape);\n\t      var checkOptions = _angularFix2['default'].extend({\n\t        prefix: 'formly-field type ' + options.type + ' for property ' + name,\n\t        url: formlyApiCheck.config.output.docsBaseUrl + 'formly-field-type-apicheck-failed'\n\t      }, apiCheckOptions);\n\t      instance[fn](checker, options[name], checkOptions);\n\t    });\n\t  }\n\t}\n\tformlyField.$inject = [\"$http\", \"$q\", \"$compile\", \"$templateCache\", \"$interpolate\", \"formlyConfig\", \"formlyApiCheck\", \"formlyUtil\", \"formlyUsability\", \"formlyWarn\"];\n\n\t// Stateless util functions\n\tfunction getDefaultOptionsOptionsTypes(type) {\n\t  return getDefaultOptionsProperty(type, 'optionsTypes', []);\n\t}\n\n\tfunction getDefaultOptionsProperty(type, prop, defaultValue) {\n\t  return type.defaultOptions && type.defaultOptions[prop] || defaultValue;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = formlyFocus;\n\n\t// @ngInject\n\tfunction formlyFocus($timeout, $document) {\n\t  return {\n\t    restrict: 'A',\n\t    link: function formlyFocusLink(scope, element, attrs) {\n\t      var previousEl = null;\n\t      var el = element[0];\n\t      var doc = $document[0];\n\t      attrs.$observe('formlyFocus', function respondToFocusExpressionChange(value) {\n\t        /* eslint no-bitwise:0 */ // I know what I'm doing. I promise...\n\t        if (value === 'true') {\n\t          $timeout(function setElementFocus() {\n\t            previousEl = doc.activeElement;\n\t            el.focus();\n\t          }, ~ ~attrs.focusWait);\n\t        } else if (value === 'false') {\n\t          if (doc.activeElement === el) {\n\t            el.blur();\n\t            if (attrs.hasOwnProperty('refocus') && previousEl) {\n\t              previousEl.focus();\n\t            }\n\t          }\n\t        }\n\t      });\n\t    }\n\t  };\n\t}\n\tformlyFocus.$inject = [\"$timeout\", \"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar _slice = Array.prototype.slice;\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = formlyForm;\n\n\t/**\n\t * @ngdoc directive\n\t * @name formlyForm\n\t * @restrict AE\n\t */\n\t// @ngInject\n\tfunction formlyForm(formlyUsability, formlyWarn, $parse, formlyConfig, $interpolate) {\n\t  var currentFormId = 1;\n\t  FormlyFormController.$inject = [\"$scope\", \"formlyApiCheck\", \"formlyUtil\"];\n\t  return {\n\t    restrict: 'AE',\n\t    template: formlyFormGetTemplate,\n\t    replace: true,\n\t    transclude: true,\n\t    scope: {\n\t      fields: '=',\n\t      model: '=',\n\t      form: '=?',\n\t      options: '=?'\n\t    },\n\t    controller: FormlyFormController,\n\t    link: formlyFormLink\n\t  };\n\n\t  function formlyFormGetTemplate(el, attrs) {\n\t    var rootEl = getRootEl();\n\t    var fieldRootEl = getFieldRootEl();\n\t    var formId = 'formly_' + currentFormId++;\n\t    var parentFormAttributes = '';\n\t    if (attrs.hasOwnProperty('isFieldGroup') && el.parent().parent().hasClass('formly')) {\n\t      parentFormAttributes = copyAttributes(el.parent().parent()[0].attributes);\n\t    }\n\t    return '\\n        <' + rootEl + ' class=\"formly\"\\n                 name=\"' + getFormName() + '\"\\n                 role=\"form\" ' + parentFormAttributes + '>\\n          <' + fieldRootEl + ' formly-field\\n               ng-repeat=\"field in fields ' + getTrackBy() + '\"\\n               ' + getHideDirective() + '=\"!field.hide\"\\n               class=\"formly-field\"\\n               options=\"field\"\\n               model=\"field.model || model\"\\n               original-model=\"model\"\\n               fields=\"fields\"\\n               form=\"theFormlyForm\"\\n               form-id=\"' + getFormName() + '\"\\n               form-state=\"options.formState\"\\n               form-options=\"options\"\\n               index=\"$index\">\\n          </' + fieldRootEl + '>\\n          <div ng-transclude class=\"' + getTranscludeClass() + '\"></div>\\n        </' + rootEl + '>\\n      ';\n\n\t    function getRootEl() {\n\t      return attrs.rootEl || 'ng-form';\n\t    }\n\n\t    function getFieldRootEl() {\n\t      return attrs.fieldRootEl || 'div';\n\t    }\n\n\t    function getHideDirective() {\n\t      return attrs.hideDirective || formlyConfig.extras.defaultHideDirective || 'ng-if';\n\t    }\n\n\t    function getTrackBy() {\n\t      if (!attrs.trackBy) {\n\t        return '';\n\t      } else {\n\t        return 'track by ' + attrs.trackBy;\n\t      }\n\t    }\n\n\t    function getFormName() {\n\t      var formName = formId;\n\t      var bindName = attrs.bindName;\n\t      if (bindName) {\n\t        if (_angularFix2['default'].version.minor < 3) {\n\t          throw formlyUsability.getFormlyError('bind-name attribute on formly-form not allowed in < angular 1.3');\n\t        }\n\t        // we can do a one-time binding here because we know we're in 1.3.x territory\n\t        formName = $interpolate.startSymbol() + '::\\'formly_\\' + ' + bindName + $interpolate.endSymbol();\n\t      }\n\t      return formName;\n\t    }\n\n\t    function getTranscludeClass() {\n\t      return attrs.transcludeClass || '';\n\t    }\n\n\t    function copyAttributes(attributes) {\n\t      var excluded = ['model', 'form', 'fields', 'options', 'name', 'role', 'class', 'data-model', 'data-form', 'data-fields', 'data-options', 'data-name'];\n\t      var arrayAttrs = [];\n\t      _angularFix2['default'].forEach(attributes, function (_ref) {\n\t        var nodeName = _ref.nodeName;\n\t        var value = _ref.value;\n\n\t        if (nodeName !== 'undefined' && excluded.indexOf(nodeName) === -1) {\n\t          arrayAttrs.push(toKebabCase(nodeName) + '=\"' + value + '\"');\n\t        }\n\t      });\n\t      return arrayAttrs.join(' ');\n\t    }\n\t  }\n\n\t  // @ngInject\n\t  function FormlyFormController($scope, formlyApiCheck, formlyUtil) {\n\t    setupOptions();\n\t    $scope.model = $scope.model || {};\n\t    setupFields();\n\n\t    // watch the model and evaluate watch expressions that depend on it.\n\t    if (!$scope.options.manualModelWatcher) {\n\t      $scope.$watch('model', onModelOrFormStateChange, true);\n\t    } else if (_angularFix2['default'].isFunction($scope.options.manualModelWatcher)) {\n\t      $scope.$watch($scope.options.manualModelWatcher, onModelOrFormStateChange, true);\n\t    }\n\n\t    if ($scope.options.formState) {\n\t      $scope.$watch('options.formState', onModelOrFormStateChange, true);\n\t    }\n\n\t    function onModelOrFormStateChange() {\n\t      _angularFix2['default'].forEach($scope.fields, runFieldExpressionProperties);\n\t    }\n\n\t    function validateFormControl(formControl, promise) {\n\t      var validate = formControl.$validate;\n\t      if (promise) {\n\t        promise.then(validate);\n\t      } else {\n\t        validate();\n\t      }\n\t    }\n\n\t    function runFieldExpressionProperties(field, index) {\n\t      var model = field.model || $scope.model;\n\t      var promise = field.runExpressions && field.runExpressions();\n\t      if (field.hideExpression) {\n\t        // can't use hide with expressionProperties reliably\n\t        var val = model[field.key];\n\t        field.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t      }\n\t      if (field.extras && field.extras.validateOnModelChange && field.formControl) {\n\t        if (_angularFix2['default'].isArray(field.formControl)) {\n\t          _angularFix2['default'].forEach(field.formControl, function (formControl) {\n\t            validateFormControl(formControl, promise);\n\t          });\n\t        } else {\n\t          validateFormControl(field.formControl, promise);\n\t        }\n\t      }\n\t    }\n\n\t    function setupFields() {\n\t      $scope.fields = $scope.fields || [];\n\n\t      checkDeprecatedOptions($scope.options);\n\n\t      var fieldTransforms = $scope.options.fieldTransform || formlyConfig.extras.fieldTransform;\n\n\t      if (!_angularFix2['default'].isArray(fieldTransforms)) {\n\t        fieldTransforms = [fieldTransforms];\n\t      }\n\n\t      _angularFix2['default'].forEach(fieldTransforms, function transformFields(fieldTransform) {\n\t        if (fieldTransform) {\n\t          $scope.fields = fieldTransform($scope.fields, $scope.model, $scope.options, $scope.form);\n\t          if (!$scope.fields) {\n\t            throw formlyUsability.getFormlyError('fieldTransform must return an array of fields');\n\t          }\n\t        }\n\t      });\n\n\t      setupModels();\n\n\t      if ($scope.options.watchAllExpressions) {\n\t        _angularFix2['default'].forEach($scope.fields, setupHideExpressionWatcher);\n\t      }\n\n\t      _angularFix2['default'].forEach($scope.fields, attachKey); // attaches a key based on the index if a key isn't specified\n\t      _angularFix2['default'].forEach($scope.fields, setupWatchers); // setup watchers for all fields\n\t    }\n\n\t    function checkDeprecatedOptions(options) {\n\t      if (formlyConfig.extras.fieldTransform && _angularFix2['default'].isFunction(formlyConfig.extras.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for formlyConfig.extras: ' + formlyConfig.extras.fieldTransform.name, formlyConfig.extras);\n\t      } else if (options.fieldTransform && _angularFix2['default'].isFunction(options.fieldTransform)) {\n\t        formlyWarn('fieldtransform-as-a-function-deprecated', 'fieldTransform as a function has been deprecated.', 'Attempted for form', options);\n\t      }\n\t    }\n\n\t    function setupOptions() {\n\t      formlyApiCheck['throw']([formlyApiCheck.formOptionsApi.optional], [$scope.options], { prefix: 'formly-form options check' });\n\t      $scope.options = $scope.options || {};\n\t      $scope.options.formState = $scope.options.formState || {};\n\n\t      _angularFix2['default'].extend($scope.options, {\n\t        updateInitialValue: updateInitialValue,\n\t        resetModel: resetModel\n\t      });\n\t    }\n\n\t    function updateInitialValue() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.updateInitialValue();\n\t        } else {\n\t          field.updateInitialValue();\n\t        }\n\t      });\n\t    }\n\n\t    function resetModel() {\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        if (isFieldGroup(field) && field.options) {\n\t          field.options.resetModel();\n\t        } else if (field.resetModel) {\n\t          field.resetModel();\n\t        }\n\t      });\n\t    }\n\n\t    function setupModels() {\n\t      // a set of field models that are already watched (the $scope.model will have its own watcher)\n\t      var watchedModels = [$scope.model];\n\t      // we will not set up automatic model watchers if manual mode is set\n\t      var manualModelWatcher = $scope.options.manualModelWatcher;\n\n\t      if ($scope.options.formState) {\n\t        // $scope.options.formState will have its own watcher\n\t        watchedModels.push($scope.options.formState);\n\t      }\n\n\t      _angularFix2['default'].forEach($scope.fields, function (field) {\n\t        var isNewModel = initModel(field);\n\n\t        if (field.model && isNewModel && watchedModels.indexOf(field.model) === -1 && !manualModelWatcher) {\n\t          $scope.$watch(function () {\n\t            return field.model;\n\t          }, onModelOrFormStateChange, true);\n\t          watchedModels.push(field.model);\n\t        }\n\t      });\n\t    }\n\n\t    function setupHideExpressionWatcher(field, index) {\n\t      if (field.hideExpression) {\n\t        (function () {\n\t          // can't use hide with expressionProperties reliably\n\t          var model = field.model || $scope.model;\n\t          $scope.$watch(function hideExpressionWatcher() {\n\t            var val = model[field.key];\n\t            return evalCloseToFormlyExpression(field.hideExpression, val, field, index);\n\t          }, function (hide) {\n\t            return field.hide = hide;\n\t          }, true);\n\t        })();\n\t      }\n\t    }\n\n\t    function initModel(field) {\n\t      var isNewModel = true;\n\n\t      if (_angularFix2['default'].isString(field.model)) {\n\t        var expression = field.model;\n\t        var index = $scope.fields.indexOf(field);\n\n\t        isNewModel = !referencesCurrentlyWatchedModel(expression);\n\n\t        field.model = evalCloseToFormlyExpression(expression, undefined, field, index);\n\t        if (!field.model) {\n\t          throw formlyUsability.getFieldError('field-model-must-be-initialized', 'Field model must be initialized. When specifying a model as a string for a field, the result of the' + ' expression must have been initialized ahead of time.', field);\n\t        }\n\t      }\n\t      return isNewModel;\n\t    }\n\n\t    function referencesCurrentlyWatchedModel(expression) {\n\t      return ['model', 'formState'].some(function (item) {\n\t        return formlyUtil.startsWith(expression, item + '.') || formlyUtil.startsWith(expression, item + '[');\n\t      });\n\t    }\n\n\t    function attachKey(field, index) {\n\t      if (!isFieldGroup(field)) {\n\t        field.key = field.key || index || 0;\n\t      }\n\t    }\n\n\t    function setupWatchers(field, index) {\n\t      if (!_angularFix2['default'].isDefined(field.watcher)) {\n\t        return;\n\t      }\n\t      var watchers = field.watcher;\n\t      if (!_angularFix2['default'].isArray(watchers)) {\n\t        watchers = [watchers];\n\t      }\n\t      _angularFix2['default'].forEach(watchers, function setupWatcher(watcher) {\n\t        if (!_angularFix2['default'].isDefined(watcher.listener) && !watcher.runFieldExpressions) {\n\t          throw formlyUsability.getFieldError('all-field-watchers-must-have-a-listener', 'All field watchers must have a listener', field);\n\t        }\n\t        var watchExpression = getWatchExpression(watcher, field, index);\n\t        var watchListener = getWatchListener(watcher, field, index);\n\n\t        var type = watcher.type || '$watch';\n\t        watcher.stopWatching = $scope[type](watchExpression, watchListener, watcher.watchDeep);\n\t      });\n\t    }\n\n\t    function getWatchExpression(watcher, field, index) {\n\t      var watchExpression = undefined;\n\t      if (!_angularFix2['default'].isUndefined(watcher.expression)) {\n\t        watchExpression = watcher.expression;\n\t      } else if (field.key) {\n\t        watchExpression = 'model[\\'' + field.key.toString().split('.').join('\\'][\\'') + '\\']';\n\t      }\n\t      if (_angularFix2['default'].isFunction(watchExpression)) {\n\t        (function () {\n\t          // wrap the field's watch expression so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalExpression = watchExpression;\n\t          watchExpression = function formlyWatchExpression() {\n\t            var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t            return originalExpression.apply(undefined, _toConsumableArray(args));\n\t          };\n\t          watchExpression.displayName = 'Formly Watch Expression for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchExpression;\n\t    }\n\n\t    function getWatchListener(watcher, field, index) {\n\t      var watchListener = watcher.listener;\n\t      if (_angularFix2['default'].isFunction(watchListener) || watcher.runFieldExpressions) {\n\t        (function () {\n\t          // wrap the field's watch listener so we can call it with the field as the first arg\n\t          // and the stop function as the last arg as a helper\n\t          var originalListener = watchListener;\n\t          watchListener = function formlyWatchListener() {\n\t            var value = undefined;\n\t            if (originalListener) {\n\t              var args = modifyArgs.apply(undefined, [watcher, index].concat(_slice.call(arguments)));\n\t              value = originalListener.apply(undefined, _toConsumableArray(args));\n\t            }\n\t            if (watcher.runFieldExpressions) {\n\t              runFieldExpressionProperties(field, index);\n\t            }\n\t            return value;\n\t          };\n\t          watchListener.displayName = 'Formly Watch Listener for field for ' + field.key;\n\t        })();\n\t      }\n\t      return watchListener;\n\t    }\n\n\t    function modifyArgs(watcher, index) {\n\t      for (var _len = arguments.length, originalArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t        originalArgs[_key - 2] = arguments[_key];\n\t      }\n\n\t      return [$scope.fields[index]].concat(originalArgs, [watcher.stopWatching]);\n\t    }\n\n\t    function evalCloseToFormlyExpression(expression, val, field, index) {\n\t      var extraLocals = getFormlyFieldLikeLocals(field, index);\n\t      return formlyUtil.formlyEval($scope, expression, val, val, extraLocals);\n\t    }\n\n\t    function getFormlyFieldLikeLocals(field, index) {\n\t      // this makes it closer to what a regular formlyExpression would be\n\t      return {\n\t        options: field,\n\t        index: index,\n\t        formState: $scope.options.formState,\n\t        originalModel: $scope.model,\n\t        formOptions: $scope.options,\n\t        formId: $scope.formId\n\t      };\n\t    }\n\t  }\n\n\t  function formlyFormLink(scope, el, attrs) {\n\t    setFormController();\n\t    fixChromeAutocomplete();\n\n\t    function setFormController() {\n\t      var formId = attrs.name;\n\t      scope.formId = formId;\n\t      scope.theFormlyForm = scope[formId];\n\t      if (attrs.form) {\n\t        var getter = $parse(attrs.form);\n\t        var setter = getter.assign;\n\t        var parentForm = getter(scope.$parent);\n\t        if (parentForm) {\n\t          scope.theFormlyForm = parentForm;\n\t          if (scope[formId]) {\n\t            scope.theFormlyForm.$removeControl(scope[formId]);\n\t          }\n\n\t          // this next line is probably one of the more dangerous things that angular-formly does to improve the\n\t          // API for angular-formly forms. It ensures that the NgModelControllers inside of formly-form will be\n\t          // attached to the form that is passed to formly-form rather than the one that formly-form creates\n\t          // this is necessary because it's confusing to have a step between the form you pass in\n\t          // and the fields in that form. It also is because angular doesn't propagate properties like $submitted down\n\t          // to children forms :-( This line was added to solve this issue:\n\t          // https://github.com/formly-js/angular-formly/issues/287\n\t          // luckily, this is how the formController has been accessed by the NgModelController since angular 1.0.0\n\t          // so I expect it will remain this way for the life of angular 1.x\n\t          el.removeData('$formController');\n\t        } else {\n\t          setter(scope.$parent, scope[formId]);\n\t        }\n\t      }\n\t      if (!scope.theFormlyForm && !formlyConfig.disableWarnings) {\n\t        /* eslint no-console:0 */\n\t        formlyWarn('formly-form-has-no-formcontroller', 'Your formly-form does not have a `form` property. Many functions of the form (like validation) may not work', el, scope);\n\t      }\n\t    }\n\n\t    /*\n\t     * chrome autocomplete lameness\n\t     * see https://code.google.com/p/chromium/issues/detail?id=468153#c14\n\t     * ლ(ಠ益ಠლ)   (╯°□°)╯︵ ┻━┻    (◞‸◟；)\n\t     */\n\t    function fixChromeAutocomplete() {\n\t      var global = formlyConfig.extras.removeChromeAutoComplete === true;\n\t      var offInstance = scope.options && scope.options.removeChromeAutoComplete === false;\n\t      var onInstance = scope.options && scope.options.removeChromeAutoComplete === true;\n\t      if (global && !offInstance || onInstance) {\n\t        var input = document.createElement('input');\n\t        input.setAttribute('autocomplete', 'address-level4');\n\t        input.setAttribute('hidden', 'true');\n\t        el[0].appendChild(input);\n\t      }\n\t    }\n\t  }\n\n\t  // stateless util functions\n\t  function toKebabCase(string) {\n\t    if (string) {\n\t      return string.replace(/([A-Z])/g, function ($1) {\n\t        return '-' + $1.toLowerCase();\n\t      });\n\t    } else {\n\t      return '';\n\t    }\n\t  }\n\n\t  function isFieldGroup(field) {\n\t    return field && !!field.fieldGroup;\n\t  }\n\t}\n\tformlyForm.$inject = [\"formlyUsability\", \"formlyWarn\", \"$parse\", \"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\tvar _otherUtils = __webpack_require__(9);\n\n\texports['default'] = addFormlyNgModelAttrsManipulator;\n\n\t// @ngInject\n\tfunction addFormlyNgModelAttrsManipulator(formlyConfig, $interpolate) {\n\t  if (formlyConfig.extras.disableNgModelAttrsManipulator) {\n\t    return;\n\t  }\n\t  formlyConfig.templateManipulators.preWrapper.push(ngModelAttrsManipulator);\n\n\t  function ngModelAttrsManipulator(template, options, scope) {\n\t    var node = document.createElement('div');\n\t    var skip = options.extras && options.extras.skipNgModelAttrsManipulator;\n\t    if (skip === true) {\n\t      return template;\n\t    }\n\t    node.innerHTML = template;\n\n\t    var modelNodes = getNgModelNodes(node, skip);\n\t    if (!modelNodes || !modelNodes.length) {\n\t      return template;\n\t    }\n\n\t    addIfNotPresent(modelNodes, 'id', scope.id);\n\t    addIfNotPresent(modelNodes, 'name', scope.name || scope.id);\n\n\t    addValidation();\n\t    alterNgModelAttr();\n\t    addModelOptions();\n\t    addTemplateOptionsAttrs();\n\t    addNgModelElAttrs();\n\n\t    return node.innerHTML;\n\n\t    function addValidation() {\n\t      if (_angularFix2['default'].isDefined(options.validators) || _angularFix2['default'].isDefined(options.validation.messages)) {\n\t        addIfNotPresent(modelNodes, 'formly-custom-validation', '');\n\t      }\n\t    }\n\n\t    function alterNgModelAttr() {\n\t      if (isPropertyAccessor(options.key)) {\n\t        addRegardlessOfPresence(modelNodes, 'ng-model', 'model.' + options.key);\n\t      }\n\t    }\n\n\t    function addModelOptions() {\n\t      if (_angularFix2['default'].isDefined(options.modelOptions)) {\n\t        addIfNotPresent(modelNodes, 'ng-model-options', 'options.modelOptions');\n\t        if (options.modelOptions.getterSetter) {\n\t          addRegardlessOfPresence(modelNodes, 'ng-model', 'options.value');\n\t        }\n\t      }\n\t    }\n\n\t    function addTemplateOptionsAttrs() {\n\t      if (!options.templateOptions && !options.expressionProperties) {\n\t        // no need to run these if there are no templateOptions or expressionProperties\n\t        return;\n\t      }\n\t      var to = options.templateOptions || {};\n\t      var ep = options.expressionProperties || {};\n\n\t      var ngModelAttributes = getBuiltInAttributes();\n\n\t      // extend with the user's specifications winning\n\t      _angularFix2['default'].extend(ngModelAttributes, options.ngModelAttrs);\n\n\t      // Feel free to make this more simple :-)\n\t      _angularFix2['default'].forEach(ngModelAttributes, function (val, name) {\n\t        /* eslint complexity:[2, 14] */\n\t        var attrVal = undefined,\n\t            attrName = undefined;\n\t        var ref = 'options.templateOptions[\\'' + name + '\\']';\n\t        var toVal = to[name];\n\t        var epVal = getEpValue(ep, name);\n\n\t        var inTo = _angularFix2['default'].isDefined(toVal);\n\t        var inEp = _angularFix2['default'].isDefined(epVal);\n\t        if (val.value) {\n\t          // I realize this looks backwards, but it's right, trust me...\n\t          attrName = val.value;\n\t          attrVal = name;\n\t        } else if (val.statement && inTo) {\n\t          attrName = val.statement;\n\t          if (_angularFix2['default'].isString(to[name])) {\n\t            attrVal = '$eval(' + ref + ')';\n\t          } else if (_angularFix2['default'].isFunction(to[name])) {\n\t            attrVal = ref + '(model[options.key], options, this, $event)';\n\t          } else {\n\t            throw new Error('options.templateOptions.' + name + ' must be a string or function: ' + JSON.stringify(options));\n\t          }\n\t        } else if (val.bound && inEp) {\n\t          attrName = val.bound;\n\t          attrVal = ref;\n\t        } else if ((val.attribute || val.boolean) && inEp) {\n\t          attrName = val.attribute || val.boolean;\n\t          attrVal = '' + $interpolate.startSymbol() + ref + $interpolate.endSymbol();\n\t        } else if (val.attribute && inTo) {\n\t          attrName = val.attribute;\n\t          attrVal = toVal;\n\t        } else if (val.boolean) {\n\t          if (inTo && !inEp && toVal) {\n\t            attrName = val.boolean;\n\t            attrVal = true;\n\t          } else {\n\t            /* eslint no-empty:0 */\n\t            // empty to illustrate that a boolean will not be added via val.bound\n\t            // if you want it added via val.bound, then put it in expressionProperties\n\t          }\n\t        } else if (val.bound && inTo) {\n\t            attrName = val.bound;\n\t            attrVal = ref;\n\t          }\n\n\t        if (_angularFix2['default'].isDefined(attrName) && _angularFix2['default'].isDefined(attrVal)) {\n\t          addIfNotPresent(modelNodes, attrName, attrVal);\n\t        }\n\t      });\n\t    }\n\n\t    function addNgModelElAttrs() {\n\t      _angularFix2['default'].forEach(options.ngModelElAttrs, function (val, name) {\n\t        addRegardlessOfPresence(modelNodes, name, val);\n\t      });\n\t    }\n\t  }\n\n\t  // Utility functions\n\t  function getNgModelNodes(node, skip) {\n\t    var selectorNot = _angularFix2['default'].isString(skip) ? ':not(' + skip + ')' : '';\n\t    var skipNot = ':not([formly-skip-ng-model-attrs-manipulator])';\n\t    var query = '[ng-model]' + selectorNot + skipNot + ', [data-ng-model]' + selectorNot + skipNot;\n\t    try {\n\t      return node.querySelectorAll(query);\n\t    } catch (e) {\n\t      //this code is needed for IE8, as it does not support the CSS3 ':not' selector\n\t      //it should be removed when IE8 support is dropped\n\t      return getNgModelNodesFallback(node, skip);\n\t    }\n\t  }\n\n\t  function getNgModelNodesFallback(node, skip) {\n\t    var allNgModelNodes = node.querySelectorAll('[ng-model], [data-ng-model]');\n\t    var matchingNgModelNodes = [];\n\n\t    //make sure this array is compatible with NodeList type by adding an 'item' function\n\t    matchingNgModelNodes.item = function (i) {\n\t      return this[i];\n\t    };\n\n\t    for (var i = 0; i < allNgModelNodes.length; i++) {\n\t      var ngModelNode = allNgModelNodes[i];\n\t      if (!ngModelNode.hasAttribute('formly-skip-ng-model-attrs-manipulator') && !(_angularFix2['default'].isString(skip) && nodeMatches(ngModelNode, skip))) {\n\t        matchingNgModelNodes.push(ngModelNode);\n\t      }\n\t    }\n\n\t    return matchingNgModelNodes;\n\t  }\n\n\t  function nodeMatches(node, selector) {\n\t    var div = document.createElement('div');\n\t    div.innerHTML = node.outerHTML;\n\t    return div.querySelector(selector);\n\t  }\n\n\t  function getBuiltInAttributes() {\n\t    var ngModelAttributes = {\n\t      focus: {\n\t        attribute: 'formly-focus'\n\t      }\n\t    };\n\t    var boundOnly = [];\n\t    var bothBooleanAndBound = ['required', 'disabled'];\n\t    var bothAttributeAndBound = ['pattern', 'minlength'];\n\t    var statementOnly = ['change', 'keydown', 'keyup', 'keypress', 'click', 'focus', 'blur'];\n\t    var attributeOnly = ['placeholder', 'min', 'max', 'step', 'tabindex', 'type'];\n\t    if (formlyConfig.extras.ngModelAttrsManipulatorPreferUnbound) {\n\t      bothAttributeAndBound.push('maxlength');\n\t    } else {\n\t      boundOnly.push('maxlength');\n\t    }\n\n\t    _angularFix2['default'].forEach(boundOnly, function (item) {\n\t      ngModelAttributes[item] = { bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothBooleanAndBound, function (item) {\n\t      ngModelAttributes[item] = { boolean: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(bothAttributeAndBound, function (item) {\n\t      ngModelAttributes[item] = { attribute: item, bound: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(statementOnly, function (item) {\n\t      var propName = 'on' + item.substr(0, 1).toUpperCase() + item.substr(1);\n\t      ngModelAttributes[propName] = { statement: 'ng-' + item };\n\t    });\n\n\t    _angularFix2['default'].forEach(attributeOnly, function (item) {\n\t      ngModelAttributes[item] = { attribute: item };\n\t    });\n\t    return ngModelAttributes;\n\t  }\n\n\t  function getEpValue(ep, name) {\n\t    return ep['templateOptions.' + name] || ep['templateOptions[\\'' + name + '\\']'] || ep['templateOptions[\"' + name + '\"]'];\n\t  }\n\n\t  function addIfNotPresent(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      if (!node.getAttribute(attr)) {\n\t        node.setAttribute(attr, val);\n\t      }\n\t    });\n\t  }\n\n\t  function addRegardlessOfPresence(nodes, attr, val) {\n\t    _angularFix2['default'].forEach(nodes, function (node) {\n\t      node.setAttribute(attr, val);\n\t    });\n\t  }\n\n\t  function isPropertyAccessor(key) {\n\t    return (0, _otherUtils.contains)(key, '.') || (0, _otherUtils.contains)(key, '[') && (0, _otherUtils.contains)(key, ']');\n\t  }\n\t}\n\taddFormlyNgModelAttrsManipulator.$inject = [\"formlyConfig\", \"$interpolate\"];\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _angularFix = __webpack_require__(2);\n\n\tvar _angularFix2 = _interopRequireDefault(_angularFix);\n\n\texports['default'] = addCustomTags;\n\n\t// @ngInject\n\tfunction addCustomTags($document) {\n\t  // IE8 check ->\n\t  // https://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx\n\t  if ($document && $document.documentMode < 9) {\n\t    (function () {\n\t      var document = $document.get(0);\n\t      // add the custom elements that we need for formly\n\t      var customElements = ['formly-field', 'formly-form'];\n\t      _angularFix2['default'].forEach(customElements, function (el) {\n\t        document.createElement(el);\n\t      });\n\t    })();\n\t  }\n\t}\n\taddCustomTags.$inject = [\"$document\"];\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly/dist/formly.js\n ** module id = 5\n ** module chunks = 1\n **/","//! angular-formly-templates-bootstrap version 6.3.0 built with ♥ by Astrism <astrisms@gmail.com>, Kent C. Dodds <kent@doddsfamily.us> (ó ì_í)=óò=(ì_í ò)\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\", \"angular-formly\", \"api-check\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngFormlyTemplatesBootstrap\"] = factory(require(\"angular\"), require(\"angular-formly\"), require(\"api-check\"));\n\telse\n\t\troot[\"ngFormlyTemplatesBootstrap\"] = factory(root[\"angular\"], root[\"ngFormly\"], root[\"apiCheck\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tmodule.exports = __webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar ngModuleName = 'formlyBootstrap';\n\tvar angular = __webpack_require__(2);\n\tvar ngModule = angular.module(ngModuleName, [__webpack_require__(4)]);\n\tngModule.constant('formlyBootstrapApiCheck', __webpack_require__(5)({\n\t  output: {\n\t    prefix: 'angular-formly-bootstrap'\n\t  }\n\t}));\n\tngModule.constant('formlyBootstrapVersion', (\"6.3.0\"));\n\n\t__webpack_require__(6)(ngModule);\n\t__webpack_require__(9)(ngModule);\n\t__webpack_require__(19)(ngModule);\n\n\texports['default'] = ngModuleName;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some versions of angular don't export the angular module properly,\n\t// so we get it from window in this case.\n\t'use strict';\n\n\tvar angular = __webpack_require__(3);\n\tif (!angular.version) {\n\t  angular = window.angular;\n\t}\n\tmodule.exports = angular;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addWrappers);\n\n\t  function addWrappers(formlyConfigProvider) {\n\t    formlyConfigProvider.setWrapper([{\n\t      name: 'bootstrapLabel',\n\t      template: __webpack_require__(7),\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string.optional,\n\t            required: check.bool.optional,\n\t            labelSrOnly: check.bool.optional\n\t          }\n\t        };\n\t      }\n\t    }, { name: 'bootstrapHasError', template: __webpack_require__(8) }]);\n\t  }\n\t  addWrappers.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div>\\n  <label for=\\\"{{id}}\\\" class=\\\"control-label {{to.labelSrOnly ? 'sr-only' : ''}}\\\" ng-if=\\\"to.label\\\">\\n    {{to.label}}\\n    {{to.required ? '*' : ''}}\\n  </label>\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"form-group\\\" ng-class=\\\"{'has-error': showError}\\\">\\n  <formly-transclude></formly-transclude>\\n</div>\\n\"\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  __webpack_require__(10)(ngModule);\n\t  __webpack_require__(12)(ngModule);\n\t  __webpack_require__(14)(ngModule);\n\t  __webpack_require__(15)(ngModule);\n\t  __webpack_require__(17)(ngModule);\n\t  __webpack_require__(18)(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'checkbox',\n\t      template: __webpack_require__(11),\n\t      wrapper: ['bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            label: check.string\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"checkbox\\\">\\n\\t<label>\\n\\t\\t<input type=\\\"checkbox\\\"\\n           class=\\\"formly-field-checkbox\\\"\\n\\t\\t       ng-model=\\\"model[options.key]\\\">\\n\\t\\t{{to.label}}\\n\\t\\t{{to.required ? '*' : ''}}\\n\\t</label>\\n</div>\\n\"\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addCheckboxType);\n\n\t  function addCheckboxType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'multiCheckbox',\n\t      template: __webpack_require__(13),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      },\n\t      defaultOptions: {\n\t        noFormControl: false,\n\t        ngModelAttrs: {\n\t          required: {\n\t            attribute: '',\n\t            bound: ''\n\t          }\n\t        }\n\t      },\n\t      controller: /* @ngInject */[\"$scope\", function controller($scope) {\n\t        var to = $scope.to;\n\t        var opts = $scope.options;\n\t        $scope.multiCheckbox = {\n\t          checked: [],\n\t          change: setModel\n\t        };\n\n\t        // initialize the checkboxes check property\n\t        $scope.$watch('model', function modelWatcher(newModelValue) {\n\t          var modelValue, valueProp;\n\n\t          if (Object.keys(newModelValue).length) {\n\t            modelValue = newModelValue[opts.key];\n\n\t            $scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n\t              if (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n\t                valueProp = to.valueProp || 'value';\n\t                for (var index = 0; index < newOptionsValues.length; index++) {\n\t                  $scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n\t                }\n\t              }\n\t            });\n\t          }\n\t        }, true);\n\n\t        function checkValidity(expressionValue) {\n\t          var valid;\n\n\t          if ($scope.to.required) {\n\t            valid = angular.isArray($scope.model[opts.key]) && $scope.model[opts.key].length > 0 && expressionValue;\n\n\t            $scope.fc.$setValidity('required', valid);\n\t          }\n\t        }\n\n\t        function setModel() {\n\t          $scope.model[opts.key] = [];\n\t          angular.forEach($scope.multiCheckbox.checked, function (checkbox, index) {\n\t            if (checkbox) {\n\t              $scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n\t            }\n\t          });\n\n\t          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n\t          $scope.fc.$setTouched();\n\t          checkValidity(true);\n\t        }\n\n\t        if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n\t          $scope.$watch(function () {\n\t            return $scope.to.required;\n\t          }, function (newValue) {\n\t            checkValidity(newValue);\n\t          });\n\t        }\n\n\t        if ($scope.to.required) {\n\t          var unwatchFormControl = $scope.$watch('fc', function (newValue) {\n\t            if (!newValue) {\n\t              return;\n\t            }\n\t            checkValidity(true);\n\t            unwatchFormControl();\n\t          });\n\t        }\n\t      }]\n\t    });\n\t  }\n\t  addCheckboxType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"checkbox\\\">\\n    <label>\\n      <input type=\\\"checkbox\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             ng-model=\\\"multiCheckbox.checked[$index]\\\"\\n             ng-change=\\\"multiCheckbox.change()\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addInputType);\n\n\t  function addInputType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'input',\n\t      template: '<input class=\"form-control\" ng-model=\"model[options.key]\">',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError']\n\t    });\n\t  }\n\t  addInputType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addRadioType);\n\n\t  function addRadioType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'radio',\n\t      template: __webpack_require__(16),\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        noFormControl: false\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addRadioType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"radio-group\\\">\\n  <div ng-repeat=\\\"(key, option) in to.options\\\" class=\\\"radio\\\">\\n    <label>\\n      <input type=\\\"radio\\\"\\n             id=\\\"{{id + '_'+ $index}}\\\"\\n             tabindex=\\\"0\\\"\\n             ng-value=\\\"option[to.valueProp || 'value']\\\"\\n             ng-model=\\\"model[options.key]\\\">\\n      {{option[to.labelProp || 'name']}}\\n    </label>\\n  </div>\\n</div>\\n\"\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addSelectType);\n\n\t  var template = '<select class=\"form-control\" ng-model=\"model[options.key]\"></select>';\n\n\t  function addSelectType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'select',\n\t      template: template,\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: function defaultOptions(options) {\n\t        /* jshint maxlen:195 */\n\t        var ngOptions = options.templateOptions.ngOptions || 'option[to.valueProp || \\'value\\'] as option[to.labelProp || \\'name\\'] group by option[to.groupProp || \\'group\\'] for option in to.options';\n\t        return {\n\t          ngModelAttrs: _defineProperty({}, ngOptions, {\n\t            value: options.templateOptions.optionsAttr || 'ng-options'\n\t          })\n\t        };\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            options: check.arrayOf(check.object),\n\t            optionsAttr: check.string.optional,\n\t            labelProp: check.string.optional,\n\t            valueProp: check.string.optional,\n\t            groupProp: check.string.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addSelectType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.config(addTextareaType);\n\n\t  function addTextareaType(formlyConfigProvider) {\n\t    formlyConfigProvider.setType({\n\t      name: 'textarea',\n\t      template: '<textarea class=\"form-control\" ng-model=\"model[options.key]\"></textarea>',\n\t      wrapper: ['bootstrapLabel', 'bootstrapHasError'],\n\t      defaultOptions: {\n\t        ngModelAttrs: {\n\t          rows: { attribute: 'rows' },\n\t          cols: { attribute: 'cols' }\n\t        }\n\t      },\n\t      apiCheck: function apiCheck(check) {\n\t        return {\n\t          templateOptions: {\n\t            rows: check.number.optional,\n\t            cols: check.number.optional\n\t          }\n\t        };\n\t      }\n\t    });\n\t  }\n\t  addTextareaType.$inject = [\"formlyConfigProvider\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tvar _addons = __webpack_require__(20);\n\n\tvar _addons2 = _interopRequireDefault(_addons);\n\n\tvar _description = __webpack_require__(22);\n\n\tvar _description2 = _interopRequireDefault(_description);\n\n\texports['default'] = function (ngModule) {\n\t  (0, _addons2['default'])(ngModule);\n\t  (0, _description2['default'])(ngModule);\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addAddonsManipulator);\n\n\t  function addAddonsManipulator(formlyConfig, formlyBootstrapApiCheck) {\n\t    var addonTemplate = __webpack_require__(21);\n\t    var addonChecker = formlyBootstrapApiCheck.shape({\n\t      'class': formlyBootstrapApiCheck.string.optional,\n\t      text: formlyBootstrapApiCheck.string.optional,\n\t      onClick: formlyBootstrapApiCheck.func.optional\n\t    }).strict.optional;\n\t    var api = formlyBootstrapApiCheck.shape({\n\t      templateOptions: formlyBootstrapApiCheck.shape({\n\t        addonLeft: addonChecker,\n\t        addonRight: addonChecker\n\t      })\n\t    });\n\t    formlyConfig.templateManipulators.preWrapper.push(function (template, options) {\n\t      if (!options.templateOptions.addonLeft && !options.templateOptions.addonRight) {\n\t        return template;\n\t      }\n\t      formlyBootstrapApiCheck.warn([api], [options]);\n\t      return addonTemplate.replace('<formly-transclude></formly-transclude>', template);\n\t    });\n\t  }\n\t  addAddonsManipulator.$inject = [\"formlyConfig\", \"formlyBootstrapApiCheck\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div ng-class=\\\"{'input-group': to.addonLeft || to.addonRight}\\\">\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonLeft\\\"\\n         ng-style=\\\"{cursor: to.addonLeft.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonLeft.onClick(options, this, $event)\\\">\\n        <i class=\\\"{{to.addonLeft.class}}\\\" ng-if=\\\"to.addonLeft.class\\\"></i>\\n        <span ng-if=\\\"to.addonLeft.text\\\">{{to.addonLeft.text}}</span>\\n    </div>\\n    <formly-transclude></formly-transclude>\\n    <div class=\\\"input-group-addon\\\"\\n         ng-if=\\\"to.addonRight\\\"\\n         ng-style=\\\"{cursor: to.addonRight.onClick ? 'pointer' : 'inherit'}\\\"\\n         ng-click=\\\"to.addonRight.onClick(options, this, $event)\\\">\\n        <i class=\\\"{{to.addonRight.class}}\\\" ng-if=\\\"to.addonRight.class\\\"></i>\\n        <span ng-if=\\\"to.addonRight.text\\\">{{to.addonRight.text}}</span>\\n    </div>\\n</div>\\n\"\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\n\texports['default'] = function (ngModule) {\n\t  ngModule.run(addDescriptionManipulator);\n\n\t  function addDescriptionManipulator(formlyConfig) {\n\t    formlyConfig.templateManipulators.preWrapper.push(function ariaDescribedBy(template, options, scope) {\n\t      if (angular.isDefined(options.templateOptions.description)) {\n\t        var el = document.createElement('div');\n\t        el.appendChild(angular.element(template)[0]);\n\t        el.appendChild(angular.element('<p id=\"' + scope.id + '_description\"' + 'class=\"help-block\"' + 'ng-if=\"to.description\">' + '{{to.description}}' + '</p>')[0]);\n\t        var modelEls = angular.element(el.querySelectorAll('[ng-model]'));\n\t        if (modelEls) {\n\t          modelEls.attr('aria-describedby', scope.id + '_description');\n\t        }\n\t        return el.innerHTML;\n\t      } else {\n\t        return template;\n\t      }\n\t    });\n\t  }\n\t  addDescriptionManipulator.$inject = [\"formlyConfig\"];\n\t};\n\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-formly-templates-bootstrap/dist/angular-formly-templates-bootstrap.js\n ** module id = 7\n ** module chunks = 1\n **/","/**\n * angular-permission\n * Route permission and access control as simple as it can get\n * @version v2.0.2 - 2016-02-03\n * @link http://www.rafaelvidaurre.com\n * @author Rafael Vidaurre <narzerus@gmail.com>\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n(function () {\n  'use strict';\n\n  var permission = angular.module('permission', ['ui.router']);\n\n  /**\n   * This decorator is required to access full state object instead of it's configuration\n   * when trying to obtain full toState state object not it's configuration\n   * Can be removed when implemented https://github.com/angular-ui/ui-router/issues/13.\n   */\n  permission.config(['$stateProvider', function ($stateProvider) {\n    $stateProvider.decorator('parent', function (state, parentFn) {\n      state.self.getState = function () {\n        return state;\n      };\n      return parentFn(state);\n    });\n  }]);\n\n  permission.run(['$rootScope', '$state', '$q', 'Authorization', 'PermissionMap', function ($rootScope, $state, $q, Authorization, PermissionMap) {\n    $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams, options) {\n\n      if (toState.$$isAuthorizationFinished) {\n        return;\n      }\n\n      if (areSetStatePermissions(toState)) {\n        event.preventDefault();\n        setStateAuthorizationStatus(true);\n\n\n        if (!areStateEventsDefaultPrevented()) {\n          var compensatedPermissionMap = compensatePermissionMap(toState.data.permissions);\n          authorizeForState(compensatedPermissionMap);\n        }\n      }\n\n      /**\n       * Checks if state is qualified to be permission based verified\n       *\n       * @returns {boolean}\n       */\n      function areSetStatePermissions(state) {\n        return angular.isDefined(state.data) && angular.isDefined(state.data.permissions);\n      }\n\n      /**\n       * Sets internal state `$$finishedAuthorization` variable to prevent looping\n       *\n       * @param status {boolean} When true authorization has been already preceded\n       */\n      function setStateAuthorizationStatus(status) {\n        angular.extend(toState, {'$$isAuthorizationFinished': status});\n      }\n\n      /**\n       * Checks if state events are not prevented by default\n       *\n       * @returns {boolean}\n       */\n      function areStateEventsDefaultPrevented() {\n        return isStateChangePermissionStartDefaultPrevented() || isStateChangeStartDefaultPrevented();\n      }\n\n      /**\n       * Builds map of permissions resolving passed values to data.permissions and combine them with all its parents\n       * keeping the order of permissions from the newest (children) to the oldest (parent)\n       *\n       * @param statePermissionMap {Object} Current state permission map\n       * @returns {{only: Array, except: Array}} Permission map\n       */\n      function compensatePermissionMap(statePermissionMap) {\n        var permissionMap = new PermissionMap({redirectTo: statePermissionMap.redirectTo});\n\n        var toStatePath = $state\n          .get(toState.name)\n          .getState().path\n          .slice()\n          .reverse();\n\n        angular.forEach(toStatePath, function (state) {\n          if (areSetStatePermissions(state)) {\n            permissionMap.extendPermissionMap(new PermissionMap(state.data.permissions));\n          }\n        });\n\n        return permissionMap;\n      }\n\n      /**\n       * Handles state authorization\n       *\n       * @param permissions {Object} Map of \"only\" or \"except\" permission names\n       */\n      function authorizeForState(permissions) {\n        Authorization\n          .authorize(permissions, toParams)\n          .then(function () {\n            $rootScope.$broadcast('$stateChangePermissionAccepted', toState, toParams, options);\n            goToState(toState.name);\n          })\n          .catch(function (rejectedPermission) {\n            $rootScope.$broadcast('$stateChangePermissionDenied', toState, toParams, options);\n            permissions.redirectToState(rejectedPermission);\n          });\n      }\n\n      /**\n       * Redirects to states when permissions are met\n       *\n       * If authorized, use call state.go without triggering the event.\n       * Then trigger $stateChangeSuccess manually to resume the rest of the process\n       * Note: This is a pseudo-hacky fix which should be fixed in future ui-router versions\n       */\n      function goToState(name) {\n        $state\n          .go(name, toParams, angular.extend({}, options, {notify: false}))\n          .then(function () {\n            $rootScope.$broadcast('$stateChangeSuccess', toState, toParams, fromState, fromParams, options);\n          });\n      }\n\n      /**\n       * Checks if event $stateChangeStart hasn't been disabled by default\n       *\n       * @returns {boolean}\n       */\n      function isStateChangeStartDefaultPrevented() {\n        return $rootScope.$broadcast('$stateChangeStart', toState, toParams, fromState, fromParams, options).defaultPrevented;\n      }\n\n      /**\n       * Checks if event $stateChangePermissionStart hasn't been disabled by default\n       *\n       * @returns {boolean}\n       */\n      function isStateChangePermissionStartDefaultPrevented() {\n        return $rootScope.$broadcast('$stateChangePermissionStart', toState, toParams, options).defaultPrevented;\n      }\n    });\n  }]);\n}());\n\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .factory('PermissionMap', ['$q', '$state', function ($q, $state) {\n\n      /**\n       * Constructs map object instructing authorization service how to handle authorizing\n       *\n       * @param permissionMap {Object} Map of permissions provided to authorization service\n       * @param permissionMap.only {Array} List of exclusive permission/role names allowed for authorization\n       * @param permissionMap.except {Array} List of exclusive permission/role names denied for authorization\n       * @param permissionMap.redirectTo {String|Function|Object|promise} Handling redirection when rejected\n       *   authorization\n       * @param [toState] {Object} UI-Router transition state object\n       * @param [toParams] {Object} UI-Router transition state params\n       * @param [options] {Object} UI-Router transition state options\n       * @constructor\n       */\n      function PermissionMap(permissionMap, toState, toParams, options) {\n        this.only = resolvePermissionMapProperty(permissionMap.only, toState, toParams, options);\n        this.except = resolvePermissionMapProperty(permissionMap.except, toState, toParams, options);\n        this.redirectTo = permissionMap.redirectTo;\n      }\n\n      /**\n       * Extends permission map by pushing to it state's permissions\n       *\n       * @param permissionMap {PermissionMap} Compensated permission map\n       */\n      PermissionMap.prototype.extendPermissionMap = function (permissionMap) {\n        this.only = this.only.concat(permissionMap.only);\n        this.except = this.except.concat(permissionMap.except);\n      };\n\n\n      /**\n       * Redirects to fallback states when permissions fail\n       *\n       * @param rejectedPermissionName {String} Permission name\n       */\n      PermissionMap.prototype.redirectToState = function (rejectedPermissionName) {\n        if (angular.isFunction(this.redirectTo)) {\n          handleFunctionRedirect(this.redirectTo, rejectedPermissionName);\n        }\n\n        if (angular.isObject(this.redirectTo)) {\n          handleObjectRedirect(this.redirectTo, rejectedPermissionName);\n        }\n\n        if (angular.isString(this.redirectTo)) {\n          handleStringRedirect(this.redirectTo, this.toParams, this.options);\n        }\n      };\n\n      /**\n       * Handles function based redirection for rejected permissions\n       *\n       * @param redirectFunction {Function} Redirection function\n       * @param permission {String} Rejected permission\n       */\n      function handleFunctionRedirect(redirectFunction, permission) {\n        $q.when(redirectFunction.call(null, permission))\n          .then(function (redirectState) {\n            if (!angular.isString(redirectState)) {\n              throw new TypeError('When used \"redirectTo\" as function, returned value must be string with state name');\n            }\n            handleStringRedirect(redirectState);\n          });\n      }\n\n      /**\n       * Handles object based redirection for rejected permissions\n       *\n       * @param redirectObject {Object} Redirection function\n       * @param permission {String} Rejected permission\n       */\n      function handleObjectRedirect(redirectObject, permission) {\n        if (!angular.isDefined(redirectObject['default'])) {\n          throw new ReferenceError('When used \"redirectTo\" as object, property \"default\" must be defined');\n        }\n\n        var redirectState = redirectObject[permission];\n\n        if (!angular.isDefined(redirectState)) {\n          redirectState = redirectObject['default'];\n        }\n\n        if (angular.isFunction(redirectState)) {\n          handleFunctionRedirect(redirectState, permission);\n        }\n\n        if (angular.isString(redirectState)) {\n          handleStringRedirect(redirectState);\n        }\n      }\n\n      /**\n       * Handles string based redirection for rejected permissions\n       */\n      function handleStringRedirect(state, toParams, options) {\n        $state.go(state, toParams, options);\n      }\n\n      /**\n       * Handles extraction of permission map \"only\" and \"except\" properties\n       * @private\n       *\n       * @param property {Array|Function|promise} Permission map property \"only\" or \"except\"\n       * @param [toState] {Object} UI-Router transition state object\n       * @param [toParams] {Object} UI-Router transition state params\n       * @param [options] {Object} UI-Router transition state options\n       * @returns {Array} Array of permission \"only\" or \"except\" names\n       */\n      function resolvePermissionMapProperty(property, toState, toParams, options) {\n        if (angular.isString(property)) {\n          return [property];\n        }\n\n        if (angular.isArray(property)) {\n          return property;\n        }\n\n        if (angular.isFunction(property)) {\n          return property.call(null, toState, toParams, options);\n        }\n\n        return [];\n      }\n\n      return PermissionMap;\n    }]);\n}());\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .factory('Permission', ['$q', function ($q) {\n\n      /**\n       * Permission definition object constructor\n       *\n       * @param permissionName {String} Name repressing permission\n       * @param validationFunction {Function} Function used to check if permission is valid\n       * @constructor\n       */\n      function Permission(permissionName, validationFunction) {\n        validateConstructor(permissionName, validationFunction);\n\n        this.permissionName = permissionName;\n        this.validationFunction = validationFunction;\n      }\n\n      /**\n       * Checks if permission is still valid\n       *\n       * @param toParams {Object} UI-Router params object\n       * @returns {Promise}\n       */\n      Permission.prototype.validatePermission = function (toParams) {\n        var validationResult = this.validationFunction.call(null, toParams, this.permissionName);\n\n        if (!angular.isFunction(validationResult.then)) {\n          validationResult = wrapInPromise(validationResult, this.permissionName);\n        }\n\n        return validationResult;\n      };\n\n      /**\n       * Converts a value into a promise, if the value is truthy it resolves it, otherwise it rejects it\n       * @private\n       *\n       * @param result {Boolean} Function to be wrapped into promise\n       * @param permissionName {String} Returned value in promise\n       * @return {Promise}\n       */\n      function wrapInPromise(result, permissionName) {\n        var dfd = $q.defer();\n\n        if (result) {\n          dfd.resolve(permissionName);\n        } else {\n          dfd.reject(permissionName);\n        }\n\n        return dfd.promise;\n      }\n\n      /**\n       * Checks if provided permission has accepted parameter types\n       * @private\n       */\n      function validateConstructor(permissionName, validationFunction) {\n        if (!angular.isString(permissionName)) {\n          throw new TypeError('Parameter \"permissionName\" name must be String');\n        }\n        if (!angular.isFunction(validationFunction)) {\n          throw new TypeError('Parameter \"validationFunction\" must be Function');\n        }\n      }\n\n      return Permission;\n    }]);\n}());\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .factory('Role', ['$q', 'PermissionStore', function ($q, PermissionStore) {\n\n      /**\n       * Role definition constructor\n       *\n       * @param roleName {String} Name representing role\n       * @param permissionNames {Array} List of permission names representing role\n       * @param [validationFunction] {Function} Optional function used to validate if permissions are still valid\n       * @constructor\n       */\n      function Role(roleName, permissionNames, validationFunction) {\n        validateConstructor(roleName, permissionNames, validationFunction);\n        this.roleName = roleName;\n        this.permissionNames = permissionNames || [];\n\n        if (validationFunction) {\n          PermissionStore.defineManyPermissions(permissionNames, validationFunction);\n        }\n      }\n\n      /**\n       * Checks if role is still valid\n       *\n       * @param toParams {Object} UI-Router params object\n       * @returns {Promise} $q.promise object\n       */\n      Role.prototype.validateRole = function (toParams) {\n\n        // When set permissions is provided check each of them\n        if (this.permissionNames.length) {\n          var promises = this.permissionNames.map(function (permissionName) {\n            if (PermissionStore.hasPermissionDefinition(permissionName)) {\n              var permission = PermissionStore.getPermissionDefinition(permissionName);\n              var validationResult = permission.validationFunction.call(null, toParams, permission.permissionName);\n\n              if (!angular.isFunction(validationResult.then)) {\n                validationResult = wrapInPromise(validationResult);\n              }\n\n              return validationResult;\n            }\n\n            return $q.reject(null);\n          });\n\n          return $q.all(promises);\n        }\n\n        // If not call validation function manually\n        var validationResult = this.validationFunction.call(null, toParams, this.roleName);\n        if (!angular.isFunction(validationResult.then)) {\n          validationResult = wrapInPromise(validationResult, this.roleName);\n        }\n\n        return $q.resolve(validationResult);\n\n      };\n\n      /**\n       * Converts a value into a promise, if the value is truthy it resolves it, otherwise it rejects it\n       * @private\n       *\n       * @param result {Boolean} Function to be wrapped into promise\n       * @param roleName {String} Returned value in promise\n       * @return {Promise}\n       */\n      function wrapInPromise(result, roleName) {\n        var dfd = $q.defer();\n\n        if (result) {\n          dfd.resolve(roleName);\n        } else {\n          dfd.reject(roleName);\n        }\n\n        return dfd.promise;\n      }\n\n      /**\n       * Checks if provided permission has accepted parameter types\n       * @private\n       */\n      function validateConstructor(roleName, permissionNames, validationFunction) {\n        if (!angular.isString(roleName)) {\n          throw new TypeError('Parameter \"roleName\" name must be String');\n        }\n\n        if (!angular.isArray(permissionNames)) {\n          throw new TypeError('Parameter \"permissionNames\" must be Array');\n        }\n\n        if (!permissionNames.length && !angular.isFunction(validationFunction)) {\n          throw new TypeError('Parameter \"validationFunction\" must be provided for empty \"permissionNames\" array');\n        }\n      }\n\n      return Role;\n    }]);\n}());\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .service('PermissionStore', ['Permission', function (Permission) {\n      var permissionStore = {};\n\n      this.definePermission = definePermission;\n      this.defineManyPermissions = defineManyPermissions;\n      this.removePermissionDefinition = removePermissionDefinition;\n      this.hasPermissionDefinition = hasPermissionDefinition;\n      this.getPermissionDefinition = getPermissionDefinition;\n      this.getStore = getStore;\n      this.clearStore = clearStore;\n\n      /**\n       * Allows to define permission on application configuration\n       *\n       * @param permissionName {String} Name of defined permission\n       * @param validationFunction {Function} Function used to validate if permission is valid\n       */\n      function definePermission(permissionName, validationFunction) {\n        permissionStore[permissionName] = new Permission(permissionName, validationFunction);\n      }\n\n      /**\n       * Allows to define set of permissionNames with shared validation function on application configuration\n       *\n       * @param permissionNames {Array} Set of permission names\n       * @param validationFunction {Function} Function used to validate if permission is valid\n       */\n      function defineManyPermissions(permissionNames, validationFunction) {\n        if (!angular.isArray(permissionNames)) {\n          throw new TypeError('Parameter \"permissionNames\" name must be Array');\n        }\n\n        angular.forEach(permissionNames, function (permissionName) {\n          definePermission(permissionName, validationFunction);\n        });\n      }\n\n      /**\n       * Deletes permission\n       *\n       * @param permissionName {String} Name of defined permission\n       */\n      function removePermissionDefinition(permissionName) {\n        delete permissionStore[permissionName];\n      }\n\n      /**\n       * Checks if permission exists\n       *\n       * @param permissionName {String} Name of defined permission\n       * @returns {Boolean}\n       */\n      function hasPermissionDefinition(permissionName) {\n        return angular.isDefined(permissionStore[permissionName]);\n      }\n\n      /**\n       * Returns permission by it's name\n       *\n       * @returns {Object} Permissions collection\n       */\n      function getPermissionDefinition(permissionName) {\n        return permissionStore[permissionName];\n      }\n\n      /**\n       * Returns all permissions\n       *\n       * @returns {Object} Permissions collection\n       */\n      function getStore() {\n        return permissionStore;\n      }\n\n      /**\n       * Removes all permissions\n       */\n      function clearStore() {\n        permissionStore = {};\n      }\n    }]);\n}());\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .service('RoleStore', ['Role', function (Role) {\n      var roleStore = {};\n\n      this.defineRole = defineRole;\n      this.getRoleDefinition = getRoleDefinition;\n      this.hasRoleDefinition = hasRoleDefinition;\n      this.removeRoleDefinition = removeRoleDefinition;\n      this.getStore = getStore;\n      this.clearStore = clearStore;\n\n      /**\n       * Allows to define role\n       *\n       * @param roleName {String} Name of defined role\n       * @param permissions {Array} Set of permission names\n       * @param [validationFunction] {Function} Function used to validate if permissions in role are valid\n       */\n      function defineRole(roleName, permissions, validationFunction) {\n        roleStore[roleName] = new Role(roleName, permissions, validationFunction);\n      }\n\n      /**\n       * Deletes role from store\n       *\n       * @param roleName {String} Name of defined permission\n       */\n      function removeRoleDefinition(roleName) {\n        delete roleStore[roleName];\n      }\n\n      /**\n       * Checks if role is defined in store\n       *\n       * @param roleName {String} Name of role\n       * @returns {Boolean}\n       */\n      function hasRoleDefinition(roleName) {\n        return angular.isDefined(roleStore[roleName]);\n      }\n\n      /**\n       * Returns role definition object by it's name\n       *\n       * @returns {Object} Role definition object\n       */\n      function getRoleDefinition(roleName) {\n        return roleStore[roleName];\n      }\n\n      /**\n       * Returns all role definitions\n       *\n       * @returns {Object} Defined roles collection\n       */\n      function getStore() {\n        return roleStore;\n      }\n\n      /**\n       * Removes all role definitions\n       */\n      function clearStore() {\n        roleStore = {};\n      }\n    }]);\n}());\n(function () {\n  'use strict';\n\n  /**\n   * Show/hide elements based on provided permissions\n   *\n   * @example\n   * <div permission only=\"'USER'\"></div>\n   * <div permission only=\"['USER','ADMIN']\" except=\"'MANAGER'\"></div>\n   * <div permission except=\"'MANAGER'\"></div>\n   */\n  angular\n    .module('permission')\n    .directive('permission', ['$log', 'Authorization', 'PermissionMap', function ($log, Authorization, PermissionMap) {\n      return {\n        restrict: 'A',\n        link: function (scope, element, attrs) {\n          try {\n            Authorization\n              .authorize(new PermissionMap({\n                only: scope.$eval(attrs.only),\n                except: scope.$eval(attrs.except)\n              }), null)\n              .then(function () {\n                element.removeClass('ng-hide');\n              })\n              .catch(function () {\n                element.addClass('ng-hide');\n              });\n          } catch (e) {\n            element.addClass('ng-hide');\n            $log.error(e.message);\n          }\n        }\n      };\n    }]);\n}());\n\n(function () {\n  'use strict';\n\n  angular\n    .module('permission')\n    .service('Authorization', ['$q', 'PermissionMap', 'PermissionStore', 'RoleStore', function ($q, PermissionMap, PermissionStore, RoleStore) {\n      this.authorize = authorize;\n\n      /**\n       * Checks if provided permissions are acceptable\n       *\n       * @param permissionsMap {PermissionMap} Map of permission names\n       * @param [toParams] {Object} UI-Router params object\n       * @returns {promise} $q.promise object\n       */\n      function authorize(permissionsMap, toParams) {\n        return handleAuthorization(permissionsMap, toParams);\n      }\n\n      /**\n       * Handles authorization based on provided permissions map\n       * @private\n       *\n       * @param permissionsMap {Object} Map of permission names\n       * @param toParams {Object} UI-Router params object\n       * @returns {promise} $q.promise object\n       */\n      function handleAuthorization(permissionsMap, toParams) {\n        var deferred = $q.defer();\n\n        var exceptPromises = findMatchingPermissions(permissionsMap.except, toParams);\n\n        $q.all(exceptPromises)\n          .then(function (rejectedPermissions) {\n            // If any \"except\" permissions are found reject authorization\n            if (rejectedPermissions.length) {\n              deferred.reject(rejectedPermissions);\n            } else {\n              // If none go to checking \"only\" permissions\n              return $q.reject(null);\n            }\n          })\n          .catch(function () {\n            var onlyPromises = findMatchingPermissions(permissionsMap.only, toParams);\n            $q.all(onlyPromises)\n              .then(function (resolvedPermissions) {\n                deferred.resolve(resolvedPermissions);\n              })\n              .catch(function (rejectedPermission) {\n                deferred.reject(rejectedPermission);\n              });\n          });\n\n        return deferred.promise;\n      }\n\n      /**\n       * Performs iteration over list of defined permissions looking for matching roles\n       * @private\n       *\n       * @param permissionNames {Array} Set of permission names\n       * @param toParams {Object} UI-Router params object\n       * @returns {Array} Promise collection\n       */\n      function findMatchingPermissions(permissionNames, toParams) {\n        return permissionNames.map(function (permissionName) {\n          if (RoleStore.hasRoleDefinition(permissionName)) {\n            return handleRoleValidation(permissionName, toParams);\n          }\n\n          if (PermissionStore.hasPermissionDefinition(permissionName)) {\n            return handlePermissionValidation(permissionName, toParams);\n          }\n\n          if (permissionName) {\n            return $q.reject(permissionName);\n          }\n        });\n      }\n\n      /**\n       * Executes role validation checking\n       * @private\n       *\n       * @param roleName {String} Store permission key\n       * @param toParams {Object} UI-Router params object\n       * @returns {Promise}\n       */\n      function handleRoleValidation(roleName, toParams) {\n        var role = RoleStore.getRoleDefinition(roleName);\n        return role.validateRole(toParams);\n      }\n\n      /**\n       * Executes permission validation checking\n       * @private\n       *\n       * @param permissionName {String} Store permission key\n       * @param toParams {Object} UI-Router params object\n       * @returns {Promise}\n       */\n      function handlePermissionValidation(permissionName, toParams) {\n        var permission = PermissionStore.getPermissionDefinition(permissionName);\n        return permission.validatePermission(toParams);\n      }\n    }]);\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-permission/dist/angular-permission.js\n ** module id = 8\n ** module chunks = 1\n **/","require('./dist/ui-bootstrap-tpls');\n\nmodule.exports = 'ui.bootstrap';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/index.js\n ** module id = 9\n ** module chunks = 1\n **/","/**\r\n * A helper module for AngularUI Router, which allows you to define your states as an object tree.\r\n * @author Mark Lagendijk <mark@lagendijk.info>\r\n * @license MIT\r\n */\r\nangular.module('ui.router.stateHelper', [ 'ui.router' ])\r\n    .provider('stateHelper', ['$stateProvider', function($stateProvider){\r\n        var self = this;\r\n\r\n        /**\r\n         * Recursively sets the states using $stateProvider.state.\r\n         * Child states are defined via a `children` property.\r\n         *\r\n         * 1. Recursively calls itself for all descendant states, by traversing the `children` properties.\r\n         * 2. Converts all the state names to dot notation, of the form `grandfather.father.state`.\r\n         * 3. Sets `parent` property of the descendant states.\r\n         *\r\n         * @param {Object} state - A regular ui.router state object.\r\n         * @param {Array} [state.children] - An optional array of child states.\r\n         * @deprecated {Boolean} keepOriginalNames - An optional flag that prevents conversion \r\n         *     of names to dot notation if true. (use options.keepOriginalNames instead)\r\n         * @param {Object} [options] - An optional options object.\r\n         * @param {Boolean} [options.keepOriginalNames=false] An optional flag that \r\n         *     prevents conversion of names to dot notation if true.\r\n         * @param {Boolean} [options.siblingTraversal=false] An optional flag that \r\n         *     adds `nextSibling` and `previousSibling` properties when enabled\r\n         */\r\n        this.state = function(state){\r\n            var args = Array.prototype.slice.apply(arguments);\r\n            var options = {\r\n                keepOriginalNames: false,\r\n                siblingTraversal: false\r\n            };  \r\n\r\n            if (typeof args[1] === 'boolean') {\r\n                options.keepOriginalNames = args[1];\r\n            } \r\n            else if (typeof args[1] === 'object') {\r\n                angular.extend(options, args[1]);\r\n            }\r\n\r\n            if (!options.keepOriginalNames) {\r\n                fixStateName(state);\r\n            }\r\n\r\n            $stateProvider.state(state);\r\n\r\n            if(state.children && state.children.length){\r\n                state.children.forEach(function(childState){\r\n                    childState.parent = state;\r\n                    self.state(childState, options);\r\n                });\r\n\r\n                if (options.siblingTraversal) {\r\n                    addSiblings(state);\r\n                }\r\n            }\r\n\r\n            return self;\r\n        };\r\n\r\n        this.setNestedState = this.state;\r\n\r\n        self.$get = angular.noop;\r\n\r\n        /**\r\n         * Converts the name of a state to dot notation, of the form `grandfather.father.state`.\r\n         * @param state\r\n         */\r\n        function fixStateName(state){\r\n            if(state.parent){\r\n                state.name = (angular.isObject(state.parent) ? state.parent.name : state.parent) + '.' + state.name;\r\n            }\r\n        }\r\n\r\n        function addSiblings(state) {\r\n            state.children.forEach(function (childState, idx, array) {\r\n                if (array[idx + 1]) {\r\n                    childState.nextSibling = array[idx + 1].name;\r\n                }\r\n                if (array[idx - 1]) {\r\n                    childState.previousSibling = array[idx - 1].name;\r\n                }\r\n            });\r\n        }\r\n    }]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router.statehelper/statehelper.js\n ** module id = 10\n ** module chunks = 1\n **/","/**\n * State-based routing for AngularJS\n * @version v0.2.18\n * @link http://angular-ui.github.com/\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'ui.router';\n}\n\n(function (window, angular, undefined) {\n/*jshint globalstrict:true*/\n/*global angular:false*/\n'use strict';\n\nvar isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    isObject = angular.isObject,\n    isArray = angular.isArray,\n    forEach = angular.forEach,\n    extend = angular.extend,\n    copy = angular.copy,\n    toJson = angular.toJson;\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, { prototype: parent }))(), extra);\n}\n\nfunction merge(dst) {\n  forEach(arguments, function(obj) {\n    if (obj !== dst) {\n      forEach(obj, function(value, key) {\n        if (!dst.hasOwnProperty(key)) dst[key] = value;\n      });\n    }\n  });\n  return dst;\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  var path = [];\n\n  for (var n in first.path) {\n    if (first.path[n] !== second.path[n]) break;\n    path.push(first.path[n]);\n  }\n  return path;\n}\n\n/**\n * IE8-safe wrapper for `Object.keys()`.\n *\n * @param {Object} object A JavaScript object.\n * @return {Array} Returns the keys of the object as an array.\n */\nfunction objectKeys(object) {\n  if (Object.keys) {\n    return Object.keys(object);\n  }\n  var result = [];\n\n  forEach(object, function(val, key) {\n    result.push(key);\n  });\n  return result;\n}\n\n/**\n * IE8-safe wrapper for `Array.prototype.indexOf()`.\n *\n * @param {Array} array A JavaScript array.\n * @param {*} value A value to search the array for.\n * @return {Number} Returns the array index value of `value`, or `-1` if not present.\n */\nfunction indexOf(array, value) {\n  if (Array.prototype.indexOf) {\n    return array.indexOf(value, Number(arguments[2]) || 0);\n  }\n  var len = array.length >>> 0, from = Number(arguments[2]) || 0;\n  from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n\n  if (from < 0) from += len;\n\n  for (; from < len; from++) {\n    if (from in array && array[from] === value) return from;\n  }\n  return -1;\n}\n\n/**\n * Merges a set of parameters with all parameters inherited between the common parents of the\n * current state and a given destination state.\n *\n * @param {Object} currentParams The value of the current state parameters ($stateParams).\n * @param {Object} newParams The set of parameters which will be composited with inherited params.\n * @param {Object} $current Internal definition of object representing the current state.\n * @param {Object} $to Internal definition of object representing state to transition to.\n */\nfunction inheritParams(currentParams, newParams, $current, $to) {\n  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];\n\n  for (var i in parents) {\n    if (!parents[i] || !parents[i].params) continue;\n    parentParams = objectKeys(parents[i].params);\n    if (!parentParams.length) continue;\n\n    for (var j in parentParams) {\n      if (indexOf(inheritList, parentParams[j]) >= 0) continue;\n      inheritList.push(parentParams[j]);\n      inherited[parentParams[j]] = currentParams[parentParams[j]];\n    }\n  }\n  return extend({}, inherited, newParams);\n}\n\n/**\n * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.\n *\n * @param {Object} a The first object.\n * @param {Object} b The second object.\n * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,\n *                     it defaults to the list of keys in `a`.\n * @return {Boolean} Returns `true` if the keys match, otherwise `false`.\n */\nfunction equalForKeys(a, b, keys) {\n  if (!keys) {\n    keys = [];\n    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility\n  }\n\n  for (var i=0; i<keys.length; i++) {\n    var k = keys[i];\n    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized\n  }\n  return true;\n}\n\n/**\n * Returns the subset of an object, based on a list of keys.\n *\n * @param {Array} keys\n * @param {Object} values\n * @return {Boolean} Returns a subset of `values`.\n */\nfunction filterByKeys(keys, values) {\n  var filtered = {};\n\n  forEach(keys, function (name) {\n    filtered[name] = values[name];\n  });\n  return filtered;\n}\n\n// like _.indexBy\n// when you know that your index values will be unique, or you want last-one-in to win\nfunction indexBy(array, propName) {\n  var result = {};\n  forEach(array, function(item) {\n    result[item[propName]] = item;\n  });\n  return result;\n}\n\n// extracted from underscore.js\n// Return a copy of the object only containing the whitelisted properties.\nfunction pick(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  forEach(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n}\n\n// extracted from underscore.js\n// Return a copy of the object omitting the blacklisted properties.\nfunction omit(obj) {\n  var copy = {};\n  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));\n  for (var key in obj) {\n    if (indexOf(keys, key) == -1) copy[key] = obj[key];\n  }\n  return copy;\n}\n\nfunction pluck(collection, key) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = isFunction(key) ? key(val) : val[key];\n  });\n  return result;\n}\n\nfunction filter(collection, callback) {\n  var array = isArray(collection);\n  var result = array ? [] : {};\n  forEach(collection, function(val, i) {\n    if (callback(val, i)) {\n      result[array ? result.length : i] = val;\n    }\n  });\n  return result;\n}\n\nfunction map(collection, callback) {\n  var result = isArray(collection) ? [] : {};\n\n  forEach(collection, function(val, i) {\n    result[i] = callback(val, i);\n  });\n  return result;\n}\n\n/**\n * @ngdoc overview\n * @name ui.router.util\n *\n * @description\n * # ui.router.util sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n *\n */\nangular.module('ui.router.util', ['ng']);\n\n/**\n * @ngdoc overview\n * @name ui.router.router\n * \n * @requires ui.router.util\n *\n * @description\n * # ui.router.router sub-module\n *\n * This module is a dependency of other sub-modules. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n */\nangular.module('ui.router.router', ['ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router.state\n * \n * @requires ui.router.router\n * @requires ui.router.util\n *\n * @description\n * # ui.router.state sub-module\n *\n * This module is a dependency of the main ui.router module. Do not include this module as a dependency\n * in your angular app (use {@link ui.router} module instead).\n * \n */\nangular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);\n\n/**\n * @ngdoc overview\n * @name ui.router\n *\n * @requires ui.router.state\n *\n * @description\n * # ui.router\n * \n * ## The main module for ui.router \n * There are several sub-modules included with the ui.router module, however only this module is needed\n * as a dependency within your angular app. The other modules are for organization purposes. \n *\n * The modules are:\n * * ui.router - the main \"umbrella\" module\n * * ui.router.router - \n * \n * *You'll need to include **only** this module as the dependency within your angular app.*\n * \n * <pre>\n * <!doctype html>\n * <html ng-app=\"myApp\">\n * <head>\n *   <script src=\"js/angular.js\"></script>\n *   <!-- Include the ui-router script -->\n *   <script src=\"js/angular-ui-router.min.js\"></script>\n *   <script>\n *     // ...and add 'ui.router' as a dependency\n *     var myApp = angular.module('myApp', ['ui.router']);\n *   </script>\n * </head>\n * <body>\n * </body>\n * </html>\n * </pre>\n */\nangular.module('ui.router', ['ui.router.state']);\n\nangular.module('ui.router.compat', ['ui.router']);\n\n/**\n * @ngdoc object\n * @name ui.router.util.$resolve\n *\n * @requires $q\n * @requires $injector\n *\n * @description\n * Manages resolution of (acyclic) graphs of promises.\n */\n$Resolve.$inject = ['$q', '$injector'];\nfunction $Resolve(  $q,    $injector) {\n  \n  var VISIT_IN_PROGRESS = 1,\n      VISIT_DONE = 2,\n      NOTHING = {},\n      NO_DEPENDENCIES = [],\n      NO_LOCALS = NOTHING,\n      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });\n  \n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#study\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Studies a set of invocables that are likely to be used multiple times.\n   * <pre>\n   * $resolve.study(invocables)(locals, parent, self)\n   * </pre>\n   * is equivalent to\n   * <pre>\n   * $resolve.resolve(invocables, locals, parent, self)\n   * </pre>\n   * but the former is more efficient (in fact `resolve` just calls `study` \n   * internally).\n   *\n   * @param {object} invocables Invocable objects\n   * @return {function} a function to pass in locals, parent and self\n   */\n  this.study = function (invocables) {\n    if (!isObject(invocables)) throw new Error(\"'invocables' must be an object\");\n    var invocableKeys = objectKeys(invocables || {});\n    \n    // Perform a topological sort of invocables to build an ordered plan\n    var plan = [], cycle = [], visited = {};\n    function visit(value, key) {\n      if (visited[key] === VISIT_DONE) return;\n      \n      cycle.push(key);\n      if (visited[key] === VISIT_IN_PROGRESS) {\n        cycle.splice(0, indexOf(cycle, key));\n        throw new Error(\"Cyclic dependency: \" + cycle.join(\" -> \"));\n      }\n      visited[key] = VISIT_IN_PROGRESS;\n      \n      if (isString(value)) {\n        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);\n      } else {\n        var params = $injector.annotate(value);\n        forEach(params, function (param) {\n          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);\n        });\n        plan.push(key, value, params);\n      }\n      \n      cycle.pop();\n      visited[key] = VISIT_DONE;\n    }\n    forEach(invocables, visit);\n    invocables = cycle = visited = null; // plan is all that's required\n    \n    function isResolve(value) {\n      return isObject(value) && value.then && value.$$promises;\n    }\n    \n    return function (locals, parent, self) {\n      if (isResolve(locals) && self === undefined) {\n        self = parent; parent = locals; locals = null;\n      }\n      if (!locals) locals = NO_LOCALS;\n      else if (!isObject(locals)) {\n        throw new Error(\"'locals' must be an object\");\n      }       \n      if (!parent) parent = NO_PARENT;\n      else if (!isResolve(parent)) {\n        throw new Error(\"'parent' must be a promise returned by $resolve.resolve()\");\n      }\n      \n      // To complete the overall resolution, we have to wait for the parent\n      // promise and for the promise for each invokable in our plan.\n      var resolution = $q.defer(),\n          result = resolution.promise,\n          promises = result.$$promises = {},\n          values = extend({}, locals),\n          wait = 1 + plan.length/3,\n          merged = false;\n          \n      function done() {\n        // Merge parent values we haven't got yet and publish our own $$values\n        if (!--wait) {\n          if (!merged) merge(values, parent.$$values); \n          result.$$values = values;\n          result.$$promises = result.$$promises || true; // keep for isResolve()\n          delete result.$$inheritedValues;\n          resolution.resolve(values);\n        }\n      }\n      \n      function fail(reason) {\n        result.$$failure = reason;\n        resolution.reject(reason);\n      }\n\n      // Short-circuit if parent has already failed\n      if (isDefined(parent.$$failure)) {\n        fail(parent.$$failure);\n        return result;\n      }\n      \n      if (parent.$$inheritedValues) {\n        merge(values, omit(parent.$$inheritedValues, invocableKeys));\n      }\n\n      // Merge parent values if the parent has already resolved, or merge\n      // parent promises and wait if the parent resolve is still in progress.\n      extend(promises, parent.$$promises);\n      if (parent.$$values) {\n        merged = merge(values, omit(parent.$$values, invocableKeys));\n        result.$$inheritedValues = omit(parent.$$values, invocableKeys);\n        done();\n      } else {\n        if (parent.$$inheritedValues) {\n          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);\n        }        \n        parent.then(done, fail);\n      }\n      \n      // Process each invocable in the plan, but ignore any where a local of the same name exists.\n      for (var i=0, ii=plan.length; i<ii; i+=3) {\n        if (locals.hasOwnProperty(plan[i])) done();\n        else invoke(plan[i], plan[i+1], plan[i+2]);\n      }\n      \n      function invoke(key, invocable, params) {\n        // Create a deferred for this invocation. Failures will propagate to the resolution as well.\n        var invocation = $q.defer(), waitParams = 0;\n        function onfailure(reason) {\n          invocation.reject(reason);\n          fail(reason);\n        }\n        // Wait for any parameter that we have a promise for (either from parent or from this\n        // resolve; in that case study() will have made sure it's ordered before us in the plan).\n        forEach(params, function (dep) {\n          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {\n            waitParams++;\n            promises[dep].then(function (result) {\n              values[dep] = result;\n              if (!(--waitParams)) proceed();\n            }, onfailure);\n          }\n        });\n        if (!waitParams) proceed();\n        function proceed() {\n          if (isDefined(result.$$failure)) return;\n          try {\n            invocation.resolve($injector.invoke(invocable, self, values));\n            invocation.promise.then(function (result) {\n              values[key] = result;\n              done();\n            }, onfailure);\n          } catch (e) {\n            onfailure(e);\n          }\n        }\n        // Publish promise synchronously; invocations further down in the plan may depend on it.\n        promises[key] = invocation.promise;\n      }\n      \n      return result;\n    };\n  };\n  \n  /**\n   * @ngdoc function\n   * @name ui.router.util.$resolve#resolve\n   * @methodOf ui.router.util.$resolve\n   *\n   * @description\n   * Resolves a set of invocables. An invocable is a function to be invoked via \n   * `$injector.invoke()`, and can have an arbitrary number of dependencies. \n   * An invocable can either return a value directly,\n   * or a `$q` promise. If a promise is returned it will be resolved and the \n   * resulting value will be used instead. Dependencies of invocables are resolved \n   * (in this order of precedence)\n   *\n   * - from the specified `locals`\n   * - from another invocable that is part of this `$resolve` call\n   * - from an invocable that is inherited from a `parent` call to `$resolve` \n   *   (or recursively\n   * - from any ancestor `$resolve` of that parent).\n   *\n   * The return value of `$resolve` is a promise for an object that contains \n   * (in this order of precedence)\n   *\n   * - any `locals` (if specified)\n   * - the resolved return values of all injectables\n   * - any values inherited from a `parent` call to `$resolve` (if specified)\n   *\n   * The promise will resolve after the `parent` promise (if any) and all promises \n   * returned by injectables have been resolved. If any invocable \n   * (or `$injector.invoke`) throws an exception, or if a promise returned by an \n   * invocable is rejected, the `$resolve` promise is immediately rejected with the \n   * same error. A rejection of a `parent` promise (if specified) will likewise be \n   * propagated immediately. Once the `$resolve` promise has been rejected, no \n   * further invocables will be called.\n   * \n   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`\n   * to throw an error. As a special case, an injectable can depend on a parameter \n   * with the same name as the injectable, which will be fulfilled from the `parent` \n   * injectable of the same name. This allows inherited values to be decorated. \n   * Note that in this case any other injectable in the same `$resolve` with the same\n   * dependency would see the decorated value, not the inherited value.\n   *\n   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an \n   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) \n   * exception.\n   *\n   * Invocables are invoked eagerly as soon as all dependencies are available. \n   * This is true even for dependencies inherited from a `parent` call to `$resolve`.\n   *\n   * As a special case, an invocable can be a string, in which case it is taken to \n   * be a service name to be passed to `$injector.get()`. This is supported primarily \n   * for backwards-compatibility with the `resolve` property of `$routeProvider` \n   * routes.\n   *\n   * @param {object} invocables functions to invoke or \n   * `$injector` services to fetch.\n   * @param {object} locals  values to make available to the injectables\n   * @param {object} parent  a promise returned by another call to `$resolve`.\n   * @param {object} self  the `this` for the invoked methods\n   * @return {object} Promise for an object that contains the resolved return value\n   * of all invocables, as well as any inherited and local values.\n   */\n  this.resolve = function (invocables, locals, parent, self) {\n    return this.study(invocables)(locals, parent, self);\n  };\n}\n\nangular.module('ui.router.util').service('$resolve', $Resolve);\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$templateFactory\n *\n * @requires $http\n * @requires $templateCache\n * @requires $injector\n *\n * @description\n * Service. Manages loading of templates.\n */\n$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];\nfunction $TemplateFactory(  $http,   $templateCache,   $injector) {\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromConfig\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a configuration object. \n   *\n   * @param {object} config Configuration object for which to load a template. \n   * The following properties are search in the specified order, and the first one \n   * that is defined is used to create the template:\n   *\n   * @param {string|object} config.template html string template or function to \n   * load via {@link ui.router.util.$templateFactory#fromString fromString}.\n   * @param {string|object} config.templateUrl url to load or a function returning \n   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.\n   * @param {Function} config.templateProvider function to invoke via \n   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.\n   * @param {object} params  Parameters to pass to the template function.\n   * @param {object} locals Locals to pass to `invoke` if the template is loaded \n   * via a `templateProvider`. Defaults to `{ params: params }`.\n   *\n   * @return {string|object}  The template html as a string, or a promise for \n   * that string,or `null` if no template is configured.\n   */\n  this.fromConfig = function (config, params, locals) {\n    return (\n      isDefined(config.template) ? this.fromString(config.template, params) :\n      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :\n      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :\n      null\n    );\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromString\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string|object} template html template as a string or function that \n   * returns an html template as a string.\n   * @param {object} params Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that \n   * string.\n   */\n  this.fromString = function (template, params) {\n    return isFunction(template) ? template(params) : template;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromUrl\n   * @methodOf ui.router.util.$templateFactory\n   * \n   * @description\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function \n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromUrl = function (url, params) {\n    if (isFunction(url)) url = url(params);\n    if (url == null) return null;\n    else return $http\n        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})\n        .then(function(response) { return response.data; });\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$templateFactory#fromProvider\n   * @methodOf ui.router.util.$templateFactory\n   *\n   * @description\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {Function} provider Function to invoke via `$injector.invoke`\n   * @param {Object} params Parameters for the template.\n   * @param {Object} locals Locals to pass to `invoke`. Defaults to \n   * `{ params: params }`.\n   * @return {string|Promise.<string>} The template html as a string, or a promise \n   * for that string.\n   */\n  this.fromProvider = function (provider, params, locals) {\n    return $injector.invoke(provider, null, locals || { params: params });\n  };\n}\n\nangular.module('ui.router.util').service('$templateFactory', $TemplateFactory);\n\nvar $$UMFP; // reference to $UrlMatcherFactoryProvider\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:UrlMatcher\n *\n * @description\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list\n * of search parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.\n *\n * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace\n * syntax, which optionally allows a regular expression for the parameter to be specified:\n *\n * * `':'` name - colon placeholder\n * * `'*'` name - catch-all placeholder\n * * `'{' name '}'` - curly placeholder\n * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the\n *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters). For colon\n * placeholders or curly placeholders without an explicit regexp, a path parameter matches any\n * number of characters other than '/'. For catch-all placeholders the path parameter matches\n * any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n * @param {string} pattern  The pattern to compile into a matcher.\n * @param {Object} config  A configuration object hash:\n * @param {Object=} parentMatcher Used to concatenate the pattern/config onto\n *   an existing UrlMatcher\n *\n * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n *\n * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any\n *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns\n *   non-null) will start with this prefix.\n *\n * @property {string} source  The pattern that was passed into the constructor\n *\n * @property {string} sourcePath  The path portion of the source property\n *\n * @property {string} sourceSearch  The search portion of the source property\n *\n * @property {string} regex  The constructed regex that will be used to match against the url when\n *   it is time to determine which url will match.\n *\n * @returns {Object}  New `UrlMatcher` object\n */\nfunction UrlMatcher(pattern, config, parentMatcher) {\n  config = extend({ params: {} }, isObject(config) ? config : {});\n\n  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n  //   '*' name\n  //   ':' name\n  //   '{' name '}'\n  //   '{' name ':' regexp '}'\n  // The regular expression is somewhat complicated due to the need to allow curly braces\n  // inside the regular expression. The placeholder regexp breaks down as follows:\n  //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n  //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n  //    [^{}\\\\]+                       - anything other than curly braces or backslash\n  //    \\\\.                            - a backslash escape\n  //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n  var placeholder       = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g,\n      compiled = '^', last = 0, m,\n      segments = this.segments = [],\n      parentParams = parentMatcher ? parentMatcher.params : {},\n      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),\n      paramNames = [];\n\n  function addParameter(id, type, config, location) {\n    paramNames.push(id);\n    if (parentParams[id]) return parentParams[id];\n    if (!/^\\w+([-.]+\\w+)*(?:\\[\\])?$/.test(id)) throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    if (params[id]) throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n    params[id] = new $$UMFP.Param(id, type, config, location);\n    return params[id];\n  }\n\n  function quoteRegExp(string, pattern, squash, optional) {\n    var surroundPattern = ['',''], result = string.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, \"\\\\$&\");\n    if (!pattern) return result;\n    switch(squash) {\n      case false: surroundPattern = ['(', ')' + (optional ? \"?\" : \"\")]; break;\n      case true:\n        result = result.replace(/\\/$/, '');\n        surroundPattern = ['(?:\\/(', ')|\\/)?'];\n      break;\n      default:    surroundPattern = ['(' + squash + \"|\", ')?']; break;\n    }\n    return result + surroundPattern[0] + pattern + surroundPattern[1];\n  }\n\n  this.source = pattern;\n\n  // Split into static segments separated by path parameter placeholders.\n  // The number of segments is always 1 more than the number of parameters.\n  function matchDetails(m, isSearch) {\n    var id, regexp, segment, type, cfg, arrayMode;\n    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null\n    cfg         = config.params[id];\n    segment     = pattern.substring(last, m.index);\n    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);\n\n    if (regexp) {\n      type      = $$UMFP.type(regexp) || inherit($$UMFP.type(\"string\"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });\n    }\n\n    return {\n      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg\n    };\n  }\n\n  var p, param, segment;\n  while ((m = placeholder.exec(pattern))) {\n    p = matchDetails(m, false);\n    if (p.segment.indexOf('?') >= 0) break; // we're into the search part\n\n    param = addParameter(p.id, p.type, p.cfg, \"path\");\n    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);\n    segments.push(p.segment);\n    last = placeholder.lastIndex;\n  }\n  segment = pattern.substring(last);\n\n  // Find any search parameter names and remove them from the last segment\n  var i = segment.indexOf('?');\n\n  if (i >= 0) {\n    var search = this.sourceSearch = segment.substring(i);\n    segment = segment.substring(0, i);\n    this.sourcePath = pattern.substring(0, last + i);\n\n    if (search.length > 0) {\n      last = 0;\n      while ((m = searchPlaceholder.exec(search))) {\n        p = matchDetails(m, true);\n        param = addParameter(p.id, p.type, p.cfg, \"search\");\n        last = placeholder.lastIndex;\n        // check if ?&\n      }\n    }\n  } else {\n    this.sourcePath = pattern;\n    this.sourceSearch = '';\n  }\n\n  compiled += quoteRegExp(segment) + (config.strict === false ? '\\/?' : '') + '$';\n  segments.push(segment);\n\n  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);\n  this.prefix = segments[0];\n  this.$$paramNames = paramNames;\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#concat\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns a new matcher for a pattern constructed by appending the path part and adding the\n * search parameters of the specified pattern to this pattern. The current pattern is not\n * modified. This can be understood as creating a pattern for URLs that are relative to (or\n * suffixes of) the current pattern.\n *\n * @example\n * The following two matchers are equivalent:\n * <pre>\n * new UrlMatcher('/user/{id}?q').concat('/details?date');\n * new UrlMatcher('/user/{id}/details?q&date');\n * </pre>\n *\n * @param {string} pattern  The pattern to append.\n * @param {Object} config  An object hash of the configuration for the matcher.\n * @returns {UrlMatcher}  A matcher for the concatenated pattern.\n */\nUrlMatcher.prototype.concat = function (pattern, config) {\n  // Because order of search parameters is irrelevant, we can add our own search\n  // parameters to the end of the new pattern. Parse the new pattern by itself\n  // and then join the bits together, but it's much easier to do this on a string level.\n  var defaultConfig = {\n    caseInsensitive: $$UMFP.caseInsensitive(),\n    strict: $$UMFP.strictMode(),\n    squash: $$UMFP.defaultSquashPolicy()\n  };\n  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);\n};\n\nUrlMatcher.prototype.toString = function () {\n  return this.source;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#exec\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Tests the specified path against this matcher, and returns an object containing the captured\n * parameter values, or null if the path does not match. The returned object contains the values\n * of any search parameters that are mentioned in the pattern, but their value may be null if\n * they are not present in `searchParams`. This means that search parameters are always treated\n * as optional.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n *   x: '1', q: 'hello'\n * });\n * // returns { id: 'bob', q: 'hello', r: null }\n * </pre>\n *\n * @param {string} path  The URL path to match, e.g. `$location.path()`.\n * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.\n * @returns {Object}  The captured parameter values.\n */\nUrlMatcher.prototype.exec = function (path, searchParams) {\n  var m = this.regexp.exec(path);\n  if (!m) return null;\n  searchParams = searchParams || {};\n\n  var paramNames = this.parameters(), nTotal = paramNames.length,\n    nPath = this.segments.length - 1,\n    values = {}, i, j, cfg, paramName;\n\n  if (nPath !== m.length - 1) throw new Error(\"Unbalanced capture group in route '\" + this.source + \"'\");\n\n  function decodePathArray(string) {\n    function reverseString(str) { return str.split(\"\").reverse().join(\"\"); }\n    function unquoteDashes(str) { return str.replace(/\\\\-/g, \"-\"); }\n\n    var split = reverseString(string).split(/-(?!\\\\)/);\n    var allReversed = map(split, reverseString);\n    return map(allReversed, unquoteDashes).reverse();\n  }\n\n  var param, paramVal;\n  for (i = 0; i < nPath; i++) {\n    paramName = paramNames[i];\n    param = this.params[paramName];\n    paramVal = m[i+1];\n    // if the param value matches a pre-replace pair, replace the value before decoding.\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n  for (/**/; i < nTotal; i++) {\n    paramName = paramNames[i];\n    values[paramName] = this.params[paramName].value(searchParams[paramName]);\n    param = this.params[paramName];\n    paramVal = searchParams[paramName];\n    for (j = 0; j < param.replace.length; j++) {\n      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;\n    }\n    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);\n    values[paramName] = param.value(paramVal);\n  }\n\n  return values;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#parameters\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Returns the names of all path and search parameters of this pattern in an unspecified order.\n *\n * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the\n *    pattern has no parameters, an empty array is returned.\n */\nUrlMatcher.prototype.parameters = function (param) {\n  if (!isDefined(param)) return this.$$paramNames;\n  return this.params[param] || null;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#validates\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Checks an object hash of parameters to validate their correctness according to the parameter\n * types of this `UrlMatcher`.\n *\n * @param {Object} params The object hash of parameters to validate.\n * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n */\nUrlMatcher.prototype.validates = function (params) {\n  return this.params.$$validates(params);\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:UrlMatcher#format\n * @methodOf ui.router.util.type:UrlMatcher\n *\n * @description\n * Creates a URL that matches this pattern by substituting the specified values\n * for the path and search parameters. Null values for path parameters are\n * treated as empty strings.\n *\n * @example\n * <pre>\n * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n * // returns '/user/bob?q=yes'\n * </pre>\n *\n * @param {Object} values  the values to substitute for the parameters in this pattern.\n * @returns {string}  the formatted URL (path and optionally search part).\n */\nUrlMatcher.prototype.format = function (values) {\n  values = values || {};\n  var segments = this.segments, params = this.parameters(), paramset = this.params;\n  if (!this.validates(values)) return null;\n\n  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];\n\n  function encodeDashes(str) { // Replace dashes with encoded \"\\-\"\n    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });\n  }\n\n  for (i = 0; i < nTotal; i++) {\n    var isPathParam = i < nPath;\n    var name = params[i], param = paramset[name], value = param.value(values[name]);\n    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);\n    var squash = isDefaultValue ? param.squash : false;\n    var encoded = param.type.encode(value);\n\n    if (isPathParam) {\n      var nextSegment = segments[i + 1];\n      var isFinalPathParam = i + 1 === nPath;\n\n      if (squash === false) {\n        if (encoded != null) {\n          if (isArray(encoded)) {\n            result += map(encoded, encodeDashes).join(\"-\");\n          } else {\n            result += encodeURIComponent(encoded);\n          }\n        }\n        result += nextSegment;\n      } else if (squash === true) {\n        var capture = result.match(/\\/$/) ? /\\/?(.*)/ : /(.*)/;\n        result += nextSegment.match(capture)[1];\n      } else if (isString(squash)) {\n        result += squash + nextSegment;\n      }\n\n      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);\n    } else {\n      if (encoded == null || (isDefaultValue && squash !== false)) continue;\n      if (!isArray(encoded)) encoded = [ encoded ];\n      if (encoded.length === 0) continue;\n      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');\n      result += (search ? '&' : '?') + (name + '=' + encoded);\n      search = true;\n    }\n  }\n\n  return result;\n};\n\n/**\n * @ngdoc object\n * @name ui.router.util.type:Type\n *\n * @description\n * Implements an interface to define custom parameter types that can be decoded from and encoded to\n * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}\n * objects when matching or formatting URLs, or comparing or validating parameter values.\n *\n * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more\n * information on registering custom types.\n *\n * @param {Object} config  A configuration object which contains the custom type definition.  The object's\n *        properties will override the default methods and/or pattern in `Type`'s public interface.\n * @example\n * <pre>\n * {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n * </pre>\n *\n * @property {RegExp} pattern The regular expression pattern used to match values of this type when\n *           coming from a substring of a URL.\n *\n * @returns {Object}  Returns a new `Type` object.\n */\nfunction Type(config) {\n  extend(this, config);\n}\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#is\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Detects whether a value is of a particular type. Accepts a native (decoded) value\n * and determines whether it matches the current `Type` object.\n *\n * @param {*} val  The value to check.\n * @param {string} key  Optional. If the type check is happening in the context of a specific\n *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the\n *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.\n * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.\n */\nType.prototype.is = function(val, key) {\n  return true;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#encode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the\n * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it\n * only needs to be a representation of `val` that has been coerced to a string.\n *\n * @param {*} val  The value to encode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.\n */\nType.prototype.encode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#decode\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Converts a parameter value (from URL string or transition param) to a custom/native value.\n *\n * @param {string} val  The URL parameter value to decode.\n * @param {string} key  The name of the parameter in which `val` is stored. Can be used for\n *        meta-programming of `Type` objects.\n * @returns {*}  Returns a custom representation of the URL parameter value.\n */\nType.prototype.decode = function(val, key) {\n  return val;\n};\n\n/**\n * @ngdoc function\n * @name ui.router.util.type:Type#equals\n * @methodOf ui.router.util.type:Type\n *\n * @description\n * Determines whether two decoded values are equivalent.\n *\n * @param {*} a  A value to compare against.\n * @param {*} b  A value to compare against.\n * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.\n */\nType.prototype.equals = function(a, b) {\n  return a == b;\n};\n\nType.prototype.$subPattern = function() {\n  var sub = this.pattern.toString();\n  return sub.substr(1, sub.length - 2);\n};\n\nType.prototype.pattern = /.*/;\n\nType.prototype.toString = function() { return \"{Type:\" + this.name + \"}\"; };\n\n/** Given an encoded string, or a decoded object, returns a decoded object */\nType.prototype.$normalize = function(val) {\n  return this.is(val) ? val : this.decode(val);\n};\n\n/*\n * Wraps an existing custom Type as an array of Type, depending on 'mode'.\n * e.g.:\n * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n * - url: \"/path?queryParam=1&queryParam=2\n * - $stateParams.queryParam will be [1, 2]\n * if `mode` is \"auto\", then\n * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n */\nType.prototype.$asArray = function(mode, isSearch) {\n  if (!mode) return this;\n  if (mode === \"auto\" && !isSearch) throw new Error(\"'auto' array mode is for query parameters only\");\n\n  function ArrayType(type, mode) {\n    function bindTo(type, callbackName) {\n      return function() {\n        return type[callbackName].apply(type, arguments);\n      };\n    }\n\n    // Wrap non-array value as array\n    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n      switch(val.length) {\n        case 0: return undefined;\n        case 1: return mode === \"auto\" ? val[0] : val;\n        default: return val;\n      }\n    }\n    function falsey(val) { return !val; }\n\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n      return function handleArray(val) {\n        if (isArray(val) && val.length === 0) return val;\n        val = arrayWrap(val);\n        var result = map(val, callback);\n        if (allTruthyMode === true)\n          return filter(result, falsey).length === 0;\n        return arrayUnwrap(result);\n      };\n    }\n\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n      return function handleArray(val1, val2) {\n        var left = arrayWrap(val1), right = arrayWrap(val2);\n        if (left.length !== right.length) return false;\n        for (var i = 0; i < left.length; i++) {\n          if (!callback(left[i], right[i])) return false;\n        }\n        return true;\n      };\n    }\n\n    this.encode = arrayHandler(bindTo(type, 'encode'));\n    this.decode = arrayHandler(bindTo(type, 'decode'));\n    this.is     = arrayHandler(bindTo(type, 'is'), true);\n    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));\n    this.pattern = type.pattern;\n    this.$normalize = arrayHandler(bindTo(type, '$normalize'));\n    this.name = type.name;\n    this.$arrayMode = mode;\n  }\n\n  return new ArrayType(this, mode);\n};\n\n\n\n/**\n * @ngdoc object\n * @name ui.router.util.$urlMatcherFactory\n *\n * @description\n * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory\n * is also available to providers under the name `$urlMatcherFactoryProvider`.\n */\nfunction $UrlMatcherFactory() {\n  $$UMFP = this;\n\n  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;\n\n  // Use tildes to pre-encode slashes.\n  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,\n  // and bidirectional encoding/decoding fails.\n  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character\n  function valToString(val) { return val != null ? val.toString().replace(/~/g, \"~~\").replace(/\\//g, \"~2F\") : val; }\n  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, \"/\").replace(/~~/g, \"~\") : val; }\n\n  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {\n    \"string\": {\n      encode: valToString,\n      decode: valFromString,\n      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.\n      // In 0.2.x, string params are optional by default for backwards compat\n      is: function(val) { return val == null || !isDefined(val) || typeof val === \"string\"; },\n      pattern: /[^/]*/\n    },\n    \"int\": {\n      encode: valToString,\n      decode: function(val) { return parseInt(val, 10); },\n      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },\n      pattern: /\\d+/\n    },\n    \"bool\": {\n      encode: function(val) { return val ? 1 : 0; },\n      decode: function(val) { return parseInt(val, 10) !== 0; },\n      is: function(val) { return val === true || val === false; },\n      pattern: /0|1/\n    },\n    \"date\": {\n      encode: function (val) {\n        if (!this.is(val))\n          return undefined;\n        return [ val.getFullYear(),\n          ('0' + (val.getMonth() + 1)).slice(-2),\n          ('0' + val.getDate()).slice(-2)\n        ].join(\"-\");\n      },\n      decode: function (val) {\n        if (this.is(val)) return val;\n        var match = this.capture.exec(val);\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },\n      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/\n    },\n    \"json\": {\n      encode: angular.toJson,\n      decode: angular.fromJson,\n      is: angular.isObject,\n      equals: angular.equals,\n      pattern: /[^/]*/\n    },\n    \"any\": { // does not encode/decode\n      encode: angular.identity,\n      decode: angular.identity,\n      equals: angular.equals,\n      pattern: /.*/\n    }\n  };\n\n  function getDefaultConfig() {\n    return {\n      strict: isStrictMode,\n      caseInsensitive: isCaseInsensitive\n    };\n  }\n\n  function isInjectable(value) {\n    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));\n  }\n\n  /**\n   * [Internal] Get the default value of a parameter, which may be an injectable function.\n   */\n  $UrlMatcherFactory.$$getDefaultValue = function(config) {\n    if (!isInjectable(config.value)) return config.value;\n    if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n    return injector.invoke(config.value);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#caseInsensitive\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  this.caseInsensitive = function(value) {\n    if (isDefined(value))\n      isCaseInsensitive = value;\n    return isCaseInsensitive;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#strictMode\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  this.strictMode = function(value) {\n    if (isDefined(value))\n      isStrictMode = value;\n    return isStrictMode;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * @param {string} value A string that defines the default parameter URL squashing behavior.\n   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *             parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *             the parameter value from the URL and replace it with this string.\n   */\n  this.defaultSquashPolicy = function(value) {\n    if (!isDefined(value)) return defaultSquashPolicy;\n    if (value !== true && value !== false && !isString(value))\n      throw new Error(\"Invalid squash policy: \" + value + \". Valid policies: false, true, arbitrary-string\");\n    defaultSquashPolicy = value;\n    return value;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#compile\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.\n   *\n   * @param {string} pattern  The URL pattern.\n   * @param {Object} config  The config object hash.\n   * @returns {UrlMatcher}  The UrlMatcher.\n   */\n  this.compile = function (pattern, config) {\n    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#isMatcher\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.\n   *\n   * @param {Object} object  The object to perform the type check against.\n   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  this.isMatcher = function (o) {\n    if (!isObject(o)) return false;\n    var result = true;\n\n    forEach(UrlMatcher.prototype, function(val, name) {\n      if (isFunction(val)) {\n        result = result && (isDefined(o[name]) && isFunction(o[name]));\n      }\n    });\n    return result;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.util.$urlMatcherFactory#type\n   * @methodOf ui.router.util.$urlMatcherFactory\n   *\n   * @description\n   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to\n   * generate URLs with typed parameters.\n   *\n   * @param {string} name  The type name.\n   * @param {Object|Function} definition   The type definition. See\n   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   * @param {Object|Function} definitionFn (optional) A function that is injected before the app\n   *        runtime starts.  The result of this function is merged into the existing `definition`.\n   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.\n   *\n   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.\n   *\n   * @example\n   * This is a simple example of a custom type that encodes and decodes items from an\n   * array, using the array index as the URL-encoded value:\n   *\n   * <pre>\n   * var list = ['John', 'Paul', 'George', 'Ringo'];\n   *\n   * $urlMatcherFactoryProvider.type('listItem', {\n   *   encode: function(item) {\n   *     // Represent the list item in the URL using its corresponding index\n   *     return list.indexOf(item);\n   *   },\n   *   decode: function(item) {\n   *     // Look up the list item by index\n   *     return list[parseInt(item, 10)];\n   *   },\n   *   is: function(item) {\n   *     // Ensure the item is valid by checking to see that it appears\n   *     // in the list\n   *     return list.indexOf(item) > -1;\n   *   }\n   * });\n   *\n   * $stateProvider.state('list', {\n   *   url: \"/list/{item:listItem}\",\n   *   controller: function($scope, $stateParams) {\n   *     console.log($stateParams.item);\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * // Changes URL to '/list/3', logs \"Ringo\" to the console\n   * $state.go('list', { item: \"Ringo\" });\n   * </pre>\n   *\n   * This is a more complex example of a type that relies on dependency injection to\n   * interact with services, and uses the parameter name from the URL to infer how to\n   * handle encoding and decoding parameter values:\n   *\n   * <pre>\n   * // Defines a custom type that gets a value from a service,\n   * // where each service gets different types of values from\n   * // a backend API:\n   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {\n   *\n   *   // Matches up services to URL parameter names\n   *   var services = {\n   *     user: Users,\n   *     post: Posts\n   *   };\n   *\n   *   return {\n   *     encode: function(object) {\n   *       // Represent the object in the URL using its unique ID\n   *       return object.id;\n   *     },\n   *     decode: function(value, key) {\n   *       // Look up the object by ID, using the parameter\n   *       // name (key) to call the correct service\n   *       return services[key].findById(value);\n   *     },\n   *     is: function(object, key) {\n   *       // Check that object is a valid dbObject\n   *       return angular.isObject(object) && object.id && services[key];\n   *     }\n   *     equals: function(a, b) {\n   *       // Check the equality of decoded objects by comparing\n   *       // their unique IDs\n   *       return a.id === b.id;\n   *     }\n   *   };\n   * });\n   *\n   * // In a config() block, you can then attach URLs with\n   * // type-annotated parameters:\n   * $stateProvider.state('users', {\n   *   url: \"/users\",\n   *   // ...\n   * }).state('users.item', {\n   *   url: \"/{user:dbObject}\",\n   *   controller: function($scope, $stateParams) {\n   *     // $stateParams.user will now be an object returned from\n   *     // the Users service\n   *   },\n   *   // ...\n   * });\n   * </pre>\n   */\n  this.type = function (name, definition, definitionFn) {\n    if (!isDefined(definition)) return $types[name];\n    if ($types.hasOwnProperty(name)) throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n\n    $types[name] = new Type(extend({ name: name }, definition));\n    if (definitionFn) {\n      typeQueue.push({ name: name, def: definitionFn });\n      if (!enqueue) flushTypeQueue();\n    }\n    return this;\n  };\n\n  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s\n  function flushTypeQueue() {\n    while(typeQueue.length) {\n      var type = typeQueue.shift();\n      if (type.pattern) throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      angular.extend($types[type.name], injector.invoke(type.def));\n    }\n  }\n\n  // Register default types. Store them in the prototype of $types.\n  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });\n  $types = inherit($types, {});\n\n  /* No need to document $get, since it returns this */\n  this.$get = ['$injector', function ($injector) {\n    injector = $injector;\n    enqueue = false;\n    flushTypeQueue();\n\n    forEach(defaultTypes, function(type, name) {\n      if (!$types[name]) $types[name] = new Type(type);\n    });\n    return this;\n  }];\n\n  this.Param = function Param(id, type, config, location) {\n    var self = this;\n    config = unwrapShorthand(config);\n    type = getType(config, type, location);\n    var arrayMode = getArrayMode();\n    type = arrayMode ? type.$asArray(arrayMode, location === \"search\") : type;\n    if (type.name === \"string\" && !arrayMode && location === \"path\" && config.value === undefined)\n      config.value = \"\"; // for 0.2.x; in 0.3.0+ do not automatically default to \"\"\n    var isOptional = config.value !== undefined;\n    var squash = getSquashPolicy(config, isOptional);\n    var replace = getReplace(config, arrayMode, isOptional, squash);\n\n    function unwrapShorthand(config) {\n      var keys = isObject(config) ? objectKeys(config) : [];\n      var isShorthand = indexOf(keys, \"value\") === -1 && indexOf(keys, \"type\") === -1 &&\n                        indexOf(keys, \"squash\") === -1 && indexOf(keys, \"array\") === -1;\n      if (isShorthand) config = { value: config };\n      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };\n      return config;\n    }\n\n    function getType(config, urlType, location) {\n      if (config.type && urlType) throw new Error(\"Param '\"+id+\"' has two type configurations.\");\n      if (urlType) return urlType;\n      if (!config.type) return (location === \"config\" ? $types.any : $types.string);\n\n      if (angular.isString(config.type))\n        return $types[config.type];\n      if (config.type instanceof Type)\n        return config.type;\n      return new Type(config.type);\n    }\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      var arrayDefaults = { array: (location === \"search\" ? \"auto\" : false) };\n      var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n      return extend(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n\n    /**\n     * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n     */\n    function getSquashPolicy(config, isOptional) {\n      var squash = config.squash;\n      if (!isOptional || squash === false) return false;\n      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;\n      if (squash === true || isString(squash)) return squash;\n      throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n    }\n\n    function getReplace(config, arrayMode, isOptional, squash) {\n      var replace, configuredKeys, defaultPolicy = [\n        { from: \"\",   to: (isOptional || arrayMode ? undefined : \"\") },\n        { from: null, to: (isOptional || arrayMode ? undefined : \"\") }\n      ];\n      replace = isArray(config.replace) ? config.replace : [];\n      if (isString(squash))\n        replace.push({ from: squash, to: undefined });\n      configuredKeys = map(replace, function(item) { return item.from; } );\n      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);\n    }\n\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    function $$getDefaultValue() {\n      if (!injector) throw new Error(\"Injectable functions cannot be called at configuration time\");\n      var defaultValue = injector.invoke(config.$$fn);\n      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))\n        throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + self.id + \"' is not an instance of Type (\" + self.type.name + \")\");\n      return defaultValue;\n    }\n\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    function $value(value) {\n      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }\n      function $replace(value) {\n        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });\n        return replacement.length ? replacement[0] : value;\n      }\n      value = $replace(value);\n      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);\n    }\n\n    function toString() { return \"{Param:\" + id + \" \" + type + \" squash: '\" + squash + \"' optional: \" + isOptional + \"}\"; }\n\n    extend(this, {\n      id: id,\n      type: type,\n      location: location,\n      array: arrayMode,\n      squash: squash,\n      replace: replace,\n      isOptional: isOptional,\n      value: $value,\n      dynamic: undefined,\n      config: config,\n      toString: toString\n    });\n  };\n\n  function ParamSet(params) {\n    extend(this, params || {});\n  }\n\n  ParamSet.prototype = {\n    $$new: function() {\n      return inherit(this, extend(new ParamSet(), { $$parent: this}));\n    },\n    $$keys: function () {\n      var keys = [], chain = [], parent = this,\n        ignore = objectKeys(ParamSet.prototype);\n      while (parent) { chain.push(parent); parent = parent.$$parent; }\n      chain.reverse();\n      forEach(chain, function(paramset) {\n        forEach(objectKeys(paramset), function(key) {\n            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);\n        });\n      });\n      return keys;\n    },\n    $$values: function(paramValues) {\n      var values = {}, self = this;\n      forEach(self.$$keys(), function(key) {\n        values[key] = self[key].value(paramValues && paramValues[key]);\n      });\n      return values;\n    },\n    $$equals: function(paramValues1, paramValues2) {\n      var equal = true, self = this;\n      forEach(self.$$keys(), function(key) {\n        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];\n        if (!self[key].type.equals(left, right)) equal = false;\n      });\n      return equal;\n    },\n    $$validates: function $$validate(paramValues) {\n      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;\n      for (i = 0; i < keys.length; i++) {\n        param = this[keys[i]];\n        rawVal = paramValues[keys[i]];\n        if ((rawVal === undefined || rawVal === null) && param.isOptional)\n          break; // There was no parameter value, but the param is optional\n        normalized = param.type.$normalize(rawVal);\n        if (!param.type.is(normalized))\n          return false; // The value was not of the correct Type, and could not be decoded to the correct Type\n        encoded = param.type.encode(normalized);\n        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))\n          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp\n      }\n      return true;\n    },\n    $$parent: undefined\n  };\n\n  this.ParamSet = ParamSet;\n}\n\n// Register as a provider so it's available to other providers\nangular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);\nangular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);\n\n/**\n * @ngdoc object\n * @name ui.router.router.$urlRouterProvider\n *\n * @requires ui.router.util.$urlMatcherFactoryProvider\n * @requires $locationProvider\n *\n * @description\n * `$urlRouterProvider` has the responsibility of watching `$location`. \n * When `$location` changes it runs through a list of rules one by one until a \n * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify \n * a url in a state configuration. All urls are compiled into a UrlMatcher object.\n *\n * There are several methods on `$urlRouterProvider` that make it useful to use directly\n * in your module config.\n */\n$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];\nfunction $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {\n  var rules = [], otherwise = null, interceptDeferred = false, listener;\n\n  // Returns a string that is a prefix of all strings matching the RegExp\n  function regExpPrefix(re) {\n    var prefix = /^\\^((?:\\\\[^a-zA-Z0-9]|[^\\\\\\[\\]\\^$*+?.()|{}]+)*)/.exec(re.source);\n    return (prefix != null) ? prefix[1].replace(/\\\\(.)/g, \"$1\") : '';\n  }\n\n  // Interpolates matched values into a String.replace()-style pattern\n  function interpolate(pattern, match) {\n    return pattern.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n      return match[what === '$' ? 0 : Number(what)];\n    });\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#rule\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines rules that are used by `$urlRouterProvider` to find matches for\n   * specific URLs.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // Here's an example of how you might allow case insensitive urls\n   *   $urlRouterProvider.rule(function ($injector, $location) {\n   *     var path = $location.path(),\n   *         normalized = path.toLowerCase();\n   *\n   *     if (path !== normalized) {\n   *       return normalized;\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {function} rule Handler function that takes `$injector` and `$location`\n   * services as arguments. You can use them to return a valid path as a string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.rule = function (rule) {\n    if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    rules.push(rule);\n    return this;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouterProvider#otherwise\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Defines a path that is used when an invalid route is requested.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   // if the path doesn't match any of the urls you configured\n   *   // otherwise will take care of routing the user to the\n   *   // specified url\n   *   $urlRouterProvider.otherwise('/index');\n   *\n   *   // Example of using function rule as param\n   *   $urlRouterProvider.otherwise(function ($injector, $location) {\n   *     return '/a/valid/url';\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|function} rule The url path you want to redirect to or a function \n   * rule that returns the url path. The function version is passed two params: \n   * `$injector` and `$location` services, and must return a url string.\n   *\n   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n   */\n  this.otherwise = function (rule) {\n    if (isString(rule)) {\n      var redirect = rule;\n      rule = function () { return redirect; };\n    }\n    else if (!isFunction(rule)) throw new Error(\"'rule' must be a function\");\n    otherwise = rule;\n    return this;\n  };\n\n\n  function handleIfMatch($injector, handler, match) {\n    if (!match) return false;\n    var result = $injector.invoke(handler, handler, { $match: match });\n    return isDefined(result) ? result : true;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#when\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Registers a handler for a given url matching. \n   * \n   * If the handler is a string, it is\n   * treated as a redirect, and is interpolated according to the syntax of match\n   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n   *\n   * If the handler is a function, it is injectable. It gets invoked if `$location`\n   * matches. You have the option of inject the match object as `$match`.\n   *\n   * The handler can return\n   *\n   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n   *   will continue trying to find another one that matches.\n   * - **string** which is treated as a redirect and passed to `$location.url()`\n   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n   *     if ($state.$current.navigable !== state ||\n   *         !equalForKeys($match, $stateParams) {\n   *      $state.transitionTo(state, $match, false);\n   *     }\n   *   });\n   * });\n   * </pre>\n   *\n   * @param {string|object} what The incoming path that you want to redirect.\n   * @param {string|function} handler The path you want to redirect your user to.\n   */\n  this.when = function (what, handler) {\n    var redirect, handlerIsString = isString(handler);\n    if (isString(what)) what = $urlMatcherFactory.compile(what);\n\n    if (!handlerIsString && !isFunction(handler) && !isArray(handler))\n      throw new Error(\"invalid 'handler' in when()\");\n\n    var strategies = {\n      matcher: function (what, handler) {\n        if (handlerIsString) {\n          redirect = $urlMatcherFactory.compile(handler);\n          handler = ['$match', function ($match) { return redirect.format($match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));\n        }, {\n          prefix: isString(what.prefix) ? what.prefix : ''\n        });\n      },\n      regex: function (what, handler) {\n        if (what.global || what.sticky) throw new Error(\"when() RegExp must not be global or sticky\");\n\n        if (handlerIsString) {\n          redirect = handler;\n          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];\n        }\n        return extend(function ($injector, $location) {\n          return handleIfMatch($injector, handler, what.exec($location.path()));\n        }, {\n          prefix: regExpPrefix(what)\n        });\n      }\n    };\n\n    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };\n\n    for (var n in check) {\n      if (check[n]) return this.rule(strategies[n](what, handler));\n    }\n\n    throw new Error(\"invalid 'what' in when()\");\n  };\n\n  /**\n   * @ngdoc function\n   * @name ui.router.router.$urlRouterProvider#deferIntercept\n   * @methodOf ui.router.router.$urlRouterProvider\n   *\n   * @description\n   * Disables (or enables) deferring location change interception.\n   *\n   * If you wish to customize the behavior of syncing the URL (for example, if you wish to\n   * defer a transition but maintain the current URL), call this method at configuration time.\n   * Then, at run time, call `$urlRouter.listen()` after you have configured your own\n   * `$locationChangeSuccess` event handler.\n   *\n   * @example\n   * <pre>\n   * var app = angular.module('app', ['ui.router.router']);\n   *\n   * app.config(function ($urlRouterProvider) {\n   *\n   *   // Prevent $urlRouter from automatically intercepting URL changes;\n   *   // this allows you to configure custom behavior in between\n   *   // location changes and route synchronization:\n   *   $urlRouterProvider.deferIntercept();\n   *\n   * }).run(function ($rootScope, $urlRouter, UserService) {\n   *\n   *   $rootScope.$on('$locationChangeSuccess', function(e) {\n   *     // UserService is an example service for managing user state\n   *     if (UserService.isLoggedIn()) return;\n   *\n   *     // Prevent $urlRouter's default handler from firing\n   *     e.preventDefault();\n   *\n   *     UserService.handleLogin().then(function() {\n   *       // Once the user has logged in, sync the current URL\n   *       // to the router:\n   *       $urlRouter.sync();\n   *     });\n   *   });\n   *\n   *   // Configures $urlRouter's listener *after* your custom listener\n   *   $urlRouter.listen();\n   * });\n   * </pre>\n   *\n   * @param {boolean} defer Indicates whether to defer location change interception. Passing\n            no parameter is equivalent to `true`.\n   */\n  this.deferIntercept = function (defer) {\n    if (defer === undefined) defer = true;\n    interceptDeferred = defer;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.router.$urlRouter\n   *\n   * @requires $location\n   * @requires $rootScope\n   * @requires $injector\n   * @requires $browser\n   *\n   * @description\n   *\n   */\n  this.$get = $get;\n  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];\n  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {\n\n    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;\n\n    function appendBasePath(url, isHtml5, absolute) {\n      if (baseHref === '/') return url;\n      if (isHtml5) return baseHref.slice(0, -1) + url;\n      if (absolute) return baseHref.slice(1) + url;\n      return url;\n    }\n\n    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree\n    function update(evt) {\n      if (evt && evt.defaultPrevented) return;\n      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;\n      lastPushedUrl = undefined;\n      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573\n      //if (ignoreUpdate) return true;\n\n      function check(rule) {\n        var handled = rule($injector, $location);\n\n        if (!handled) return false;\n        if (isString(handled)) $location.replace().url(handled);\n        return true;\n      }\n      var n = rules.length, i;\n\n      for (i = 0; i < n; i++) {\n        if (check(rules[i])) return;\n      }\n      // always check otherwise last to allow dynamic updates to the set of rules\n      if (otherwise) check(otherwise);\n    }\n\n    function listen() {\n      listener = listener || $rootScope.$on('$locationChangeSuccess', update);\n      return listener;\n    }\n\n    if (!interceptDeferred) listen();\n\n    return {\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#sync\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.\n       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,\n       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed\n       * with the transition by calling `$urlRouter.sync()`.\n       *\n       * @example\n       * <pre>\n       * angular.module('app', ['ui.router'])\n       *   .run(function($rootScope, $urlRouter) {\n       *     $rootScope.$on('$locationChangeSuccess', function(evt) {\n       *       // Halt state change from even starting\n       *       evt.preventDefault();\n       *       // Perform custom logic\n       *       var meetsRequirement = ...\n       *       // Continue with the update and state transition if logic allows\n       *       if (meetsRequirement) $urlRouter.sync();\n       *     });\n       * });\n       * </pre>\n       */\n      sync: function() {\n        update();\n      },\n\n      listen: function() {\n        return listen();\n      },\n\n      update: function(read) {\n        if (read) {\n          location = $location.url();\n          return;\n        }\n        if ($location.url() === location) return;\n\n        $location.url(location);\n        $location.replace();\n      },\n\n      push: function(urlMatcher, params, options) {\n         var url = urlMatcher.format(params || {});\n\n        // Handle the special hash param, if needed\n        if (url !== null && params && params['#']) {\n            url += '#' + params['#'];\n        }\n\n        $location.url(url);\n        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;\n        if (options && options.replace) $location.replace();\n      },\n\n      /**\n       * @ngdoc function\n       * @name ui.router.router.$urlRouter#href\n       * @methodOf ui.router.router.$urlRouter\n       *\n       * @description\n       * A URL generation method that returns the compiled URL for a given\n       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.\n       *\n       * @example\n       * <pre>\n       * $bob = $urlRouter.href(new UrlMatcher(\"/about/:person\"), {\n       *   person: \"bob\"\n       * });\n       * // $bob == \"/about/bob\";\n       * </pre>\n       *\n       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.\n       * @param {object=} params An object of parameter values to fill the matcher's required parameters.\n       * @param {object=} options Options object. The options are:\n       *\n       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n       *\n       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n       */\n      href: function(urlMatcher, params, options) {\n        if (!urlMatcher.validates(params)) return null;\n\n        var isHtml5 = $locationProvider.html5Mode();\n        if (angular.isObject(isHtml5)) {\n          isHtml5 = isHtml5.enabled;\n        }\n\n        isHtml5 = isHtml5 && $sniffer.history;\n        \n        var url = urlMatcher.format(params);\n        options = options || {};\n\n        if (!isHtml5 && url !== null) {\n          url = \"#\" + $locationProvider.hashPrefix() + url;\n        }\n\n        // Handle special hash param, if needed\n        if (url !== null && params && params['#']) {\n          url += '#' + params['#'];\n        }\n\n        url = appendBasePath(url, isHtml5, options.absolute);\n\n        if (!options.absolute || !url) {\n          return url;\n        }\n\n        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();\n        port = (port === 80 || port === 443 ? '' : ':' + port);\n\n        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');\n      }\n    };\n  }\n}\n\nangular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$stateProvider\n *\n * @requires ui.router.router.$urlRouterProvider\n * @requires ui.router.util.$urlMatcherFactoryProvider\n *\n * @description\n * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\n$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];\nfunction $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {\n\n  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';\n\n  // Builds state properties from definition passed to registerState()\n  var stateBuilder = {\n\n    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.\n    // state.children = [];\n    // if (parent) parent.children.push(state);\n    parent: function(state) {\n      if (isDefined(state.parent) && state.parent) return findState(state.parent);\n      // regex matches any valid composite state name\n      // would match \"contact.list\" but not \"contacts\"\n      var compositeName = /^(.+)\\.[^.]+$/.exec(state.name);\n      return compositeName ? findState(compositeName[1]) : root;\n    },\n\n    // inherit 'data' from parent and override by own values (if any)\n    data: function(state) {\n      if (state.parent && state.parent.data) {\n        state.data = state.self.data = inherit(state.parent.data, state.data);\n      }\n      return state.data;\n    },\n\n    // Build a URLMatcher if necessary, either via a relative or absolute URL\n    url: function(state) {\n      var url = state.url, config = { params: state.params || {} };\n\n      if (isString(url)) {\n        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);\n        return (state.parent.navigable || root).url.concat(url, config);\n      }\n\n      if (!url || $urlMatcherFactory.isMatcher(url)) return url;\n      throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n    },\n\n    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n    navigable: function(state) {\n      return state.url ? state : (state.parent ? state.parent.navigable : null);\n    },\n\n    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params\n    ownParams: function(state) {\n      var params = state.url && state.url.params || new $$UMFP.ParamSet();\n      forEach(state.params || {}, function(config, id) {\n        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, \"config\");\n      });\n      return params;\n    },\n\n    // Derive parameters for this state and ensure they're a super-set of parent's parameters\n    params: function(state) {\n      var ownParams = pick(state.ownParams, state.ownParams.$$keys());\n      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();\n    },\n\n    // If there is no explicit multi-view configuration, make one up so we don't have\n    // to handle both cases in the view directive later. Note that having an explicit\n    // 'views' property will mean the default unnamed view properties are ignored. This\n    // is also a good time to resolve view names to absolute names, so everything is a\n    // straight lookup at link time.\n    views: function(state) {\n      var views = {};\n\n      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {\n        if (name.indexOf('@') < 0) name += '@' + state.parent.name;\n        views[name] = view;\n      });\n      return views;\n    },\n\n    // Keep a full path from the root down to this state as this is needed for state activation.\n    path: function(state) {\n      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path\n    },\n\n    // Speed up $state.contains() as it's used a lot\n    includes: function(state) {\n      var includes = state.parent ? extend({}, state.parent.includes) : {};\n      includes[state.name] = true;\n      return includes;\n    },\n\n    $delegates: {}\n  };\n\n  function isRelative(stateName) {\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  function findState(stateOrName, base) {\n    if (!stateOrName) return undefined;\n\n    var isStr = isString(stateOrName),\n        name  = isStr ? stateOrName : stateOrName.name,\n        path  = isRelative(name);\n\n    if (path) {\n      if (!base) throw new Error(\"No reference point given for path '\"  + name + \"'\");\n      base = findState(base);\n      \n      var rel = name.split(\".\"), i = 0, pathLength = rel.length, current = base;\n\n      for (; i < pathLength; i++) {\n        if (rel[i] === \"\" && i === 0) {\n          current = base;\n          continue;\n        }\n        if (rel[i] === \"^\") {\n          if (!current.parent) throw new Error(\"Path '\" + name + \"' not valid for state '\" + base.name + \"'\");\n          current = current.parent;\n          continue;\n        }\n        break;\n      }\n      rel = rel.slice(i).join(\".\");\n      name = current.name + (current.name && rel ? \".\" : \"\") + rel;\n    }\n    var state = states[name];\n\n    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n      return state;\n    }\n    return undefined;\n  }\n\n  function queueState(parentName, state) {\n    if (!queue[parentName]) {\n      queue[parentName] = [];\n    }\n    queue[parentName].push(state);\n  }\n\n  function flushQueuedChildren(parentName) {\n    var queued = queue[parentName] || [];\n    while(queued.length) {\n      registerState(queued.shift());\n    }\n  }\n\n  function registerState(state) {\n    // Wrap a new object around the state so we can store our private details easily.\n    state = inherit(state, {\n      self: state,\n      resolve: state.resolve || {},\n      toString: function() { return this.name; }\n    });\n\n    var name = state.name;\n    if (!isString(name) || name.indexOf('@') >= 0) throw new Error(\"State must have a valid name\");\n    if (states.hasOwnProperty(name)) throw new Error(\"State '\" + name + \"' is already defined\");\n\n    // Get parent name\n    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))\n        : (isString(state.parent)) ? state.parent\n        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name\n        : '';\n\n    // If parent is not registered yet, add state to queue and register later\n    if (parentName && !states[parentName]) {\n      return queueState(parentName, state.self);\n    }\n\n    for (var key in stateBuilder) {\n      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);\n    }\n    states[name] = state;\n\n    // Register the state in the global state list and with $urlRouter if necessary.\n    if (!state[abstractKey] && state.url) {\n      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {\n        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {\n          $state.transitionTo(state, $match, { inherit: true, location: false });\n        }\n      }]);\n    }\n\n    // Register any queued children\n    flushQueuedChildren(name);\n\n    return state;\n  }\n\n  // Checks text to see if it looks like a glob.\n  function isGlob (text) {\n    return text.indexOf('*') > -1;\n  }\n\n  // Returns true if glob matches current $state name.\n  function doesStateMatchGlob (glob) {\n    var globSegments = glob.split('.'),\n        segments = $state.$current.name.split('.');\n\n    //match single stars\n    for (var i = 0, l = globSegments.length; i < l; i++) {\n      if (globSegments[i] === '*') {\n        segments[i] = '*';\n      }\n    }\n\n    //match greedy starts\n    if (globSegments[0] === '**') {\n       segments = segments.slice(indexOf(segments, globSegments[1]));\n       segments.unshift('**');\n    }\n    //match greedy ends\n    if (globSegments[globSegments.length - 1] === '**') {\n       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);\n       segments.push('**');\n    }\n\n    if (globSegments.length != segments.length) {\n      return false;\n    }\n\n    return segments.join('') === globSegments.join('');\n  }\n\n\n  // Implicit root state that is always active\n  root = registerState({\n    name: '',\n    url: '^',\n    views: null,\n    'abstract': true\n  });\n  root.navigable = null;\n\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#decorator\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Allows you to extend (carefully) or override (at your own peril) the \n   * `stateBuilder` object used internally by `$stateProvider`. This can be used \n   * to add custom functionality to ui-router, for example inferring templateUrl \n   * based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new \n   * properties within the state's internal definition. There is currently no clear \n   * use-case for this beyond accessing internal states (i.e. $state.$current), \n   * however, expect this to become increasingly relevant as we introduce additional \n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of \n   * execution of the builder functions in non-deterministic. Builder functions \n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is \n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to \n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view \n   *   name (i.e. \"viewName@stateName\") and each value is the config object \n   *   (template, controller) for the view. Even when you don't use the views object \n   *   explicitly on a state config, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template \n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state, \n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state. \n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that \n   *   would pass a `$state.includes()` test.\n   *\n   * @example\n   * <pre>\n   * // Override the internal 'views' builder with a function that takes the state\n   * // definition, and a reference to the internal function being overridden:\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   var result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (config, name) {\n   *     var autoName = (state.name + '.' + name).replace('.', '/');\n   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = config;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   *\n   * // ...\n   *\n   * $state.go('home');\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * </pre>\n   *\n   * @param {string} name The name of the builder function to decorate. \n   * @param {object} func A function that is responsible for decorating the original \n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state config object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  this.decorator = decorator;\n  function decorator(name, func) {\n    /*jshint validthis: true */\n    if (isString(name) && !isDefined(func)) {\n      return stateBuilder[name];\n    }\n    if (!isFunction(func) || !isString(name)) {\n      return this;\n    }\n    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {\n      stateBuilder.$delegates[name] = stateBuilder[name];\n    }\n    stateBuilder[name] = func;\n    return this;\n  }\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$stateProvider#state\n   * @methodOf ui.router.state.$stateProvider\n   *\n   * @description\n   * Registers a state configuration under a given state name. The stateConfig object\n   * has the following acceptable properties.\n   *\n   * @param {string} name A unique state name, e.g. \"home\", \"about\", \"contacts\".\n   * To create a parent/child state use a dot, e.g. \"about.sales\", \"home.newest\".\n   * @param {object} stateConfig State configuration object.\n   * @param {string|function=} stateConfig.template\n   * <a id='template'></a>\n   *   html template as a string or a function that returns\n   *   an html template as a string which should be used by the uiView directives. This property \n   *   takes precedence over templateUrl.\n   *   \n   *   If `template` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by\n   *     applying the current state\n   *\n   * <pre>template:\n   *   \"<h1>inline template definition</h1>\" +\n   *   \"<div ui-view></div>\"</pre>\n   * <pre>template: function(params) {\n   *       return \"<h1>generated template</h1>\"; }</pre>\n   * </div>\n   *\n   * @param {string|function=} stateConfig.templateUrl\n   * <a id='templateUrl'></a>\n   *\n   *   path or function that returns a path to an html\n   *   template that should be used by uiView.\n   *   \n   *   If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by \n   *     applying the current state\n   *\n   * <pre>templateUrl: \"home.html\"</pre>\n   * <pre>templateUrl: function(params) {\n   *     return myTemplates[params.pageId]; }</pre>\n   *\n   * @param {function=} stateConfig.templateProvider\n   * <a id='templateProvider'></a>\n   *    Provider function that returns HTML content string.\n   * <pre> templateProvider:\n   *       function(MyTemplateService, params) {\n   *         return MyTemplateService.getTemplate(params.pageId);\n   *       }</pre>\n   *\n   * @param {string|function=} stateConfig.controller\n   * <a id='controller'></a>\n   *\n   *  Controller fn that should be associated with newly\n   *   related scope or the name of a registered controller if passed as a string.\n   *   Optionally, the ControllerAs may be declared here.\n   * <pre>controller: \"MyRegisteredController\"</pre>\n   * <pre>controller:\n   *     \"MyRegisteredController as fooCtrl\"}</pre>\n   * <pre>controller: function($scope, MyService) {\n   *     $scope.data = MyService.getData(); }</pre>\n   *\n   * @param {function=} stateConfig.controllerProvider\n   * <a id='controllerProvider'></a>\n   *\n   * Injectable provider function that returns the actual controller or string.\n   * <pre>controllerProvider:\n   *   function(MyResolveData) {\n   *     if (MyResolveData.foo)\n   *       return \"FooCtrl\"\n   *     else if (MyResolveData.bar)\n   *       return \"BarCtrl\";\n   *     else return function($scope) {\n   *       $scope.baz = \"Qux\";\n   *     }\n   *   }</pre>\n   *\n   * @param {string=} stateConfig.controllerAs\n   * <a id='controllerAs'></a>\n   * \n   * A controller alias name. If present the controller will be\n   *   published to scope under the controllerAs name.\n   * <pre>controllerAs: \"myCtrl\"</pre>\n   *\n   * @param {string|object=} stateConfig.parent\n   * <a id='parent'></a>\n   * Optionally specifies the parent state of this state.\n   *\n   * <pre>parent: 'parentState'</pre>\n   * <pre>parent: parentState // JS variable</pre>\n   *\n   * @param {object=} stateConfig.resolve\n   * <a id='resolve'></a>\n   *\n   * An optional map&lt;string, function&gt; of dependencies which\n   *   should be injected into the controller. If any of these dependencies are promises, \n   *   the router will wait for them all to be resolved before the controller is instantiated.\n   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired\n   *   and the values of the resolved promises are injected into any controllers that reference them.\n   *   If any  of the promises are rejected the $stateChangeError event is fired.\n   *\n   *   The map object is:\n   *   \n   *   - key - {string}: name of dependency to be injected into controller\n   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, \n   *     it is injected and return value it treated as dependency. If result is a promise, it is \n   *     resolved before its value is injected into controller.\n   *\n   * <pre>resolve: {\n   *     myResolve1:\n   *       function($http, $stateParams) {\n   *         return $http.get(\"/api/foos/\"+stateParams.fooID);\n   *       }\n   *     }</pre>\n   *\n   * @param {string=} stateConfig.url\n   * <a id='url'></a>\n   *\n   *   A url fragment with optional parameters. When a state is navigated or\n   *   transitioned to, the `$stateParams` service will be populated with any \n   *   parameters that were passed.\n   *\n   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for\n   *   more details on acceptable patterns )\n   *\n   * examples:\n   * <pre>url: \"/home\"\n   * url: \"/users/:userid\"\n   * url: \"/books/{bookid:[a-zA-Z_-]}\"\n   * url: \"/books/{categoryid:int}\"\n   * url: \"/books/{publishername:string}/{categoryid:int}\"\n   * url: \"/messages?before&after\"\n   * url: \"/messages?{before:date}&{after:date}\"\n   * url: \"/messages/:mailboxid?{before:date}&{after:date}\"\n   * </pre>\n   *\n   * @param {object=} stateConfig.views\n   * <a id='views'></a>\n   * an optional map&lt;string, object&gt; which defined multiple views, or targets views\n   * manually/explicitly.\n   *\n   * Examples:\n   *\n   * Targets three named `ui-view`s in the parent state's template\n   * <pre>views: {\n   *     header: {\n   *       controller: \"headerCtrl\",\n   *       templateUrl: \"header.html\"\n   *     }, body: {\n   *       controller: \"bodyCtrl\",\n   *       templateUrl: \"body.html\"\n   *     }, footer: {\n   *       controller: \"footCtrl\",\n   *       templateUrl: \"footer.html\"\n   *     }\n   *   }</pre>\n   *\n   * Targets named `ui-view=\"header\"` from grandparent state 'top''s template, and named `ui-view=\"body\" from parent state's template.\n   * <pre>views: {\n   *     'header@top': {\n   *       controller: \"msgHeaderCtrl\",\n   *       templateUrl: \"msgHeader.html\"\n   *     }, 'body': {\n   *       controller: \"messagesCtrl\",\n   *       templateUrl: \"messages.html\"\n   *     }\n   *   }</pre>\n   *\n   * @param {boolean=} [stateConfig.abstract=false]\n   * <a id='abstract'></a>\n   * An abstract state will never be directly activated,\n   *   but can provide inherited properties to its common children states.\n   * <pre>abstract: true</pre>\n   *\n   * @param {function=} stateConfig.onEnter\n   * <a id='onEnter'></a>\n   *\n   * Callback function for when a state is entered. Good way\n   *   to trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onEnter: function(MyService, $stateParams) {\n   *     MyService.foo($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {function=} stateConfig.onExit\n   * <a id='onExit'></a>\n   *\n   * Callback function for when a state is exited. Good way to\n   *   trigger an action or dispatch an event, such as opening a dialog.\n   * If minifying your scripts, make sure to explicitly annotate this function,\n   * because it won't be automatically annotated by your build tools.\n   *\n   * <pre>onExit: function(MyService, $stateParams) {\n   *     MyService.cleanup($stateParams.myParam);\n   * }</pre>\n   *\n   * @param {boolean=} [stateConfig.reloadOnSearch=true]\n   * <a id='reloadOnSearch'></a>\n   *\n   * If `false`, will not retrigger the same state\n   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). \n   *   Useful for when you'd like to modify $location.search() without triggering a reload.\n   * <pre>reloadOnSearch: false</pre>\n   *\n   * @param {object=} stateConfig.data\n   * <a id='data'></a>\n   *\n   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is\n   *   prototypally inherited.  In other words, adding a data property to a state adds it to\n   *   the entire subtree via prototypal inheritance.\n   *\n   * <pre>data: {\n   *     requiredRole: 'foo'\n   * } </pre>\n   *\n   * @param {object=} stateConfig.params\n   * <a id='params'></a>\n   *\n   * A map which optionally configures parameters declared in the `url`, or\n   *   defines additional non-url parameters.  For each parameter being\n   *   configured, add a configuration object keyed to the name of the parameter.\n   *\n   *   Each parameter configuration object may contain the following properties:\n   *\n   *   - ** value ** - {object|function=}: specifies the default value for this\n   *     parameter.  This implicitly sets this parameter as optional.\n   *\n   *     When UI-Router routes to a state and no value is\n   *     specified for this parameter in the URL or transition, the\n   *     default value will be used instead.  If `value` is a function,\n   *     it will be injected and invoked, and the return value used.\n   *\n   *     *Note*: `undefined` is treated as \"no default value\" while `null`\n   *     is treated as \"the default value is `null`\".\n   *\n   *     *Shorthand*: If you only need to configure the default value of the\n   *     parameter, you may use a shorthand syntax.   In the **`params`**\n   *     map, instead mapping the param name to a full parameter configuration\n   *     object, simply set map it to the default parameter value, e.g.:\n   *\n   * <pre>// define a parameter's default value\n   * params: {\n   *     param1: { value: \"defaultValue\" }\n   * }\n   * // shorthand default values\n   * params: {\n   *     param1: \"defaultValue\",\n   *     param2: \"param2Default\"\n   * }</pre>\n   *\n   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be\n   *     treated as an array of values.  If you specified a Type, the value will be\n   *     treated as an array of the specified Type.  Note: query parameter values\n   *     default to a special `\"auto\"` mode.\n   *\n   *     For query parameters in `\"auto\"` mode, if multiple  values for a single parameter\n   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values\n   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if\n   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single\n   *     value (e.g.: `{ foo: '1' }`).\n   *\n   * <pre>params: {\n   *     param1: { array: true }\n   * }</pre>\n   *\n   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when\n   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the\n   *     configured default squash policy.\n   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})\n   *\n   *   There are three squash settings:\n   *\n   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL\n   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed\n   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.\n   *       This can allow for cleaner looking URLs.\n   *     - `\"<arbitrary string>\"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.\n   *\n   * <pre>params: {\n   *     param1: {\n   *       value: \"defaultId\",\n   *       squash: true\n   * } }\n   * // squash \"defaultValue\" to \"~\"\n   * params: {\n   *     param1: {\n   *       value: \"defaultValue\",\n   *       squash: \"~\"\n   * } }\n   * </pre>\n   *\n   *\n   * @example\n   * <pre>\n   * // Some state name examples\n   *\n   * // stateName can be a single top-level name (must be unique).\n   * $stateProvider.state(\"home\", {});\n   *\n   * // Or it can be a nested state name. This state is a child of the\n   * // above \"home\" state.\n   * $stateProvider.state(\"home.newest\", {});\n   *\n   * // Nest states as deeply as needed.\n   * $stateProvider.state(\"home.newest.abc.xyz.inception\", {});\n   *\n   * // state() returns $stateProvider, so you can chain state declarations.\n   * $stateProvider\n   *   .state(\"home\", {})\n   *   .state(\"about\", {})\n   *   .state(\"contacts\", {});\n   * </pre>\n   *\n   */\n  this.state = state;\n  function state(name, definition) {\n    /*jshint validthis: true */\n    if (isObject(name)) definition = name;\n    else definition.name = name;\n    registerState(definition);\n    return this;\n  }\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$state\n   *\n   * @requires $rootScope\n   * @requires $q\n   * @requires ui.router.state.$view\n   * @requires $injector\n   * @requires ui.router.util.$resolve\n   * @requires ui.router.state.$stateParams\n   * @requires ui.router.router.$urlRouter\n   *\n   * @property {object} params A param object, e.g. {sectionId: section.id)}, that \n   * you'd like to test against the current active state.\n   * @property {object} current A reference to the state's config object. However \n   * you passed it in. Useful for accessing custom data.\n   * @property {object} transition Currently pending transition. A promise that'll \n   * resolve or reject.\n   *\n   * @description\n   * `$state` service is responsible for representing states as well as transitioning\n   * between them. It also provides interfaces to ask for current state or even states\n   * you're coming from.\n   */\n  this.$get = $get;\n  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];\n  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {\n\n    var TransitionSuperseded = $q.reject(new Error('transition superseded'));\n    var TransitionPrevented = $q.reject(new Error('transition prevented'));\n    var TransitionAborted = $q.reject(new Error('transition aborted'));\n    var TransitionFailed = $q.reject(new Error('transition failed'));\n\n    // Handles the case where a state which is the target of a transition is not found, and the user\n    // can optionally retry or defer the transition\n    function handleRedirect(redirect, state, params, options) {\n      /**\n       * @ngdoc event\n       * @name ui.router.state.$state#$stateNotFound\n       * @eventOf ui.router.state.$state\n       * @eventType broadcast on root scope\n       * @description\n       * Fired when a requested state **cannot be found** using the provided state name during transition.\n       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by\n       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,\n       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the\n       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.\n       *\n       * @param {Object} event Event object.\n       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.\n       * @param {State} fromState Current state object.\n       * @param {Object} fromParams Current state params.\n       *\n       * @example\n       *\n       * <pre>\n       * // somewhere, assume lazy.state has not been defined\n       * $state.go(\"lazy.state\", {a:1, b:2}, {inherit:false});\n       *\n       * // somewhere else\n       * $scope.$on('$stateNotFound',\n       * function(event, unfoundState, fromState, fromParams){\n       *     console.log(unfoundState.to); // \"lazy.state\"\n       *     console.log(unfoundState.toParams); // {a:1, b:2}\n       *     console.log(unfoundState.options); // {inherit:false} + default options\n       * })\n       * </pre>\n       */\n      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);\n\n      if (evt.defaultPrevented) {\n        $urlRouter.update();\n        return TransitionAborted;\n      }\n\n      if (!evt.retry) {\n        return null;\n      }\n\n      // Allow the handler to return a promise to defer state lookup retry\n      if (options.$retry) {\n        $urlRouter.update();\n        return TransitionFailed;\n      }\n      var retryTransition = $state.transition = $q.when(evt.retry);\n\n      retryTransition.then(function() {\n        if (retryTransition !== $state.transition) return TransitionSuperseded;\n        redirect.options.$retry = true;\n        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);\n      }, function() {\n        return TransitionAborted;\n      });\n      $urlRouter.update();\n\n      return retryTransition;\n    }\n\n    root.locals = { resolve: null, globals: { $stateParams: {} } };\n\n    $state = {\n      params: {},\n      current: root.self,\n      $current: root,\n      transition: null\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#reload\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method that force reloads the current state. All resolves are re-resolved,\n     * controllers reinstantiated, and events re-fired.\n     *\n     * @example\n     * <pre>\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n     *\n     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.\n     * @example\n     * <pre>\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' \n     * //and current state is 'contacts.detail.item'\n     * var app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * </pre>\n     *\n     * `reload()` is just an alias for:\n     * <pre>\n     * $state.transitionTo($state.current, $stateParams, { \n     *   reload: true, inherit: false, notify: true\n     * });\n     * </pre>\n\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.reload = function reload(state) {\n      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#go\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Convenience method for transitioning to a new state. `$state.go` calls \n     * `$state.transitionTo` internally but automatically sets options to \n     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. \n     * This allows you to easily use an absolute or relative to path and specify \n     * only the parameters you'd like to update (while letting unspecified parameters \n     * inherit from the currently active ancestor states).\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * </pre>\n     * <img src='../ngdoc_assets/StateGoExamples.png'/>\n     *\n     * @param {string} to Absolute state name or relative state path. Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to a parent state\n     * - `$state.go('^.sibling')` - will go to a sibling state\n     * - `$state.go('.child.grandchild')` - will go to grandchild state\n     *\n     * @param {object=} params A map of the parameters that will be sent to the state, \n     * will populate $stateParams. Any parameters that are not specified will be inherited from currently \n     * defined parameters. Only parameters specified in the state definition can be overridden, new \n     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters\n     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.\n     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child\n     * will get you all current parameters, etc.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params\n     *    have changed.  It will reload the resolves and views of the current state and parent states.\n     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \\\n     *    the transition reloads the resolves and views for that matched state, and all its children states.\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     *\n     * Possible success values:\n     *\n     * - $state.current\n     *\n     * <br/>Possible rejection values:\n     *\n     * - 'transition superseded' - when a newer transition has been started after this one\n     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener\n     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or\n     *   when a `$stateNotFound` `event.retry` promise errors.\n     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.\n     * - *resolve error* - when an error has occurred with a `resolve`\n     *\n     */\n    $state.go = function go(to, params, options) {\n      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#transitionTo\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}\n     * uses `transitionTo` internally. `$state.go` is recommended in most situations.\n     *\n     * @example\n     * <pre>\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * </pre>\n     *\n     * @param {string} to State name.\n     * @param {object=} toParams A map of the parameters that will be sent to the state,\n     * will populate $stateParams.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`\n     *    will not. If string, must be `\"replace\"`, which will update url and also replace last history record.\n     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.\n     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params \n     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd\n     *    use this when you want to force a reload when *everything* is the same, including search params.\n     *    if String, then will reload the state with the name given in reload, and any children.\n     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.\n     *\n     * @returns {promise} A promise representing the state of the new transition. See\n     * {@link ui.router.state.$state#methods_go $state.go}.\n     */\n    $state.transitionTo = function transitionTo(to, toParams, options) {\n      toParams = toParams || {};\n      options = extend({\n        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false\n      }, options || {});\n\n      var from = $state.$current, fromParams = $state.params, fromPath = from.path;\n      var evt, toState = findState(to, options.relative);\n\n      // Store the hash param for later (since it will be stripped out by various methods)\n      var hash = toParams['#'];\n\n      if (!isDefined(toState)) {\n        var redirect = { to: to, toParams: toParams, options: options };\n        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);\n\n        if (redirectResult) {\n          return redirectResult;\n        }\n\n        // Always retry once if the $stateNotFound was not prevented\n        // (handles either redirect changed or state lazy-definition)\n        to = redirect.to;\n        toParams = redirect.toParams;\n        options = redirect.options;\n        toState = findState(to, options.relative);\n\n        if (!isDefined(toState)) {\n          if (!options.relative) throw new Error(\"No such state '\" + to + \"'\");\n          throw new Error(\"Could not resolve '\" + to + \"' from state '\" + options.relative + \"'\");\n        }\n      }\n      if (toState[abstractKey]) throw new Error(\"Cannot transition to abstract state '\" + to + \"'\");\n      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);\n      if (!toState.params.$$validates(toParams)) return TransitionFailed;\n\n      toParams = toState.params.$$values(toParams);\n      to = toState;\n\n      var toPath = to.path;\n\n      // Starting from the root of the path, keep all levels that haven't changed\n      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];\n\n      if (!options.reload) {\n        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      } else if (isString(options.reload) || isObject(options.reload)) {\n        if (isObject(options.reload) && !options.reload.name) {\n          throw new Error('Invalid reload state object');\n        }\n        \n        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);\n        if (options.reload && !reloadState) {\n          throw new Error(\"No such reload state '\" + (isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        }\n\n        while (state && state === fromPath[keep] && state !== reloadState) {\n          locals = toLocals[keep] = state.locals;\n          keep++;\n          state = toPath[keep];\n        }\n      }\n\n      // If we're going to the same state and all locals are kept, we've got nothing to do.\n      // But clear 'transition', as we still want to cancel any other pending transitions.\n      // TODO: We may not want to bump 'transition' if we're called from a location change\n      // that we've initiated ourselves, because we might accidentally abort a legitimate\n      // transition initiated from code?\n      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {\n        if (hash) toParams['#'] = hash;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);\n        if (options.location && to.navigable && to.navigable.url) {\n          $urlRouter.push(to.navigable.url, toParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n          $urlRouter.update(true);\n        }\n        $state.transition = null;\n        return $q.when($state.current);\n      }\n\n      // Filter parameters before we pass them to event handlers etc.\n      toParams = filterByKeys(to.params.$$keys(), toParams || {});\n      \n      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart\n      if (hash) toParams['#'] = hash;\n      \n      // Broadcast start event and cancel the transition if requested\n      if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeStart\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when the state transition **begins**. You can use `event.preventDefault()`\n         * to prevent the transition from happening and then the transition promise will be\n         * rejected with a `'transition prevented'` value.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         *\n         * @example\n         *\n         * <pre>\n         * $rootScope.$on('$stateChangeStart',\n         * function(event, toState, toParams, fromState, fromParams){\n         *     event.preventDefault();\n         *     // transitionTo() promise will be rejected with\n         *     // a 'transition prevented' error\n         * })\n         * </pre>\n         */\n        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {\n          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);\n          //Don't update and resync url if there's been a new transition started. see issue #2238, #600\n          if ($state.transition == null) $urlRouter.update();\n          return TransitionPrevented;\n        }\n      }\n\n      // Resolve locals for the remaining states, but don't update any global state just\n      // yet -- if anything fails to resolve the current state needs to remain untouched.\n      // We also set up an inheritance chain for the locals here. This allows the view directive\n      // to quickly look up the correct definition for each view in the current state. Even\n      // though we create the locals object itself outside resolveState(), it is initially\n      // empty and gets filled asynchronously. We need to keep track of the promise for the\n      // (fully resolved) current locals, and pass this down the chain.\n      var resolved = $q.when(locals);\n\n      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {\n        locals = toLocals[l] = inherit(locals);\n        resolved = resolveState(state, toParams, state === to, resolved, locals, options);\n      }\n\n      // Once everything is resolved, we are ready to perform the actual transition\n      // and return a promise for the new state. We also keep track of what the\n      // current promise is, so that we can detect overlapping transitions and\n      // keep only the outcome of the last transition.\n      var transition = $state.transition = resolved.then(function () {\n        var l, entering, exiting;\n\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Exit 'from' states not kept\n        for (l = fromPath.length - 1; l >= keep; l--) {\n          exiting = fromPath[l];\n          if (exiting.self.onExit) {\n            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);\n          }\n          exiting.locals = null;\n        }\n\n        // Enter 'to' states not kept\n        for (l = keep; l < toPath.length; l++) {\n          entering = toPath[l];\n          entering.locals = toLocals[l];\n          if (entering.self.onEnter) {\n            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);\n          }\n        }\n\n        // Run it again, to catch any transitions in callbacks\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        // Update globals in $state\n        $state.$current = to;\n        $state.current = to.self;\n        $state.params = toParams;\n        copy($state.params, $stateParams);\n        $state.transition = null;\n\n        if (options.location && to.navigable) {\n          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {\n            $$avoidResync: true, replace: options.location === 'replace'\n          });\n        }\n\n        if (options.notify) {\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeSuccess\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired once the state transition is **complete**.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         */\n          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);\n        }\n        $urlRouter.update(true);\n\n        return $state.current;\n      }, function (error) {\n        if ($state.transition !== transition) return TransitionSuperseded;\n\n        $state.transition = null;\n        /**\n         * @ngdoc event\n         * @name ui.router.state.$state#$stateChangeError\n         * @eventOf ui.router.state.$state\n         * @eventType broadcast on root scope\n         * @description\n         * Fired when an **error occurs** during transition. It's important to note that if you\n         * have any errors in your resolve functions (javascript errors, non-existent services, etc)\n         * they will not throw traditionally. You must listen for this $stateChangeError event to\n         * catch **ALL** errors.\n         *\n         * @param {Object} event Event object.\n         * @param {State} toState The state being transitioned to.\n         * @param {Object} toParams The params supplied to the `toState`.\n         * @param {State} fromState The current state, pre-transition.\n         * @param {Object} fromParams The params supplied to the `fromState`.\n         * @param {Error} error The resolve error object.\n         */\n        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);\n\n        if (!evt.defaultPrevented) {\n            $urlRouter.update();\n        }\n\n        return $q.reject(error);\n      });\n\n      return transition;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#is\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},\n     * but only checks for the full state name. If params is supplied then it will be\n     * tested for strict equality against the current active params object, so all params\n     * must match with none missing and no extras.\n     *\n     * @example\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     * test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it is the state.\n     */\n    $state.is = function is(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) { return undefined; }\n      if ($state.$current !== state) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#includes\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * @example\n     * Partial and relative names\n     * <pre>\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     *\n     * // Using relative names (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * <div ng-class=\"{highlighted: $state.includes('.item')}\">Item</div>\n     * </pre>\n     *\n     * Basic globbing patterns\n     * <pre>\n     * $state.$current.name = 'contacts.details.item.url';\n     *\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * </pre>\n     *\n     * @param {string} stateOrName A partial name, relative name, or glob pattern\n     * to be searched for within the current state name.\n     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,\n     * that you'd like to test against the current active state.\n     * @param {object=} options An options object.  The options are:\n     *\n     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,\n     * .includes will test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    $state.includes = function includes(stateOrName, params, options) {\n      options = extend({ relative: $state.$current }, options || {});\n      if (isString(stateOrName) && isGlob(stateOrName)) {\n        if (!doesStateMatchGlob(stateOrName)) {\n          return false;\n        }\n        stateOrName = $state.$current.name;\n      }\n\n      var state = findState(stateOrName, options.relative);\n      if (!isDefined(state)) { return undefined; }\n      if (!isDefined($state.$current.includes[state.name])) { return false; }\n      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;\n    };\n\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#href\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * A url generation method that returns the compiled url for the given state populated with the given params.\n     *\n     * @example\n     * <pre>\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * </pre>\n     *\n     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.\n     * @param {object=} params An object of parameter values to fill the state's required parameters.\n     * @param {object=} options Options object. The options are:\n     *\n     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the\n     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka\n     *    ancestor with a valid url).\n     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.\n     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), \n     *    defines which state to be relative from.\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * \n     * @returns {string} compiled state url\n     */\n    $state.href = function href(stateOrName, params, options) {\n      options = extend({\n        lossy:    true,\n        inherit:  true,\n        absolute: false,\n        relative: $state.$current\n      }, options || {});\n\n      var state = findState(stateOrName, options.relative);\n\n      if (!isDefined(state)) return null;\n      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);\n      \n      var nav = (state && options.lossy) ? state.navigable : state;\n\n      if (!nav || nav.url === undefined || nav.url === null) {\n        return null;\n      }\n      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {\n        absolute: options.absolute\n      });\n    };\n\n    /**\n     * @ngdoc function\n     * @name ui.router.state.$state#get\n     * @methodOf ui.router.state.$state\n     *\n     * @description\n     * Returns the state configuration object for any specific state or all states.\n     *\n     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for\n     * the requested state. If not provided, returns an array of ALL state configs.\n     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.\n     * @returns {Object|Array} State configuration object or array of all objects.\n     */\n    $state.get = function (stateOrName, context) {\n      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });\n      var state = findState(stateOrName, context || $state.$current);\n      return (state && state.self) ? state.self : null;\n    };\n\n    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {\n      // Make a restricted $stateParams with only the parameters that apply to this state if\n      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,\n      // we also need $stateParams to be available for any $injector calls we make during the\n      // dependency resolution process.\n      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);\n      var locals = { $stateParams: $stateParams };\n\n      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.\n      // We're also including $stateParams in this; that way the parameters are restricted\n      // to the set that should be visible to the state, and are independent of when we update\n      // the global $state and $stateParams values.\n      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);\n      var promises = [dst.resolve.then(function (globals) {\n        dst.globals = globals;\n      })];\n      if (inherited) promises.push(inherited);\n\n      function resolveViews() {\n        var viewsPromises = [];\n\n        // Resolve template and dependencies for all views.\n        forEach(state.views, function (view, name) {\n          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});\n          injectables.$template = [ function () {\n            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';\n          }];\n\n          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {\n            // References to the controller (only instantiated at link time)\n            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {\n              var injectLocals = angular.extend({}, injectables, dst.globals);\n              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);\n            } else {\n              result.$$controller = view.controller;\n            }\n            // Provide access to the state itself for internal use\n            result.$$state = state;\n            result.$$controllerAs = view.controllerAs;\n            dst[name] = result;\n          }));\n        });\n\n        return $q.all(viewsPromises).then(function(){\n          return dst.globals;\n        });\n      }\n\n      // Wait for all the promises and then return the activation object\n      return $q.all(promises).then(resolveViews).then(function (values) {\n        return dst;\n      });\n    }\n\n    return $state;\n  }\n\n  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {\n    // Return true if there are no differences in non-search (path/object) params, false if there are differences\n    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {\n      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.\n      function notSearchParam(key) {\n        return fromAndToState.params[key].location != \"search\";\n      }\n      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);\n      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));\n      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);\n      return nonQueryParamSet.$$equals(fromParams, toParams);\n    }\n\n    // If reload was not explicitly requested\n    // and we're transitioning to the same state we're already in\n    // and    the locals didn't change\n    //     or they changed in a way that doesn't merit reloading\n    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)\n    // Then return true.\n    if (!options.reload && to === from &&\n      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {\n      return true;\n    }\n  }\n}\n\nangular.module('ui.router.state')\n  .factory('$stateParams', function () { return {}; })\n  .provider('$state', $StateProvider);\n\n\n$ViewProvider.$inject = [];\nfunction $ViewProvider() {\n\n  this.$get = $get;\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$view\n   *\n   * @requires ui.router.util.$templateFactory\n   * @requires $rootScope\n   *\n   * @description\n   *\n   */\n  $get.$inject = ['$rootScope', '$templateFactory'];\n  function $get(   $rootScope,   $templateFactory) {\n    return {\n      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })\n      /**\n       * @ngdoc function\n       * @name ui.router.state.$view#load\n       * @methodOf ui.router.state.$view\n       *\n       * @description\n       *\n       * @param {string} name name\n       * @param {object} options option object.\n       */\n      load: function load(name, options) {\n        var result, defaults = {\n          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}\n        };\n        options = extend(defaults, options);\n\n        if (options.view) {\n          result = $templateFactory.fromConfig(options.view, options.params, options.locals);\n        }\n        return result;\n      }\n    };\n  }\n}\n\nangular.module('ui.router.state').provider('$view', $ViewProvider);\n\n/**\n * @ngdoc object\n * @name ui.router.state.$uiViewScrollProvider\n *\n * @description\n * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.\n */\nfunction $ViewScrollProvider() {\n\n  var useAnchorScroll = false;\n\n  /**\n   * @ngdoc function\n   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll\n   * @methodOf ui.router.state.$uiViewScrollProvider\n   *\n   * @description\n   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for\n   * scrolling based on the url anchor.\n   */\n  this.useAnchorScroll = function () {\n    useAnchorScroll = true;\n  };\n\n  /**\n   * @ngdoc object\n   * @name ui.router.state.$uiViewScroll\n   *\n   * @requires $anchorScroll\n   * @requires $timeout\n   *\n   * @description\n   * When called with a jqLite element, it scrolls the element into view (after a\n   * `$timeout` so the DOM has time to refresh).\n   *\n   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,\n   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.\n   */\n  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n    if (useAnchorScroll) {\n      return $anchorScroll;\n    }\n\n    return function ($element) {\n      return $timeout(function () {\n        $element[0].scrollIntoView();\n      }, 0, false);\n    };\n  }];\n}\n\nangular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\nvar ngMajorVer = angular.version.major;\nvar ngMinorVer = angular.version.minor;\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-view\n *\n * @requires ui.router.state.$state\n * @requires $compile\n * @requires $controller\n * @requires $injector\n * @requires ui.router.state.$uiViewScroll\n * @requires $document\n *\n * @restrict ECA\n *\n * @description\n * The ui-view directive tells $state where to place your templates.\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states.\n *\n * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window\n * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll\n * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you\n * scroll ui-view elements into view when they are populated during a state activation.\n *\n * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations\n * will be applied to the ui-view)\n *\n * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)\n * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*\n *\n * @param {string=} onload Expression to evaluate whenever the view updates.\n * \n * @example\n * A view can be unnamed or named. \n * <pre>\n * <!-- Unnamed -->\n * <div ui-view></div> \n * \n * <!-- Named -->\n * <div ui-view=\"viewName\"></div>\n * </pre>\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a \n * single view and it is unnamed then you can populate it like so:\n * <pre>\n * <div ui-view></div> \n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * </pre>\n * \n * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}\n * config property, by name, in this case an empty name:\n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * But typically you'll only use the views property if you name your view or have more than one view \n * in the same template. There's not really a compelling reason to name a view if its the only one, \n * but you could if you wanted, like so:\n * <pre>\n * <div ui-view=\"main\"></div>\n * </pre> \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }    \n * })\n * </pre>\n * \n * Really though, you'll use views to set up multiple views:\n * <pre>\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div> \n * <div ui-view=\"data\"></div> \n * </pre>\n * \n * <pre>\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }    \n * })\n * </pre>\n *\n * Examples for `autoscroll`:\n *\n * <pre>\n * <!-- If autoscroll present with no expression,\n *      then scroll ui-view into view -->\n * <ui-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true -->\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * </pre>\n */\n$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];\nfunction $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {\n\n  function getService() {\n    return ($injector.has) ? function(service) {\n      return $injector.has(service) ? $injector.get(service) : null;\n    } : function(service) {\n      try {\n        return $injector.get(service);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n\n  var service = getService(),\n      $animator = service('$animator'),\n      $animate = service('$animate');\n\n  // Returns a set of DOM manipulation functions based on which Angular version\n  // it should use\n  function getRenderer(attrs, scope) {\n    var statics = {\n      enter: function (element, target, cb) { target.after(element); cb(); },\n      leave: function (element, cb) { element.remove(); cb(); }\n    };\n\n    if (!!attrs.noanimation) return statics;\n\n    function animEnabled(element) {\n      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);\n      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();\n      return (!!$animator);\n    }\n\n    // ng 1.2+\n    if ($animate) {\n      return {\n        enter: function(element, target, cb) {\n          if (!animEnabled(element)) {\n            statics.enter(element, target, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.enter(element, null, target).then(cb);\n          } else {\n            $animate.enter(element, null, target, cb);\n          }\n        },\n        leave: function(element, cb) {\n          if (!animEnabled(element)) {\n            statics.leave(element, cb);\n          } else if (angular.version.minor > 2) {\n            $animate.leave(element).then(cb);\n          } else {\n            $animate.leave(element, cb);\n          }\n        }\n      };\n    }\n\n    // ng 1.1.5\n    if ($animator) {\n      var animate = $animator && $animator(scope, attrs);\n\n      return {\n        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },\n        leave: function(element, cb) { animate.leave(element); cb(); }\n      };\n    }\n\n    return statics;\n  }\n\n  var directive = {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    compile: function (tElement, tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        var previousEl, currentEl, currentScope, latestLocals,\n            onloadExp     = attrs.onload || '',\n            autoScrollExp = attrs.autoscroll,\n            renderer      = getRenderer(attrs, scope);\n\n        scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n\n        updateView(true);\n\n        function cleanupLastView() {\n          var _previousEl = previousEl;\n          var _currentScope = currentScope;\n\n          if (_currentScope) {\n            _currentScope._willBeDestroyed = true;\n          }\n\n          function cleanOld() {\n            if (_previousEl) {\n              _previousEl.remove();\n            }\n\n            if (_currentScope) {\n              _currentScope.$destroy();\n            }\n          }\n\n          if (currentEl) {\n            renderer.leave(currentEl, function() {\n              cleanOld();\n              previousEl = null;\n            });\n\n            previousEl = currentEl;\n          } else {\n            cleanOld();\n            previousEl = null;\n          }\n\n          currentEl = null;\n          currentScope = null;\n        }\n\n        function updateView(firstTime) {\n          var newScope,\n              name            = getUiViewName(scope, attrs, $element, $interpolate),\n              previousLocals  = name && $state.$current && $state.$current.locals[name];\n\n          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do\n          newScope = scope.$new();\n          latestLocals = $state.$current.locals[name];\n\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoading\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           *\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit('$viewContentLoading', name);\n\n          var clone = $transclude(newScope, function(clone) {\n            renderer.enter(clone, $element, function onUiViewEnter() {\n              if(currentScope) {\n                currentScope.$emit('$viewContentAnimationEnded');\n              }\n\n              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                $uiViewScroll(clone);\n              }\n            });\n            cleanupLastView();\n          });\n\n          currentEl = clone;\n          currentScope = newScope;\n          /**\n           * @ngdoc event\n           * @name ui.router.state.directive:ui-view#$viewContentLoaded\n           * @eventOf ui.router.state.directive:ui-view\n           * @eventType emits on ui-view directive scope\n           * @description\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          currentScope.$emit('$viewContentLoaded', name);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    }\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];\nfunction $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    compile: function (tElement) {\n      var initial = tElement.html();\n      return function (scope, $element, attrs) {\n        var current = $state.$current,\n            name = getUiViewName(scope, attrs, $element, $interpolate),\n            locals  = current && current.locals[name];\n\n        if (! locals) {\n          return;\n        }\n\n        $element.data('$uiView', { name: name, state: locals.$$state });\n        $element.html(locals.$template ? locals.$template : initial);\n\n        var link = $compile($element.contents());\n\n        if (locals.$$controller) {\n          locals.$scope = scope;\n          locals.$element = $element;\n          var controller = $controller(locals.$$controller, locals);\n          if (locals.$$controllerAs) {\n            scope[locals.$$controllerAs] = controller;\n          }\n          $element.data('$ngControllerController', controller);\n          $element.children().data('$ngControllerController', controller);\n        }\n\n        link(scope);\n      };\n    }\n  };\n}\n\n/**\n * Shared ui-view code for both directives:\n * Given scope, element, and its attributes, return the view's name\n */\nfunction getUiViewName(scope, attrs, element, $interpolate) {\n  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);\n  var inherited = element.inheritedData('$uiView');\n  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));\n}\n\nangular.module('ui.router.state').directive('uiView', $ViewDirective);\nangular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\nfunction parseStateRef(ref, current) {\n  var preparsed = ref.match(/^\\s*({[^}]*})\\s*$/), parsed;\n  if (preparsed) ref = current + '(' + preparsed[1] + ')';\n  parsed = ref.replace(/\\n/g, \" \").match(/^([^(]+?)\\s*(\\((.*)\\))?$/);\n  if (!parsed || parsed.length !== 4) throw new Error(\"Invalid state ref '\" + ref + \"'\");\n  return { state: parsed[1], paramExpr: parsed[3] || null };\n}\n\nfunction stateContext(el) {\n  var stateData = el.parent().inheritedData('$uiView');\n\n  if (stateData && stateData.state && stateData.state.name) {\n    return stateData.state;\n  }\n}\n\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n  var isForm = el[0].nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : (isSvg ? 'xlink:href' : 'href'),\n    isAnchor: el.prop(\"tagName\").toUpperCase() === \"A\",\n    clickable: !isForm\n  };\n}\n\nfunction clickHook(el, $state, $timeout, type, current) {\n  return function(e) {\n    var button = e.which || e.button, target = current();\n\n    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      var transition = $timeout(function() {\n        $state.go(target.state, target.params, target.options);\n      });\n      e.preventDefault();\n\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;\n\n      e.preventDefault = function() {\n        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);\n      };\n    }\n  };\n}\n\nfunction defaultOpts(el, $state) {\n  return { relative: stateContext(el) || $state.$current, inherit: true };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref\n *\n * @requires ui.router.state.$state\n * @requires $timeout\n *\n * @restrict A\n *\n * @description\n * A directive that binds a link (`<a>` tag) to a state. If the state has an associated\n * URL, the directive will automatically generate & update the `href` attribute via\n * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking\n * the link will trigger a state transition with optional parameters.\n *\n * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be\n * handled natively by the browser.\n *\n * You can also use relative state paths within ui-sref, just like the relative\n * paths passed to `$state.go()`. You just need to be aware that the path is relative\n * to the state that the link lives in, in other words the state that loaded the\n * template containing the link.\n *\n * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}\n * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,\n * and `reload`.\n *\n * @example\n * Here's an example of how you'd use ui-sref and how it would compile. If you have the\n * following template:\n * <pre>\n * <a ui-sref=\"home\">Home</a> | <a ui-sref=\"about\">About</a> | <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * </pre>\n *\n * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):\n * <pre>\n * <a href=\"#/home\" ui-sref=\"home\">Home</a> | <a href=\"#/about\" ui-sref=\"about\">About</a> | <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * </pre>\n *\n * @param {string} ui-sref 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var ref    = parseStateRef(attrs.uiSref, $state.current.name);\n      var def    = { state: ref.state, href: null, params: null };\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n\n      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});\n\n      var update = function(val) {\n        if (val) def.params = angular.copy(val);\n        def.href = $state.href(ref.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(ref.state, def.params);\n        if (def.href !== null) attrs.$set(type.attr, def.href);\n      };\n\n      if (ref.paramExpr) {\n        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);\n        def.params = angular.copy(scope.$eval(ref.paramExpr));\n      }\n      update();\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-state\n *\n * @requires ui.router.state.uiSref\n *\n * @restrict A\n *\n * @description\n * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,\n * params and override options.\n *\n * @param {string} ui-state 'stateName' can be any valid absolute or relative state\n * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}\n * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}\n */\n$StateRefDynamicDirective.$inject = ['$state', '$timeout'];\nfunction $StateRefDynamicDirective($state, $timeout) {\n  return {\n    restrict: 'A',\n    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n    link: function(scope, element, attrs, uiSrefActive) {\n      var type   = getTypeInfo(element);\n      var active = uiSrefActive[1] || uiSrefActive[0];\n      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];\n      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';\n      var def    = { state: null, params: null, options: null, href: null };\n\n      function runStateRefLink (group) {\n        def.state = group[0]; def.params = group[1]; def.options = group[2];\n        def.href = $state.href(def.state, def.params, def.options);\n\n        if (active) active.$$addStateInfo(def.state, def.params);\n        if (def.href) attrs.$set(type.attr, def.href);\n      }\n\n      scope.$watch(watch, runStateRefLink, true);\n      runStateRefLink(scope.$eval(watch));\n\n      if (!type.clickable) return;\n      element.bind(\"click\", clickHook(element, $state, $timeout, type, function() { return def; }));\n    }\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * A directive working alongside ui-sref to add classes to an element when the\n * related ui-sref directive's state is active, and removing them when it is inactive.\n * The primary use-case is to simplify the special appearance of navigation menus\n * relying on `ui-sref`, by having the \"active\" state's menu button appear different,\n * distinguishing it from the inactive menu items.\n *\n * ui-sref-active can live on the same element as ui-sref or on a parent element. The first\n * ui-sref-active found at the same level or above the ui-sref will be used.\n *\n * Will activate when the ui-sref's target state or any child state is active. If you\n * need to activate only when the ui-sref target state is active and *not* any of\n * it's children, then you will use\n * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}\n *\n * @example\n * Given the following template:\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n *\n * When the app state is \"app.user\" (or any children states), and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n * <pre>\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * Multiple classes may be specified in a space-separated format:\n * <pre>\n * <ul>\n *   <li ui-sref-active='class1 class2 class3'>\n *     <a ui-sref=\"app.user\">link</a>\n *   </li>\n * </ul>\n * </pre>\n *\n * It is also possible to pass ui-sref-active an expression that evaluates\n * to an object hash, whose keys represent active class names and whose\n * values represent the respective state names/globs.\n * ui-sref-active will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * @Example\n * Given the following template, with \"admin\" being an abstract state:\n * <pre>\n * <div ui-sref-active=\"{'active': 'admin.*'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * </pre>\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied\n * to both the <div> and <a> elements. It is important to note that the state\n * names/globs passed to ui-sref-active shadow the state provided by ui-sref.\n */\n\n/**\n * @ngdoc directive\n * @name ui.router.state.directive:ui-sref-active-eq\n *\n * @requires ui.router.state.$state\n * @requires ui.router.state.$stateParams\n * @requires $interpolate\n *\n * @restrict A\n *\n * @description\n * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate\n * when the exact target state used in the `ui-sref` is active; no child states.\n *\n */\n$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];\nfunction $StateRefActiveDirective($state, $stateParams, $interpolate) {\n  return  {\n    restrict: \"A\",\n    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {\n      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;\n\n      // There probably isn't much point in $observing this\n      // uiSrefActive and uiSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n\n      try {\n        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n      } catch (e) {\n        // Do nothing. uiSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n      if (isObject(uiSrefActive)) {\n        forEach(uiSrefActive, function(stateOrName, activeClass) {\n          if (isString(stateOrName)) {\n            var ref = parseStateRef(stateOrName, $state.current.name);\n            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n          }\n        });\n      }\n\n      // Allow uiSref to communicate with uiSrefActive[Equals]\n      this.$$addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ui-sref-active, so we\n        // shadow the one that comes from ui-sref\n        if (isObject(uiSrefActive) && states.length > 0) {\n          return;\n        }\n        addState(newState, newParams, uiSrefActive);\n        update();\n      };\n\n      $scope.$on('$stateChangeSuccess', update);\n\n      function addState(stateName, stateParams, activeClass) {\n        var state = $state.get(stateName, stateContext($element));\n        var stateHash = createStateHash(stateName, stateParams);\n\n        states.push({\n          state: state || { name: stateName },\n          params: stateParams,\n          hash: stateHash\n        });\n\n        activeClasses[stateHash] = activeClass;\n      }\n\n      /**\n       * @param {string} state\n       * @param {Object|string} [params]\n       * @return {string}\n       */\n      function createStateHash(state, params) {\n        if (!isString(state)) {\n          throw new Error('state should be a string');\n        }\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        params = $scope.$eval(params);\n        if (isObject(params)) {\n          return state + toJson(params);\n        }\n        return state;\n      }\n\n      // Update route state\n      function update() {\n        for (var i = 0; i < states.length; i++) {\n          if (anyMatch(states[i].state, states[i].params)) {\n            addClass($element, activeClasses[states[i].hash]);\n          } else {\n            removeClass($element, activeClasses[states[i].hash]);\n          }\n\n          if (exactMatch(states[i].state, states[i].params)) {\n            addClass($element, activeEqClass);\n          } else {\n            removeClass($element, activeEqClass);\n          }\n        }\n      }\n\n      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }\n      function removeClass(el, className) { el.removeClass(className); }\n      function anyMatch(state, params) { return $state.includes(state.name, params); }\n      function exactMatch(state, params) { return $state.is(state.name, params); }\n\n      update();\n    }]\n  };\n}\n\nangular.module('ui.router.state')\n  .directive('uiSref', $StateRefDirective)\n  .directive('uiSrefActive', $StateRefActiveDirective)\n  .directive('uiSrefActiveEq', $StateRefActiveDirective)\n  .directive('uiState', $StateRefDynamicDirective);\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:isState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_is $state.is(\"stateName\")}.\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n  var isFilter = function (state, params) {\n    return $state.is(state, params);\n  };\n  isFilter.$stateful = true;\n  return isFilter;\n}\n\n/**\n * @ngdoc filter\n * @name ui.router.state.filter:includedByState\n *\n * @requires ui.router.state.$state\n *\n * @description\n * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n  var includesFilter = function (state, params, options) {\n    return $state.includes(state, params, options);\n  };\n  includesFilter.$stateful = true;\n  return  includesFilter;\n}\n\nangular.module('ui.router.state')\n  .filter('isState', $IsStateFilter)\n  .filter('includedByState', $IncludedByStateFilter);\n})(window, window.angular);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-router/release/angular-ui-router.js\n ** module id = 11\n ** module chunks = 1\n **/","(function (root, factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(['angular'], factory);\n  } else if (root.hasOwnProperty('angular')) {\n    // Browser globals (root is window), we don't register it.\n    factory(root.angular);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('angular'));\n  }\n}(this , function (angular) {\n    'use strict';\n\n    // In cases where Angular does not get passed or angular is a truthy value\n    // but misses .module we can fall back to using window.\n    angular = (angular && angular.module ) ? angular : window.angular;\n\n    /**\n     * @ngdoc overview\n     * @name ngStorage\n     */\n\n    return angular.module('ngStorage', [])\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$localStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$localStorage', _storageProvider('localStorage'))\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$sessionStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\n    function _storageProvider(storageType) {\n        return function () {\n          var storageKeyPrefix = 'ngStorage-';\n\n          this.setKeyPrefix = function (prefix) {\n            if (typeof prefix !== 'string') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n            }\n            storageKeyPrefix = prefix;\n          };\n\n          var serializer = angular.toJson;\n          var deserializer = angular.fromJson;\n\n          this.setSerializer = function (s) {\n            if (typeof s !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n            }\n\n            serializer = s;\n          };\n\n          this.setDeserializer = function (d) {\n            if (typeof d !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n            }\n\n            deserializer = d;\n          };\n\n          // Note: This is not very elegant at all.\n          this.get = function (key) {\n            return deserializer(window[storageType].getItem(storageKeyPrefix + key));\n          };\n\n          // Note: This is not very elegant at all.\n          this.set = function (key, value) {\n            return window[storageType].setItem(storageKeyPrefix + key, serializer(value));\n          };\n\n          this.$get = [\n              '$rootScope',\n              '$window',\n              '$log',\n              '$timeout',\n              '$document',\n\n              function(\n                  $rootScope,\n                  $window,\n                  $log,\n                  $timeout,\n                  $document\n              ){\n                function isStorageSupported(storageType) {\n\n                    // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n                    // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n                    // that error and allow execution to continue.\n\n                    // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n                    // when \"Block cookies\": \"Always block\" is turned on\n                    var supported;\n                    try {\n                        supported = $window[storageType];\n                    }\n                    catch (err) {\n                        supported = false;\n                    }\n\n                    // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage\n                    // is available, but trying to call .setItem throws an exception below:\n                    // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n                    if (supported && storageType === 'localStorage') {\n                        var key = '__' + Math.round(Math.random() * 1e7);\n\n                        try {\n                            localStorage.setItem(key, key);\n                            localStorage.removeItem(key);\n                        }\n                        catch (err) {\n                            supported = false;\n                        }\n                    }\n\n                    return supported;\n                }\n\n                // The magic number 10 is used which only works for some keyPrefixes...\n                // See https://github.com/gsklee/ngStorage/issues/137\n                var prefixLength = storageKeyPrefix.length;\n\n                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n                var webStorage = isStorageSupported(storageType) || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n                    $storage = {\n                        $default: function(items) {\n                            for (var k in items) {\n                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n                            }\n\n                            $storage.$sync();\n                            return $storage;\n                        },\n                        $reset: function(items) {\n                            for (var k in $storage) {\n                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n                            }\n\n                            return $storage.$default(items);\n                        },\n                        $sync: function () {\n                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n                            }\n                        },\n                        $apply: function() {\n                            var temp$storage;\n\n                            _debounce = null;\n\n                            if (!angular.equals($storage, _last$storage)) {\n                                temp$storage = angular.copy(_last$storage);\n                                angular.forEach($storage, function(v, k) {\n                                    if (angular.isDefined(v) && '$' !== k[0]) {\n                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n                                        delete temp$storage[k];\n                                    }\n                                });\n\n                                for (var k in temp$storage) {\n                                    webStorage.removeItem(storageKeyPrefix + k);\n                                }\n\n                                _last$storage = angular.copy($storage);\n                            }\n                        }\n                    },\n                    _last$storage,\n                    _debounce;\n\n                $storage.$sync();\n\n                _last$storage = angular.copy($storage);\n\n                $rootScope.$watch(function() {\n                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n                });\n\n                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n                $window.addEventListener && $window.addEventListener('storage', function(event) {\n                    if (!event.key) {\n                      return;\n                    }\n\n                    // Reference doc.\n                    var doc = $document[0];\n\n                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\n                        _last$storage = angular.copy($storage);\n\n                        $rootScope.$apply();\n                    }\n                });\n\n                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n                    $storage.$apply();\n                });\n\n                return $storage;\n              }\n          ];\n      };\n    }\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ngstorage/ngStorage.js\n ** module id = 12\n ** module chunks = 1\n **/","/**\n * oclazyload - Load modules on demand (lazy load) with angularJS\n * @version v1.0.9\n * @link https://github.com/ocombe/ocLazyLoad\n * @license MIT\n * @author Olivier Combe <olivier.combe@gmail.com>\n */\n(function (angular, window) {\n    'use strict';\n\n    var regModules = ['ng', 'oc.lazyLoad'],\n        regInvokes = {},\n        regConfigs = [],\n        modulesToLoad = [],\n        // modules to load from angular.module or other sources\n    realModules = [],\n        // real modules called from angular.module\n    recordDeclarations = [],\n        broadcast = angular.noop,\n        runBlocks = {},\n        justLoaded = [];\n\n    var ocLazyLoad = angular.module('oc.lazyLoad', ['ng']);\n\n    ocLazyLoad.provider('$ocLazyLoad', [\"$controllerProvider\", \"$provide\", \"$compileProvider\", \"$filterProvider\", \"$injector\", \"$animateProvider\", function ($controllerProvider, $provide, $compileProvider, $filterProvider, $injector, $animateProvider) {\n        var modules = {},\n            providers = {\n            $controllerProvider: $controllerProvider,\n            $compileProvider: $compileProvider,\n            $filterProvider: $filterProvider,\n            $provide: $provide, // other things (constant, decorator, provider, factory, service)\n            $injector: $injector,\n            $animateProvider: $animateProvider\n        },\n            debug = false,\n            events = false,\n            moduleCache = [],\n            modulePromises = {};\n\n        moduleCache.push = function (value) {\n            if (this.indexOf(value) === -1) {\n                Array.prototype.push.apply(this, arguments);\n            }\n        };\n\n        this.config = function (config) {\n            // If we want to define modules configs\n            if (angular.isDefined(config.modules)) {\n                if (angular.isArray(config.modules)) {\n                    angular.forEach(config.modules, function (moduleConfig) {\n                        modules[moduleConfig.name] = moduleConfig;\n                    });\n                } else {\n                    modules[config.modules.name] = config.modules;\n                }\n            }\n\n            if (angular.isDefined(config.debug)) {\n                debug = config.debug;\n            }\n\n            if (angular.isDefined(config.events)) {\n                events = config.events;\n            }\n        };\n\n        /**\n         * Get the list of existing registered modules\n         * @param element\n         */\n        this._init = function _init(element) {\n            // this is probably useless now because we override angular.bootstrap\n            if (modulesToLoad.length === 0) {\n                var elements = [element],\n                    names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n                    NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/,\n                    append = function append(elm) {\n                    return elm && elements.push(elm);\n                };\n\n                angular.forEach(names, function (name) {\n                    names[name] = true;\n                    append(document.getElementById(name));\n                    name = name.replace(':', '\\\\:');\n                    if (typeof element[0] !== 'undefined' && element[0].querySelectorAll) {\n                        angular.forEach(element[0].querySelectorAll('.' + name), append);\n                        angular.forEach(element[0].querySelectorAll('.' + name + '\\\\:'), append);\n                        angular.forEach(element[0].querySelectorAll('[' + name + ']'), append);\n                    }\n                });\n\n                angular.forEach(elements, function (elm) {\n                    if (modulesToLoad.length === 0) {\n                        var className = ' ' + element.className + ' ';\n                        var match = NG_APP_CLASS_REGEXP.exec(className);\n                        if (match) {\n                            modulesToLoad.push((match[2] || '').replace(/\\s+/g, ','));\n                        } else {\n                            angular.forEach(elm.attributes, function (attr) {\n                                if (modulesToLoad.length === 0 && names[attr.name]) {\n                                    modulesToLoad.push(attr.value);\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n\n            if (modulesToLoad.length === 0 && !((window.jasmine || window.mocha) && angular.isDefined(angular.mock))) {\n                console.error('No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad.');\n            }\n\n            var addReg = function addReg(moduleName) {\n                if (regModules.indexOf(moduleName) === -1) {\n                    // register existing modules\n                    regModules.push(moduleName);\n                    var mainModule = angular.module(moduleName);\n\n                    // register existing components (directives, services, ...)\n                    _invokeQueue(null, mainModule._invokeQueue, moduleName);\n                    _invokeQueue(null, mainModule._configBlocks, moduleName); // angular 1.3+\n\n                    angular.forEach(mainModule.requires, addReg);\n                }\n            };\n\n            angular.forEach(modulesToLoad, function (moduleName) {\n                addReg(moduleName);\n            });\n\n            modulesToLoad = []; // reset for next bootstrap\n            recordDeclarations.pop(); // wait for the next lazy load\n        };\n\n        /**\n         * Like JSON.stringify but that doesn't throw on circular references\n         * @param obj\n         */\n        var stringify = function stringify(obj) {\n            try {\n                return JSON.stringify(obj);\n            } catch (e) {\n                var cache = [];\n                return JSON.stringify(obj, function (key, value) {\n                    if (angular.isObject(value) && value !== null) {\n                        if (cache.indexOf(value) !== -1) {\n                            // Circular reference found, discard key\n                            return;\n                        }\n                        // Store value in our collection\n                        cache.push(value);\n                    }\n                    return value;\n                });\n            }\n        };\n\n        var hashCode = function hashCode(str) {\n            var hash = 0,\n                i,\n                chr,\n                len;\n            if (str.length == 0) {\n                return hash;\n            }\n            for (i = 0, len = str.length; i < len; i++) {\n                chr = str.charCodeAt(i);\n                hash = (hash << 5) - hash + chr;\n                hash |= 0; // Convert to 32bit integer\n            }\n            return hash;\n        };\n\n        function _register(providers, registerModules, params) {\n            if (registerModules) {\n                var k,\n                    moduleName,\n                    moduleFn,\n                    tempRunBlocks = [];\n                for (k = registerModules.length - 1; k >= 0; k--) {\n                    moduleName = registerModules[k];\n                    if (!angular.isString(moduleName)) {\n                        moduleName = getModuleName(moduleName);\n                    }\n                    if (!moduleName || justLoaded.indexOf(moduleName) !== -1 || modules[moduleName] && realModules.indexOf(moduleName) === -1) {\n                        continue;\n                    }\n                    // new if not registered\n                    var newModule = regModules.indexOf(moduleName) === -1;\n                    moduleFn = ngModuleFct(moduleName);\n                    if (newModule) {\n                        regModules.push(moduleName);\n                        _register(providers, moduleFn.requires, params);\n                    }\n                    if (moduleFn._runBlocks.length > 0) {\n                        // new run blocks detected! Replace the old ones (if existing)\n                        runBlocks[moduleName] = [];\n                        while (moduleFn._runBlocks.length > 0) {\n                            runBlocks[moduleName].push(moduleFn._runBlocks.shift());\n                        }\n                    }\n                    if (angular.isDefined(runBlocks[moduleName]) && (newModule || params.rerun)) {\n                        tempRunBlocks = tempRunBlocks.concat(runBlocks[moduleName]);\n                    }\n                    _invokeQueue(providers, moduleFn._invokeQueue, moduleName, params.reconfig);\n                    _invokeQueue(providers, moduleFn._configBlocks, moduleName, params.reconfig); // angular 1.3+\n                    broadcast(newModule ? 'ocLazyLoad.moduleLoaded' : 'ocLazyLoad.moduleReloaded', moduleName);\n                    registerModules.pop();\n                    justLoaded.push(moduleName);\n                }\n                // execute the run blocks at the end\n                var instanceInjector = providers.getInstanceInjector();\n                angular.forEach(tempRunBlocks, function (fn) {\n                    instanceInjector.invoke(fn);\n                });\n            }\n        }\n\n        function _registerInvokeList(args, moduleName) {\n            var invokeList = args[2][0],\n                type = args[1],\n                newInvoke = false;\n            if (angular.isUndefined(regInvokes[moduleName])) {\n                regInvokes[moduleName] = {};\n            }\n            if (angular.isUndefined(regInvokes[moduleName][type])) {\n                regInvokes[moduleName][type] = {};\n            }\n            var onInvoke = function onInvoke(invokeName, invoke) {\n                if (!regInvokes[moduleName][type].hasOwnProperty(invokeName)) {\n                    regInvokes[moduleName][type][invokeName] = [];\n                }\n                if (checkHashes(invoke, regInvokes[moduleName][type][invokeName])) {\n                    newInvoke = true;\n                    regInvokes[moduleName][type][invokeName].push(invoke);\n                    broadcast('ocLazyLoad.componentLoaded', [moduleName, type, invokeName]);\n                }\n            };\n\n            function checkHashes(potentialNew, invokes) {\n                var isNew = true,\n                    newHash;\n                if (invokes.length) {\n                    newHash = signature(potentialNew);\n                    angular.forEach(invokes, function (invoke) {\n                        isNew = isNew && signature(invoke) !== newHash;\n                    });\n                }\n                return isNew;\n            }\n\n            function signature(data) {\n                if (angular.isArray(data)) {\n                    // arrays are objects, we need to test for it first\n                    return hashCode(data.toString());\n                } else if (angular.isObject(data)) {\n                    // constants & values for example\n                    return hashCode(stringify(data));\n                } else {\n                    if (angular.isDefined(data) && data !== null) {\n                        return hashCode(data.toString());\n                    } else {\n                        // null & undefined constants\n                        return data;\n                    }\n                }\n            }\n\n            if (angular.isString(invokeList)) {\n                onInvoke(invokeList, args[2][1]);\n            } else if (angular.isObject(invokeList)) {\n                angular.forEach(invokeList, function (invoke, key) {\n                    if (angular.isString(invoke)) {\n                        // decorators for example\n                        onInvoke(invoke, invokeList[1]);\n                    } else {\n                        // components registered as object lists {\"componentName\": function() {}}\n                        onInvoke(key, invoke);\n                    }\n                });\n            } else {\n                return false;\n            }\n            return newInvoke;\n        }\n\n        function _invokeQueue(providers, queue, moduleName, reconfig) {\n            if (!queue) {\n                return;\n            }\n\n            var i, len, args, provider;\n            for (i = 0, len = queue.length; i < len; i++) {\n                args = queue[i];\n                if (angular.isArray(args)) {\n                    if (providers !== null) {\n                        if (providers.hasOwnProperty(args[0])) {\n                            provider = providers[args[0]];\n                        } else {\n                            throw new Error('unsupported provider ' + args[0]);\n                        }\n                    }\n                    var isNew = _registerInvokeList(args, moduleName);\n                    if (args[1] !== 'invoke') {\n                        if (isNew && angular.isDefined(provider)) {\n                            provider[args[1]].apply(provider, args[2]);\n                        }\n                    } else {\n                        // config block\n                        var callInvoke = function callInvoke(fct) {\n                            var invoked = regConfigs.indexOf(moduleName + '-' + fct);\n                            if (invoked === -1 || reconfig) {\n                                if (invoked === -1) {\n                                    regConfigs.push(moduleName + '-' + fct);\n                                }\n                                if (angular.isDefined(provider)) {\n                                    provider[args[1]].apply(provider, args[2]);\n                                }\n                            }\n                        };\n                        if (angular.isFunction(args[2][0])) {\n                            callInvoke(args[2][0]);\n                        } else if (angular.isArray(args[2][0])) {\n                            for (var j = 0, jlen = args[2][0].length; j < jlen; j++) {\n                                if (angular.isFunction(args[2][0][j])) {\n                                    callInvoke(args[2][0][j]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function getModuleName(module) {\n            var moduleName = null;\n            if (angular.isString(module)) {\n                moduleName = module;\n            } else if (angular.isObject(module) && module.hasOwnProperty('name') && angular.isString(module.name)) {\n                moduleName = module.name;\n            }\n            return moduleName;\n        }\n\n        function moduleExists(moduleName) {\n            if (!angular.isString(moduleName)) {\n                return false;\n            }\n            try {\n                return ngModuleFct(moduleName);\n            } catch (e) {\n                if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                    return false;\n                }\n            }\n        }\n\n        this.$get = [\"$log\", \"$rootElement\", \"$rootScope\", \"$cacheFactory\", \"$q\", function ($log, $rootElement, $rootScope, $cacheFactory, $q) {\n            var instanceInjector,\n                filesCache = $cacheFactory('ocLazyLoad');\n\n            if (!debug) {\n                $log = {};\n                $log['error'] = angular.noop;\n                $log['warn'] = angular.noop;\n                $log['info'] = angular.noop;\n            }\n\n            // Make this lazy because when $get() is called the instance injector hasn't been assigned to the rootElement yet\n            providers.getInstanceInjector = function () {\n                return instanceInjector ? instanceInjector : instanceInjector = $rootElement.data('$injector') || angular.injector();\n            };\n\n            broadcast = function broadcast(eventName, params) {\n                if (events) {\n                    $rootScope.$broadcast(eventName, params);\n                }\n                if (debug) {\n                    $log.info(eventName, params);\n                }\n            };\n\n            function reject(e) {\n                var deferred = $q.defer();\n                $log.error(e.message);\n                deferred.reject(e);\n                return deferred.promise;\n            }\n\n            return {\n                _broadcast: broadcast,\n\n                _$log: $log,\n\n                /**\n                 * Returns the files cache used by the loaders to store the files currently loading\n                 * @returns {*}\n                 */\n                _getFilesCache: function getFilesCache() {\n                    return filesCache;\n                },\n\n                /**\n                 * Let the service know that it should monitor angular.module because files are loading\n                 * @param watch boolean\n                 */\n                toggleWatch: function toggleWatch(watch) {\n                    if (watch) {\n                        recordDeclarations.push(true);\n                    } else {\n                        recordDeclarations.pop();\n                    }\n                },\n\n                /**\n                 * Let you get a module config object\n                 * @param moduleName String the name of the module\n                 * @returns {*}\n                 */\n                getModuleConfig: function getModuleConfig(moduleName) {\n                    if (!angular.isString(moduleName)) {\n                        throw new Error('You need to give the name of the module to get');\n                    }\n                    if (!modules[moduleName]) {\n                        return null;\n                    }\n                    return angular.copy(modules[moduleName]);\n                },\n\n                /**\n                 * Let you define a module config object\n                 * @param moduleConfig Object the module config object\n                 * @returns {*}\n                 */\n                setModuleConfig: function setModuleConfig(moduleConfig) {\n                    if (!angular.isObject(moduleConfig)) {\n                        throw new Error('You need to give the module config object to set');\n                    }\n                    modules[moduleConfig.name] = moduleConfig;\n                    return moduleConfig;\n                },\n\n                /**\n                 * Returns the list of loaded modules\n                 * @returns {string[]}\n                 */\n                getModules: function getModules() {\n                    return regModules;\n                },\n\n                /**\n                 * Let you check if a module has been loaded into Angular or not\n                 * @param modulesNames String/Object a module name, or a list of module names\n                 * @returns {boolean}\n                 */\n                isLoaded: function isLoaded(modulesNames) {\n                    var moduleLoaded = function moduleLoaded(module) {\n                        var isLoaded = regModules.indexOf(module) > -1;\n                        if (!isLoaded) {\n                            isLoaded = !!moduleExists(module);\n                        }\n                        return isLoaded;\n                    };\n                    if (angular.isString(modulesNames)) {\n                        modulesNames = [modulesNames];\n                    }\n                    if (angular.isArray(modulesNames)) {\n                        var i, len;\n                        for (i = 0, len = modulesNames.length; i < len; i++) {\n                            if (!moduleLoaded(modulesNames[i])) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    } else {\n                        throw new Error('You need to define the module(s) name(s)');\n                    }\n                },\n\n                /**\n                 * Given a module, return its name\n                 * @param module\n                 * @returns {String}\n                 */\n                _getModuleName: getModuleName,\n\n                /**\n                 * Returns a module if it exists\n                 * @param moduleName\n                 * @returns {module}\n                 */\n                _getModule: function getModule(moduleName) {\n                    try {\n                        return ngModuleFct(moduleName);\n                    } catch (e) {\n                        // this error message really suxx\n                        if (/No module/.test(e) || e.message.indexOf('$injector:nomod') > -1) {\n                            e.message = 'The module \"' + stringify(moduleName) + '\" that you are trying to load does not exist. ' + e.message;\n                        }\n                        throw e;\n                    }\n                },\n\n                /**\n                 * Check if a module exists and returns it if it does\n                 * @param moduleName\n                 * @returns {boolean}\n                 */\n                moduleExists: moduleExists,\n\n                /**\n                 * Load the dependencies, and might try to load new files depending on the config\n                 * @param moduleName (String or Array of Strings)\n                 * @param localParams\n                 * @returns {*}\n                 * @private\n                 */\n                _loadDependencies: function _loadDependencies(moduleName, localParams) {\n                    var loadedModule,\n                        requires,\n                        diff,\n                        promisesList = [],\n                        self = this;\n\n                    moduleName = self._getModuleName(moduleName);\n\n                    if (moduleName === null) {\n                        return $q.when();\n                    } else {\n                        try {\n                            loadedModule = self._getModule(moduleName);\n                        } catch (e) {\n                            return reject(e);\n                        }\n                        // get unloaded requires\n                        requires = self.getRequires(loadedModule);\n                    }\n\n                    angular.forEach(requires, function (requireEntry) {\n                        // If no configuration is provided, try and find one from a previous load.\n                        // If there isn't one, bail and let the normal flow run\n                        if (angular.isString(requireEntry)) {\n                            var config = self.getModuleConfig(requireEntry);\n                            if (config === null) {\n                                moduleCache.push(requireEntry); // We don't know about this module, but something else might, so push it anyway.\n                                return;\n                            }\n                            requireEntry = config;\n                            // ignore the name because it's probably not a real module name\n                            config.name = undefined;\n                        }\n\n                        // Check if this dependency has been loaded previously\n                        if (self.moduleExists(requireEntry.name)) {\n                            // compare against the already loaded module to see if the new definition adds any new files\n                            diff = requireEntry.files.filter(function (n) {\n                                return self.getModuleConfig(requireEntry.name).files.indexOf(n) < 0;\n                            });\n\n                            // If the module was redefined, advise via the console\n                            if (diff.length !== 0) {\n                                self._$log.warn('Module \"', moduleName, '\" attempted to redefine configuration for dependency. \"', requireEntry.name, '\"\\n Additional Files Loaded:', diff);\n                            }\n\n                            // Push everything to the file loader, it will weed out the duplicates.\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: New dependencies need to be loaded from external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                            return;\n                        } else if (angular.isArray(requireEntry)) {\n                            var files = [];\n                            angular.forEach(requireEntry, function (entry) {\n                                // let's check if the entry is a file name or a config name\n                                var config = self.getModuleConfig(entry);\n                                if (config === null) {\n                                    files.push(entry);\n                                } else if (config.files) {\n                                    files = files.concat(config.files);\n                                }\n                            });\n                            if (files.length > 0) {\n                                requireEntry = {\n                                    files: files\n                                };\n                            }\n                        } else if (angular.isObject(requireEntry)) {\n                            if (requireEntry.hasOwnProperty('name') && requireEntry['name']) {\n                                // The dependency doesn't exist in the module cache and is a new configuration, so store and push it.\n                                self.setModuleConfig(requireEntry);\n                                moduleCache.push(requireEntry['name']);\n                            }\n                        }\n\n                        // Check if the dependency has any files that need to be loaded. If there are, push a new promise to the promise list.\n                        if (angular.isDefined(requireEntry.files) && requireEntry.files.length !== 0) {\n                            if (angular.isDefined(self.filesLoader)) {\n                                // if a files loader is defined\n                                promisesList.push(self.filesLoader(requireEntry, localParams).then(function () {\n                                    return self._loadDependencies(requireEntry);\n                                }));\n                            } else {\n                                return reject(new Error('Error: the module \"' + requireEntry.name + '\" is defined in external files (' + requireEntry.files + '), but no loader has been defined.'));\n                            }\n                        }\n                    });\n\n                    // Create a wrapper promise to watch the promise list and resolve it once everything is done.\n                    return $q.all(promisesList);\n                },\n\n                /**\n                 * Inject new modules into Angular\n                 * @param moduleName\n                 * @param localParams\n                 * @param real\n                 */\n                inject: function inject(moduleName) {\n                    var localParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n                    var real = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n                    var self = this,\n                        deferred = $q.defer();\n                    if (angular.isDefined(moduleName) && moduleName !== null) {\n                        if (angular.isArray(moduleName)) {\n                            var promisesList = [];\n                            angular.forEach(moduleName, function (module) {\n                                promisesList.push(self.inject(module, localParams, real));\n                            });\n                            return $q.all(promisesList);\n                        } else {\n                            self._addToLoadList(self._getModuleName(moduleName), true, real);\n                        }\n                    }\n                    if (modulesToLoad.length > 0) {\n                        var res = modulesToLoad.slice(); // clean copy\n                        var loadNext = function loadNext(moduleName) {\n                            moduleCache.push(moduleName);\n                            modulePromises[moduleName] = deferred.promise;\n                            self._loadDependencies(moduleName, localParams).then(function success() {\n                                try {\n                                    justLoaded = [];\n                                    _register(providers, moduleCache, localParams);\n                                } catch (e) {\n                                    self._$log.error(e.message);\n                                    deferred.reject(e);\n                                    return;\n                                }\n\n                                if (modulesToLoad.length > 0) {\n                                    loadNext(modulesToLoad.shift()); // load the next in list\n                                } else {\n                                        deferred.resolve(res); // everything has been loaded, resolve\n                                    }\n                            }, function error(err) {\n                                deferred.reject(err);\n                            });\n                        };\n\n                        // load the first in list\n                        loadNext(modulesToLoad.shift());\n                    } else if (localParams && localParams.name && modulePromises[localParams.name]) {\n                        return modulePromises[localParams.name];\n                    } else {\n                        deferred.resolve();\n                    }\n                    return deferred.promise;\n                },\n\n                /**\n                 * Get the list of required modules/services/... for this module\n                 * @param module\n                 * @returns {Array}\n                 */\n                getRequires: function getRequires(module) {\n                    var requires = [];\n                    angular.forEach(module.requires, function (requireModule) {\n                        if (regModules.indexOf(requireModule) === -1) {\n                            requires.push(requireModule);\n                        }\n                    });\n                    return requires;\n                },\n\n                /**\n                 * Invoke the new modules & component by their providers\n                 * @param providers\n                 * @param queue\n                 * @param moduleName\n                 * @param reconfig\n                 * @private\n                 */\n                _invokeQueue: _invokeQueue,\n\n                /**\n                 * Check if a module has been invoked and registers it if not\n                 * @param args\n                 * @param moduleName\n                 * @returns {boolean} is new\n                 */\n                _registerInvokeList: _registerInvokeList,\n\n                /**\n                 * Register a new module and loads it, executing the run/config blocks if needed\n                 * @param providers\n                 * @param registerModules\n                 * @param params\n                 * @private\n                 */\n                _register: _register,\n\n                /**\n                 * Add a module name to the list of modules that will be loaded in the next inject\n                 * @param name\n                 * @param force\n                 * @private\n                 */\n                _addToLoadList: _addToLoadList,\n\n                /**\n                 * Unregister modules (you shouldn't have to use this)\n                 * @param modules\n                 */\n                _unregister: function _unregister(modules) {\n                    if (angular.isDefined(modules)) {\n                        if (angular.isArray(modules)) {\n                            angular.forEach(modules, function (module) {\n                                regInvokes[module] = undefined;\n                            });\n                        }\n                    }\n                }\n            };\n        }];\n\n        // Let's get the list of loaded modules & components\n        this._init(angular.element(window.document));\n    }]);\n\n    var bootstrapFct = angular.bootstrap;\n    angular.bootstrap = function (element, modules, config) {\n        // we use slice to make a clean copy\n        angular.forEach(modules.slice(), function (module) {\n            _addToLoadList(module, true, true);\n        });\n        return bootstrapFct(element, modules, config);\n    };\n\n    var _addToLoadList = function _addToLoadList(name, force, real) {\n        if ((recordDeclarations.length > 0 || force) && angular.isString(name) && modulesToLoad.indexOf(name) === -1) {\n            modulesToLoad.push(name);\n            if (real) {\n                realModules.push(name);\n            }\n        }\n    };\n\n    var ngModuleFct = angular.module;\n    angular.module = function (name, requires, configFn) {\n        _addToLoadList(name, false, true);\n        return ngModuleFct(name, requires, configFn);\n    };\n\n    // CommonJS package manager support:\n    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {\n        module.exports = 'oc.lazyLoad';\n    }\n})(angular, window);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').directive('ocLazyLoad', [\"$ocLazyLoad\", \"$compile\", \"$animate\", \"$parse\", \"$timeout\", function ($ocLazyLoad, $compile, $animate, $parse, $timeout) {\n        return {\n            restrict: 'A',\n            terminal: true,\n            priority: 1000,\n            compile: function compile(element, attrs) {\n                // we store the content and remove it before compilation\n                var content = element[0].innerHTML;\n                element.html('');\n\n                return function ($scope, $element, $attr) {\n                    var model = $parse($attr.ocLazyLoad);\n                    $scope.$watch(function () {\n                        return model($scope) || $attr.ocLazyLoad; // it can be a module name (string), an object, an array, or a scope reference to any of this\n                    }, function (moduleName) {\n                        if (angular.isDefined(moduleName)) {\n                            $ocLazyLoad.load(moduleName).then(function () {\n                                // Attach element contents to DOM and then compile them.\n                                // This prevents an issue where IE invalidates saved element objects (HTMLCollections)\n                                // of the compiled contents when attaching to the parent DOM.\n                                $animate.enter(content, $element);\n                                // get the new content & compile it\n                                $compile($element.contents())($scope);\n                            });\n                        }\n                    }, true);\n                };\n            }\n        };\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", \"$window\", \"$interval\", function ($delegate, $q, $window, $interval) {\n            var uaCssChecked = false,\n                useCssLoadPatch = false,\n                anchor = $window.document.getElementsByTagName('head')[0] || $window.document.getElementsByTagName('body')[0];\n\n            /**\r\n             * Load a js/css file\r\n             * @param type\r\n             * @param path\r\n             * @param params\r\n             * @returns promise\r\n             */\n            $delegate.buildElement = function buildElement(type, path, params) {\n                var deferred = $q.defer(),\n                    el,\n                    loaded,\n                    filesCache = $delegate._getFilesCache(),\n                    cacheBuster = function cacheBuster(url) {\n                    var dc = new Date().getTime();\n                    if (url.indexOf('?') >= 0) {\n                        if (url.substring(0, url.length - 1) === '&') {\n                            return url + '_dc=' + dc;\n                        }\n                        return url + '&_dc=' + dc;\n                    } else {\n                        return url + '?_dc=' + dc;\n                    }\n                };\n\n                // Store the promise early so the file load can be detected by other parallel lazy loads\n                // (ie: multiple routes on one page) a 'true' value isn't sufficient\n                // as it causes false positive load results.\n                if (angular.isUndefined(filesCache.get(path))) {\n                    filesCache.put(path, deferred.promise);\n                }\n\n                // Switch in case more content types are added later\n                switch (type) {\n                    case 'css':\n                        el = $window.document.createElement('link');\n                        el.type = 'text/css';\n                        el.rel = 'stylesheet';\n                        el.href = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    case 'js':\n                        el = $window.document.createElement('script');\n                        el.src = params.cache === false ? cacheBuster(path) : path;\n                        break;\n                    default:\n                        filesCache.remove(path);\n                        deferred.reject(new Error('Requested type \"' + type + '\" is not known. Could not inject \"' + path + '\"'));\n                        break;\n                }\n                el.onload = el['onreadystatechange'] = function (e) {\n                    if (el['readyState'] && !/^c|loade/.test(el['readyState']) || loaded) return;\n                    el.onload = el['onreadystatechange'] = null;\n                    loaded = 1;\n                    $delegate._broadcast('ocLazyLoad.fileLoaded', path);\n                    deferred.resolve();\n                };\n                el.onerror = function () {\n                    filesCache.remove(path);\n                    deferred.reject(new Error('Unable to load ' + path));\n                };\n                el.async = params.serie ? 0 : 1;\n\n                var insertBeforeElem = anchor.lastChild;\n                if (params.insertBefore) {\n                    var element = angular.element(angular.isDefined(window.jQuery) ? params.insertBefore : document.querySelector(params.insertBefore));\n                    if (element && element.length > 0) {\n                        insertBeforeElem = element[0];\n                    }\n                }\n                insertBeforeElem.parentNode.insertBefore(el, insertBeforeElem);\n\n                /*\r\n                 The event load or readystatechange doesn't fire in:\r\n                 - iOS < 6       (default mobile browser)\r\n                 - Android < 4.4 (default mobile browser)\r\n                 - Safari < 6    (desktop browser)\r\n                 */\n                if (type == 'css') {\n                    if (!uaCssChecked) {\n                        var ua = $window.navigator.userAgent.toLowerCase();\n\n                        // iOS < 6\n                        if (/iP(hone|od|ad)/.test($window.navigator.platform)) {\n                            var v = $window.navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n                            var iOSVersion = parseFloat([parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)].join('.'));\n                            useCssLoadPatch = iOSVersion < 6;\n                        } else if (ua.indexOf(\"android\") > -1) {\n                            // Android < 4.4\n                            var androidVersion = parseFloat(ua.slice(ua.indexOf(\"android\") + 8));\n                            useCssLoadPatch = androidVersion < 4.4;\n                        } else if (ua.indexOf('safari') > -1) {\n                            var versionMatch = ua.match(/version\\/([\\.\\d]+)/i);\n                            useCssLoadPatch = versionMatch && versionMatch[1] && parseFloat(versionMatch[1]) < 6;\n                        }\n                    }\n\n                    if (useCssLoadPatch) {\n                        var tries = 1000; // * 20 = 20000 miliseconds\n                        var interval = $interval(function () {\n                            try {\n                                el.sheet.cssRules;\n                                $interval.cancel(interval);\n                                el.onload();\n                            } catch (e) {\n                                if (--tries <= 0) {\n                                    el.onerror();\n                                }\n                            }\n                        }, 20);\n                    }\n                }\n\n                return deferred.promise;\n            };\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\r\n             * The function that loads new files\r\n             * @param config\r\n             * @param params\r\n             * @returns {*}\r\n             */\n            $delegate.filesLoader = function filesLoader(config) {\n                var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var cssFiles = [],\n                    templatesFiles = [],\n                    jsFiles = [],\n                    promises = [],\n                    cachePromise = null,\n                    filesCache = $delegate._getFilesCache();\n\n                $delegate.toggleWatch(true); // start watching angular.module calls\n\n                angular.extend(params, config);\n\n                var pushFile = function pushFile(path) {\n                    var file_type = null,\n                        m;\n                    if (angular.isObject(path)) {\n                        file_type = path.type;\n                        path = path.path;\n                    }\n                    cachePromise = filesCache.get(path);\n                    if (angular.isUndefined(cachePromise) || params.cache === false) {\n\n                        // always check for requirejs syntax just in case\n                        if ((m = /^(css|less|html|htm|js)?(?=!)/.exec(path)) !== null) {\n                            // Detect file type using preceding type declaration (ala requireJS)\n                            file_type = m[1];\n                            path = path.substr(m[1].length + 1, path.length); // Strip the type from the path\n                        }\n\n                        if (!file_type) {\n                            if ((m = /[.](css|less|html|htm|js)?((\\?|#).*)?$/.exec(path)) !== null) {\n                                // Detect file type via file extension\n                                file_type = m[1];\n                            } else if (!$delegate.jsLoader.hasOwnProperty('ocLazyLoadLoader') && $delegate.jsLoader.hasOwnProperty('requirejs')) {\n                                // requirejs\n                                file_type = 'js';\n                            } else {\n                                $delegate._$log.error('File type could not be determined. ' + path);\n                                return;\n                            }\n                        }\n\n                        if ((file_type === 'css' || file_type === 'less') && cssFiles.indexOf(path) === -1) {\n                            cssFiles.push(path);\n                        } else if ((file_type === 'html' || file_type === 'htm') && templatesFiles.indexOf(path) === -1) {\n                            templatesFiles.push(path);\n                        } else if (file_type === 'js' || jsFiles.indexOf(path) === -1) {\n                            jsFiles.push(path);\n                        } else {\n                            $delegate._$log.error('File type is not valid. ' + path);\n                        }\n                    } else if (cachePromise) {\n                        promises.push(cachePromise);\n                    }\n                };\n\n                if (params.serie) {\n                    pushFile(params.files.shift());\n                } else {\n                    angular.forEach(params.files, function (path) {\n                        pushFile(path);\n                    });\n                }\n\n                if (cssFiles.length > 0) {\n                    var cssDeferred = $q.defer();\n                    $delegate.cssLoader(cssFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.cssLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            cssDeferred.reject(err);\n                        } else {\n                            cssDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(cssDeferred.promise);\n                }\n\n                if (templatesFiles.length > 0) {\n                    var templatesDeferred = $q.defer();\n                    $delegate.templatesLoader(templatesFiles, function (err) {\n                        if (angular.isDefined(err) && $delegate.templatesLoader.hasOwnProperty('ocLazyLoadLoader')) {\n                            $delegate._$log.error(err);\n                            templatesDeferred.reject(err);\n                        } else {\n                            templatesDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(templatesDeferred.promise);\n                }\n\n                if (jsFiles.length > 0) {\n                    var jsDeferred = $q.defer();\n                    $delegate.jsLoader(jsFiles, function (err) {\n                        if (angular.isDefined(err) && ($delegate.jsLoader.hasOwnProperty(\"ocLazyLoadLoader\") || $delegate.jsLoader.hasOwnProperty(\"requirejs\"))) {\n                            $delegate._$log.error(err);\n                            jsDeferred.reject(err);\n                        } else {\n                            jsDeferred.resolve();\n                        }\n                    }, params);\n                    promises.push(jsDeferred.promise);\n                }\n\n                if (promises.length === 0) {\n                    var deferred = $q.defer(),\n                        err = \"Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'.\";\n                    $delegate._$log.error(err);\n                    deferred.reject(err);\n                    return deferred.promise;\n                } else if (params.serie && params.files.length > 0) {\n                    return $q.all(promises).then(function () {\n                        return $delegate.filesLoader(config, params);\n                    });\n                } else {\n                    return $q.all(promises)['finally'](function (res) {\n                        $delegate.toggleWatch(false); // stop watching angular.module calls\n                        return res;\n                    });\n                }\n            };\n\n            /**\r\n             * Load a module or a list of modules into Angular\r\n             * @param module Mixed the name of a predefined module config object, or a module config object, or an array of either\r\n             * @param params Object optional parameters\r\n             * @returns promise\r\n             */\n            $delegate.load = function (originalModule) {\n                var originalParams = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n                var self = this,\n                    config = null,\n                    deferredList = [],\n                    deferred = $q.defer(),\n                    errText;\n\n                // clean copy\n                var module = angular.copy(originalModule);\n                var params = angular.copy(originalParams);\n\n                // If module is an array, break it down\n                if (angular.isArray(module)) {\n                    // Resubmit each entry as a single module\n                    angular.forEach(module, function (m) {\n                        deferredList.push(self.load(m, params));\n                    });\n\n                    // Resolve the promise once everything has loaded\n                    $q.all(deferredList).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n\n                    return deferred.promise;\n                }\n\n                // Get or Set a configuration depending on what was passed in\n                if (angular.isString(module)) {\n                    config = self.getModuleConfig(module);\n                    if (!config) {\n                        config = {\n                            files: [module]\n                        };\n                    }\n                } else if (angular.isObject(module)) {\n                    // case {type: 'js', path: lazyLoadUrl + 'testModule.fakejs'}\n                    if (angular.isDefined(module.path) && angular.isDefined(module.type)) {\n                        config = {\n                            files: [module]\n                        };\n                    } else {\n                        config = self.setModuleConfig(module);\n                    }\n                }\n\n                if (config === null) {\n                    var moduleName = self._getModuleName(module);\n                    errText = 'Module \"' + (moduleName || 'unknown') + '\" is not configured, cannot load.';\n                    $delegate._$log.error(errText);\n                    deferred.reject(new Error(errText));\n                    return deferred.promise;\n                } else {\n                    // deprecated\n                    if (angular.isDefined(config.template)) {\n                        if (angular.isUndefined(config.files)) {\n                            config.files = [];\n                        }\n                        if (angular.isString(config.template)) {\n                            config.files.push(config.template);\n                        } else if (angular.isArray(config.template)) {\n                            config.files.concat(config.template);\n                        }\n                    }\n                }\n\n                var localParams = angular.extend({}, params, config);\n\n                // if someone used an external loader and called the load function with just the module name\n                if (angular.isUndefined(config.files) && angular.isDefined(config.name) && $delegate.moduleExists(config.name)) {\n                    return $delegate.inject(config.name, localParams, true);\n                }\n\n                $delegate.filesLoader(config, localParams).then(function () {\n                    $delegate.inject(null, localParams).then(function (res) {\n                        deferred.resolve(res);\n                    }, function (err) {\n                        deferred.reject(err);\n                    });\n                }, function (err) {\n                    deferred.reject(err);\n                });\n\n                return deferred.promise;\n            };\n\n            // return the patched service\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * cssLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite cssLoader and it will probably not use promises :(\n             */\n            $delegate.cssLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('css', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.cssLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$q\", function ($delegate, $q) {\n            /**\n             * jsLoader function\n             * @type Function\n             * @param paths array list of js files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters\n             * because the user can overwrite jsLoader and it will probably not use promises :(\n             */\n            $delegate.jsLoader = function (paths, callback, params) {\n                var promises = [];\n                angular.forEach(paths, function (path) {\n                    promises.push($delegate.buildElement('js', path, params));\n                });\n                $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.jsLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n(function (angular) {\n    'use strict';\n\n    angular.module('oc.lazyLoad').config([\"$provide\", function ($provide) {\n        $provide.decorator('$ocLazyLoad', [\"$delegate\", \"$templateCache\", \"$q\", \"$http\", function ($delegate, $templateCache, $q, $http) {\n            /**\n             * templatesLoader function\n             * @type Function\n             * @param paths array list of css files to load\n             * @param callback to call when everything is loaded. We use a callback and not a promise\n             * @param params object config parameters for $http\n             * because the user can overwrite templatesLoader and it will probably not use promises :(\n             */\n            $delegate.templatesLoader = function (paths, callback, params) {\n                var promises = [],\n                    filesCache = $delegate._getFilesCache();\n\n                angular.forEach(paths, function (url) {\n                    var deferred = $q.defer();\n                    promises.push(deferred.promise);\n                    $http.get(url, params).success(function (data) {\n                        if (angular.isString(data) && data.length > 0) {\n                            angular.forEach(angular.element(data), function (node) {\n                                if (node.nodeName === 'SCRIPT' && node.type === 'text/ng-template') {\n                                    $templateCache.put(node.id, node.innerHTML);\n                                }\n                            });\n                        }\n                        if (angular.isUndefined(filesCache.get(url))) {\n                            filesCache.put(url, true);\n                        }\n                        deferred.resolve();\n                    }).error(function (err) {\n                        deferred.reject(new Error('Unable to load template file \"' + url + '\": ' + err));\n                    });\n                });\n                return $q.all(promises).then(function () {\n                    callback();\n                }, function (err) {\n                    callback(err);\n                });\n            };\n            $delegate.templatesLoader.ocLazyLoadLoader = true;\n\n            return $delegate;\n        }]);\n    }]);\n})(angular);\n// Array.indexOf polyfill for IE8\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function (searchElement, fromIndex) {\n        var k;\n\n        // 1. Let O be the result of calling ToObject passing\n        //    the this value as the argument.\n        if (this == null) {\n            throw new TypeError('\"this\" is null or not defined');\n        }\n\n        var O = Object(this);\n\n        // 2. Let lenValue be the result of calling the Get\n        //    internal method of O with the argument \"length\".\n        // 3. Let len be ToUint32(lenValue).\n        var len = O.length >>> 0;\n\n        // 4. If len is 0, return -1.\n        if (len === 0) {\n            return -1;\n        }\n\n        // 5. If argument fromIndex was passed let n be\n        //    ToInteger(fromIndex); else let n be 0.\n        var n = +fromIndex || 0;\n\n        if (Math.abs(n) === Infinity) {\n            n = 0;\n        }\n\n        // 6. If n >= len, return -1.\n        if (n >= len) {\n            return -1;\n        }\n\n        // 7. If n >= 0, then Let k be n.\n        // 8. Else, n<0, Let k be len - abs(n).\n        //    If k is less than 0, then let k be 0.\n        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n        // 9. Repeat, while k < len\n        while (k < len) {\n            // a. Let Pk be ToString(k).\n            //   This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the\n            //    HasProperty internal method of O with argument Pk.\n            //   This step can be combined with c\n            // c. If kPresent is true, then\n            //    i.  Let elementK be the result of calling the Get\n            //        internal method of O with the argument ToString(k).\n            //   ii.  Let same be the result of applying the\n            //        Strict Equality Comparison Algorithm to\n            //        searchElement and elementK.\n            //  iii.  If same is true, return k.\n            if (k in O && O[k] === searchElement) {\n                return k;\n            }\n            k++;\n        }\n        return -1;\n    };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/oclazyload/dist/ocLazyLoad.js\n ** module id = 13\n ** module chunks = 1\n **/","/*! https://mths.be/utf8js v2.0.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tcheckScalarValue(codePoint);\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tvar byte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar utf8 = {\n\t\t'version': '2.0.0',\n\t\t'encode': utf8encode,\n\t\t'decode': utf8decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn utf8;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = utf8;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tvar object = {};\n\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\tfor (var key in utf8) {\n\t\t\t\thasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.utf8 = utf8;\n\t}\n\n}(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/utf8/utf8.js\n ** module id = 14\n ** module chunks = 1\n **/","'use strict';\nangular.module(\"ngLocale\", [], [\"$provide\", function($provide) {\nvar PLURAL_CATEGORY = {ZERO: \"zero\", ONE: \"one\", TWO: \"two\", FEW: \"few\", MANY: \"many\", OTHER: \"other\"};\nfunction getDecimals(n) {\n  n = n + '';\n  var i = n.indexOf('.');\n  return (i == -1) ? 0 : n.length - i - 1;\n}\n\nfunction getVF(n, opt_precision) {\n  var v = opt_precision;\n\n  if (undefined === v) {\n    v = Math.min(getDecimals(n), 3);\n  }\n\n  var base = Math.pow(10, v);\n  var f = ((n * base) | 0) % base;\n  return {v: v, f: f};\n}\n\n$provide.value(\"$locale\", {\n  \"DATETIME_FORMATS\": {\n    \"AMPMS\": [\n      \"vorm.\",\n      \"nachm.\"\n    ],\n    \"DAY\": [\n      \"Sonntag\",\n      \"Montag\",\n      \"Dienstag\",\n      \"Mittwoch\",\n      \"Donnerstag\",\n      \"Freitag\",\n      \"Samstag\"\n    ],\n    \"ERANAMES\": [\n      \"v. Chr.\",\n      \"n. Chr.\"\n    ],\n    \"ERAS\": [\n      \"v. Chr.\",\n      \"n. Chr.\"\n    ],\n    \"FIRSTDAYOFWEEK\": 0,\n    \"MONTH\": [\n      \"Januar\",\n      \"Februar\",\n      \"M\\u00e4rz\",\n      \"April\",\n      \"Mai\",\n      \"Juni\",\n      \"Juli\",\n      \"August\",\n      \"September\",\n      \"Oktober\",\n      \"November\",\n      \"Dezember\"\n    ],\n    \"SHORTDAY\": [\n      \"So.\",\n      \"Mo.\",\n      \"Di.\",\n      \"Mi.\",\n      \"Do.\",\n      \"Fr.\",\n      \"Sa.\"\n    ],\n    \"SHORTMONTH\": [\n      \"Jan.\",\n      \"Feb.\",\n      \"M\\u00e4rz\",\n      \"Apr.\",\n      \"Mai\",\n      \"Juni\",\n      \"Juli\",\n      \"Aug.\",\n      \"Sep.\",\n      \"Okt.\",\n      \"Nov.\",\n      \"Dez.\"\n    ],\n    \"STANDALONEMONTH\": [\n      \"Januar\",\n      \"Februar\",\n      \"M\\u00e4rz\",\n      \"April\",\n      \"Mai\",\n      \"Juni\",\n      \"Juli\",\n      \"August\",\n      \"September\",\n      \"Oktober\",\n      \"November\",\n      \"Dezember\"\n    ],\n    \"WEEKENDRANGE\": [\n      5,\n      6\n    ],\n    \"fullDate\": \"EEEE, d. MMMM y\",\n    \"longDate\": \"d. MMMM y\",\n    \"medium\": \"dd.MM.y HH:mm:ss\",\n    \"mediumDate\": \"dd.MM.y\",\n    \"mediumTime\": \"HH:mm:ss\",\n    \"short\": \"dd.MM.yy HH:mm\",\n    \"shortDate\": \"dd.MM.yy\",\n    \"shortTime\": \"HH:mm\"\n  },\n  \"NUMBER_FORMATS\": {\n    \"CURRENCY_SYM\": \"\\u20ac\",\n    \"DECIMAL_SEP\": \",\",\n    \"GROUP_SEP\": \".\",\n    \"PATTERNS\": [\n      {\n        \"gSize\": 3,\n        \"lgSize\": 3,\n        \"maxFrac\": 3,\n        \"minFrac\": 0,\n        \"minInt\": 1,\n        \"negPre\": \"-\",\n        \"negSuf\": \"\",\n        \"posPre\": \"\",\n        \"posSuf\": \"\"\n      },\n      {\n        \"gSize\": 3,\n        \"lgSize\": 3,\n        \"maxFrac\": 2,\n        \"minFrac\": 2,\n        \"minInt\": 1,\n        \"negPre\": \"-\",\n        \"negSuf\": \"\\u00a0\\u00a4\",\n        \"posPre\": \"\",\n        \"posSuf\": \"\\u00a0\\u00a4\"\n      }\n    ]\n  },\n  \"id\": \"de-de\",\n  \"pluralCat\": function(n, opt_precision) {  var i = n | 0;  var vf = getVF(n, opt_precision);  if (i == 1 && vf.v == 0) {    return PLURAL_CATEGORY.ONE;  }  return PLURAL_CATEGORY.OTHER;}\n});\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/angular-locale_de-de.js\n ** module id = 15\n ** module chunks = 1\n **/","/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 1.2.1 - 2016-02-27\n * License: MIT\n */angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.debounce\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module(\"ui.bootstrap.tpls\", [\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/popup.html\",\"uib/template/datepicker/year.html\",\"uib/template/modal/backdrop.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]);\nangular.module('ui.bootstrap.collapse', [])\n\n  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        var expandingExpr = $parse(attrs.expanding),\n            expandedExpr = $parse(attrs.expanded),\n            collapsingExpr = $parse(attrs.collapsing),\n            collapsedExpr = $parse(attrs.collapsed);\n\n        if (!scope.$eval(attrs.uibCollapse)) {\n          element.addClass('in')\n            .addClass('collapse')\n            .attr('aria-expanded', true)\n            .attr('aria-hidden', false)\n            .css({height: 'auto'});\n        }\n\n        function expand() {\n          if (element.hasClass('collapse') && element.hasClass('in')) {\n            return;\n          }\n\n          $q.resolve(expandingExpr(scope))\n            .then(function() {\n              element.removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', true)\n                .attr('aria-hidden', false);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  addClass: 'in',\n                  easing: 'ease',\n                  to: { height: element[0].scrollHeight + 'px' }\n                }).start()['finally'](expandDone);\n              } else {\n                $animate.addClass(element, 'in', {\n                  to: { height: element[0].scrollHeight + 'px' }\n                }).then(expandDone);\n              }\n            });\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse')\n            .css({height: 'auto'});\n          expandedExpr(scope);\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          $q.resolve(collapsingExpr(scope))\n            .then(function() {\n              element\n                // IMPORTANT: The height must be set before adding \"collapsing\" class.\n                // Otherwise, the browser attempts to animate from height 0 (in\n                // collapsing class) to the given height here.\n                .css({height: element[0].scrollHeight + 'px'})\n                // initially all panel collapse have the collapse class, this removal\n                // prevents the animation from jumping to collapsed state\n                .removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', false)\n                .attr('aria-hidden', true);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: 'in',\n                  to: {height: '0'}\n                }).start()['finally'](collapseDone);\n              } else {\n                $animate.removeClass(element, 'in', {\n                  to: {height: '0'}\n                }).then(collapseDone);\n              }\n            });\n        }\n\n        function collapseDone() {\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n          collapsedExpr(scope);\n        }\n\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\n\n.constant('uibAccordionConfig', {\n  closeOthers: true\n})\n\n.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if (closeOthers) {\n      angular.forEach(this.groups, function(group) {\n        if (group !== openGroup) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function(event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if (index !== -1) {\n      this.groups.splice(index, 1);\n    }\n  };\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('uibAccordion', function() {\n  return {\n    controller: 'UibAccordionController',\n    controllerAs: 'accordion',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion.html';\n    }\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('uibAccordionGroup', function() {\n  return {\n    require: '^uibAccordion',         // We need this directive to be inside an accordion\n    transclude: true,              // It transcludes the contents of the directive into the template\n    replace: true,                // The element containing the directive will be replaced with the template\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';\n    },\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      accordionCtrl.addGroup(scope);\n\n      scope.openClass = attrs.openClass || 'panel-open';\n      scope.panelClass = attrs.panelClass || 'panel-default';\n      scope.$watch('isOpen', function(value) {\n        element.toggleClass(scope.openClass, !!value);\n        if (value) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function($event) {\n        if (!scope.isDisabled) {\n          if (!$event || $event.which === 32) {\n            scope.isOpen = !scope.isOpen;\n          }\n        }\n      };\n\n      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n      scope.headingId = id + '-tab';\n      scope.panelId = id + '-panel';\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n.directive('uibAccordionHeading', function() {\n  return {\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n.directive('uibAccordionTransclude', function() {\n  return {\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, controller) {\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n        if (heading) {\n          var elem = angular.element(element[0].querySelector('[uib-accordion-header]'));\n          elem.html('');\n          elem.append(heading);\n        }\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\n  $scope.closeable = !!$attrs.close;\n\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\n  if (dismissOnTimeout) {\n    $timeout(function() {\n      $scope.close();\n    }, parseInt(dismissOnTimeout, 10));\n  }\n}])\n\n.directive('uibAlert', function() {\n  return {\n    controller: 'UibAlertController',\n    controllerAs: 'alert',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/alert/alert.html';\n    },\n    transclude: true,\n    replace: true,\n    scope: {\n      type: '@',\n      close: '&'\n    }\n  };\n});\n\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('uibButtonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('uibBtnRadio', ['$parse', function($parse) {\n  return {\n    require: ['uibBtnRadio', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'buttons',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      var uncheckableExpr = $parse(attrs.uibUncheckable);\n\n      element.find('input').css({display: 'none'});\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n\n      if (attrs.uibUncheckable) {\n        scope.$watch(uncheckableExpr, function(uncheckable) {\n          attrs.$set('uncheckable', uncheckable ? '' : undefined);\n        });\n      }\n    }\n  };\n}])\n\n.directive('uibBtnCheckbox', function() {\n  return {\n    require: ['uibBtnCheckbox', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'button',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attribute, defaultValue) {\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        scope.$apply(function() {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.carousel', [])\n\n.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    currentIndex = $scope.active,\n    currentInterval, isPlaying, bufferedTransitions = [];\n\n  var destroyed = false;\n\n  self.addSlide = function(slide, element) {\n    slides.push({\n      slide: slide,\n      element: element\n    });\n    slides.sort(function(a, b) {\n      return +a.slide.index > +b.slide.index;\n    });\n    //if this is the first slide or the slide is set to active, select it\n    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {\n      if ($scope.$currentTransition) {\n        $scope.$currentTransition = null;\n      }\n\n      currentIndex = slide.index;\n      $scope.active = slide.index;\n      setActive(currentIndex);\n      self.select(slides[findSlideIndex(slide)]);\n      if (slides.length === 1) {\n        $scope.play();\n      }\n    }\n  };\n\n  self.getCurrentIndex = function() {\n    for (var i = 0; i < slides.length; i++) {\n      if (slides[i].slide.index === currentIndex) {\n        return i;\n      }\n    }\n  };\n\n  self.next = $scope.next = function() {\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\n    if (newIndex === 0 && $scope.noWrap()) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(slides[newIndex], 'next');\n  };\n\n  self.prev = $scope.prev = function() {\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(slides[newIndex], 'prev');\n  };\n\n  self.removeSlide = function(slide) {\n    var index = findSlideIndex(slide);\n\n    var bufferedIndex = bufferedTransitions.indexOf(slides[index]);\n    if (bufferedIndex !== -1) {\n      bufferedTransitions.splice(bufferedIndex, 1);\n    }\n\n    //get the index of the slide inside the carousel\n    slides.splice(index, 1);\n    if (slides.length > 0 && currentIndex === index) {\n      if (index >= slides.length) {\n        currentIndex = slides.length - 1;\n        $scope.active = currentIndex;\n        setActive(currentIndex);\n        self.select(slides[slides.length - 1]);\n      } else {\n        currentIndex = index;\n        $scope.active = currentIndex;\n        setActive(currentIndex);\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n      $scope.active = currentIndex;\n    }\n\n    //clean the active value when no more slide\n    if (slides.length === 0) {\n      currentIndex = null;\n      $scope.active = null;\n      clearBufferedTransitions();\n    }\n  };\n\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = findSlideIndex(nextSlide.slide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n    }\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (nextSlide.slide.index !== currentIndex &&\n      !$scope.$currentTransition) {\n      goNext(nextSlide.slide, nextIndex, direction);\n    } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {\n      bufferedTransitions.push(slides[nextIndex]);\n    }\n  };\n\n  /* Allow outside people to call indexOf on slides array */\n  $scope.indexOfSlide = function(slide) {\n    return +slide.slide.index;\n  };\n\n  $scope.isActive = function(slide) {\n    return $scope.active === slide.slide.index;\n  };\n\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n    resetTimer();\n  });\n\n  $scope.$watch('noTransition', function(noTransition) {\n    $animate.enabled($element, !noTransition);\n  });\n\n  $scope.$watch('interval', restartTimer);\n\n  $scope.$watchCollection('slides', resetTransition);\n\n  $scope.$watch('active', function(index) {\n    if (angular.isNumber(index) && currentIndex !== index) {\n      for (var i = 0; i < slides.length; i++) {\n        if (slides[i].slide.index === index) {\n          index = i;\n          break;\n        }\n      }\n\n      var slide = slides[index];\n      if (slide) {\n        currentIndex = index;\n        setActive(index);\n        self.select(slides[index]);\n      }\n    }\n  });\n\n  function clearBufferedTransitions() {\n    while (bufferedTransitions.length) {\n      bufferedTransitions.shift();\n    }\n  }\n\n  function getSlideByIndex(index) {\n    for (var i = 0, l = slides.length; i < l; ++i) {\n      if (slides[i].index === index) {\n        return slides[i];\n      }\n    }\n  }\n\n  function setActive(index) {\n    for (var i = 0; i < slides.length; i++) {\n      slides[i].slide.active = i === index;\n    }\n  }\n\n  function goNext(slide, index, direction) {\n    if (destroyed) {\n      return;\n    }\n\n    angular.extend(slide, {direction: direction});\n    angular.extend(slides[currentIndex].slide || {}, {direction: direction});\n    if ($animate.enabled($element) && !$scope.$currentTransition &&\n      slides[index].element && self.slides.length > 1) {\n      slides[index].element.data(SLIDE_DIRECTION, slide.direction);\n      var currentIdx = self.getCurrentIndex();\n\n      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {\n        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);\n      }\n\n      $scope.$currentTransition = true;\n      $animate.on('addClass', slides[index].element, function(element, phase) {\n        if (phase === 'close') {\n          $scope.$currentTransition = null;\n          $animate.off('addClass', element);\n          if (bufferedTransitions.length) {\n            var nextSlide = bufferedTransitions.pop().slide;\n            var nextIndex = nextSlide.index;\n            var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n            clearBufferedTransitions();\n\n            goNext(nextSlide, nextIndex, nextDirection);\n          }\n        }\n      });\n    }\n\n    $scope.active = slide.index;\n    currentIndex = slide.index;\n    setActive(index);\n\n    //every time you change slides, reset the timer\n    restartTimer();\n  }\n\n  function findSlideIndex(slide) {\n    for (var i = 0; i < slides.length; i++) {\n      if (slides[i].slide === slide) {\n        return i;\n      }\n    }\n  }\n\n  function resetTimer() {\n    if (currentInterval) {\n      $interval.cancel(currentInterval);\n      currentInterval = null;\n    }\n  }\n\n  function resetTransition(slides) {\n    if (!slides.length) {\n      $scope.$currentTransition = null;\n      clearBufferedTransitions();\n    }\n  }\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval > 0) {\n      currentInterval = $interval(timerFn, interval);\n    }\n  }\n\n  function timerFn() {\n    var interval = +$scope.interval;\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n      $scope.next();\n    } else {\n      $scope.pause();\n    }\n  }\n}])\n\n.directive('uibCarousel', function() {\n  return {\n    transclude: true,\n    replace: true,\n    controller: 'UibCarouselController',\n    controllerAs: 'carousel',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/carousel.html';\n    },\n    scope: {\n      active: '=',\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    }\n  };\n})\n\n.directive('uibSlide', function() {\n  return {\n    require: '^uibCarousel',\n    transclude: true,\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/slide.html';\n    },\n    scope: {\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n    }\n  };\n})\n\n.animation('.item', ['$animateCss',\nfunction($animateCss) {\n  var SLIDE_DIRECTION = 'uib-slideDirection';\n\n  function removeClass(element, className, callback) {\n    element.removeClass(className);\n    if (callback) {\n      callback();\n    }\n  }\n\n  return {\n    beforeAddClass: function(element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element,\n          directionClass + ' ' + direction, done);\n        element.addClass(direction);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    },\n    beforeRemoveClass: function (element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  var localeId;\n  var formatCodeToRegex;\n\n  this.init = function() {\n    localeId = $locale.id;\n\n    this.parsers = {};\n    this.formatters = {};\n\n    formatCodeToRegex = [\n      {\n        key: 'yyyy',\n        regex: '\\\\d{4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yyyy');\n        }\n      },\n      {\n        key: 'yy',\n        regex: '\\\\d{2}',\n        apply: function(value) { this.year = +value + 2000; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yy');\n        }\n      },\n      {\n        key: 'y',\n        regex: '\\\\d{1,4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'y');\n        }\n      },\n      {\n        key: 'M!',\n        regex: '0?[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) {\n          var value = date.getMonth();\n          if (/^[0-9]$/.test(value)) {\n            return dateFilter(date, 'MM');\n          }\n\n          return dateFilter(date, 'M');\n        }\n      },\n      {\n        key: 'MMMM',\n        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMMM'); }\n      },\n      {\n        key: 'MMM',\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMM'); }\n      },\n      {\n        key: 'MM',\n        regex: '0[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'MM'); }\n      },\n      {\n        key: 'M',\n        regex: '[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'M'); }\n      },\n      {\n        key: 'd!',\n        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) {\n          var value = date.getDate();\n          if (/^[1-9]$/.test(value)) {\n            return dateFilter(date, 'dd');\n          }\n\n          return dateFilter(date, 'd');\n        }\n      },\n      {\n        key: 'dd',\n        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'dd'); }\n      },\n      {\n        key: 'd',\n        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'd'); }\n      },\n      {\n        key: 'EEEE',\n        regex: $locale.DATETIME_FORMATS.DAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEEE'); }\n      },\n      {\n        key: 'EEE',\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEE'); }\n      },\n      {\n        key: 'HH',\n        regex: '(?:0|1)[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'HH'); }\n      },\n      {\n        key: 'hh',\n        regex: '0[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'hh'); }\n      },\n      {\n        key: 'H',\n        regex: '1?[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'H'); }\n      },\n      {\n        key: 'h',\n        regex: '[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'h'); }\n      },\n      {\n        key: 'mm',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'mm'); }\n      },\n      {\n        key: 'm',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'm'); }\n      },\n      {\n        key: 'sss',\n        regex: '[0-9][0-9][0-9]',\n        apply: function(value) { this.milliseconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'sss'); }\n      },\n      {\n        key: 'ss',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'ss'); }\n      },\n      {\n        key: 's',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 's'); }\n      },\n      {\n        key: 'a',\n        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n        apply: function(value) {\n          if (this.hours === 12) {\n            this.hours = 0;\n          }\n\n          if (value === 'PM') {\n            this.hours += 12;\n          }\n        },\n        formatter: function(date) { return dateFilter(date, 'a'); }\n      },\n      {\n        key: 'Z',\n        regex: '[+-]\\\\d{4}',\n        apply: function(value) {\n          var matches = value.match(/([+-])(\\d{2})(\\d{2})/),\n            sign = matches[1],\n            hours = matches[2],\n            minutes = matches[3];\n          this.hours += toInt(sign + hours);\n          this.minutes += toInt(sign + minutes);\n        },\n        formatter: function(date) {\n          return dateFilter(date, 'Z');\n        }\n      },\n      {\n        key: 'ww',\n        regex: '[0-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'ww'); }\n      },\n      {\n        key: 'w',\n        regex: '[0-9]|[1-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'w'); }\n      },\n      {\n        key: 'GGGG',\n        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\\s/g, '\\\\s'),\n        formatter: function(date) { return dateFilter(date, 'GGGG'); }\n      },\n      {\n        key: 'GGG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GGG'); }\n      },\n      {\n        key: 'GG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GG'); }\n      },\n      {\n        key: 'G',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'G'); }\n      }\n    ];\n  };\n\n  this.init();\n\n  function createParser(format, func) {\n    var map = [], regex = format.split('');\n\n    // check for literal values\n    var quoteIndex = format.indexOf('\\'');\n    if (quoteIndex > -1) {\n      var inLiteral = false;\n      format = format.split('');\n      for (var i = quoteIndex; i < format.length; i++) {\n        if (inLiteral) {\n          if (format[i] === '\\'') {\n            if (i + 1 < format.length && format[i+1] === '\\'') { // escaped single quote\n              format[i+1] = '$';\n              regex[i+1] = '';\n            } else { // end of literal\n              regex[i] = '';\n              inLiteral = false;\n            }\n          }\n          format[i] = '$';\n        } else {\n          if (format[i] === '\\'') { // start of literal\n            format[i] = '$';\n            regex[i] = '';\n            inLiteral = true;\n          }\n        }\n      }\n\n      format = format.join('');\n    }\n\n    angular.forEach(formatCodeToRegex, function(data) {\n      var index = format.indexOf(data.key);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + data.key.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({\n          index: index,\n          key: data.key,\n          apply: data[func],\n          matcher: data.regex\n        });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  this.filter = function(date, format) {\n    if (!angular.isDate(date) || isNaN(date) || !format) {\n      return '';\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.formatters[format]) {\n      this.formatters[format] = createParser(format, 'formatter');\n    }\n\n    var parser = this.formatters[format],\n      map = parser.map;\n\n    var _format = format;\n\n    return map.reduce(function(str, mapper, i) {\n      var match = _format.match(new RegExp('(.*)' + mapper.key));\n      if (match && angular.isString(match[1])) {\n        str += match[1];\n        _format = _format.replace(match[1] + mapper.key, '');\n      }\n\n      var endStr = i === map.length - 1 ? _format : '';\n\n      if (mapper.apply) {\n        return str + mapper.apply.call(null, date) + endStr;\n      }\n\n      return str + endStr;\n    }, '');\n  };\n\n  this.parse = function(input, format, baseDate) {\n    if (!angular.isString(input) || !format) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.parsers[format]) {\n      this.parsers[format] = createParser(format, 'apply');\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex),\n        tzOffset = false;\n    if (results && results.length) {\n      var fields, dt;\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n        fields = {\n          year: baseDate.getFullYear(),\n          month: baseDate.getMonth(),\n          date: baseDate.getDate(),\n          hours: baseDate.getHours(),\n          minutes: baseDate.getMinutes(),\n          seconds: baseDate.getSeconds(),\n          milliseconds: baseDate.getMilliseconds()\n        };\n      } else {\n        if (baseDate) {\n          $log.warn('dateparser:', 'baseDate is not a valid date');\n        }\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n      }\n\n      for (var i = 1, n = results.length; i < n; i++) {\n        var mapper = map[i - 1];\n        if (mapper.matcher === 'Z') {\n          tzOffset = true;\n        }\n\n        if (mapper.apply) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :\n        Date.prototype.setFullYear;\n      var timesetter = tzOffset ? Date.prototype.setUTCHours :\n        Date.prototype.setHours;\n\n      if (isValid(fields.year, fields.month, fields.date)) {\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {\n          dt = new Date(baseDate);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours, fields.minutes,\n            fields.seconds, fields.milliseconds);\n        } else {\n          dt = new Date(0);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,\n            fields.seconds || 0, fields.milliseconds || 0);\n        }\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if (date < 1) {\n      return false;\n    }\n\n    if (month === 1 && date > 28) {\n      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);\n    }\n\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\n      return date < 31;\n    }\n\n    return true;\n  }\n\n  function toInt(str) {\n    return parseInt(str, 10);\n  }\n\n  this.toTimezone = toTimezone;\n  this.fromTimezone = fromTimezone;\n  this.timezoneToOffset = timezoneToOffset;\n  this.addDateMinutes = addDateMinutes;\n  this.convertTimezoneToLocal = convertTimezoneToLocal;\n\n  function toTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;\n  }\n\n  function fromTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;\n  }\n\n  //https://github.com/angular/angular.js/blob/4daafd3dbe6a80d578f5a31df1bb99c77559543e/src/Angular.js#L1207\n  function timezoneToOffset(timezone, fallback) {\n    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\n    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n  }\n\n  function addDateMinutes(date, minutes) {\n    date = new Date(date.getTime());\n    date.setMinutes(date.getMinutes() + minutes);\n    return date;\n  }\n\n  function convertTimezoneToLocal(date, timezone, reverse) {\n    reverse = reverse ? -1 : 1;\n    var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());\n    return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));\n  }\n}]);\n\n// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to\n// at most one element.\nangular.module('ui.bootstrap.isClass', [])\n.directive('uibIsClass', [\n         '$animate',\nfunction ($animate) {\n  //                    11111111          22222222\n  var ON_REGEXP = /^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/;\n  //                    11111111           22222222\n  var IS_REGEXP = /^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;\n\n  var dataPerTracked = {};\n\n  return {\n    restrict: 'A',\n    compile: function (tElement, tAttrs) {\n      var linkedScopes = [];\n      var instances = [];\n      var expToData = {};\n      var lastActivated = null;\n      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);\n      var onExp = onExpMatches[2];\n      var expsStr = onExpMatches[1];\n      var exps = expsStr.split(',');\n\n      return linkFn;\n\n      function linkFn(scope, element, attrs) {\n        linkedScopes.push(scope);\n        instances.push({\n          scope: scope,\n          element: element\n        });\n\n        exps.forEach(function (exp, k) {\n          addForExp(exp, scope);\n        });\n\n        scope.$on('$destroy', removeScope);\n      }\n\n      function addForExp(exp, scope) {\n        var matches = exp.match(IS_REGEXP);\n        var clazz = scope.$eval(matches[1]);\n        var compareWithExp = matches[2];\n        var data = expToData[exp];\n        if (!data) {\n          var watchFn = function (compareWithVal) {\n            var newActivated = null;\n            instances.some(function (instance) {\n              var thisVal = instance.scope.$eval(onExp);\n              if (thisVal === compareWithVal) {\n                newActivated = instance;\n                return true;\n              }\n            });\n            if (data.lastActivated !== newActivated) {\n              if (data.lastActivated) {\n                $animate.removeClass(data.lastActivated.element, clazz);\n              }\n              if (newActivated) {\n                $animate.addClass(newActivated.element, clazz);\n              }\n              data.lastActivated = newActivated;\n            }\n          };\n          expToData[exp] = data = {\n            lastActivated: null,\n            scope: scope,\n            watchFn: watchFn,\n            compareWithExp: compareWithExp,\n            watcher: scope.$watch(compareWithExp, watchFn)\n          };\n        }\n        data.watchFn(scope.$eval(compareWithExp));\n      }\n\n      function removeScope(e) {\n        var removedScope = e.targetScope;\n        var index = linkedScopes.indexOf(removedScope);\n        linkedScopes.splice(index, 1);\n        instances.splice(index, 1);\n        if (linkedScopes.length) {\n          var newWatchScope = linkedScopes[0];\n          angular.forEach(expToData, function (data) {\n            if (data.scope === removedScope) {\n              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);\n              data.scope = newWatchScope;\n            }\n          });\n        }\n        else {\n          expToData = {};\n        }\n      }\n    }\n  };\n}]);\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods for working with the DOM.\n * It is meant to be used where we need to absolute-position elements in\n * relation to another element (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n    /**\n     * Used by scrollbarWidth() function to cache scrollbar's width.\n     * Do not access this variable directly, use scrollbarWidth() instead.\n     */\n    var SCROLLBAR_WIDTH;\n    var OVERFLOW_REGEX = {\n      normal: /(auto|scroll)/,\n      hidden: /(auto|scroll|hidden)/\n    };\n    var PLACEMENT_REGEX = {\n      auto: /\\s?auto?\\s?/i,\n      primary: /^(top|bottom|left|right)$/,\n      secondary: /^(top|bottom|left|right|center)$/,\n      vertical: /^(top|bottom)$/\n    };\n\n    return {\n\n      /**\n       * Provides a raw DOM element from a jQuery/jQLite element.\n       *\n       * @param {element} elem - The element to convert.\n       *\n       * @returns {element} A HTML element.\n       */\n      getRawNode: function(elem) {\n        return elem.nodeName ? elem : elem[0] || elem;\n      },\n\n      /**\n       * Provides a parsed number for a style property.  Strips\n       * units and casts invalid numbers to 0.\n       *\n       * @param {string} value - The style value to parse.\n       *\n       * @returns {number} A valid number.\n       */\n      parseStyle: function(value) {\n        value = parseFloat(value);\n        return isFinite(value) ? value : 0;\n      },\n\n      /**\n       * Provides the closest positioned ancestor.\n       *\n       * @param {element} element - The element to get the offest parent for.\n       *\n       * @returns {element} The closest positioned ancestor.\n       */\n      offsetParent: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var offsetParent = elem.offsetParent || $document[0].documentElement;\n\n        function isStaticPositioned(el) {\n          return ($window.getComputedStyle(el).position || 'static') === 'static';\n        }\n\n        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || $document[0].documentElement;\n      },\n\n      /**\n       * Provides the scrollbar width, concept from TWBS measureScrollbar()\n       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js\n       *\n       * @returns {number} The width of the browser scollbar.\n       */\n      scrollbarWidth: function() {\n        if (angular.isUndefined(SCROLLBAR_WIDTH)) {\n          var scrollElem = angular.element('<div class=\"uib-position-scrollbar-measure\"></div>');\n          $document.find('body').append(scrollElem);\n          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;\n          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;\n          scrollElem.remove();\n        }\n\n        return SCROLLBAR_WIDTH;\n      },\n\n      /**\n       * Checks to see if the element is scrollable.\n       *\n       * @param {element} elem - The element to check.\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n       *   default is false.\n       *\n       * @returns {boolean} Whether the element is scrollable.\n       */\n      isScrollable: function(elem, includeHidden) {\n        elem = this.getRawNode(elem);\n\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n        var elemStyle = $window.getComputedStyle(elem);\n        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);\n      },\n\n      /**\n       * Provides the closest scrollable ancestor.\n       * A port of the jQuery UI scrollParent method:\n       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js\n       *\n       * @param {element} elem - The element to find the scroll parent of.\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n       *   default is false.\n       *\n       * @returns {element} A HTML element.\n       */\n      scrollParent: function(elem, includeHidden) {\n        elem = this.getRawNode(elem);\n\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n        var documentEl = $document[0].documentElement;\n        var elemStyle = $window.getComputedStyle(elem);\n        var excludeStatic = elemStyle.position === 'absolute';\n        var scrollParent = elem.parentElement || documentEl;\n\n        if (scrollParent === documentEl || elemStyle.position === 'fixed') {\n          return documentEl;\n        }\n\n        while (scrollParent.parentElement && scrollParent !== documentEl) {\n          var spStyle = $window.getComputedStyle(scrollParent);\n          if (excludeStatic && spStyle.position !== 'static') {\n            excludeStatic = false;\n          }\n\n          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {\n            break;\n          }\n          scrollParent = scrollParent.parentElement;\n        }\n\n        return scrollParent;\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/ - distance to closest positioned\n       * ancestor.  Does not account for margins by default like jQuery position.\n       *\n       * @param {element} elem - The element to caclulate the position on.\n       * @param {boolean=} [includeMargins=false] - Should margins be accounted\n       * for, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of offset parent</li>\n       *     <li>**left**: distance to left edge of offset parent</li>\n       *   </ul>\n       */\n      position: function(elem, includeMagins) {\n        elem = this.getRawNode(elem);\n\n        var elemOffset = this.offset(elem);\n        if (includeMagins) {\n          var elemStyle = $window.getComputedStyle(elem);\n          elemOffset.top -= this.parseStyle(elemStyle.marginTop);\n          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);\n        }\n        var parent = this.offsetParent(elem);\n        var parentOffset = {top: 0, left: 0};\n\n        if (parent !== $document[0].documentElement) {\n          parentOffset = this.offset(parent);\n          parentOffset.top += parent.clientTop - parent.scrollTop;\n          parentOffset.left += parent.clientLeft - parent.scrollLeft;\n        }\n\n        return {\n          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),\n          top: Math.round(elemOffset.top - parentOffset.top),\n          left: Math.round(elemOffset.left - parentOffset.left)\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/ - distance to viewport.  Does\n       * not account for borders, margins, or padding on the body\n       * element.\n       *\n       * @param {element} elem - The element to calculate the offset on.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of viewport</li>\n       *     <li>**right**: distance to bottom edge of viewport</li>\n       *   </ul>\n       */\n      offset: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var elemBCR = elem.getBoundingClientRect();\n        return {\n          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),\n          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),\n          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))\n        };\n      },\n\n      /**\n       * Provides offset distance to the closest scrollable ancestor\n       * or viewport.  Accounts for border and scrollbar width.\n       *\n       * Right and bottom dimensions represent the distance to the\n       * respective edge of the viewport element.  If the element\n       * edge extends beyond the viewport, a negative value will be\n       * reported.\n       *\n       * @param {element} elem - The element to get the viewport offset for.\n       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead\n       * of the first scrollable element, default is false.\n       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element\n       * be accounted for, default is true.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: distance to the top content edge of viewport element</li>\n       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>\n       *     <li>**left**: distance to the left content edge of viewport element</li>\n       *     <li>**right**: distance to the right content edge of viewport element</li>\n       *   </ul>\n       */\n      viewportOffset: function(elem, useDocument, includePadding) {\n        elem = this.getRawNode(elem);\n        includePadding = includePadding !== false ? true : false;\n\n        var elemBCR = elem.getBoundingClientRect();\n        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};\n\n        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);\n        var offsetParentBCR = offsetParent.getBoundingClientRect();\n\n        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;\n        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;\n        if (offsetParent === $document[0].documentElement) {\n          offsetBCR.top += $window.pageYOffset;\n          offsetBCR.left += $window.pageXOffset;\n        }\n        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;\n        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;\n\n        if (includePadding) {\n          var offsetParentStyle = $window.getComputedStyle(offsetParent);\n          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);\n          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);\n          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);\n          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);\n        }\n\n        return {\n          top: Math.round(elemBCR.top - offsetBCR.top),\n          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),\n          left: Math.round(elemBCR.left - offsetBCR.left),\n          right: Math.round(offsetBCR.right - elemBCR.right)\n        };\n      },\n\n      /**\n       * Provides an array of placement values parsed from a placement string.\n       * Along with the 'auto' indicator, supported placement strings are:\n       *   <ul>\n       *     <li>top: element on top, horizontally centered on host element.</li>\n       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>\n       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>\n       *     <li>bottom: element on bottom, horizontally centered on host element.</li>\n       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>\n       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>\n       *     <li>left: element on left, vertically centered on host element.</li>\n       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>\n       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>\n       *     <li>right: element on right, vertically centered on host element.</li>\n       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>\n       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>\n       *   </ul>\n       * A placement string with an 'auto' indicator is expected to be\n       * space separated from the placement, i.e: 'auto bottom-left'  If\n       * the primary and secondary placement values do not match 'top,\n       * bottom, left, right' then 'top' will be the primary placement and\n       * 'center' will be the secondary placement.  If 'auto' is passed, true\n       * will be returned as the 3rd value of the array.\n       *\n       * @param {string} placement - The placement string to parse.\n       *\n       * @returns {array} An array with the following values\n       * <ul>\n       *   <li>**[0]**: The primary placement.</li>\n       *   <li>**[1]**: The secondary placement.</li>\n       *   <li>**[2]**: If auto is passed: true, else undefined.</li>\n       * </ul>\n       */\n      parsePlacement: function(placement) {\n        var autoPlace = PLACEMENT_REGEX.auto.test(placement);\n        if (autoPlace) {\n          placement = placement.replace(PLACEMENT_REGEX.auto, '');\n        }\n\n        placement = placement.split('-');\n\n        placement[0] = placement[0] || 'top';\n        if (!PLACEMENT_REGEX.primary.test(placement[0])) {\n          placement[0] = 'top';\n        }\n\n        placement[1] = placement[1] || 'center';\n        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {\n          placement[1] = 'center';\n        }\n\n        if (autoPlace) {\n          placement[2] = true;\n        } else {\n          placement[2] = false;\n        }\n\n        return placement;\n      },\n\n      /**\n       * Provides coordinates for an element to be positioned relative to\n       * another element.  Passing 'auto' as part of the placement parameter\n       * will enable smart placement - where the element fits. i.e:\n       * 'auto left-top' will check to see if there is enough space to the left\n       * of the hostElem to fit the targetElem, if not place right (same for secondary\n       * top placement).  Available space is calculated using the viewportOffset\n       * function.\n       *\n       * @param {element} hostElem - The element to position against.\n       * @param {element} targetElem - The element to position.\n       * @param {string=} [placement=top] - The placement for the targetElem,\n       *   default is 'top'. 'center' is assumed as secondary placement for\n       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:\n       *   <ul>\n       *     <li>top</li>\n       *     <li>top-right</li>\n       *     <li>top-left</li>\n       *     <li>bottom</li>\n       *     <li>bottom-left</li>\n       *     <li>bottom-right</li>\n       *     <li>left</li>\n       *     <li>left-top</li>\n       *     <li>left-bottom</li>\n       *     <li>right</li>\n       *     <li>right-top</li>\n       *     <li>right-bottom</li>\n       *   </ul>\n       * @param {boolean=} [appendToBody=false] - Should the top and left values returned\n       *   be calculated from the body element, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: Value for targetElem top.</li>\n       *     <li>**left**: Value for targetElem left.</li>\n       *     <li>**placement**: The resolved placement.</li>\n       *   </ul>\n       */\n      positionElements: function(hostElem, targetElem, placement, appendToBody) {\n        hostElem = this.getRawNode(hostElem);\n        targetElem = this.getRawNode(targetElem);\n\n        // need to read from prop to support tests.\n        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');\n        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');\n\n        placement = this.parsePlacement(placement);\n\n        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);\n        var targetElemPos = {top: 0, left: 0, placement: ''};\n\n        if (placement[2]) {\n          var viewportOffset = this.viewportOffset(hostElem);\n\n          var targetElemStyle = $window.getComputedStyle(targetElem);\n          var adjustedSize = {\n            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),\n            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))\n          };\n\n          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :\n                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :\n                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :\n                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :\n                         placement[0];\n\n          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :\n                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :\n                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :\n                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :\n                         placement[1];\n\n          if (placement[1] === 'center') {\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;\n              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {\n                placement[1] = 'left';\n              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {\n                placement[1] = 'right';\n              }\n            } else {\n              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;\n              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {\n                placement[1] = 'top';\n              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {\n                placement[1] = 'bottom';\n              }\n            }\n          }\n        }\n\n        switch (placement[0]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top - targetHeight;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left - targetWidth;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width;\n            break;\n        }\n\n        switch (placement[1]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;\n            break;\n          case 'center':\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;\n            } else {\n              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;\n            }\n            break;\n        }\n\n        targetElemPos.top = Math.round(targetElemPos.top);\n        targetElemPos.left = Math.round(targetElemPos.left);\n        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];\n\n        return targetElemPos;\n      },\n\n      /**\n      * Provides a way for positioning tooltip & dropdown\n      * arrows when using placement options beyond the standard\n      * left, right, top, or bottom.\n      *\n      * @param {element} elem - The tooltip/dropdown element.\n      * @param {string} placement - The placement for the elem.\n      */\n      positionArrow: function(elem, placement) {\n        elem = this.getRawNode(elem);\n\n        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');\n        if (!innerElem) {\n          return;\n        }\n\n        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');\n\n        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');\n        if (!arrowElem) {\n          return;\n        }\n\n        var arrowCss = {\n          top: '',\n          bottom: '',\n          left: '',\n          right: ''\n        };\n\n        placement = this.parsePlacement(placement);\n        if (placement[1] === 'center') {\n          // no adjustment necessary - just reset styles\n          angular.element(arrowElem).css(arrowCss);\n          return;\n        }\n\n        var borderProp = 'border-' + placement[0] + '-width';\n        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];\n\n        var borderRadiusProp = 'border-';\n        if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n          borderRadiusProp += placement[0] + '-' + placement[1];\n        } else {\n          borderRadiusProp += placement[1] + '-' + placement[0];\n        }\n        borderRadiusProp += '-radius';\n        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];\n\n        switch (placement[0]) {\n          case 'top':\n            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'bottom':\n            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'left':\n            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'right':\n            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;\n            break;\n        }\n\n        arrowCss[placement[1]] = borderRadius;\n\n        angular.element(arrowElem).css(arrowCss);\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position'])\n\n.value('$datepickerSuppressError', false)\n.value('uibDatepickerAttributeWarning', true)\n\n.constant('uibDatepickerConfig', {\n  datepickerMode: 'day',\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  maxDate: null,\n  maxMode: 'year',\n  minDate: null,\n  minMode: 'day',\n  ngModelOptions: {},\n  shortcutPropagation: false,\n  showWeeks: true,\n  yearColumns: 5,\n  yearRows: 4\n})\n\n.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', 'uibDatepickerAttributeWarning', 'uibDateParser',\n  function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerSuppressError, datepickerAttributeWarning, dateParser) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;\n      ngModelOptions = {},\n      watchListeners = [],\n      optionsUsed = !!$attrs.datepickerOptions;\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  if (optionsUsed) {\n    [\n      'customClass',\n      'dateDisabled',\n      'datepickerMode',\n      'formatDay',\n      'formatDayHeader',\n      'formatDayTitle',\n      'formatMonth',\n      'formatMonthTitle',\n      'formatYear',\n      'initDate',\n      'maxDate',\n      'maxMode',\n      'minDate',\n      'minMode',\n      'showWeeks',\n      'shortcutPropagation',\n      'startingDay',\n      'yearColumns',\n      'yearRows'\n    ].forEach(function(key) {\n      switch (key) {\n        case 'customClass':\n        case 'dateDisabled':\n          $scope[key] = $scope.datepickerOptions[key] || angular.noop;\n          break;\n        case 'datepickerMode':\n          $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?\n            $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;\n          break;\n        case 'formatDay':\n        case 'formatDayHeader':\n        case 'formatDayTitle':\n        case 'formatMonth':\n        case 'formatMonthTitle':\n        case 'formatYear':\n          self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n            $interpolate($scope.datepickerOptions[key])($scope.$parent) :\n            datepickerConfig[key];\n          break;\n        case 'showWeeks':\n        case 'shortcutPropagation':\n        case 'yearColumns':\n        case 'yearRows':\n          self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n            $scope.datepickerOptions[key] : datepickerConfig[key];\n          break;\n        case 'startingDay':\n          if (angular.isDefined($scope.datepickerOptions.startingDay)) {\n            self.startingDay = $scope.datepickerOptions.startingDay;\n          } else if (angular.isNumber(datepickerConfig.startingDay)) {\n            self.startingDay = datepickerConfig.startingDay;\n          } else {\n            self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n          }\n\n          break;\n        case 'maxDate':\n        case 'minDate':\n          if ($scope.datepickerOptions[key]) {\n            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n              if (value) {\n                if (angular.isDate(value)) {\n                  self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n                } else {\n                  self[key] = new Date(dateFilter(value, 'medium'));\n                }\n              } else {\n                self[key] = null;\n              }\n\n              self.refreshView();\n            });\n          } else {\n            self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;\n          }\n\n          break;\n        case 'maxMode':\n        case 'minMode':\n          if ($scope.datepickerOptions[key]) {\n            $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n              self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];\n              if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||\n                key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {\n                $scope.datepickerMode = self[key];\n                $scope.datepickerOptions.datepickerMode = self[key];\n              }\n            });\n          } else {\n            self[key] = $scope[key] = datepickerConfig[key] || null;\n          }\n\n          break;\n        case 'initDate':\n          if ($scope.datepickerOptions.initDate) {\n            self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();\n            $scope.$watch(function() { return $scope.datepickerOptions.initDate; }, function(initDate) {\n              if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n                self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n                self.refreshView();\n              }\n            });\n          } else {\n            self.activeDate = new Date();\n          }\n      }\n    });\n  } else {\n    // Interpolated configuration attributes\n    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle'], function(key) {\n      self[key] = angular.isDefined($attrs[key]) ? $interpolate($attrs[key])($scope.$parent) : datepickerConfig[key];\n\n      if (angular.isDefined($attrs[key]) && datepickerAttributeWarning) {\n        $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n      }\n    });\n\n    // Evaled configuration attributes\n    angular.forEach(['showWeeks', 'yearRows', 'yearColumns', 'shortcutPropagation'], function(key) {\n      self[key] = angular.isDefined($attrs[key]) ?\n        $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];\n\n      if (angular.isDefined($attrs[key]) && datepickerAttributeWarning) {\n        $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n      }\n    });\n\n    angular.forEach(['dateDisabled', 'customClass'], function(key) {\n      if (angular.isDefined($attrs[key]) && datepickerAttributeWarning) {\n        $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n      }\n    });\n\n    if (angular.isDefined($attrs.startingDay)) {\n      if (datepickerAttributeWarning) {\n        $log.warn('uib-datepicker startingDay attribute usage is deprecated, use datepicker-options attribute instead');\n      }\n\n      self.startingDay = $scope.$parent.$eval($attrs.startingDay);\n    } else if (angular.isNumber(datepickerConfig.startingDay)) {\n      self.startingDay = datepickerConfig.startingDay;\n    } else {\n      self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n    }\n\n    // Watchable date attributes\n    angular.forEach(['minDate', 'maxDate'], function(key) {\n      if ($attrs[key]) {\n        if (datepickerAttributeWarning) {\n          $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n        }\n\n        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {\n          if (value) {\n            if (angular.isDate(value)) {\n              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n            } else {\n              self[key] = new Date(dateFilter(value, 'medium'));\n            }\n          } else {\n            self[key] = null;\n          }\n\n          self.refreshView();\n        }));\n      } else {\n        self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;\n      }\n    });\n\n    angular.forEach(['minMode', 'maxMode'], function(key) {\n      if ($attrs[key]) {\n        if (datepickerAttributeWarning) {\n          $log.warn('uib-datepicker ' + key + ' attribute usage is deprecated, use datepicker-options attribute instead');\n        }\n\n        watchListeners.push($scope.$parent.$watch($attrs[key], function(value) {\n          self[key] = $scope[key] = angular.isDefined(value) ? value : $attrs[key];\n          if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||\n            key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {\n            $scope.datepickerMode = self[key];\n          }\n        }));\n      } else {\n        self[key] = $scope[key] = datepickerConfig[key] || null;\n      }\n    });\n\n    if (angular.isDefined($attrs.initDate)) {\n      if (datepickerAttributeWarning) {\n        $log.warn('uib-datepicker initDate attribute usage is deprecated, use datepicker-options attribute instead');\n      }\n\n      var initDate = dateParser.fromTimezone($scope.$parent.$eval($attrs.initDate), ngModelOptions.timezone);\n      this.activeDate = !isNaN(initDate) ? initDate : new Date();\n      watchListeners.push($scope.$parent.$watch($attrs.initDate, function(initDate) {\n        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n          initDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\n          self.activeDate = !isNaN(initDate) ? initDate : new Date();\n          self.refreshView();\n        }\n      }));\n    } else {\n      this.activeDate = new Date();\n    }\n\n    if ($attrs.datepickerMode && datepickerAttributeWarning) {\n      $log.warn('uib-datepicker datepickerMode attribute usage is deprecated, use datepicker-options attribute instead');\n    }\n\n    $scope.datepickerMode = $scope.datepickerMode ||\n      datepickerConfig.datepickerMode;\n  }\n\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n  if (angular.isDefined($attrs.ngDisabled)) {\n    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {\n      $scope.disabled = disabled;\n      self.refreshView();\n    }));\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;\n\n    this.activeDate = ngModelCtrl.$modelValue || new Date();\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n          isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      $scope.selectedDt = null;\n      this._refreshView();\n      if ($scope.activeDt) {\n        $scope.activeDateId = $scope.activeDt.uid;\n      }\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      date = dateParser.fromTimezone(date, ngModelOptions.timezone);\n      ngModelCtrl.$setValidity('dateDisabled', !date ||\n        this.element && !this.isDisabled(date));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    model = dateParser.fromTimezone(model, ngModelOptions.timezone);\n    var dt = {\n      date: date,\n      label: dateParser.filter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      current: this.compare(date, new Date()) === 0,\n      customClass: this.customClass(date) || null\n    };\n\n    if (model && this.compare(date, model) === 0) {\n      $scope.selectedDt = dt;\n    }\n\n    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {\n      $scope.activeDt = dt;\n    }\n\n    return dt;\n  };\n\n  this.isDisabled = function(date) {\n    return $scope.disabled ||\n      this.minDate && this.compare(date, this.minDate) < 0 ||\n      this.maxDate && this.compare(date, this.maxDate) > 0 ||\n      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      dt = dateParser.toTimezone(dt, ngModelOptions.timezone);\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);\n\n      $scope.$emit('uib:datepicker.mode');\n    }\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if ($scope.datepickerMode === self.maxMode && direction === 1 ||\n      $scope.datepickerMode === self.minMode && direction === -1) {\n      return;\n    }\n\n    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);\n\n    $scope.$emit('uib:datepicker.mode');\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n\n  $scope.$on(\"$destroy\", function() {\n    //Clear all watch listeners on destroy\n    while (watchListeners.length) {\n      watchListeners.shift()();\n    }\n  });\n\n  function setMode(mode) {\n    $scope.datepickerMode = mode;\n    if (optionsUsed) {\n      $scope.datepickerOptions.datepickerMode = mode;\n    }\n  }\n}])\n\n.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  this.step = { months: 1 };\n  this.element = $element;\n  function getDaysInMonth(year, month) {\n    return month === 1 && year % 4 === 0 &&\n      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];\n  }\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    scope.showWeeks = ctrl.showWeeks;\n    ctrl.refreshView();\n  };\n\n  this.getDates = function(startDate, n) {\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n    while (i < n) {\n      date = new Date(current);\n      dates[i++] = date;\n      current.setDate(current.getDate() + 1);\n    }\n    return dates;\n  };\n\n  this._refreshView = function() {\n    var year = this.activeDate.getFullYear(),\n      month = this.activeDate.getMonth(),\n      firstDayOfMonth = new Date(this.activeDate);\n\n    firstDayOfMonth.setFullYear(year, month, 1);\n\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\n      numDisplayedFromPreviousMonth = difference > 0 ?\n        7 - difference : - difference,\n      firstDate = new Date(firstDayOfMonth);\n\n    if (numDisplayedFromPreviousMonth > 0) {\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n    }\n\n    // 42 is the number of days on a six-week calendar\n    var days = this.getDates(firstDate, 42);\n    for (var i = 0; i < 42; i ++) {\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n        secondary: days[i].getMonth() !== month,\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.labels = new Array(7);\n    for (var j = 0; j < 7; j++) {\n      scope.labels[j] = {\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\n        full: dateFilter(days[j].date, 'EEEE')\n      };\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n    scope.rows = this.split(days, 7);\n\n    if (scope.showWeeks) {\n      scope.weekNumbers = [];\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n          numWeeks = scope.rows.length;\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n        scope.weekNumbers.push(\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n      }\n    }\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  function getISO8601WeekNumber(date) {\n    var checkDate = new Date(date);\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  }\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getDate();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - 7;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + 7;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setMonth(month, 1);\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n    } else if (key === 'home') {\n      date = 1;\n    } else if (key === 'end') {\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n    }\n    this.activeDate.setDate(date);\n  };\n}])\n\n.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  this.step = { years: 1 };\n  this.element = $element;\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    ctrl.refreshView();\n  };\n\n  this._refreshView = function() {\n    var months = new Array(12),\n        year = this.activeDate.getFullYear(),\n        date;\n\n    for (var i = 0; i < 12; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(year, i, 1);\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n    scope.rows = this.split(months, 3);\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getMonth();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - 3;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + 3;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setFullYear(year);\n    } else if (key === 'home') {\n      date = 0;\n    } else if (key === 'end') {\n      date = 11;\n    }\n    this.activeDate.setMonth(date);\n  };\n}])\n\n.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var columns, range;\n  this.element = $element;\n\n  function getStartingYear(year) {\n    return parseInt((year - 1) / range, 10) * range + 1;\n  }\n\n  this.yearpickerInit = function() {\n    columns = this.yearColumns;\n    range = this.yearRows * columns;\n    this.step = { years: range };\n  };\n\n  this._refreshView = function() {\n    var years = new Array(range), date;\n\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(start + i, 0, 1);\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n    scope.rows = this.split(years, columns);\n    scope.columns = columns;\n  };\n\n  this.compare = function(date1, date2) {\n    return date1.getFullYear() - date2.getFullYear();\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getFullYear();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - columns;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + columns;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      date += (key === 'pageup' ? - 1 : 1) * range;\n    } else if (key === 'home') {\n      date = getStartingYear(this.activeDate.getFullYear());\n    } else if (key === 'end') {\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n    }\n    this.activeDate.setFullYear(date);\n  };\n}])\n\n.directive('uibDatepicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerMode: '=?',\n      datepickerOptions: '=?',\n      dateDisabled: '&',\n      customClass: '&',\n      shortcutPropagation: '&?'\n    },\n    require: ['uibDatepicker', '^ngModel'],\n    controller: 'UibDatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n})\n\n.directive('uibDaypicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/day.html';\n    },\n    require: ['^uibDatepicker', 'uibDaypicker'],\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibMonthpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/month.html';\n    },\n    require: ['^uibDatepicker', 'uibMonthpicker'],\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibYearpicker', function() {\n  return {\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/year.html';\n    },\n    require: ['^uibDatepicker', 'uibYearpicker'],\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var ctrl = ctrls[0];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n})\n\n.value('uibDatepickerPopupAttributeWarning', true)\n\n.constant('uibDatepickerPopupConfig', {\n  altInputFormats: [],\n  appendToBody: false,\n  clearText: 'Clear',\n  closeOnDateSelection: true,\n  closeText: 'Done',\n  currentText: 'Today',\n  datepickerPopup: 'yyyy-MM-dd',\n  datepickerPopupTemplateUrl: 'uib/template/datepicker/popup.html',\n  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',\n  html5Types: {\n    date: 'yyyy-MM-dd',\n    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n    'month': 'yyyy-MM'\n  },\n  onOpenFocus: true,\n  showButtonBar: true,\n  placement: 'auto bottom-left'\n})\n\n.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', 'uibDatepickerPopupAttributeWarning',\nfunction($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, datepickerPopupAttributeWarning) {\n  var cache = {},\n    isHtml5DateInput = false;\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,\n    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];\n\n  $scope.watchData = {};\n\n  this.init = function(_ngModel_) {\n    ngModel = _ngModel_;\n    ngModelOptions = _ngModel_.$options || datepickerConfig.ngModelOptions;\n    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?\n      $scope.$parent.$eval($attrs.closeOnDateSelection) :\n      datepickerPopupConfig.closeOnDateSelection;\n    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?\n      $scope.$parent.$eval($attrs.datepickerAppendToBody) :\n      datepickerPopupConfig.appendToBody;\n    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?\n      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?\n      $attrs.datepickerPopupTemplateUrl :\n      datepickerPopupConfig.datepickerPopupTemplateUrl;\n    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?\n      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n    altInputFormats = angular.isDefined($attrs.altInputFormats) ?\n      $scope.$parent.$eval($attrs.altInputFormats) :\n      datepickerPopupConfig.altInputFormats;\n\n    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?\n      $scope.$parent.$eval($attrs.showButtonBar) :\n      datepickerPopupConfig.showButtonBar;\n\n    if (datepickerPopupConfig.html5Types[$attrs.type]) {\n      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];\n      isHtml5DateInput = true;\n    } else {\n      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n        // Invalidate the $modelValue to ensure that formatters re-run\n        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n        if (newDateFormat !== dateFormat) {\n          dateFormat = newDateFormat;\n          ngModel.$modelValue = null;\n\n          if (!dateFormat) {\n            throw new Error('uibDatepickerPopup must have a date format specified.');\n          }\n        }\n      });\n    }\n\n    if (!dateFormat) {\n      throw new Error('uibDatepickerPopup must have a date format specified.');\n    }\n\n    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {\n      throw new Error('HTML5 date input types do not support custom formats.');\n    }\n\n    // popup element used to display calendar\n    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n    $scope.ngModelOptions = angular.copy(ngModelOptions);\n    $scope.ngModelOptions.timezone = null;\n    if ($scope.ngModelOptions.updateOnDefault === true) {\n      $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ?\n        $scope.ngModelOptions.updateOn + ' default' : 'default';\n    }\n\n    popupEl.attr({\n      'ng-model': 'date',\n      'ng-model-options': 'ngModelOptions',\n      'ng-change': 'dateSelection(date)',\n      'template-url': datepickerPopupTemplateUrl\n    });\n\n    // datepicker element\n    datepickerEl = angular.element(popupEl.children()[0]);\n    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\n    if (isHtml5DateInput) {\n      if ($attrs.type === 'month') {\n        datepickerEl.attr('datepicker-mode', '\"month\"');\n        datepickerEl.attr('min-mode', 'month');\n      }\n    }\n\n    if ($scope.datepickerOptions) {\n      datepickerEl.attr('datepicker-options', 'datepickerOptions');\n    }\n\n    angular.forEach(['minMode', 'maxMode', 'datepickerMode', 'shortcutPropagation'], function(key) {\n      if ($attrs[key]) {\n        if (datepickerPopupAttributeWarning) {\n          $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n        }\n\n        var getAttribute = $parse($attrs[key]);\n        var propConfig = {\n          get: function() {\n            return getAttribute($scope.$parent);\n          }\n        };\n\n        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n\n        // Propagate changes from datepicker to outside\n        if (key === 'datepickerMode') {\n          var setAttribute = getAttribute.assign;\n          propConfig.set = function(v) {\n            setAttribute($scope.$parent, v);\n          };\n        }\n\n        Object.defineProperty($scope.watchData, key, propConfig);\n      }\n    });\n\n    angular.forEach(['minDate', 'maxDate', 'initDate'], function(key) {\n      if ($attrs[key]) {\n        if (datepickerPopupAttributeWarning) {\n          $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n        }\n\n        var getAttribute = $parse($attrs[key]);\n\n        watchListeners.push($scope.$parent.$watch(getAttribute, function(value) {\n          if (key === 'minDate' || key === 'maxDate') {\n            if (value === null) {\n              cache[key] = null;\n            } else if (angular.isDate(value)) {\n              cache[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\n            } else {\n              cache[key] = new Date(dateFilter(value, 'medium'));\n            }\n\n            $scope.watchData[key] = value === null ? null : cache[key];\n          } else {\n            var date = value ? new Date(value) : new Date();\n            $scope.watchData[key] = dateParser.fromTimezone(date, ngModelOptions.timezone);\n          }\n        }));\n\n        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);\n      }\n    });\n\n    if ($attrs.dateDisabled) {\n      if (datepickerPopupAttributeWarning) {\n        $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n      }\n\n      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');\n    }\n\n    angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRows', 'yearColumns'], function(key) {\n      if (angular.isDefined($attrs[key])) {\n        if (datepickerPopupAttributeWarning) {\n          $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n        }\n\n        datepickerEl.attr(cameltoDash(key), $attrs[key]);\n      }\n    });\n\n    if ($attrs.customClass) {\n      if (datepickerPopupAttributeWarning) {\n        $log.warn('uib-datepicker settings via uib-datepicker-popup attributes are deprecated and will be removed in UI Bootstrap 1.3, use datepicker-options attribute instead');\n      }\n\n      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');\n    }\n\n    if (!isHtml5DateInput) {\n      // Internal API to maintain the correct ng-invalid-[key] class\n      ngModel.$$parserName = 'date';\n      ngModel.$validators.date = validator;\n      ngModel.$parsers.unshift(parseDate);\n      ngModel.$formatters.push(function(value) {\n        if (ngModel.$isEmpty(value)) {\n          $scope.date = value;\n          return value;\n        }\n\n        $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);\n\n        if (angular.isNumber($scope.date)) {\n          $scope.date = new Date($scope.date);\n        }\n\n        return dateParser.filter($scope.date, dateFormat);\n      });\n    } else {\n      ngModel.$formatters.push(function(value) {\n        $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);\n        return value;\n      });\n    }\n\n    // Detect changes in the view from the text box\n    ngModel.$viewChangeListeners.push(function() {\n      $scope.date = parseDateString(ngModel.$viewValue);\n    });\n\n    $element.on('keydown', inputKeydownBind);\n\n    $popup = $compile(popupEl)($scope);\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\n    popupEl.remove();\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else {\n      $element.after($popup);\n    }\n\n    $scope.$on('$destroy', function() {\n      if ($scope.isOpen === true) {\n        if (!$rootScope.$$phase) {\n          $scope.$apply(function() {\n            $scope.isOpen = false;\n          });\n        }\n      }\n\n      $popup.remove();\n      $element.off('keydown', inputKeydownBind);\n      $document.off('click', documentClickBind);\n      if (scrollParentEl) {\n        scrollParentEl.off('scroll', positionPopup);\n      }\n      angular.element($window).off('resize', positionPopup);\n\n      //Clear all watch listeners on destroy\n      while (watchListeners.length) {\n        watchListeners.shift()();\n      }\n    });\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n  };\n\n  $scope.isDisabled = function(date) {\n    if (date === 'today') {\n      date = new Date();\n    }\n\n    return $scope.watchData.minDate && $scope.compare(date, cache.minDate) < 0 ||\n        $scope.watchData.maxDate && $scope.compare(date, cache.maxDate) > 0;\n  };\n\n  $scope.compare = function(date1, date2) {\n    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n  };\n\n  // Inner change\n  $scope.dateSelection = function(dt) {\n    if (angular.isDefined(dt)) {\n      $scope.date = dt;\n    }\n    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n    $element.val(date);\n    ngModel.$setViewValue(date);\n\n    if (closeOnDateSelection) {\n      $scope.isOpen = false;\n      $element[0].focus();\n    }\n  };\n\n  $scope.keydown = function(evt) {\n    if (evt.which === 27) {\n      evt.stopPropagation();\n      $scope.isOpen = false;\n      $element[0].focus();\n    }\n  };\n\n  $scope.select = function(date, evt) {\n    evt.stopPropagation();\n\n    if (date === 'today') {\n      var today = new Date();\n      if (angular.isDate($scope.date)) {\n        date = new Date($scope.date);\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n      } else {\n        date = new Date(today.setHours(0, 0, 0, 0));\n      }\n    }\n    $scope.dateSelection(date);\n  };\n\n  $scope.close = function(evt) {\n    evt.stopPropagation();\n\n    $scope.isOpen = false;\n    $element[0].focus();\n  };\n\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n  if ($attrs.ngDisabled) {\n    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {\n      $scope.disabled = disabled;\n    }));\n  }\n\n  $scope.$watch('isOpen', function(value) {\n    if (value) {\n      if (!$scope.disabled) {\n        $timeout(function() {\n          positionPopup();\n\n          if (onOpenFocus) {\n            $scope.$broadcast('uib:datepicker.focus');\n          }\n          $document.on('click', documentClickBind);\n\n          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n          if (appendToBody || $position.parsePlacement(placement)[2]) {\n            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));\n            if (scrollParentEl) {\n              scrollParentEl.on('scroll', positionPopup);\n            }\n          } else {\n            scrollParentEl = null;\n          }\n\n          angular.element($window).on('resize', positionPopup);\n        }, 0, false);\n      } else {\n        $scope.isOpen = false;\n      }\n    } else {\n      $document.off('click', documentClickBind);\n      if (scrollParentEl) {\n        scrollParentEl.off('scroll', positionPopup);\n      }\n      angular.element($window).off('resize', positionPopup);\n    }\n  });\n\n  function cameltoDash(string) {\n    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n  }\n\n  function parseDateString(viewValue) {\n    var date = dateParser.parse(viewValue, dateFormat, $scope.date);\n    if (isNaN(date)) {\n      for (var i = 0; i < altInputFormats.length; i++) {\n        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);\n        if (!isNaN(date)) {\n          return date;\n        }\n      }\n    }\n    return date;\n  }\n\n  function parseDate(viewValue) {\n    if (angular.isNumber(viewValue)) {\n      // presumably timestamp to date object\n      viewValue = new Date(viewValue);\n    }\n\n    if (!viewValue) {\n      return null;\n    }\n\n    if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n      return viewValue;\n    }\n\n    if (angular.isString(viewValue)) {\n      var date = parseDateString(viewValue);\n      if (!isNaN(date)) {\n        return dateParser.toTimezone(date, ngModelOptions.timezone);\n      }\n    }\n\n    return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;\n  }\n\n  function validator(modelValue, viewValue) {\n    var value = modelValue || viewValue;\n\n    if (!$attrs.ngRequired && !value) {\n      return true;\n    }\n\n    if (angular.isNumber(value)) {\n      value = new Date(value);\n    }\n\n    if (!value) {\n      return true;\n    }\n\n    if (angular.isDate(value) && !isNaN(value)) {\n      return true;\n    }\n\n    if (angular.isString(value)) {\n      return !isNaN(parseDateString(viewValue));\n    }\n\n    return false;\n  }\n\n  function documentClickBind(event) {\n    if (!$scope.isOpen && $scope.disabled) {\n      return;\n    }\n\n    var popup = $popup[0];\n    var dpContainsTarget = $element[0].contains(event.target);\n    // The popup node may not be an element node\n    // In some browsers (IE) only element nodes have the 'contains' function\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n      $scope.$apply(function() {\n        $scope.isOpen = false;\n      });\n    }\n  }\n\n  function inputKeydownBind(evt) {\n    if (evt.which === 27 && $scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.$apply(function() {\n        $scope.isOpen = false;\n      });\n      $element[0].focus();\n    } else if (evt.which === 40 && !$scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.$apply(function() {\n        $scope.isOpen = true;\n      });\n    }\n  }\n\n  function positionPopup() {\n    if ($scope.isOpen) {\n      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));\n      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n      var position = $position.positionElements($element, dpElement, placement, appendToBody);\n      dpElement.css({top: position.top + 'px', left: position.left + 'px'});\n      if (dpElement.hasClass('uib-position-measure')) {\n        dpElement.removeClass('uib-position-measure');\n      }\n    }\n  }\n\n  $scope.$on('uib:datepicker.mode', function() {\n    $timeout(positionPopup, 0, false);\n  });\n}])\n\n.directive('uibDatepickerPopup', function() {\n  return {\n    require: ['ngModel', 'uibDatepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      datepickerOptions: '=?',\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@',\n      dateDisabled: '&',\n      customClass: '&'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n})\n\n.directive('uibDatepickerPopupWrap', function() {\n  return {\n    replace: true,\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/popup.html';\n    }\n  };\n});\n\nangular.module('ui.bootstrap.debounce', [])\n/**\n * A helper, internal service that debounces a function\n */\n  .factory('$$debounce', ['$timeout', function($timeout) {\n    return function(callback, debounceTime) {\n      var timeoutPromise;\n\n      return function() {\n        var self = this;\n        var args = Array.prototype.slice.call(arguments);\n        if (timeoutPromise) {\n          $timeout.cancel(timeoutPromise);\n        }\n\n        timeoutPromise = $timeout(function() {\n          callback.apply(self, args);\n        }, debounceTime);\n      };\n    };\n  }]);\n\nangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\n\n.constant('uibDropdownConfig', {\n  appendToOpenClass: 'uib-dropdown-open',\n  openClass: 'open'\n})\n\n.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\n  var openScope = null;\n\n  this.open = function(dropdownScope) {\n    if (!openScope) {\n      $document.on('click', closeDropdown);\n      $document.on('keydown', keybindFilter);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n  };\n\n  this.close = function(dropdownScope) {\n    if (openScope === dropdownScope) {\n      openScope = null;\n      $document.off('click', closeDropdown);\n      $document.off('keydown', keybindFilter);\n    }\n  };\n\n  var closeDropdown = function(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope) { return; }\n\n    if (evt && openScope.getAutoClose() === 'disabled') { return; }\n\n    if (evt && evt.which === 3) { return; }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  var keybindFilter = function(evt) {\n    if (evt.which === 27) {\n      openScope.focusToggleElement();\n      closeDropdown();\n    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      openScope.focusDropdownEntry(evt.which);\n    }\n  };\n}])\n\n.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    appendToOpenClass = dropdownConfig.appendToOpenClass,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    appendToBody = false,\n    appendTo = null,\n    keynavEnabled = false,\n    selectedOption = null,\n    body = $document.find('body');\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    if (angular.isDefined($attrs.dropdownAppendTo)) {\n      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);\n      if (appendToEl) {\n        appendTo = angular.element(appendToEl);\n      }\n    }\n\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\n    keynavEnabled = angular.isDefined($attrs.keyboardNav);\n\n    if (appendToBody && !appendTo) {\n      appendTo = body;\n    }\n\n    if (appendTo && self.dropdownMenu) {\n      appendTo.append(self.dropdownMenu);\n      $element.on('$destroy', function handleDestroyEvent() {\n        self.dropdownMenu.remove();\n      });\n    }\n  };\n\n  this.toggle = function(open) {\n    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      angular.element(self.dropdownMenu).find('a') :\n      $element.find('ul').eq(0).find('a');\n\n    switch (keyCode) {\n      case 40: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = self.selectedOption === elems.length - 1 ?\n            self.selectedOption :\n            self.selectedOption + 1;\n        }\n        break;\n      }\n      case 38: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    if (appendTo && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),\n        css,\n        rightalign;\n\n      css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        css.right = window.innerWidth -\n          (pos.left + $element.prop('offsetWidth')) + 'px';\n      }\n\n      // Need to adjust our positioning to be relative to the appendTo container\n      // if it's not the body element\n      if (!appendToBody) {\n        var appendOffset = $position.offset(appendTo);\n\n        css.top = pos.top - appendOffset.top + 'px';\n\n        if (!rightalign) {\n          css.left = pos.left - appendOffset.left + 'px';\n        } else {\n          css.right = window.innerWidth -\n            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';\n        }\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    var openContainer = appendTo ? appendTo : $element;\n    var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);\n\n    if (hasOpenClass === !isOpen) {\n      $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {\n        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n          toggleInvoker($scope, { open: !!isOpen });\n        }\n      });\n    }\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n          });\n        });\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope);\n    } else {\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      uibDropdownService.close(scope);\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n\n  $scope.$on('$locationChangeSuccess', function() {\n    if (scope.getAutoClose() !== 'disabled') {\n      scope.isOpen = false;\n    }\n  });\n}])\n\n.directive('uibDropdown', function() {\n  return {\n    controller: 'UibDropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init();\n    }\n  };\n})\n\n.directive('uibDropdownMenu', function() {\n  return {\n    restrict: 'A',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n})\n\n.directive('uibDropdownToggle', function() {\n  return {\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.bind('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.unbind('click', toggleDropdown);\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.stackedMap', [])\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function() {\n    return {\n      createNew: function() {\n        var stack = [];\n\n        return {\n          add: function(key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function(key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function() {\n            return stack[stack.length - 1];\n          },\n          remove: function(key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function() {\n            return stack.splice(stack.length - 1, 1)[0];\n          },\n          length: function() {\n            return stack.length;\n          }\n        };\n      }\n    };\n  });\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])\n/**\n * A helper, internal data structure that stores all references attached to key\n */\n  .factory('$$multiMap', function() {\n    return {\n      createNew: function() {\n        var map = {};\n\n        return {\n          entries: function() {\n            return Object.keys(map).map(function(key) {\n              return {\n                key: key,\n                value: map[key]\n              };\n            });\n          },\n          get: function(key) {\n            return map[key];\n          },\n          hasKey: function(key) {\n            return !!map[key];\n          },\n          keys: function() {\n            return Object.keys(map);\n          },\n          put: function(key, value) {\n            if (!map[key]) {\n              map[key] = [];\n            }\n\n            map[key].push(value);\n          },\n          remove: function(key, value) {\n            var values = map[key];\n\n            if (!values) {\n              return;\n            }\n\n            var idx = values.indexOf(value);\n\n            if (idx !== -1) {\n              values.splice(idx, 1);\n            }\n\n            if (!values.length) {\n              delete map[key];\n            }\n          }\n        };\n      }\n    };\n  })\n\n/**\n * Pluggable resolve mechanism for the modal resolve resolution\n * Supports UI Router's $resolve service\n */\n  .provider('$uibResolve', function() {\n    var resolve = this;\n    this.resolver = null;\n\n    this.setResolver = function(resolver) {\n      this.resolver = resolver;\n    };\n\n    this.$get = ['$injector', '$q', function($injector, $q) {\n      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;\n      return {\n        resolve: function(invocables, locals, parent, self) {\n          if (resolver) {\n            return resolver.resolve(invocables, locals, parent, self);\n          }\n\n          var promises = [];\n\n          angular.forEach(invocables, function(value) {\n            if (angular.isFunction(value) || angular.isArray(value)) {\n              promises.push($q.resolve($injector.invoke(value)));\n            } else if (angular.isString(value)) {\n              promises.push($q.resolve($injector.get(value)));\n            } else {\n              promises.push($q.resolve(value));\n            }\n          });\n\n          return $q.all(promises).then(function(resolves) {\n            var resolveObj = {};\n            var resolveIter = 0;\n            angular.forEach(invocables, function(value, key) {\n              resolveObj[key] = resolves[resolveIter++];\n            });\n\n            return resolveObj;\n          });\n        }\n      };\n    }];\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('uibModalBackdrop', ['$animateCss', '$injector', '$uibModalStack',\n  function($animateCss, $injector, $modalStack) {\n    return {\n      replace: true,\n      templateUrl: 'uib/template/modal/backdrop.html',\n      compile: function(tElement, tAttrs) {\n        tElement.addClass(tAttrs.backdropClass);\n        return linkFn;\n      }\n    };\n\n    function linkFn(scope, element, attrs) {\n      if (attrs.modalInClass) {\n        $animateCss(element, {\n          addClass: attrs.modalInClass\n        }).start();\n\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n          var done = setIsAsync();\n          if (scope.modalOptions.animation) {\n            $animateCss(element, {\n              removeClass: attrs.modalInClass\n            }).start().then(done);\n          } else {\n            done();\n          }\n        });\n      }\n    }\n  }])\n\n  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animate', '$animateCss', '$document',\n  function($modalStack, $q, $animate, $animateCss, $document) {\n    return {\n      scope: {\n        index: '@'\n      },\n      replace: true,\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'uib/template/modal/window.html';\n      },\n      link: function(scope, element, attrs) {\n        element.addClass(attrs.windowClass || '');\n        element.addClass(attrs.windowTopClass || '');\n        scope.size = attrs.size;\n\n        scope.close = function(evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop &&\n            modal.value.backdrop !== 'static' &&\n            evt.target === evt.currentTarget) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n\n        // moved from template to fix issue #2280\n        element.on('click', scope.close);\n\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n        // We can detect that by using this property in the template associated with this directive and then use\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n        scope.$isRendered = true;\n\n        // Deferred object that will be resolved when this modal is render.\n        var modalRenderDeferObj = $q.defer();\n        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\n        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\n        attrs.$observe('modalRender', function(value) {\n          if (value === 'true') {\n            modalRenderDeferObj.resolve();\n          }\n        });\n\n        modalRenderDeferObj.promise.then(function() {\n          var animationPromise = null;\n\n          if (attrs.modalInClass) {\n            animationPromise = $animateCss(element, {\n              addClass: attrs.modalInClass\n            }).start();\n\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n              var done = setIsAsync();\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: attrs.modalInClass\n                }).start().then(done);\n              } else {\n                $animate.removeClass(element, attrs.modalInClass).then(done);\n              }\n            });\n          }\n\n\n          $q.when(animationPromise).then(function() {\n            // Notify {@link $modalStack} that modal is rendered.\n            var modal = $modalStack.getTop();\n            if (modal) {\n              $modalStack.modalRendered(modal.key);\n            }\n\n            /**\n             * If something within the freshly-opened modal already has focus (perhaps via a\n             * directive that causes focus). then no need to try and focus anything.\n             */\n            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {\n              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n              /**\n               * Auto-focusing of a freshly-opened modal element causes any child elements\n               * with the autofocus attribute to lose focus. This is an issue on touch\n               * based devices which will show and then hide the onscreen keyboard.\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n               * the modal element if the modal does not contain an autofocus element.\n               */\n              if (inputWithAutofocus) {\n                inputWithAutofocus.focus();\n              } else {\n                element[0].focus();\n              }\n            }\n          });\n        });\n      }\n    };\n  }])\n\n  .directive('uibModalAnimationClass', function() {\n    return {\n      compile: function(tElement, tAttrs) {\n        if (tAttrs.modalAnimation) {\n          tElement.addClass(tAttrs.uibModalAnimationClass);\n        }\n      }\n    };\n  })\n\n  .directive('uibModalTransclude', function() {\n    return {\n      link: function(scope, element, attrs, controller, transclude) {\n        transclude(scope.$parent, function(clone) {\n          element.empty();\n          element.append(clone);\n        });\n      }\n    };\n  })\n\n  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',\n    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap',\n    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap) {\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var openedClasses = $$multiMap.createNew();\n      var $modalStack = {\n        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n      };\n\n      //Modal focus behavior\n      var focusableElementList;\n      var focusIndex = 0;\n      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +\n        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\n        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n        var modalWindow = openedWindows.get(modalInstance).value;\n        var appendToElement = modalWindow.appendTo;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n          openedClasses.remove(modalBodyClass, modalInstance);\n          appendToElement.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));\n          toggleTopWindowClass(true);\n        }, modalWindow.closedDeferred);\n        checkRemoveBackdrop();\n\n        //move focus to specified element if available, or else to body\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n          elementToReceiveFocus.focus();\n        } else if (appendToElement.focus) {\n          appendToElement.focus();\n        }\n      }\n\n      // Add or remove \"windowTopClass\" from the top window in the stack\n      function toggleTopWindowClass(toggleSwitch) {\n        var modalWindow;\n\n        if (openedWindows.length() > 0) {\n          modalWindow = openedWindows.top().value;\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n        }\n      }\n\n      function checkRemoveBackdrop() {\n        //remove backdrop if no longer needed\n        if (backdropDomEl && backdropIndex() === -1) {\n          var backdropScopeRef = backdropScope;\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n            backdropScopeRef = null;\n          });\n          backdropDomEl = undefined;\n          backdropScope = undefined;\n        }\n      }\n\n      function removeAfterAnimate(domEl, scope, done, closedDeferred) {\n        var asyncDeferred;\n        var asyncPromise = null;\n        var setIsAsync = function() {\n          if (!asyncDeferred) {\n            asyncDeferred = $q.defer();\n            asyncPromise = asyncDeferred.promise;\n          }\n\n          return function asyncDone() {\n            asyncDeferred.resolve();\n          };\n        };\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\n        // Note that it's intentional that asyncPromise might be null.\n        // That's when setIsAsync has not been called during the\n        // NOW_CLOSING_EVENT broadcast.\n        return $q.when(asyncPromise).then(afterAnimating);\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          $animateCss(domEl, {\n            event: 'leave'\n          }).start().then(function() {\n            domEl.remove();\n            if (closedDeferred) {\n              closedDeferred.resolve();\n            }\n          });\n\n          scope.$destroy();\n          if (done) {\n            done();\n          }\n        }\n      }\n\n      $document.on('keydown', keydownListener);\n\n      $rootScope.$on('$destroy', function() {\n        $document.off('keydown', keydownListener);\n      });\n\n      function keydownListener(evt) {\n        if (evt.isDefaultPrevented()) {\n          return evt;\n        }\n\n        var modal = openedWindows.top();\n        if (modal) {\n          switch (evt.which) {\n            case 27: {\n              if (modal.value.keyboard) {\n                evt.preventDefault();\n                $rootScope.$apply(function() {\n                  $modalStack.dismiss(modal.key, 'escape key press');\n                });\n              }\n              break;\n            }\n            case 9: {\n              $modalStack.loadFocusElementList(modal);\n              var focusChanged = false;\n              if (evt.shiftKey) {\n                if ($modalStack.isFocusInFirstItem(evt) || $modalStack.isModalFocused(evt, modal)) {\n                  focusChanged = $modalStack.focusLastFocusableElement();\n                }\n              } else {\n                if ($modalStack.isFocusInLastItem(evt)) {\n                  focusChanged = $modalStack.focusFirstFocusableElement();\n                }\n              }\n\n              if (focusChanged) {\n                evt.preventDefault();\n                evt.stopPropagation();\n              }\n              break;\n            }\n          }\n        }\n      }\n\n      $modalStack.open = function(modalInstance, modal) {\n        var modalOpener = $document[0].activeElement,\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\n        toggleTopWindowClass(false);\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          renderDeferred: modal.renderDeferred,\n          closedDeferred: modal.closedDeferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard,\n          openedClass: modal.openedClass,\n          windowTopClass: modal.windowTopClass,\n          animation: modal.animation,\n          appendTo: modal.appendTo\n        });\n\n        openedClasses.put(modalBodyClass, modalInstance);\n\n        var appendToElement = modal.appendTo,\n            currBackdropIndex = backdropIndex();\n\n        if (!appendToElement.length) {\n          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');\n        }\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.modalOptions = modal;\n          backdropScope.index = currBackdropIndex;\n          backdropDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n          backdropDomEl.attr('backdrop-class', modal.backdropClass);\n          if (modal.animation) {\n            backdropDomEl.attr('modal-animation', 'true');\n          }\n          $compile(backdropDomEl)(backdropScope);\n          $animate.enter(backdropDomEl, appendToElement);\n        }\n\n        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n        angularDomEl.attr({\n          'template-url': modal.windowTemplateUrl,\n          'window-class': modal.windowClass,\n          'window-top-class': modal.windowTopClass,\n          'size': modal.size,\n          'index': openedWindows.length() - 1,\n          'animate': 'animate'\n        }).html(modal.content);\n        if (modal.animation) {\n          angularDomEl.attr('modal-animation', 'true');\n        }\n\n        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement)\n          .then(function() {\n            if (!modal.scope.$$uibDestructionScheduled) {\n              $animate.addClass(appendToElement, modalBodyClass);\n            }\n          });\n\n        openedWindows.top().value.modalDomEl = angularDomEl;\n        openedWindows.top().value.modalOpener = modalOpener;\n\n        $modalStack.clearFocusListCache();\n      };\n\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\n        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n      }\n\n      $modalStack.close = function(modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismiss = function(modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismissAll = function(reason) {\n        var topModal = this.getTop();\n        while (topModal && this.dismiss(topModal.key, reason)) {\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function() {\n        return openedWindows.top();\n      };\n\n      $modalStack.modalRendered = function(modalInstance) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.renderDeferred.resolve();\n        }\n      };\n\n      $modalStack.focusFirstFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[0].focus();\n          return true;\n        }\n        return false;\n      };\n      $modalStack.focusLastFocusableElement = function() {\n        if (focusableElementList.length > 0) {\n          focusableElementList[focusableElementList.length - 1].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.isModalFocused = function(evt, modalWindow) {\n        if (evt && modalWindow) {\n          var modalDomEl = modalWindow.value.modalDomEl;\n          if (modalDomEl && modalDomEl.length) {\n            return (evt.target || evt.srcElement) === modalDomEl[0];\n          }\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInFirstItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) === focusableElementList[0];\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInLastItem = function(evt) {\n        if (focusableElementList.length > 0) {\n          return (evt.target || evt.srcElement) === focusableElementList[focusableElementList.length - 1];\n        }\n        return false;\n      };\n\n      $modalStack.clearFocusListCache = function() {\n        focusableElementList = [];\n        focusIndex = 0;\n      };\n\n      $modalStack.loadFocusElementList = function(modalWindow) {\n        if (focusableElementList === undefined || !focusableElementList.length) {\n          if (modalWindow) {\n            var modalDomE1 = modalWindow.value.modalDomEl;\n            if (modalDomE1 && modalDomE1.length) {\n              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);\n            }\n          }\n        }\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$uibModal', function() {\n    var $modalProvider = {\n      options: {\n        animation: true,\n        backdrop: true, //can also be false or 'static'\n        keyboard: true\n      },\n      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',\n        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $templateRequest(angular.isFunction(options.templateUrl) ?\n                options.templateUrl() : options.templateUrl);\n          }\n\n          var promiseChain = null;\n          $modal.getPromiseChain = function() {\n            return promiseChain;\n          };\n\n          $modal.open = function(modalOptions) {\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n            var modalClosedDeferred = $q.defer();\n            var modalRenderDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              closed: modalClosedDeferred.promise,\n              rendered: modalRenderDeferred.promise,\n              close: function (result) {\n                return $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                return $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);\n\n            //verify options\n            if (!modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise =\n              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);\n\n            function resolveWithTemplate() {\n              return templateAndResolvePromise;\n            }\n\n            // Wait for the resolution of the existing promise chain.\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n            // Then add to $modalStack and resolve opened.\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n            var samePromise;\n            samePromise = promiseChain = $q.all([promiseChain])\n              .then(resolveWithTemplate, resolveWithTemplate)\n              .then(function resolveSuccess(tplAndVars) {\n                var providedScope = modalOptions.scope || $rootScope;\n\n                var modalScope = providedScope.$new();\n                modalScope.$close = modalInstance.close;\n                modalScope.$dismiss = modalInstance.dismiss;\n\n                modalScope.$on('$destroy', function() {\n                  if (!modalScope.$$uibDestructionScheduled) {\n                    modalScope.$dismiss('$uibUnscheduledDestruction');\n                  }\n                });\n\n                var ctrlInstance, ctrlLocals = {};\n\n                //controllers\n                if (modalOptions.controller) {\n                  ctrlLocals.$scope = modalScope;\n                  ctrlLocals.$uibModalInstance = modalInstance;\n                  angular.forEach(tplAndVars[1], function(value, key) {\n                    ctrlLocals[key] = value;\n                  });\n\n                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);\n                  if (modalOptions.controllerAs) {\n                    if (modalOptions.bindToController) {\n                      ctrlInstance.$close = modalScope.$close;\n                      ctrlInstance.$dismiss = modalScope.$dismiss;\n                      angular.extend(ctrlInstance, providedScope);\n                      if (angular.isFunction(ctrlInstance.$onInit)) {\n                        ctrlInstance.$onInit();\n                      }\n                    }\n\n                    modalScope[modalOptions.controllerAs] = ctrlInstance;\n                  }\n                }\n\n                $modalStack.open(modalInstance, {\n                  scope: modalScope,\n                  deferred: modalResultDeferred,\n                  renderDeferred: modalRenderDeferred,\n                  closedDeferred: modalClosedDeferred,\n                  content: tplAndVars[0],\n                  animation: modalOptions.animation,\n                  backdrop: modalOptions.backdrop,\n                  keyboard: modalOptions.keyboard,\n                  backdropClass: modalOptions.backdropClass,\n                  windowTopClass: modalOptions.windowTopClass,\n                  windowClass: modalOptions.windowClass,\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n                  size: modalOptions.size,\n                  openedClass: modalOptions.openedClass,\n                  appendTo: modalOptions.appendTo\n                });\n                modalOpenedDeferred.resolve(true);\n\n            }, function resolveError(reason) {\n              modalOpenedDeferred.reject(reason);\n              modalResultDeferred.reject(reason);\n            })['finally'](function() {\n              if (promiseChain === samePromise) {\n                promiseChain = null;\n              }\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }\n      ]\n    };\n\n    return $modalProvider;\n  });\n\nangular.module('ui.bootstrap.paging', [])\n/**\n * Helper internal service for generating common controller code between the\n * pager and pagination components\n */\n.factory('uibPaging', ['$parse', function($parse) {\n  return {\n    create: function(ctrl, $scope, $attrs) {\n      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl\n      ctrl._watchers = [];\n\n      ctrl.init = function(ngModelCtrl, config) {\n        ctrl.ngModelCtrl = ngModelCtrl;\n        ctrl.config = config;\n\n        ngModelCtrl.$render = function() {\n          ctrl.render();\n        };\n\n        if ($attrs.itemsPerPage) {\n          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {\n            ctrl.itemsPerPage = parseInt(value, 10);\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }));\n        } else {\n          ctrl.itemsPerPage = config.itemsPerPage;\n        }\n\n        $scope.$watch('totalItems', function(newTotal, oldTotal) {\n          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }\n        });\n      };\n\n      ctrl.calculateTotalPages = function() {\n        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);\n        return Math.max(totalPages || 0, 1);\n      };\n\n      ctrl.render = function() {\n        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;\n      };\n\n      $scope.selectPage = function(page, evt) {\n        if (evt) {\n          evt.preventDefault();\n        }\n\n        var clickAllowed = !$scope.ngDisabled || !evt;\n        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n          if (evt && evt.target) {\n            evt.target.blur();\n          }\n          ctrl.ngModelCtrl.$setViewValue(page);\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.getText = function(key) {\n        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];\n      };\n\n      $scope.noPrevious = function() {\n        return $scope.page === 1;\n      };\n\n      $scope.noNext = function() {\n        return $scope.page === $scope.totalPages;\n      };\n\n      ctrl.updatePage = function() {\n        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable\n\n        if ($scope.page > $scope.totalPages) {\n          $scope.selectPage($scope.totalPages);\n        } else {\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.$on('$destroy', function() {\n        while (ctrl._watchers.length) {\n          ctrl._watchers.shift()();\n        }\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])\n\n.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {\n  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;\n\n  uibPaging.create(this, $scope, $attrs);\n}])\n\n.constant('uibPagerConfig', {\n  itemsPerPage: 10,\n  previousText: '« Previous',\n  nextText: 'Next »',\n  align: true\n})\n\n.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['uibPager', '?ngModel'],\n    controller: 'UibPagerController',\n    controllerAs: 'pager',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pager/pager.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n        return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPagerConfig);\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])\n.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {\n  var ctrl = this;\n  // Setup configuration parameters\n  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,\n    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,\n    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,\n    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,\n    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;\n  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;\n  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;\n\n  uibPaging.create(this, $scope, $attrs);\n\n  if ($attrs.maxSize) {\n    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {\n      maxSize = parseInt(value, 10);\n      ctrl.render();\n    }));\n  }\n\n  // Create page object used in template\n  function makePage(number, text, isActive) {\n    return {\n      number: number,\n      text: text,\n      active: isActive\n    };\n  }\n\n  function getPages(currentPage, totalPages) {\n    var pages = [];\n\n    // Default page limits\n    var startPage = 1, endPage = totalPages;\n    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n    // recompute if maxSize\n    if (isMaxSized) {\n      if (rotate) {\n        // Current page is displayed in the middle of the visible ones\n        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\n        endPage = startPage + maxSize - 1;\n\n        // Adjust if limit is exceeded\n        if (endPage > totalPages) {\n          endPage = totalPages;\n          startPage = endPage - maxSize + 1;\n        }\n      } else {\n        // Visible pages are paginated with maxSize\n        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;\n\n        // Adjust last page if limit is exceeded\n        endPage = Math.min(startPage + maxSize - 1, totalPages);\n      }\n    }\n\n    // Add page number links\n    for (var number = startPage; number <= endPage; number++) {\n      var page = makePage(number, pageLabel(number), number === currentPage);\n      pages.push(page);\n    }\n\n    // Add links to move between page sets\n    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {\n      if (startPage > 1) {\n        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning\n        var previousPageSet = makePage(startPage - 1, '...', false);\n        pages.unshift(previousPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential\n            var secondPageLink = makePage(2, '2', false);\n            pages.unshift(secondPageLink);\n          }\n          //add the first page\n          var firstPageLink = makePage(1, '1', false);\n          pages.unshift(firstPageLink);\n        }\n      }\n\n      if (endPage < totalPages) {\n        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end\n        var nextPageSet = makePage(endPage + 1, '...', false);\n        pages.push(nextPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential\n            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);\n            pages.push(secondToLastPageLink);\n          }\n          //add the last page\n          var lastPageLink = makePage(totalPages, totalPages, false);\n          pages.push(lastPageLink);\n        }\n      }\n    }\n    return pages;\n  }\n\n  var originalRender = this.render;\n  this.render = function() {\n    originalRender();\n    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {\n      $scope.pages = getPages($scope.page, $scope.totalPages);\n    }\n  };\n}])\n\n.constant('uibPaginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  boundaryLinkNumbers: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true,\n  forceEllipses: false\n})\n\n.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['uibPagination', '?ngModel'],\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pagination/pagination.html';\n    },\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider('$uibTooltip', function() {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    placementClassPrefix: '',\n    animation: true,\n    popupDelay: 0,\n    popupCloseDelay: 0,\n    useContentExp: false\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'outsideClick': 'outsideClick',\n    'focus': 'blur',\n    'none': ''\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function(value) {\n\t\tangular.extend(globalOptions, value);\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );\n   */\n  this.setTriggers = function setTriggers(triggers) {\n    angular.extend(triggerMap, triggers);\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake_case.\n   */\n  function snake_case(name) {\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n    var openedTooltips = $$stackedMap.createNew();\n    $document.on('keypress', keypressListener);\n\n    $rootScope.$on('$destroy', function() {\n      $document.off('keypress', keypressListener);\n    });\n\n    function keypressListener(e) {\n      if (e.which === 27) {\n        var last = openedTooltips.top();\n        if (last) {\n          last.value.close();\n          openedTooltips.removeTop();\n          last = null;\n        }\n      }\n    }\n\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n      options = angular.extend({}, defaultOptions, globalOptions, options);\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers(trigger) {\n        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n        var hide = show.map(function(trigger) {\n          return triggerMap[trigger] || trigger;\n        });\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case(ttType);\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName + '-popup '+\n          'title=\"' + startSym + 'title' + endSym + '\" '+\n          (options.useContentExp ?\n            'content-exp=\"contentExp()\" ' :\n            'content=\"' + startSym + 'content' + endSym + '\" ') +\n          'placement=\"' + startSym + 'placement' + endSym + '\" '+\n          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" '+\n          'animation=\"animation\" ' +\n          'is-open=\"isOpen\"' +\n          'origin-scope=\"origScope\" ' +\n          'class=\"uib-position-measure\"' +\n          '>' +\n        '</div>';\n\n      return {\n        compile: function(tElem, tAttrs) {\n          var tooltipLinker = $compile(template);\n\n          return function link(scope, element, attrs, tooltipCtrl) {\n            var tooltip;\n            var tooltipLinkedScope;\n            var transitionTimeout;\n            var showTimeout;\n            var hideTimeout;\n            var positionTimeout;\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n            var triggers = getTriggers(undefined);\n            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n            var ttScope = scope.$new(true);\n            var repositionScheduled = false;\n            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n            var observers = [];\n            var lastPlacement;\n\n            var positionTooltip = function() {\n              // check if tooltip exists and is not empty\n              if (!tooltip || !tooltip.html()) { return; }\n\n              if (!positionTimeout) {\n                positionTimeout = $timeout(function() {\n                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });\n\n                  if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {\n                    tooltip.removeClass(lastPlacement.split('-')[0]);\n                    tooltip.addClass(ttPosition.placement.split('-')[0]);\n                  }\n\n                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {\n                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);\n                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);\n                  }\n\n                  // first time through tt element will have the\n                  // uib-position-measure class or if the placement\n                  // has changed we need to position the arrow.\n                  if (tooltip.hasClass('uib-position-measure')) {\n                    $position.positionArrow(tooltip, ttPosition.placement);\n                    tooltip.removeClass('uib-position-measure');\n                  } else if (lastPlacement !== ttPosition.placement) {\n                    $position.positionArrow(tooltip, ttPosition.placement);\n                  }\n                  lastPlacement = ttPosition.placement;\n\n                  positionTimeout = null;\n                }, 0, false);\n              }\n            };\n\n            // Set up the correct scope to allow transclusion later\n            ttScope.origScope = scope;\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            ttScope.isOpen = false;\n            openedTooltips.add(ttScope, {\n              close: hide\n            });\n\n            function toggleTooltipBind() {\n              if (!ttScope.isOpen) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n                return;\n              }\n\n              cancelHide();\n              prepareTooltip();\n\n              if (ttScope.popupDelay) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!showTimeout) {\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n                }\n              } else {\n                show();\n              }\n            }\n\n            function hideTooltipBind() {\n              cancelShow();\n\n              if (ttScope.popupCloseDelay) {\n                if (!hideTimeout) {\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n                }\n              } else {\n                hide();\n              }\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n              cancelShow();\n              cancelHide();\n\n              // Don't show empty tooltips.\n              if (!ttScope.content) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // And show the tooltip.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = true;\n                assignIsOpen(true);\n                positionTooltip();\n              });\n            }\n\n            function cancelShow() {\n              if (showTimeout) {\n                $timeout.cancel(showTimeout);\n                showTimeout = null;\n              }\n\n              if (positionTimeout) {\n                $timeout.cancel(positionTimeout);\n                positionTimeout = null;\n              }\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              if (!ttScope) {\n                return;\n              }\n\n              // First things first: we don't show it anymore.\n              ttScope.$evalAsync(function() {\n                if (ttScope) {\n                  ttScope.isOpen = false;\n                  assignIsOpen(false);\n                  // And now we remove it from the DOM. However, if we have animation, we\n                  // need to wait for it to expire beforehand.\n                  // FIXME: this is a placeholder for a port of the transitions library.\n                  // The fade transition in TWBS is 150ms.\n                  if (ttScope.animation) {\n                    if (!transitionTimeout) {\n                      transitionTimeout = $timeout(removeTooltip, 150, false);\n                    }\n                  } else {\n                    removeTooltip();\n                  }\n                }\n              });\n            }\n\n            function cancelHide() {\n              if (hideTimeout) {\n                $timeout.cancel(hideTimeout);\n                hideTimeout = null;\n              }\n\n              if (transitionTimeout) {\n                $timeout.cancel(transitionTimeout);\n                transitionTimeout = null;\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                return;\n              }\n\n              tooltipLinkedScope = ttScope.$new();\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n                if (appendToBody) {\n                  $document.find('body').append(tooltip);\n                } else {\n                  element.after(tooltip);\n                }\n              });\n\n              prepObservers();\n            }\n\n            function removeTooltip() {\n              cancelShow();\n              cancelHide();\n              unregisterObservers();\n\n              if (tooltip) {\n                tooltip.remove();\n                tooltip = null;\n              }\n              if (tooltipLinkedScope) {\n                tooltipLinkedScope.$destroy();\n                tooltipLinkedScope = null;\n              }\n            }\n\n            /**\n             * Set the initial scope values. Once\n             * the tooltip is created, the observers\n             * will be added to keep things in sync.\n             */\n            function prepareTooltip() {\n              ttScope.title = attrs[prefix + 'Title'];\n              if (contentParse) {\n                ttScope.content = contentParse(scope);\n              } else {\n                ttScope.content = attrs[ttType];\n              }\n\n              ttScope.popupClass = attrs[prefix + 'Class'];\n              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n              var placement = $position.parsePlacement(ttScope.placement);\n              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];\n\n              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n            }\n\n            function assignIsOpen(isOpen) {\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n                isOpenParse.assign(scope, isOpen);\n              }\n            }\n\n            ttScope.contentExp = function() {\n              return ttScope.content;\n            };\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe('disabled', function(val) {\n              if (val) {\n                cancelShow();\n              }\n\n              if (val && ttScope.isOpen) {\n                hide();\n              }\n            });\n\n            if (isOpenParse) {\n              scope.$watch(isOpenParse, function(val) {\n                if (ttScope && !val === ttScope.isOpen) {\n                  toggleTooltipBind();\n                }\n              });\n            }\n\n            function prepObservers() {\n              observers.length = 0;\n\n              if (contentParse) {\n                observers.push(\n                  scope.$watch(contentParse, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    }\n                  })\n                );\n\n                observers.push(\n                  tooltipLinkedScope.$watch(function() {\n                    if (!repositionScheduled) {\n                      repositionScheduled = true;\n                      tooltipLinkedScope.$$postDigest(function() {\n                        repositionScheduled = false;\n                        if (ttScope && ttScope.isOpen) {\n                          positionTooltip();\n                        }\n                      });\n                    }\n                  })\n                );\n              } else {\n                observers.push(\n                  attrs.$observe(ttType, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    } else {\n                      positionTooltip();\n                    }\n                  })\n                );\n              }\n\n              observers.push(\n                attrs.$observe(prefix + 'Title', function(val) {\n                  ttScope.title = val;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n\n              observers.push(\n                attrs.$observe(prefix + 'Placement', function(val) {\n                  ttScope.placement = val ? val : options.placement;\n                  var placement = $position.parsePlacement(ttScope.placement);\n                  lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n            }\n\n            function unregisterObservers() {\n              if (observers.length) {\n                angular.forEach(observers, function(observer) {\n                  observer();\n                });\n                observers.length = 0;\n              }\n            }\n\n            // hide tooltips/popovers for outsideClick trigger\n            function bodyHideTooltipBind(e) {\n              if (!ttScope || !ttScope.isOpen || !tooltip) {\n                return;\n              }\n              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked\n              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {\n                hideTooltipBind();\n              }\n            }\n\n            var unregisterTriggers = function() {\n              triggers.show.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  element.off('click', toggleTooltipBind);\n                } else {\n                  element.off(trigger, showTooltipBind);\n                  element.off(trigger, toggleTooltipBind);\n                }\n              });\n              triggers.hide.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  $document.off('click', bodyHideTooltipBind);\n                } else {\n                  element.off(trigger, hideTooltipBind);\n                }\n              });\n            };\n\n            function prepTriggers() {\n              var val = attrs[prefix + 'Trigger'];\n              unregisterTriggers();\n\n              triggers = getTriggers(val);\n\n              if (triggers.show !== 'none') {\n                triggers.show.forEach(function(trigger, idx) {\n                  if (trigger === 'outsideClick') {\n                    element.on('click', toggleTooltipBind);\n                    $document.on('click', bodyHideTooltipBind);\n                  } else if (trigger === triggers.hide[idx]) {\n                    element.on(trigger, toggleTooltipBind);\n                  } else if (trigger) {\n                    element.on(trigger, showTooltipBind);\n                    element.on(triggers.hide[idx], hideTooltipBind);\n                  }\n\n                  element.on('keypress', function(e) {\n                    if (e.which === 27) {\n                      hideTooltipBind();\n                    }\n                  });\n                });\n              }\n            }\n\n            prepTriggers();\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            var appendToBodyVal;\n            var appendKey = prefix + 'AppendToBody';\n            if (appendKey in attrs && attrs[appendKey] === undefined) {\n              appendToBodyVal = true;\n            } else {\n              appendToBodyVal = scope.$eval(attrs[appendKey]);\n            }\n\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              unregisterTriggers();\n              removeTooltip();\n              openedTooltips.remove(ttScope);\n              ttScope = null;\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n// This is mostly ngInclude code but with a custom scope\n.directive('uibTooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest',\nfunction ($animate, $sce, $compile, $templateRequest) {\n  return {\n    link: function(scope, elem, attrs) {\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n/**\n * Note that it's intentional that these classes are *not* applied through $animate.\n * They must not be animated as they're expected to be present on the tooltip on\n * initialization.\n */\n.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      // need to set the primary position so the\n      // arrow has space during position measure.\n      // tooltip.positionTooltip()\n      if (scope.placement) {\n        // // There are no top-left etc... classes\n        // // in TWBS, so we need the primary position.\n        var position = $uibPosition.parsePlacement(scope.placement);\n        element.addClass(position[0]);\n      }\n\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n\n      if (scope.animation()) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n}])\n\n.directive('uibTooltipPopup', function() {\n  return {\n    replace: true,\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-popup.html'\n  };\n})\n\n.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('uibTooltipTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'\n  };\n})\n\n.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibTooltipHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'\n  };\n})\n\n.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, and selector delegatation.\n */\nangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\n.directive('uibPopoverTemplatePopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\n      originScope: '&' },\n    templateUrl: 'uib/template/popover/popover-template.html'\n  };\n})\n\n.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverHtmlPopup', function() {\n  return {\n    replace: true,\n    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/popover/popover-html.html'\n  };\n})\n\n.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverPopup', function() {\n  return {\n    replace: true,\n    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\n    templateUrl: 'uib/template/popover/popover.html'\n  };\n})\n\n.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopover', 'popover', 'click');\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('uibProgressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n  var self = this,\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = getMaxOrDefault();\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = getMaxOrDefault();\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n    this.bars.forEach(function (bar) {\n      bar.recalculatePercentage();\n    });\n  };\n\n  //$attrs.$observe('maxParam', function(maxParam) {\n  $scope.$watch('maxParam', function(maxParam) {\n    self.bars.forEach(function(bar) {\n      bar.max = getMaxOrDefault();\n      bar.recalculatePercentage();\n    });\n  });\n\n  function getMaxOrDefault () {\n    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;\n  }\n}])\n\n.directive('uibProgress', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    require: 'uibProgress',\n    scope: {\n      maxParam: '=?max'\n    },\n    templateUrl: 'uib/template/progressbar/progress.html'\n  };\n})\n\n.directive('uibBar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^uibProgress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, element, attrs);\n    }\n  };\n})\n\n.directive('uibProgressbar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    scope: {\n      value: '=',\n      maxParam: '=?max',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n});\n\nangular.module('ui.bootstrap.rating', [])\n\n.constant('uibRatingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null,\n  titles : ['one', 'two', 'three', 'four', 'five']\n})\n\n.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl = { $setViewValue: angular.noop };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.push(function(value) {\n      if (angular.isNumber(value) && value << 0 !== value) {\n        value = Math.round(value);\n      }\n\n      return value;\n    });\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n      tmpTitles : ratingConfig.titles;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n      $scope.$parent.$eval($attrs.ratingStates) :\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n    }\n    return states;\n  };\n\n  this.getTitle = function(index) {\n    if (index >= this.titles.length) {\n      return index + 1;\n    }\n\n    return this.titles[index];\n  };\n\n  $scope.rate = function(value) {\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if (!$scope.readonly) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n  };\n}])\n\n.directive('uibRating', function() {\n  return {\n    require: ['uibRating', 'ngModel'],\n    scope: {\n      readonly: '=?readOnly',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'UibRatingController',\n    templateUrl: 'uib/template/rating/rating.html',\n    replace: true,\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n});\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('UibTabsetController', ['$scope', function ($scope) {\n  var ctrl = this,\n    oldIndex;\n  ctrl.tabs = [];\n\n  ctrl.select = function(index) {\n    if (!destroyed) {\n      var previousIndex = findTabIndex(oldIndex);\n      var previousSelected = ctrl.tabs[previousIndex];\n      if (previousSelected) {\n        previousSelected.tab.onDeselect();\n        previousSelected.tab.active = false;\n      }\n\n      var selected = ctrl.tabs[index];\n      if (selected) {\n        selected.tab.onSelect();\n        selected.tab.active = true;\n        ctrl.active = selected.index;\n        oldIndex = selected.index;\n      } else if (!selected && angular.isNumber(oldIndex)) {\n        ctrl.active = null;\n        oldIndex = null;\n      }\n    }\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    ctrl.tabs.push({\n      tab: tab,\n      index: tab.index\n    });\n    ctrl.tabs.sort(function(t1, t2) {\n      if (t1.index > t2.index) {\n        return 1;\n      }\n\n      if (t1.index < t2.index) {\n        return -1;\n      }\n\n      return 0;\n    });\n\n    if (tab.index === ctrl.active || !angular.isNumber(ctrl.active) && ctrl.tabs.length === 1) {\n      var newActiveIndex = findTabIndex(tab.index);\n      ctrl.select(newActiveIndex);\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index = findTabIndex(tab.index);\n\n    if (tab.index === ctrl.active) {\n      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?\n        index - 1 : index + 1 % ctrl.tabs.length;\n      ctrl.select(newActiveTabIndex);\n    }\n\n    ctrl.tabs.splice(index, 1);\n  };\n\n  $scope.$watch('tabset.active', function(val) {\n    if (angular.isNumber(val) && val !== oldIndex) {\n      ctrl.select(findTabIndex(val));\n    }\n  });\n\n  var destroyed;\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n\n  function findTabIndex(index) {\n    for (var i = 0; i < ctrl.tabs.length; i++) {\n      if (ctrl.tabs[i].index === index) {\n        return i;\n      }\n    }\n  }\n}])\n\n.directive('uibTabset', function() {\n  return {\n    transclude: true,\n    replace: true,\n    scope: {},\n    bindToController: {\n      active: '=?',\n      type: '@'\n    },\n    controller: 'UibTabsetController',\n    controllerAs: 'tabset',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/tabs/tabset.html';\n    },\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ?\n        scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ?\n        scope.$parent.$eval(attrs.justified) : false;\n      if (angular.isUndefined(attrs.active)) {\n        scope.active = 0;\n      }\n    }\n  };\n})\n\n.directive('uibTab', ['$parse', function($parse) {\n  return {\n    require: '^uibTabset',\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/tabs/tab.html';\n    },\n    transclude: true,\n    scope: {\n      heading: '@',\n      index: '=?',\n      classes: '@?',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    controllerAs: 'tab',\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n      scope.disabled = false;\n      if (attrs.disable) {\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\n          scope.disabled = !! value;\n        });\n      }\n\n      if (angular.isUndefined(attrs.index)) {\n        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {\n          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;\n        } else {\n          scope.index = 0;\n        }\n      }\n\n      if (angular.isUndefined(attrs.classes)) {\n        scope.classes = '';\n      }\n\n      scope.select = function() {\n        if (!scope.disabled) {\n          var index;\n          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {\n            if (tabsetCtrl.tabs[i].tab === scope) {\n              index = i;\n              break;\n            }\n          }\n\n          tabsetCtrl.select(index);\n        }\n      };\n\n      tabsetCtrl.addTab(scope);\n      scope.$on('$destroy', function() {\n        tabsetCtrl.removeTab(scope);\n      });\n\n      //We need to transclude later, once the content container is ready.\n      //when this link happens, we're inside a tab heading.\n      scope.$transcludeFn = transclude;\n    }\n  };\n}])\n\n.directive('uibTabHeadingTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTab',\n    link: function(scope, elm) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n})\n\n.directive('uibTabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTabset',\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n\n  function isTabHeading(node) {\n    return node.tagName && (\n      node.hasAttribute('uib-tab-heading') ||\n      node.hasAttribute('data-uib-tab-heading') ||\n      node.hasAttribute('x-uib-tab-heading') ||\n      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'x-uib-tab-heading'\n    );\n  }\n});\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('uibTimepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  secondStep: 1,\n  showMeridian: true,\n  showSeconds: false,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true,\n  arrowkeys: true,\n  showSpinners: true,\n  templateUrl: 'uib/template/timepicker/timepicker.html'\n})\n\n.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var selected = new Date(),\n    watchers = [],\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;\n\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n  $element.removeAttr('tabindex');\n\n  this.init = function(ngModelCtrl_, inputs) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\n      return modelValue ? new Date(modelValue) : null;\n    });\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1),\n        secondsInputEl = inputs.eq(2);\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\n    if (mousewheel) {\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n    if (arrowkeys) {\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = +value;\n    }));\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = +value;\n    }));\n  }\n\n  var min;\n  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {\n    var dt = new Date(value);\n    min = isNaN(dt) ? undefined : dt;\n  }));\n\n  var max;\n  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {\n    var dt = new Date(value);\n    max = isNaN(dt) ? undefined : dt;\n  }));\n\n  var disabled = false;\n  if ($attrs.ngDisabled) {\n    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {\n      disabled = value;\n    }));\n  }\n\n  $scope.noIncrementHours = function() {\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementHours = function() {\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementMinutes = function() {\n    var incrementedSelected = addMinutes(selected, minuteStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementMinutes = function() {\n    var decrementedSelected = addMinutes(selected, -minuteStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementSeconds = function() {\n    var incrementedSelected = addSeconds(selected, secondStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementSeconds = function() {\n    var decrementedSelected = addSeconds(selected, -secondStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noToggleMeridian = function() {\n    if (selected.getHours() < 12) {\n      return disabled || addMinutes(selected, 12 * 60) > max;\n    }\n\n    return disabled || addMinutes(selected, -12 * 60) < min;\n  };\n\n  var secondStep = timepickerConfig.secondStep;\n  if ($attrs.secondStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {\n      secondStep = +value;\n    }));\n  }\n\n  $scope.showSeconds = timepickerConfig.showSeconds;\n  if ($attrs.showSeconds) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {\n      $scope.showSeconds = !!value;\n    }));\n  }\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if (ngModelCtrl.$error.time) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n          selected.setHours(hours);\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    }));\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate() {\n    var hours = +$scope.hours;\n    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :\n      hours >= 0 && hours < 24;\n    if (!valid) {\n      return undefined;\n    }\n\n    if ($scope.showMeridian) {\n      if (hours === 12) {\n        hours = 0;\n      }\n      if ($scope.meridian === meridians[1]) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = +$scope.minutes;\n    return minutes >= 0 && minutes < 60 ? minutes : undefined;\n  }\n\n  function getSecondsFromTemplate() {\n    var seconds = +$scope.seconds;\n    return seconds >= 0 && seconds < 60 ? seconds : undefined;\n  }\n\n  function pad(value) {\n    if (value === null) {\n      return '';\n    }\n\n    return angular.isDefined(value) && value.toString().length < 2 ?\n      '0' + value : value.toString();\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;\n      return e.detail || delta > 0;\n    };\n\n    hoursInputEl.bind('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n      }\n      e.preventDefault();\n    });\n\n    minutesInputEl.bind('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n      }\n      e.preventDefault();\n    });\n\n     secondsInputEl.bind('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());\n      }\n      e.preventDefault();\n    });\n  };\n\n  // Respond on up/down arrowkeys\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    hoursInputEl.bind('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementHours();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementHours();\n          $scope.$apply();\n        }\n      }\n    });\n\n    minutesInputEl.bind('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementMinutes();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementMinutes();\n          $scope.$apply();\n        }\n      }\n    });\n\n    secondsInputEl.bind('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementSeconds();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementSeconds();\n          $scope.$apply();\n        }\n      }\n    });\n  };\n\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    if ($scope.readonlyInput) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      $scope.updateSeconds = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {\n      ngModelCtrl.$setViewValue(null);\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n      }\n\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n      }\n\n      if (angular.isDefined(invalidSeconds)) {\n        $scope.invalidSeconds = invalidSeconds;\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate(),\n        minutes = getMinutesFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(true);\n        } else {\n          refresh('h');\n        }\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.bind('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if ($scope.hours === null || $scope.hours === '') {\n        invalidate(true);\n      } else if (!$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply(function() {\n          $scope.hours = pad($scope.hours);\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(undefined, true);\n        } else {\n          refresh('m');\n        }\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.bind('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if ($scope.minutes === null) {\n        invalidate(undefined, true);\n      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {\n        $scope.$apply(function() {\n          $scope.minutes = pad($scope.minutes);\n        });\n      }\n    });\n\n    $scope.updateSeconds = function() {\n      var seconds = getSecondsFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(seconds)) {\n        selected.setSeconds(seconds);\n        refresh('s');\n      } else {\n        invalidate(undefined, undefined, true);\n      }\n    };\n\n    secondsInputEl.bind('blur', function(e) {\n      if (!$scope.invalidSeconds && $scope.seconds < 10) {\n        $scope.$apply( function() {\n          $scope.seconds = pad($scope.seconds);\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$viewValue;\n\n    if (isNaN(date)) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if (date) {\n        selected = date;\n      }\n\n      if (selected < min || selected > max) {\n        ngModelCtrl.$setValidity('time', false);\n        $scope.invalidHours = true;\n        $scope.invalidMinutes = true;\n      } else {\n        makeValid();\n      }\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh(keyboardChange) {\n    makeValid();\n    ngModelCtrl.$setViewValue(new Date(selected));\n    updateTemplate(keyboardChange);\n  }\n\n  function makeValid() {\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n    $scope.invalidSeconds = false;\n  }\n\n  function updateTemplate(keyboardChange) {\n    if (!ngModelCtrl.$modelValue) {\n      $scope.hours = null;\n      $scope.minutes = null;\n      $scope.seconds = null;\n      $scope.meridian = meridians[0];\n    } else {\n      var hours = selected.getHours(),\n        minutes = selected.getMinutes(),\n        seconds = selected.getSeconds();\n\n      if ($scope.showMeridian) {\n        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system\n      }\n\n      $scope.hours = keyboardChange === 'h' ? hours : pad(hours);\n      if (keyboardChange !== 'm') {\n        $scope.minutes = pad(minutes);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\n      if (keyboardChange !== 's') {\n        $scope.seconds = pad(seconds);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n    }\n  }\n\n  function addSecondsToSelected(seconds) {\n    selected = addSeconds(selected, seconds);\n    refresh();\n  }\n\n  function addMinutes(selected, minutes) {\n    return addSeconds(selected, minutes*60);\n  }\n\n  function addSeconds(date, seconds) {\n    var dt = new Date(date.getTime() + seconds * 1000);\n    var newDate = new Date(date);\n    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());\n    return newDate;\n  }\n\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\n  $scope.incrementHours = function() {\n    if (!$scope.noIncrementHours()) {\n      addSecondsToSelected(hourStep * 60 * 60);\n    }\n  };\n\n  $scope.decrementHours = function() {\n    if (!$scope.noDecrementHours()) {\n      addSecondsToSelected(-hourStep * 60 * 60);\n    }\n  };\n\n  $scope.incrementMinutes = function() {\n    if (!$scope.noIncrementMinutes()) {\n      addSecondsToSelected(minuteStep * 60);\n    }\n  };\n\n  $scope.decrementMinutes = function() {\n    if (!$scope.noDecrementMinutes()) {\n      addSecondsToSelected(-minuteStep * 60);\n    }\n  };\n\n  $scope.incrementSeconds = function() {\n    if (!$scope.noIncrementSeconds()) {\n      addSecondsToSelected(secondStep);\n    }\n  };\n\n  $scope.decrementSeconds = function() {\n    if (!$scope.noDecrementSeconds()) {\n      addSecondsToSelected(-secondStep);\n    }\n  };\n\n  $scope.toggleMeridian = function() {\n    var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n    if (!$scope.noToggleMeridian()) {\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));\n      } else {\n        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];\n      }\n    }\n  };\n\n  $scope.blur = function() {\n    ngModelCtrl.$setTouched();\n  };\n\n  $scope.$on('$destroy', function() {\n    while (watchers.length) {\n      watchers.shift()();\n    }\n  });\n}])\n\n.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {\n  return {\n    require: ['uibTimepicker', '?^ngModel'],\n    controller: 'UibTimepickerController',\n    controllerAs: 'timepicker',\n    replace: true,\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || uibTimepickerConfig.templateUrl;\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n    //                      00000111000000000000022200000000000000003333333333333330000000000044000\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n    return {\n      parse: function(input) {\n        var match = input.match(TYPEAHEAD_REGEXP);\n        if (!match) {\n          throw new Error(\n            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n              ' but got \"' + input + '\".');\n        }\n\n        return {\n          itemName: match[3],\n          source: $parse(match[4]),\n          viewMapper: $parse(match[2] || match[1]),\n          modelMapper: $parse(match[1])\n        };\n      }\n    };\n  }])\n\n  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    var modelCtrl, ngModelOptions;\n    //SUPPORTED ATTRIBUTES (OPTIONS)\n\n    //minimal no of characters that needs to be entered before typeahead kicks-in\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n    if (!minLength && minLength !== 0) {\n      minLength = 1;\n    }\n\n    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {\n        minLength = !newVal && newVal !== 0 ? 1 : newVal;\n    });\n    \n    //minimal wait time after last character typed before typeahead kicks-in\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n    //should it restrict model values to the ones selected from the popup only?\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {\n      isEditable = newVal !== false;\n    });\n\n    //binding to a variable that indicates if matches are being retrieved asynchronously\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n    //a callback executed when a match is selected\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n    //should it select highlighted popup value when losing focus?\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n    //binding to a variable that indicates if there were no results after the query is completed\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n    var appendTo = attrs.typeaheadAppendTo ?\n      originalScope.$eval(attrs.typeaheadAppendTo) : null;\n\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n    //If input matches an item of the list exactly, select it automatically\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n    //binding to a variable that indicates if dropdown is open\n    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;\n\n    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;\n\n    //INTERNAL VARIABLES\n\n    //model setter executed upon match selection\n    var parsedModel = $parse(attrs.ngModel);\n    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n    var $setModelValue = function(scope, newValue) {\n      if (angular.isFunction(parsedModel(originalScope)) &&\n        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\n        return invokeModelSetter(scope, {$$$p: newValue});\n      }\n\n      return parsedModel.assign(scope, newValue);\n    };\n\n    //expressions used by typeahead\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\n    var hasFocus;\n\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n    //mousedown & mouseup events\n    //Issue #3699\n    var selected;\n\n    //create a child scope for the typeahead directive so we are not polluting original scope\n    //with typeahead-specific data (matches, query etc.)\n    var scope = originalScope.$new();\n    var offDestroy = originalScope.$on('$destroy', function() {\n      scope.$destroy();\n    });\n    scope.$on('$destroy', offDestroy);\n\n    // WAI-ARIA\n    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n    element.attr({\n      'aria-autocomplete': 'list',\n      'aria-expanded': false,\n      'aria-owns': popupId\n    });\n\n    var inputsContainer, hintInputElem;\n    //add read-only input to show hint\n    if (showHint) {\n      inputsContainer = angular.element('<div></div>');\n      inputsContainer.css('position', 'relative');\n      element.after(inputsContainer);\n      hintInputElem = element.clone();\n      hintInputElem.attr('placeholder', '');\n      hintInputElem.attr('tabindex', '-1');\n      hintInputElem.val('');\n      hintInputElem.css({\n        'position': 'absolute',\n        'top': '0px',\n        'left': '0px',\n        'border-color': 'transparent',\n        'box-shadow': 'none',\n        'opacity': 1,\n        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',\n        'color': '#999'\n      });\n      element.css({\n        'position': 'relative',\n        'vertical-align': 'top',\n        'background-color': 'transparent'\n      });\n      inputsContainer.append(hintInputElem);\n      hintInputElem.after(element);\n    }\n\n    //pop-up element used to display matches\n    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n    popUpEl.attr({\n      id: popupId,\n      matches: 'matches',\n      active: 'activeIdx',\n      select: 'select(activeIdx, evt)',\n      'move-in-progress': 'moveInProgress',\n      query: 'query',\n      position: 'position',\n      'assign-is-open': 'assignIsOpen(isOpen)',\n      debounce: 'debounceUpdate'\n    });\n    //custom item template\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n    }\n\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n    }\n\n    var resetHint = function() {\n      if (showHint) {\n        hintInputElem.val('');\n      }\n    };\n\n    var resetMatches = function() {\n      scope.matches = [];\n      scope.activeIdx = -1;\n      element.attr('aria-expanded', false);\n      resetHint();\n    };\n\n    var getMatchId = function(index) {\n      return popupId + '-option-' + index;\n    };\n\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n    // This attribute is added or removed automatically when the `activeIdx` changes.\n    scope.$watch('activeIdx', function(index) {\n      if (index < 0) {\n        element.removeAttr('aria-activedescendant');\n      } else {\n        element.attr('aria-activedescendant', getMatchId(index));\n      }\n    });\n\n    var inputIsExactMatch = function(inputValue, index) {\n      if (scope.matches.length > index && inputValue) {\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n      }\n\n      return false;\n    };\n\n    var getMatchesAsync = function(inputValue, evt) {\n      var locals = {$viewValue: inputValue};\n      isLoadingSetter(originalScope, true);\n      isNoResultsSetter(originalScope, false);\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n        //it might happen that several async queries were in progress if a user were typing fast\n        //but we are interested only in responses that correspond to the current view value\n        var onCurrentRequest = inputValue === modelCtrl.$viewValue;\n        if (onCurrentRequest && hasFocus) {\n          if (matches && matches.length > 0) {\n            scope.activeIdx = focusFirst ? 0 : -1;\n            isNoResultsSetter(originalScope, false);\n            scope.matches.length = 0;\n\n            //transform labels\n            for (var i = 0; i < matches.length; i++) {\n              locals[parserResult.itemName] = matches[i];\n              scope.matches.push({\n                id: getMatchId(i),\n                label: parserResult.viewMapper(scope, locals),\n                model: matches[i]\n              });\n            }\n\n            scope.query = inputValue;\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n            //due to other elements being rendered\n            recalculatePosition();\n\n            element.attr('aria-expanded', true);\n\n            //Select the single remaining option if user input matches\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n                $$debounce(function() {\n                  scope.select(0, evt);\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n              } else {\n                scope.select(0, evt);\n              }\n            }\n\n            if (showHint) {\n              var firstLabel = scope.matches[0].label;\n              if (angular.isString(inputValue) &&\n                inputValue.length > 0 &&\n                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {\n                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));\n              } else {\n                hintInputElem.val('');\n              }\n            }\n          } else {\n            resetMatches();\n            isNoResultsSetter(originalScope, true);\n          }\n        }\n        if (onCurrentRequest) {\n          isLoadingSetter(originalScope, false);\n        }\n      }, function() {\n        resetMatches();\n        isLoadingSetter(originalScope, false);\n        isNoResultsSetter(originalScope, true);\n      });\n    };\n\n    // bind events only if appendToBody params exist - performance feature\n    if (appendToBody) {\n      angular.element($window).on('resize', fireRecalculating);\n      $document.find('body').on('scroll', fireRecalculating);\n    }\n\n    // Declare the debounced function outside recalculating for\n    // proper debouncing\n    var debouncedRecalculate = $$debounce(function() {\n      // if popup is visible\n      if (scope.matches.length) {\n        recalculatePosition();\n      }\n\n      scope.moveInProgress = false;\n    }, eventDebounceTime);\n\n    // Default progress type\n    scope.moveInProgress = false;\n\n    function fireRecalculating() {\n      if (!scope.moveInProgress) {\n        scope.moveInProgress = true;\n        scope.$digest();\n      }\n\n      debouncedRecalculate();\n    }\n\n    // recalculate actual position and set new values to scope\n    // after digest loop is popup in right position\n    function recalculatePosition() {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top += element.prop('offsetHeight');\n    }\n\n    //we need to propagate user's query so we can higlight matches\n    scope.query = undefined;\n\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutPromise;\n\n    var scheduleSearchWithTimeout = function(inputValue) {\n      timeoutPromise = $timeout(function() {\n        getMatchesAsync(inputValue);\n      }, waitTime);\n    };\n\n    var cancelPreviousTimeout = function() {\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n    };\n\n    resetMatches();\n\n    scope.assignIsOpen = function (isOpen) {\n      isOpenSetter(originalScope, isOpen);\n    };\n\n    scope.select = function(activeIdx, evt) {\n      //called from within the $digest() cycle\n      var locals = {};\n      var model, item;\n\n      selected = true;\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n      model = parserResult.modelMapper(originalScope, locals);\n      $setModelValue(originalScope, model);\n      modelCtrl.$setValidity('editable', true);\n      modelCtrl.$setValidity('parse', true);\n\n      onSelectCallback(originalScope, {\n        $item: item,\n        $model: model,\n        $label: parserResult.viewMapper(originalScope, locals),\n        $event: evt\n      });\n\n      resetMatches();\n\n      //return focus to the input element if a match was selected via a mouse click event\n      // use timeout to avoid $rootScope:inprog error\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n        $timeout(function() { element[0].focus(); }, 0, false);\n      }\n    };\n\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n    element.on('keydown', function(evt) {\n      //typeahead is open and an \"interesting\" key was pressed\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n        return;\n      }\n\n      /**\n       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit\n       * or\n       * shift + tab is pressed to bring focus to the previous element\n       * then clear the results\n       */\n      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13) || evt.which === 9 && !!evt.shiftKey) {\n        resetMatches();\n        scope.$digest();\n        return;\n      }\n\n      evt.preventDefault();\n      var target;\n      switch (evt.which) {\n        case 9:\n        case 13:\n          scope.$apply(function () {\n            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n              $$debounce(function() {\n                scope.select(scope.activeIdx, evt);\n              }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n            } else {\n              scope.select(scope.activeIdx, evt);\n            }\n          });\n          break;\n        case 27:\n          evt.stopPropagation();\n\n          resetMatches();\n          scope.$digest();\n          break;\n        case 38:\n          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n          scope.$digest();\n          target = popUpEl.find('li')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n        case 40:\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n          scope.$digest();\n          target = popUpEl.find('li')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n      }\n    });\n\n    element.bind('focus', function (evt) {\n      hasFocus = true;\n      if (minLength === 0 && !modelCtrl.$viewValue) {\n        $timeout(function() {\n          getMatchesAsync(modelCtrl.$viewValue, evt);\n        }, 0);\n      }\n    });\n\n    element.bind('blur', function(evt) {\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n        selected = true;\n        scope.$apply(function() {\n          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {\n            $$debounce(function() {\n              scope.select(scope.activeIdx, evt);\n            }, scope.debounceUpdate.blur);\n          } else {\n            scope.select(scope.activeIdx, evt);\n          }\n        });\n      }\n      if (!isEditable && modelCtrl.$error.editable) {\n        modelCtrl.$viewValue = '';\n        element.val('');\n      }\n      hasFocus = false;\n      selected = false;\n    });\n\n    // Keep reference to click handler to unbind it.\n    var dismissClickHandler = function(evt) {\n      // Issue #3973\n      // Firefox treats right click as a click on document\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n        resetMatches();\n        if (!$rootScope.$$phase) {\n          scope.$digest();\n        }\n      }\n    };\n\n    $document.on('click', dismissClickHandler);\n\n    originalScope.$on('$destroy', function() {\n      $document.off('click', dismissClickHandler);\n      if (appendToBody || appendTo) {\n        $popup.remove();\n      }\n\n      if (appendToBody) {\n        angular.element($window).off('resize', fireRecalculating);\n        $document.find('body').off('scroll', fireRecalculating);\n      }\n      // Prevent jQuery cache memory leak\n      popUpEl.remove();\n\n      if (showHint) {\n          inputsContainer.remove();\n      }\n    });\n\n    var $popup = $compile(popUpEl)(scope);\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else if (appendTo) {\n      angular.element(appendTo).eq(0).append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    this.init = function(_modelCtrl, _ngModelOptions) {\n      modelCtrl = _modelCtrl;\n      ngModelOptions = _ngModelOptions;\n\n      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function(inputValue) {\n        hasFocus = true;\n\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        }\n\n        if (!inputValue) {\n          // Reset in case user had typed something previously.\n          modelCtrl.$setValidity('editable', true);\n          return null;\n        }\n\n        modelCtrl.$setValidity('editable', false);\n        return undefined;\n      });\n\n      modelCtrl.$formatters.push(function(modelValue) {\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        // The validity may be set to false via $parsers (see above) if\n        // the model is restricted to selected values. If the model\n        // is set manually it is considered to be valid.\n        if (!isEditable) {\n          modelCtrl.$setValidity('editable', true);\n        }\n\n        if (inputFormatter) {\n          locals.$model = modelValue;\n          return inputFormatter(originalScope, locals);\n        }\n\n        //it might happen that we don't have enough info to properly render input value\n        //we need to check for this situation and simply return model value if we can't apply custom formatting\n        locals[parserResult.itemName] = modelValue;\n        candidateViewValue = parserResult.viewMapper(originalScope, locals);\n        locals[parserResult.itemName] = undefined;\n        emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n      });\n    };\n  }])\n\n  .directive('uibTypeahead', function() {\n    return {\n      controller: 'UibTypeaheadController',\n      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\n      link: function(originalScope, element, attrs, ctrls) {\n        ctrls[2].init(ctrls[0], ctrls[1]);\n      }\n    };\n  })\n\n  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&',\n        assignIsOpen: '&',\n        debounce: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          var isDropdownOpen = scope.matches.length > 0;\n          scope.assignIsOpen({ isOpen: isDropdownOpen });\n          return isDropdownOpen;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active === matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx, evt) {\n          var debounce = scope.debounce();\n          if (angular.isNumber(debounce) || angular.isObject(debounce)) {\n            $$debounce(function() {\n              scope.select({activeIdx: activeIdx, evt: evt});\n            }, angular.isNumber(debounce) ? debounce : debounce['default']);\n          } else {\n            scope.select({activeIdx: activeIdx, evt: evt});\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n    return {\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link: function(scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          var tplEl = angular.element(tplContent.trim());\n          element.replaceWith(tplEl);\n          $compile(tplEl)(scope);\n        });\n      }\n    };\n  }])\n\n  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n      return matchItem;\n    };\n  }]);\n\nangular.module(\"uib/template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion-group.html\",\n    \"<div class=\\\"panel\\\" ng-class=\\\"panelClass || 'panel-default'\\\">\\n\" +\n    \"  <div role=\\\"tab\\\" id=\\\"{{::headingId}}\\\" aria-selected=\\\"{{isOpen}}\\\" class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n    \"    <h4 class=\\\"panel-title\\\">\\n\" +\n    \"      <a role=\\\"button\\\" data-toggle=\\\"collapse\\\" href aria-expanded=\\\"{{isOpen}}\\\" aria-controls=\\\"{{::panelId}}\\\" tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span uib-accordion-header ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n    \"    </h4>\\n\" +\n    \"  </div>\\n\" +\n    \"  <div id=\\\"{{::panelId}}\\\" aria-labelledby=\\\"{{::headingId}}\\\" aria-hidden=\\\"{{!isOpen}}\\\" role=\\\"tabpanel\\\" class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n    \"    <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion.html\",\n    \"<div role=\\\"tablist\\\" class=\\\"panel-group\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/alert/alert.html\",\n    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\n    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\n    \"    </button>\\n\" +\n    \"    <div ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/carousel/carousel.html\",\n    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\n    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\n    \"  </a>\\n\" +\n    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ol>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/carousel/slide.html\",\n    \"<div ng-class=\\\"{\\n\" +\n    \"    'active': active\\n\" +\n    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/datepicker.html\",\n    \"<div class=\\\"uib-datepicker\\\" ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\n    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\n    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\n    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/day.html\",\n    \"<table class=\\\"uib-daypicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-weeks\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-day text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/month.html\",\n    \"<table class=\\\"uib-monthpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-months\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-month text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/popup.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"uib-datepicker-popup dropdown-menu uib-position-measure\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"    <li ng-transclude></li>\\n\" +\n    \"    <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n    \"      <span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today', $event)\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null, $event)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"      </span>\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close($event)\\\">{{ getText('close') }}</button>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ul>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/year.html\",\n    \"<table class=\\\"uib-yearpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::columns - 2}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-years\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-year text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/modal/backdrop.html\",\n    \"<div class=\\\"modal-backdrop\\\"\\n\" +\n    \"     uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"     modal-in-class=\\\"in\\\"\\n\" +\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n    \"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/modal/window.html\",\n    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\n    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"    modal-in-class=\\\"in\\\"\\n\" +\n    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\n    \"    <div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pager/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/pager/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/pagination/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/pagination/pagination.html\",\n    \"<ul class=\\\"pagination\\\">\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\n    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-html-popup.html\",\n    \"<div class=\\\"tooltip\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-popup.html\",\n    \"<div class=\\\"tooltip\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-template-popup.html\",\n    \"<div class=\\\"tooltip\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\n    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-html.html\",\n    \"<div class=\\\"popover\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-template.html\",\n    \"<div class=\\\"popover\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\"\\n\" +\n    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover.html\",\n    \"<div class=\\\"popover\\\"\\n\" +\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\n    \"  uib-tooltip-classes\\n\" +\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"title\\\" ng-if=\\\"title\\\"></h3>\\n\" +\n    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/bar.html\",\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n}]);\n\nangular.module(\"uib/template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\">\\n\" +\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\">\\n\" +\n    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\" aria-valuetext=\\\"{{r.title}}\\\"></i>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tab.html\",\n    \"<li ng-class=\\\"[{active: active, disabled: disabled}, classes]\\\" class=\\\"uib-tab nav-item\\\">\\n\" +\n    \"  <a href ng-click=\\\"select()\\\" class=\\\"nav-link\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tabset.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"nav nav-{{tabset.type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n    \"  <div class=\\\"tab-content\\\">\\n\" +\n    \"    <div class=\\\"tab-pane\\\"\\n\" +\n    \"         ng-repeat=\\\"tab in tabset.tabs\\\"\\n\" +\n    \"         ng-class=\\\"{active: tabset.active === tab.index}\\\"\\n\" +\n    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/timepicker/timepicker.html\",\n    \"<table class=\\\"uib-timepicker\\\">\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-increment hours\\\"><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-increment minutes\\\"><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-increment seconds\\\"><a ng-click=\\\"incrementSeconds()\\\" ng-class=\\\"{disabled: noIncrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <td class=\\\"form-group uib-time hours\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"HH\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementHours()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time minutes\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"MM\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementMinutes()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time seconds\\\" ng-class=\\\"{'has-error': invalidSeconds}\\\" ng-show=\\\"showSeconds\\\">\\n\" +\n    \"        <input style=\\\"width:50px;\\\" type=\\\"text\\\" placeholder=\\\"SS\\\" ng-model=\\\"seconds\\\" ng-change=\\\"updateSeconds()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementSeconds()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\" class=\\\"uib-time am-pm\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-decrement hours\\\"><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-decrement minutes\\\"><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-decrement seconds\\\"><a ng-click=\\\"decrementSeconds()\\\" ng-class=\\\"{disabled: noDecrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-match.html\",\n    \"<a href\\n\" +\n    \"   tabindex=\\\"-1\\\"\\n\" +\n    \"   ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"\\n\" +\n    \"   ng-attr-title=\\\"{{match.label}}\\\"></a>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index, $event)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\nangular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); });\nangular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll;}</style>'); });\nangular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}.uib-left,.uib-right{width:100%}</style>'); });\nangular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); });\nangular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'); });\nangular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); });\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/angular-ui-bootstrap/dist/ui-bootstrap-tpls.js\n ** module id = 16\n ** module chunks = 1\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 134\n ** module chunks = 1\n **/"],"sourceRoot":""}